<?xml version='1.0' encoding='utf-8'?>
<root><database name="tomcat"><table name="tomcat"><column name="id">1</column><column name="bug_id">56012</column><column name="summary">wrong import statement generation while using the extends attribute of the page directive</column><column name="description">Here is the test example, extends.jsp, &lt;%@ page import="dvt.jsp.jaspertest.*" %&gt; &lt;%@ page extends="TestJspBase" %&gt; &lt;% out.println("TEST"); %&gt; and its TestJspBase.java. package dvt.jsp.jaspertest; import jeus.servlet.jsp.HttpJspBase; import javax.servlet.ServletException; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.IOException; public class TestJspBase extends HttpJspBase { @Override public void _jspService(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { /* do nothing here */ } } I know that the fully qualified class name must be used while using the extends attribute of the page directive. But the java generator of jasper has also a problem. /* * Generated by the Jasper component of Apache Tomcat * Version: Apache Tomcat/7.0.50 * Generated at: 2014-01-15 04:56:28 UTC * Note: The last modified time of this file was set to * the last modified time of the source file after * generation to assist with modification tracking. */ package org.apache.jsp; import javax.servlet.*; import javax.servlet.http.*; import javax.servlet.jsp.*; import dvt.jsp.jaspertest.*; import TestJspBase; public final class extends_jsp extends TestJspBase implements org.apache.jasper.runtime.JspSourceDependent { The problem is 'import TestJspBase;'. The java language spec. does not allow the class name of default package. http://docs.oracle.com/javase/specs/jls/se5.0/html/packages.html#70209 In my opinion, no import statement generation would be best for the simple class name. org.apache.jasper.compiler.PageInfo public void setExtends(String value, Node.PageDirective n) { xtends = value; } FYI, there was a time that such import statement was possible to use until it was fixed at JDK 1.4. http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=4361575</column><column name="report_time">2014-01-15 07:30:17</column><column name="report_timestamp">1389790000</column><column name="status">resolved fixed</column><column name="commit">42056be</column><column name="commit_timestamp">1390080000</column><column name="files">java/org/apache/jasper/compiler/PageInfo.java
java/org/apache/jasper/compiler/Validator.java</column><column name="result">1:java/org/apache/jasper/compiler/PageInfo.java
21:java/org/apache/jasper/compiler/Validator.java</column></table><table name="tomcat"><column name="id">2</column><column name="bug_id">56029</column><column name="summary">Ternary operator doesn't work as expected inside attributes in jspx pages</column><column name="description">The following JSPX file worked upto Tomcat 7.0.47: &lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;jsp:root xmlns:jsp="http://java.sun.com/JSP/Page" version="2.1" 	xmlns:c="http://java.sun.com/jsp/jstl/core" 	xmlns:fmt="http://java.sun.com/jsp/jstl/fmt"	 &gt; 	&lt;jsp:directive.page contentType="text/html; charset=utf-8" pageEncoding="UTF-8" /&gt; 	&lt;jsp:directive.page session="false" /&gt; 	&lt;jsp:output omit-xml-declaration="true" /&gt; 	&lt;div&gt;	 		&lt;span id="mainNavNews" class="${currentController eq 'News' ? 'selectedItem' : ''}"&gt;foobar&lt;/span&gt;	 	&lt;/div&gt;	 &lt;/jsp:root&gt; With tomcat 7.0.50 it fails with the following exception: org.apache.jasper.JasperException: /WEB-INF/views/layouts/mainNavigation.jspx (line: 10, column: 87) "${currentController eq 'News' ? 'selectedItem' : ''}" contains invalid expression(s): javax.el.ELException: Failed to parse the expression [${currentControllereq'News'?'selectedItem':''}] 	at org.apache.jasper.compiler.DefaultErrorHandler.jspError(DefaultErrorHandler.java:42) 	at org.apache.jasper.compiler.ErrorDispatcher.dispatch(ErrorDispatcher.java:443) 	at org.apache.jasper.compiler.ErrorDispatcher.jspError(ErrorDispatcher.java:199) 	at org.apache.jasper.compiler.Validator$ValidateVisitor.getJspAttribute(Validator.java:1399) 	at org.apache.jasper.compiler.Validator$ValidateVisitor.visit(Validator.java:772) 	at org.apache.jasper.compiler.Node$UninterpretedTag.accept(Node.java:1251) 	at org.apache.jasper.compiler.Node$Nodes.visit(Node.java:2375) 	at org.apache.jasper.compiler.Node$Visitor.visitBody(Node.java:2427) 	at org.apache.jasper.compiler.Validator$ValidateVisitor.visit(Validator.java:779) 	at org.apache.jasper.compiler.Node$UninterpretedTag.accept(Node.java:1251) 	at org.apache.jasper.compiler.Node$Nodes.visit(Node.java:2375) 	at org.apache.jasper.compiler.Node$Visitor.visitBody(Node.java:2427) 	at org.apache.jasper.compiler.Validator$ValidateVisitor.visit(Validator.java:529) 	at org.apache.jasper.compiler.Node$JspRoot.accept(Node.java:564) 	at org.apache.jasper.compiler.Node$Nodes.visit(Node.java:2375) 	at org.apache.jasper.compiler.Node$Visitor.visitBody(Node.java:2427) 	at org.apache.jasper.compiler.Node$Visitor.visit(Node.java:2433) 	at org.apache.jasper.compiler.Node$Root.accept(Node.java:474) 	at org.apache.jasper.compiler.Node$Nodes.visit(Node.java:2375) 	at org.apache.jasper.compiler.Validator.validateExDirectives(Validator.java:1817) 	at org.apache.jasper.compiler.Compiler.generateJava(Compiler.java:217) 	at org.apache.jasper.compiler.Compiler.__compile(Compiler.java:373) 	at org.apache.jasper.compiler.Compiler.compile(Compiler.java) 	at org.apache.jasper.compiler.Compiler.compile(Compiler.java:353) 	at org.apache.jasper.compiler.Compiler.compile(Compiler.java:340) 	at org.apache.jasper.JspCompilationContext.compile(JspCompilationContext.java:657) 	at org.apache.jasper.servlet.JspServletWrapper.service(JspServletWrapper.java:357) 	at org.apache.jasper.servlet.JspServlet._serviceJspFile(JspServlet.java:390) 	at org.apache.jasper.servlet.JspServlet.serviceJspFile(JspServlet.java) 	at org.apache.jasper.servlet.JspServlet.service(JspServlet.java:334) It works when the ternary operation doesn't appear inside an attribute or instead of eq '==' is used.</column><column name="report_time">2014-01-18 12:42:47</column><column name="report_timestamp">1390070000</column><column name="status">resolved fixed</column><column name="commit">b430e29</column><column name="commit_timestamp">1390070000</column><column name="files">java/org/apache/jasper/compiler/ELParser.java
test/org/apache/jasper/compiler/TestELParser.java</column><column name="result">301:java/org/apache/jasper/compiler/ELParser.java
1822:test/org/apache/jasper/compiler/TestELParser.java</column></table><table name="tomcat"><column name="id">3</column><column name="bug_id">55943</column><column name="summary">Provide a way prevent  looking at the System classloader before the webapp classloaders</column><column name="description">I would like a way to prevent Tomcat from checking the System classloader before the webapp classloaders. This would be useful when using the embedded Tomact API to produce isolated servlet containers. I ran in to some difficulty with this when I was adding Tomcat support to the SBT (Simple Build Tool) plugin: https://github.com/JamesEarlDouglas/xsbt-web-plugin In particular I had an issue where SBT includes a version of the Scala standard library, on the system classpath, that has been run through Proguard. This was conflicting with web applications that were including their own version of the Scala standard library. I was eventually able to work around this using this hack: https://github.com/JamesEarlDouglas/xsbt-web-plugin/commit/f8a9b149f0c7c87d7b6e8f862c493841d82ad90a However, it would be nice if there was a way to accomplish this that didn't involve such a hack. I would be happy to submit a patch for this. However, I would like some guidence on how the API should be changed to accomplish this. Perhaps a new flag on the WebappLoader class? Thanks</column><column name="report_time">2014-01-01 10:02:46</column><column name="report_timestamp">1388590000</column><column name="status">resolved fixed</column><column name="commit">f28800c</column><column name="commit_timestamp">1389970000</column><column name="files">java/org/apache/catalina/loader/WebappClassLoader.java</column><column name="result">3:java/org/apache/catalina/loader/WebappClassLoader.java</column></table><table name="tomcat"><column name="id">4</column><column name="bug_id">56025</column><column name="summary">Order of invocation of method of ServerEndpointConfig.Configurator</column><column name="description">The current order of invocation (from http://svn.apache.org/repos/asf/tomcat/trunk/java/org/apache/tomcat/websocket/server/UpgradeUtil.java) is: checkOrigin() getNegotiatedSubprotocol() getEndpointInstance() modifyHandshake() JSR 356 is guilty for not specifying this order, but I believe a different order is more useful. Below I refer to "the application" as a subclass of the ServerEndpointConfig.Configurator implemented by end users. I'd like to propose this new order: modifyHandshake() as first: this allows applications to query/store information about the upgrade request (for example, the URI); checkOrigin() as second: this allows applications to check the origin with more information available, because the request/response are available from the previous call and therefore checks of the origin against the request URI and/or other HTTP headers will be possible; getNegotiatedSubprotocol() as third: this should be always invoked, while right now it is not invoked if the client does not specify the Sec-WebSocket-Protocol header; this is not ideal since the server may have been configured with a sub-protocol, but the application is never called to check what the client has sent; getEndPointInstance() as last: there is no point in creating the endpoint if the other methods returned a failure, nor there is point to invoke any other method if this one returned null. The current order also does not invoke method getNegotiatedExtensions(), but as far as I understand extensions are not yet supported. I believe this method should be eventually invoked as fourth, before getEndPointInstance(). Thanks !</column><column name="report_time">2014-01-17 08:23:30</column><column name="report_timestamp">1389970000</column><column name="status">resolved fixed</column><column name="commit">11b1e83</column><column name="commit_timestamp">1389960000</column><column name="files">java/org/apache/tomcat/websocket/server/UpgradeUtil.java</column><column name="result">59:java/org/apache/tomcat/websocket/server/UpgradeUtil.java</column></table><table name="tomcat"><column name="id">5</column><column name="bug_id">56010</column><column name="summary">JspFactory.getPageContext with JspWriter.DEFAULT_BUFFER throws IllegalArgumentException</column><column name="description">When a servlet calls JspFactory.getPageContext() with JspWriter.DEFAULT_BUFFER, Tomcat Japser throws IllegalArgumentException. PageContext pageContext = JspFactory.getDefaultFactory().getPageContext(this, req, resp, null, false, JspWriter.DEFAULT_BUFFER, true); java.lang.IllegalArgumentException: Buffer size &lt;= 0 	org.apache.jasper.runtime.JspWriterImpl.&lt;init&gt;(JspWriterImpl.java:81) 	org.apache.jasper.runtime.PageContextImpl._initialize(PageContextImpl.java:154) 	org.apache.jasper.runtime.PageContextImpl.initialize(PageContextImpl.java:125) 	org.apache.jasper.runtime.JspFactoryImpl.internalGetPageContext(JspFactoryImpl.java:112) 	org.apache.jasper.runtime.JspFactoryImpl.getPageContext(JspFactoryImpl.java:65) 	dvt.jsp.jaspertest.JspFactoryTestServlet.doGet(JspFactoryTestServlet.java:21) 	javax.servlet.http.HttpServlet.service(HttpServlet.java:621) 	javax.servlet.http.HttpServlet.service(HttpServlet.java:728) Based on the description of JspFactory.getPageContext(), if buffer size is JspWriter.DEFAULT_BUFFER(-1), PageContext must treat it as implementation default, which in case is org.apache.jasper.Constants#DEFAULT_BUFFER_SIZE(8192). buffer - size of buffer in bytes, JspWriter.NO_BUFFER if no buffer, JspWriter.DEFAULT_BUFFER if implementation default. from http://docs.oracle.com/javaee/7/api/javax/servlet/jsp/JspFactory.html#getPageContext(javax.servlet.Servlet, javax.servlet.ServletRequest, javax.servlet.ServletResponse, java.lang.String, boolean, int, boolean) Note that -Dorg.apache.jasper.runtime.JspFactoryImpl.USE_POOL=false should be specified.</column><column name="report_time">2014-01-15 03:34:23</column><column name="report_timestamp">1389770000</column><column name="status">resolved fixed</column><column name="commit">48650dd</column><column name="commit_timestamp">1389880000</column><column name="files">java/org/apache/jasper/runtime/PageContextImpl.java
test/org/apache/jasper/runtime/TestPageContextImpl.java</column><column name="result">3:java/org/apache/jasper/runtime/PageContextImpl.java
77:test/org/apache/jasper/runtime/TestPageContextImpl.java</column></table><table name="tomcat"><column name="id">6</column><column name="bug_id">55996</column><column name="summary">Async context does not timeout with HTTP NIO connector</column><column name="description">Created attachment 31200 Servlet with Async processing and Java Based client I created a ProblemServlet which receives request via a Java based client. The Servlet starts an Async processing for each request. Within the Async processing run() method there is a while loop which cyclically sends String messages to the client. The implementation of run method is shown. public void run() { try { String msg = ""; ServletOutputStream outputStream = publisherAsyncCtx.getResponse().getOutputStream(); boolean continu = true; while (continu) { msg = ""; msg = "|" + " " + new Date(); System.out.println("publishing message... " + msg); outputStream.println(msg); publisherAsyncCtx.getResponse().flushBuffer(); try { Thread.sleep(1000); } catch (InterruptedException e) { System.out.println("sleep InterruptedException: " + e.getMessage()); e.printStackTrace(); } } } When a Java based console application client hits this servlet and reads its output stream, for around 10 sec the messages arrive. But after 10 seconds the connection is closed by the server. Logs on the Server side: Starting the Async Context. publishing message... | Mon Jan 13 11:28:30 IST 2014 publishing message... | Mon Jan 13 11:28:31 IST 2014 publishing message... | Mon Jan 13 11:28:32 IST 2014 publishing message... | Mon Jan 13 11:28:33 IST 2014 publishing message... | Mon Jan 13 11:28:34 IST 2014 publishing message... | Mon Jan 13 11:28:35 IST 2014 publishing message... | Mon Jan 13 11:28:36 IST 2014 publishing message... | Mon Jan 13 11:28:37 IST 2014 publishing message... | Mon Jan 13 11:28:38 IST 2014 publishing message... | Mon Jan 13 11:28:39 IST 2014 publishing message... | Mon Jan 13 11:28:40 IST 2014 publishing message... | Mon Jan 13 11:28:41 IST 2014 Exception in thread "http-bio-8080-exec-6" java.lang.IllegalStateException: The request associated with the AsyncContext has already completed processing. 	at org.apache.catalina.core.AsyncContextImpl.check(AsyncContextImpl.java:521) 	at org.apache.catalina.core.AsyncContextImpl.getResponse(AsyncContextImpl.java:245) 	at com.pg.orion.artcloopcheck.ProblemServlet$AsynRunnable.run(ProblemServlet.java:67) 	at org.apache.catalina.core.AsyncContextImpl$RunnableWrapper.run(AsyncContextImpl.java:557) 	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1145) 	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:615) 	at java.lang.Thread.run(Thread.java:722) Issue is seen with "apache-tomcat-7.0.50", "apache-tomcat-7.0.47". Not tested with other release 7 variants. The same codebase when run on "apache-tomcat-8.0.0-RC10" there are no issues.</column><column name="report_time">2014-01-13 06:12:37</column><column name="report_timestamp">1389610000</column><column name="status">resolved fixed</column><column name="commit">553ad39</column><column name="commit_timestamp">1389720000</column><column name="files">java/org/apache/tomcat/util/net/SocketWrapper.java</column><column name="result">46:java/org/apache/tomcat/util/net/SocketWrapper.java</column></table><table name="tomcat"><column name="id">7</column><column name="bug_id">55995</column><column name="summary">java.lang.NullPointerException at org.apache.jasper.servlet.JspCServletContext.getResource(JspCServletContext.java:344)</column><column name="description">Null pointer exception when running JSPC from a Shell Script. JspCServletContext.java:344 /** * Return a URL object of a resource that is mapped to the * specified context-relative path. * * @param path Context-relative path of the desired resource * * @exception MalformedURLException if the resource path is * not properly formed */ @Override public URL getResource(String path) throws MalformedURLException { if (!path.startsWith("/")) throw new MalformedURLException("Path '" + path + "' does not start with '/'"); TldCache.java:124 private long[] getLastModified(TldResourcePath tldResourcePath) { long[] result = new long[2]; result[0] = -1; result[1] = -1; try { URL url = servletContext.getResource(tldResourcePath.getWebappPath()); /usr/java/jdk1.7.0_45/bin/java -classpath :/home/tomcat/apache-tomcat-8.0.0-RC10/lib/catalina-storeconfig.jar:/home/tomcat/apache-tomcat-8.0.0-RC10/lib/tomcat-websocket.jar:/home/tomcat/apache-tomcat-8.0.0-RC10/lib/tomcat-i18n-es.jar:/home/tomcat/apache-tomcat-8.0.0-RC10/lib/catalina-tribes.jar:/home/tomcat/apache-tomcat-8.0.0-RC10/lib/catalina-ha.jar:/home/tomcat/apache-tomcat-8.0.0-RC10/lib/tomcat-i18n-ja.jar:/home/tomcat/apache-tomcat-8.0.0-RC10/lib/jsp-api.jar:/home/tomcat/apache-tomcat-8.0.0-RC10/lib/tomcat-util.jar:/home/tomcat/apache-tomcat-8.0.0-RC10/lib/tomcat-jni.jar:/home/tomcat/apache-tomcat-8.0.0-RC10/lib/jasper.jar:/home/tomcat/apache-tomcat-8.0.0-RC10/lib/websocket-api.jar:/home/tomcat/apache-tomcat-8.0.0-RC10/lib/ecj-4.3.1.jar:/home/tomcat/apache-tomcat-8.0.0-RC10/lib/tomcat-i18n-fr.jar:/home/tomcat/apache-tomcat-8.0.0-RC10/lib/tomcat-api.jar:/home/tomcat/apache-tomcat-8.0.0-RC10/lib/tomcat-coyote.jar:/home/tomcat/apache-tomcat-8.0.0-RC10/lib/servlet-api.jar:/home/tomcat/apache-tomcat-8.0.0-RC10/lib/jasper-el.jar:/home/tomcat/apache-tomcat-8.0.0-RC10/lib/catalina.jar:/home/tomcat/apache-tomcat-8.0.0-RC10/lib/tomcat-dbcp.jar:/home/tomcat/apache-tomcat-8.0.0-RC10/lib/tomcat-jdbc.jar:/home/tomcat/apache-tomcat-8.0.0-RC10/lib/annotations-api.jar:/home/tomcat/apache-tomcat-8.0.0-RC10/lib/tomcat-util-scan.jar:/home/tomcat/apache-tomcat-8.0.0-RC10/lib/catalina-ant.jar:/home/tomcat/apache-tomcat-8.0.0-RC10/lib/el-api.jar:/home/tomcat/apache-tomcat-8.0.0-RC10/lib/tomcat-spdy.jar:/home/tomcat/apache-tomcat-8.0.0-RC10/bin/tomcat-juli.jar:/home/tomcat/apache-tomcat-8.0.0-RC10/bin/bootstrap.jar:/home/tomcat/apache-tomcat-8.0.0-RC10/bin/commons-daemon.jar:/home/tomcat/apache-tomcat-8.0.0-RC10/webapps/examples/WEB-INF/lib/jstl.jar:/home/tomcat/apache-tomcat-8.0.0-RC10/webapps/examples/WEB-INF/lib/standard.jar:/home/java/source/HEAD/work/jsp_compile_shared/WEB-INF/lib/ant-1.6.5.jar org.apache.jasper.JspC 	-d /home/java/source/HEAD/work/tomcat80 	-v 	-l 	-uriroot /home/java/source/HEAD/work/jsp_compile_shared /home/java/source/HEAD/work/jsp_compile_shared/WEB-INF/jsp/dialog/qbAxesDlg.jsp /home/java/source/HEAD/work/jsp_compile_shared/WEB-INF/jsp/dialog/qbManualGecodingDlg.jsp /home/java/source/HEAD/work/jsp_compile_shared/WEB-INF/jsp/fmtdlg.jsp /home/java/source/HEAD/work/jsp_compile_shared/WEB-INF/jsp/index.jsp /home/java/source/HEAD/work/jsp_compile_shared/WEB-INF/jsp/joindlg.jsp /home/java/source/HEAD/work/jsp_compile_shared/WEB-INF/jsp/producer.jsp /home/java/source/HEAD/work/jsp_compile_shared/WEB-INF/jsp/simplefilter.jsp /home/java/source/HEAD/work/jsp_compile_shared/WEB-INF/jsp/selectvaluedlg.jsp /home/java/source/HEAD/work/jsp_compile_shared/WEB-INF/jsp/binddowsTestView.jsp /home/java/source/HEAD/work/jsp_compile_shared/WEB-INF/jsp/variableeditordlg.jsp /home/java/source/HEAD/work/jsp_compile_shared/WEB-INF/jsp/filterprompteditor.jsp /home/java/source/HEAD/work/jsp_compile_shared/WEB-INF/jsp/ajax_response.jsp /home/java/source/HEAD/work/jsp_compile_shared/WEB-INF/jsp/fontdlg.jsp /home/java/source/HEAD/work/jsp_compile_shared/WEB-INF/jsp/join_fields.jsp /home/java/source/HEAD/work/jsp_compile_shared/WEB-INF/jsp/tree_component.jsp /home/java/source/HEAD/work/jsp_compile_shared/WEB-INF/jsp/waiting_banner.jsp /home/java/source/HEAD/work/jsp_compile_shared/WEB-INF/jsp/bid/folderblock/BID_FolderBlockInit.jsp /home/java/source/HEAD/work/jsp_compile_shared/WEB-INF/jsp/bid/folderblock/BID_FolderBlockBoot.jsp /home/java/source/HEAD/work/jsp_compile_shared/WEB-INF/jsp/bid/BID_EmptyContent.jsp /home/java/source/HEAD/work/jsp_compile_shared/WEB-INF/jsp/bid/xml/BID_UrlProperties.jsp /home/java/source/HEAD/work/jsp_compile_shared/WEB-INF/jsp/bid/xml/BID_IBFSpathToHrefs.jsp /home/java/source/HEAD/work/jsp_compile_shared/WEB-INF/jsp/bid/xml/BID_xmlresponse.jsp /home/java/source/HEAD/work/jsp_compile_shared/WEB-INF/jsp/bid/xml/BID_statusResponse.jsp /home/java/source/HEAD/work/jsp_compile_shared/WEB-INF/jsp/bid/favorites/BID_favorites_tree.jsp /home/java/source/HEAD/work/jsp_compile_shared/WEB-INF/jsp/bid/favorites/BID_FavoritesBlockBoot.jsp /home/java/source/HEAD/work/jsp_compile_shared/WEB-INF/jsp/bid/favorites/BID_FavoritesBlockInit.jsp /home/java/source/HEAD/work/jsp_compile_shared/WEB-INF/jsp/bid/favorites/BID_favorites_tree_boot.jsp /home/java/source/HEAD/work/jsp_compile_shared/WEB-INF/jsp/bid/favorites/BID_listToXML.jsp /home/java/source/HEAD/work/jsp_compile_shared/WEB-INF/jsp/bid/index.jsp /home/java/source/HEAD/work/jsp_compile_shared/WEB-INF/jsp/bid/views/BID_InternalPage.jsp /home/java/source/HEAD/work/jsp_compile_shared/WEB-INF/jsp/bid/views/BID_SearchTree_Boot.jsp /home/java/source/HEAD/work/jsp_compile_shared/WEB-INF/jsp/bid/views/BID_SATree_Boot.jsp /home/java/source/HEAD/work/jsp_compile_shared/WEB-INF/jsp/bid/views/BID_BiFrame.jsp /home/java/source/HEAD/work/jsp_compile_shared/WEB-INF/jsp/bid/views/BID_initView.jsp /home/java/source/HEAD/work/jsp_compile_shared/WEB-INF/jsp/bid/views/BID_ShowToolbar.jsp /home/java/source/HEAD/work/jsp_compile_shared/WEB-INF/jsp/bid/views/BID_ExternalPage.jsp /home/java/source/HEAD/work/jsp_compile_shared/WEB-INF/jsp/bid/views/BID_SATreeBiFrame.jsp /home/java/source/HEAD/work/jsp_compile_shared/WEB-INF/jsp/bid/views/BID_initBindows.jsp /home/java/source/HEAD/work/jsp_compile_shared/WEB-INF/jsp/bid/views/BID_SearchTreeBiFrame.jsp /home/java/source/HEAD/work/jsp_compile_shared/WEB-INF/jsp/bid/recents/BID_recents_tree_boot.jsp /home/java/source/HEAD/work/jsp_compile_shared/WEB-INF/jsp/bid/recents/BID_recents_tree.jsp /home/java/source/HEAD/work/jsp_compile_shared/WEB-INF/jsp/bid/recents/BID_listToXML.jsp /home/java/source/HEAD/work/jsp_compile_shared/WEB-INF/jsp/bid/error.jsp /home/java/source/HEAD/work/jsp_compile_shared/WEB-INF/jsp/bid/groups/BID_listToXML.jsp /home/java/source/HEAD/work/jsp_compile_shared/WEB-INF/jsp/bid/search/BID_searchListToXML.jsp /home/java/source/HEAD/work/jsp_compile_shared/WEB-INF/jsp/bid/search/BID_listToXML.jsp /home/java/source/HEAD/work/jsp_compile_shared/WEB-INF/jsp/bid/tree/BID_MrPropertiesToXML.jsp /home/java/source/HEAD/work/jsp_compile_shared/WEB-INF/jsp/bid/tree/BID_flatListToXML.jsp /home/java/source/HEAD/work/jsp_compile_shared/WEB-INF/jsp/bid/tree/BID_PlainText.jsp /home/java/source/HEAD/work/jsp_compile_shared/WEB-INF/jsp/bid/tree/BID_listToXML.jsp	 2&gt;&amp;1 	 	 Exception in thread "main" java.lang.NullPointerException 	at org.apache.jasper.servlet.JspCServletContext.getResource(JspCServletContext.java:344) 	at org.apache.jasper.compiler.TldCache.getLastModified(TldCache.java:124) 	at org.apache.jasper.compiler.TldCache.&lt;init&gt;(TldCache.java:70) 	at org.apache.jasper.JspC.initServletContext(JspC.java:1468) 	at org.apache.jasper.JspC.execute(JspC.java:1321) 	at org.apache.jasper.JspC.main(JspC.java:269)</column><column name="report_time">2014-01-13 05:55:30</column><column name="report_timestamp">1389610000</column><column name="status">resolved fixed</column><column name="commit">5e6b884</column><column name="commit_timestamp">1389700000</column><column name="files">java/org/apache/jasper/compiler/TldCache.java</column><column name="result">6:java/org/apache/jasper/compiler/TldCache.java</column></table><table name="tomcat"><column name="id">8</column><column name="bug_id">55893</column><column name="summary">Split AccessLogValve and extract the formatting logic in an AbstractAccessLogValve</column><column name="description">Created attachment 31120 Patch file Split AccessLogValve in an AbstractAccessLogValve with the formatting logic and an AccessLogValve with the logic to write logs into files. This split will ease alternate implementations of access logs valves. For example, a valve that would output access logs to a Syslog server.</column><column name="report_time">2013-12-16 21:24:37</column><column name="report_timestamp">1387250000</column><column name="status">resolved fixed</column><column name="commit">92ce68a</column><column name="commit_timestamp">1389360000</column><column name="files">java/org/apache/catalina/valves/AbstractAccessLogValve.java
java/org/apache/catalina/valves/AccessLogValve.java</column><column name="result">1:java/org/apache/catalina/valves/AccessLogValve.java</column></table><table name="tomcat"><column name="id">9</column><column name="bug_id">55978</column><column name="summary">Initial call to onWritePossible() not made by container when using HTTP upgrade</column><column name="description">When using a WriteListener and non-blocking IO with the Servlet async API, the container makes the first call to onWritePossible() as per the spec. When using a WriteListener and non-blocking IO with the Servlet HTTP upgrade API the container does not make the initial call to onWritePossible(). When fixing this bug it is worth checking the initial call to onDataAvailable() as well.</column><column name="report_time">2014-01-08 10:37:25</column><column name="report_timestamp">1389200000</column><column name="status">resolved fixed</column><column name="commit">bd24edc</column><column name="commit_timestamp">1389350000</column><column name="files">java/org/apache/coyote/AbstractProtocol.java
java/org/apache/coyote/http11/upgrade/AbstractProcessor.java
java/org/apache/coyote/http11/upgrade/AbstractServletOutputStream.java
java/org/apache/coyote/http11/upgrade/AprServletOutputStream.java
java/org/apache/coyote/http11/upgrade/BioServletOutputStream.java
java/org/apache/coyote/http11/upgrade/NioServletOutputStream.java
test/org/apache/coyote/http11/upgrade/TestUpgrade.java</column><column name="result">7:java/org/apache/coyote/http11/upgrade/AbstractServletOutputStream.java
9:java/org/apache/coyote/http11/upgrade/AbstractProcessor.java
21:test/org/apache/coyote/http11/upgrade/TestUpgrade.java
354:java/org/apache/coyote/AbstractProtocol.java
373:java/org/apache/coyote/http11/upgrade/NioServletOutputStream.java
606:java/org/apache/coyote/http11/upgrade/BioServletOutputStream.java
930:java/org/apache/coyote/http11/upgrade/AprServletOutputStream.java</column></table><table name="tomcat"><column name="id">10</column><column name="bug_id">55976</column><column name="summary">Broken response from NIO connector in Tomcat 7.0.50</column><column name="description">Tomcat 7.0.50 (proposed for voting at the time of submitting this issue) with Oracle Java 1.7.0_40 on Win7 64-bit, sometimes returns incorrect response when NIO connector is used. Start of the report, and steps to reproduce the problem are in this thread: http://www.mail-archive.com/dev@tomcat.apache.org/msg80175.html -Ognjen</column><column name="report_time">2014-01-08 09:52:04</column><column name="report_timestamp">1389190000</column><column name="status">closed fixed</column><column name="commit">d423ae2</column><column name="commit_timestamp">1389300000</column><column name="files">java/org/apache/coyote/http11/Http11NioProcessor.java</column><column name="result">17:java/org/apache/coyote/http11/Http11NioProcessor.java</column></table><table name="tomcat"><column name="id">11</column><column name="bug_id">55974</column><column name="summary">Honor the order when reporting XML parsing errors and warnings in XmlErrorHandler class</column><column name="description">Originally reported in comment 1 of bug 55973. o.a.t.util.descriptor.XmlErrorHandler class stores the errors and warnings in a HashSet. A hashset does not preserve ordering. If there are several errors, then a) When all errors are printed (e.g. via XmlErrorHandler#logFindings(...)), their order is random. b) When only one error is reported (e.g. by code added in r1552826), the one error is chosen randomly. The ordering can be preserved if the collection is stored as LinkedHashSet or an ArrayList. Is there a benefit of using a 'set' here, or a 'list' would suffice?</column><column name="report_time">2014-01-07 22:59:05</column><column name="report_timestamp">1389150000</column><column name="status">resolved fixed</column><column name="commit">328adb1</column><column name="commit_timestamp">1389280000</column><column name="files">java/org/apache/tomcat/util/descriptor/XmlErrorHandler.java</column><column name="result">1:java/org/apache/tomcat/util/descriptor/XmlErrorHandler.java</column></table><table name="tomcat"><column name="id">12</column><column name="bug_id">55970</column><column name="summary">A reloadable context is reloaded repeatedly if WEB-INF/lib contains non-jar files</column><column name="description">This is reproduction recipe for an issue reported on the users@ list. See "rc-10 bug?" thread. http://tomcat.markmail.org/thread/m6eecxjuygj6yjxq Steps to reproduce with 8.0.0-RC10: ------------------------------------- 1. Mark the "examples" web application as reloadable, by adding the following file: /META-INF/context.xml &lt;Context reloadable="true"/&gt; 2. Add a stray non-jar file to the WEB-INF/lib directory. E.g. /WEB-INF/lib/foo.txt 3. Start Tomcat. 4. Every 10 seconds the examples webapp is reloaded. This is accompanied by the following log messages: 07-Jan-2014 22:01:58.672 INFO [ContainerBackgroundProcessor[StandardEngine[Catalina]]] org.apache.catalina.loader.WebappClassLoader.modified One of more JARs have been added to the web application [/examples] 07-Jan-2014 22:01:58.673 INFO [ContainerBackgroundProcessor[StandardEngine[Catalina]]] org.apache.catalina.core.StandardContext.reload Reloading Context with name [/examples] has started 07-Jan-2014 22:01:59.704 INFO [ContainerBackgroundProcessor[StandardEngine[Catalina]]] org.apache.catalina.core.StandardContext.reload Reloading Context with name [/examples] is completed ------------------------------------- Quoting from the e-mail: [quote] From webappclassloader.java snippet below (line 737), jars[] does not only contain jars, but also any other resources. i added a howTo.txt file in WEB-INF/lib, which results in jars.length will NEVER equal jarModificationTimes.size(). Fix is simple - just filter out the non-jar, non-executable elements b4 comparing. Workaround is equally trivial - remove said elements from the the lib folder. Hope this helps, Peter // Check if JARs have been added or removed WebResource[] jars = resources.listResources("/WEB-INF/lib"); if (jars.length &gt; jarModificationTimes.size()) { log.info(sm.getString("webappClassLoader.jarsAdded", resources.getContext().getName())); return true; } else if (jars.length &lt; jarModificationTimes.size()){ log.info(sm.getString("webappClassLoader.jarsRemoved", resources.getContext().getName())); return true; } for (WebResource jar : jars) { if (jar.getName().endsWith(".jar") &amp;&amp; jar.isFile() &amp;&amp; jar.canRead()) { [/quote] This affects only those web applications that were explicitly marked as "reloadable" in their or in the default context.xml file. In the default configuration the "reloadable" flag is false and thus the "modified()" check in WebappLoader.backgroundProcess() is skipped.</column><column name="report_time">2014-01-07 18:13:45</column><column name="report_timestamp">1389140000</column><column name="status">resolved fixed</column><column name="commit">5594699</column><column name="commit_timestamp">1389280000</column><column name="files">java/org/apache/catalina/loader/WebappClassLoader.java</column><column name="result">14:java/org/apache/catalina/loader/WebappClassLoader.java</column></table><table name="tomcat"><column name="id">13</column><column name="bug_id">55960</column><column name="summary">TestSSOnonLoginAndBasicAuthenticator is flawed and incomplete</column><column name="description">Created attachment 31173 updated test class and new servlet test class As the original author of this test class, I am embarrassed to have to open this bug report. I started a code review and cleanup of this class some time ago, then tried to add some new test cases to examine the way the SSO Valve interacts with the standard Authenticators for a client that does not use cookies. As my updated test class took shape, I started a thread on the users list called "Single Signon without Cookies". Based on this discussion, I removed a lot of my newly developed test cases because they were not needed. I was surprised because some of them completed "successfully" although I now realise they ought to have failed. After further investigation, I discovered that my original logic inadvertently allowed the client to return the SSO cookie even though instructed NOT to do so. Once the tests were looking better, I decided to check the overall timing and found my new suite of 7 tests had an elapsed time of 290 seconds, while the current svn version completes in only 35 seconds. Long running times are unavoidable because two tests explore SSO and webapp session expiry. One test case has to let a session expire and the shortest timeout is 1 minute. The other test has to let a session expire and prove that a longer-lived session preserves the SSO status. With an expiry granularity of 1 minute, the longer-lived session has to be expired after 2 more minutes. That means the test case will have run for nearly 4 minutes. I do not understand why, in the svn (current) version, these two test cases always run to a successful completion. The remaining test cases do not expire sessions and all complete in less than 3 seconds, so the two expiry cases are waiting about 30 seconds between them. This simply isn't long enough. What is worse, I noticed the setup methods for the two webapps call (Standard)Context.setSessionTimeout(int mins) with time arguments that are erroneously small numbers of seconds! The Tomcat code and documentation consistently define the session expiry argument to be a number of minutes, which means the short and long timeouts of 4 and 10 "seconds" would be interpreted as 4 and 10 MINUTES respectively, and so to work properly the current test ought to take about 20 minutes to complete, rather than the observed 35 seconds! I used a debugger to verify the two sessions have maxInactiveInterval set to 240 and 600 during one suspicious test. I don't think it is productive to worry about the current versions of these tests, because I have significantly redeveloped the class and debugged it. The elapsed times of the test cases confirm they now work properly. The new "no cookies" test case required a new variant of a test servlet which allows the client to supply a request parameter. This parameter is interpreted as a url which is to encoded and inserted into the HTML response. Thus the returned URL can be used by the client to continue using the established session. The only downside was the increased elapsed time when compared to the broken version. Unfortunately, there is no simple way for a unit test to establish a shorter timeout than 60 seconds. This topic was discussed at length on the dev list - the most complete account is in Konstantin's post to "Re: svn commit: r1415184" on 4 December 2012. The new version of the test class uses: ((ManagerBase) basicContext.getManager()) .setProcessExpiresFrequency(MANAGER_EXPIRE_SESSIONS_FAST); .. to ensure the sessions are expired as quickly as possible. and: StandardSession.setMaxInactiveInterval(EXTRA_DELAY_SECS); .. to force a quicker expiry of the session before waiting. The new suite of tests complete in about 50 seconds, comparable to the old broken version, and only one quarter of the "unkludged" test time. Although the elapsed time could be trimmed a little bit more, I think the version I propose has a sensible resilience to variation in real-life timeouts. The net result is an extensive change, but I cannot see how to implement it in smaller chunks because the changes are inter-dependent.</column><column name="report_time">2014-01-06 14:47:05</column><column name="report_timestamp">1389040000</column><column name="status">resolved fixed</column><column name="commit">ad129f8</column><column name="commit_timestamp">1389280000</column><column name="files">test/org/apache/catalina/authenticator/TestSSOnonLoginAndBasicAuthenticator.java
test/org/apache/catalina/startup/TesterServletEncodeUrl.java</column><column name="result">1:test/org/apache/catalina/authenticator/TestSSOnonLoginAndBasicAuthenticator.java</column></table><table name="tomcat"><column name="id">14</column><column name="bug_id">55958</column><column name="summary">Tomcat tries to deploy dir as zip archive even when it is a directory if the name ends with .war</column><column name="description">Webapp deployment fails if the dirname ends with .war because it is automatically considered as zip archive.</column><column name="report_time">2014-01-06 09:28:12</column><column name="report_timestamp">1389020000</column><column name="status">resolved fixed</column><column name="commit">5964a52</column><column name="commit_timestamp">1389280000</column><column name="files">java/org/apache/catalina/core/ContainerBase.java
java/org/apache/catalina/ha/deploy/FarmWarDeployer.java
java/org/apache/catalina/manager/HTMLManagerServlet.java
java/org/apache/catalina/mbeans/MBeanUtils.java
java/org/apache/catalina/startup/FailedContext.java
java/org/apache/catalina/startup/HostConfig.java
java/org/apache/catalina/storeconfig/StandardContextSF.java
java/org/apache/catalina/util/ContextName.java
test/org/apache/catalina/startup/TestHostConfigAutomaticDeployment.java
test/org/apache/catalina/util/TestContextName.java</column><column name="result">7:java/org/apache/catalina/manager/HTMLManagerServlet.java
8:java/org/apache/catalina/startup/HostConfig.java
9:java/org/apache/catalina/ha/deploy/FarmWarDeployer.java
12:java/org/apache/catalina/util/ContextName.java
22:test/org/apache/catalina/util/TestContextName.java
27:test/org/apache/catalina/startup/TestHostConfigAutomaticDeployment.java
50:java/org/apache/catalina/core/ContainerBase.java
59:java/org/apache/catalina/startup/FailedContext.java
222:java/org/apache/catalina/mbeans/MBeanUtils.java
228:java/org/apache/catalina/storeconfig/StandardContextSF.java</column></table><table name="tomcat"><column name="id">15</column><column name="bug_id">55937</column><column name="summary">Tomcat auto deployer not working for ROOT applications</column><column name="description">Created attachment 31162 catalina and localhost logs I am trying to deploy a web app as the ROOT application for Tomcat 7, running on Ubuntu 12 with Amazon EC2. I experienced the problem with 7.0.35, 7.0.42, and 7.0.49. 1) When I use auto-deploy using the Tomcat Deployer 'deploy' ant task to a non-ROOT context name, such as /360Site, everything works as expected - war file is uploaded, decompressed to directory, and is immediately available. 2) When I use the manager HTML interface to upload the ROOT.war file by clicking the 'Select WAR file to upload' and then clicking 'deploy', everything works as expected. However, 3) When I do exactly the same thing as #1 (tomcat auto deploy) but just change the 'path' variable from /360Store to /ROOT, here is what happens: * WAR file appears in the webapps directory, but does not get expanded. * The webapp is not running (I get a blank page when I go to the URL in the browser) * I see these entries in the catalina.&lt;date&gt;.log (after doing the auto-deploy: Dec 27, 2013 3:34:03 PM org.apache.catalina.startup.HostConfig deleteRedeployResources INFO: Undeploying context [] Dec 27, 2013 3:34:03 PM org.apache.catalina.loader.WebappClassLoader clearReferencesJdbc SEVERE: The web application [] registered the JDBC driver [com.mysql.jdbc.Driver] but failed to unregister it when the web application was stopped. To prevent a memory leak, the JDBC Driver has been forcibly unregistered. Dec 27, 2013 3:34:03 PM org.apache.catalina.startup.HostConfig deployWAR INFO: Deploying web application archive /var/lib/tomcat7/webapps/ROOT.war Dec 27, 2013 3:34:04 PM org.apache.catalina.startup.ContextConfig init SEVERE: Exception fixing docBase for context [] java.util.zip.ZipException: error in opening zip file 	at java.util.zip.ZipFile.open(Native Method) 	at java.util.zip.ZipFile.&lt;init&gt;(ZipFile.java:215) 	at java.util.zip.ZipFile.&lt;init&gt;(ZipFile.java:145) 	at java.util.jar.JarFile.&lt;init&gt;(JarFile.java:153) 	at java.util.jar.JarFile.&lt;init&gt;(JarFile.java:90) 	at sun.net.www.protocol.jar.URLJarFile.&lt;init&gt;(URLJarFile.java:93) 	at sun.net.www.protocol.jar.URLJarFile.getJarFile(URLJarFile.java:69) 	at sun.net.www.protocol.jar.JarFileFactory.get(JarFileFactory.java:88) 	at sun.net.www.protocol.jar.JarURLConnection.connect(JarURLConnection.java:122) 	at sun.net.www.protocol.jar.JarURLConnection.getJarFile(JarURLConnection.java:89) 	at org.apache.catalina.startup.ExpandWar.expand(ExpandWar.java:113) 	at org.apache.catalina.startup.ContextConfig.fixDocBase(ContextConfig.java:722) 	at org.apache.catalina.startup.ContextConfig.init(ContextConfig.java:843) 	at org.apache.catalina.startup.ContextConfig.lifecycleEvent(ContextConfig.java:387) 	at org.apache.catalina.util.LifecycleSupport.fireLifecycleEvent(LifecycleSupport.java:119) 	at org.apache.catalina.util.LifecycleBase.fireLifecycleEvent(LifecycleBase.java:90) 	at org.apache.catalina.util.LifecycleBase.setStateInternal(LifecycleBase.java:402) 	at org.apache.catalina.util.LifecycleBase.init(LifecycleBase.java:110) 	at org.apache.catalina.util.LifecycleBase.start(LifecycleBase.java:139) 	at org.apache.catalina.core.ContainerBase.addChildInternal(ContainerBase.java:901) 	at org.apache.catalina.core.ContainerBase.addChild(ContainerBase.java:877) 	at org.apache.catalina.core.StandardHost.addChild(StandardHost.java:633) 	at org.apache.catalina.startup.HostConfig.deployWAR(HostConfig.java:983) 	at org.apache.catalina.startup.HostConfig$DeployWar.run(HostConfig.java:1660) 	at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:471) 	at java.util.concurrent.FutureTask$Sync.innerRun(FutureTask.java:334) 	at java.util.concurrent.FutureTask.run(FutureTask.java:166) 	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1145) 	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:615) 	at java.lang.Thread.run(Thread.java:724) Dec 27, 2013 3:34:04 PM org.apache.catalina.core.StandardContext resourcesStart SEVERE: Error starting static Resources java.lang.IllegalArgumentException: Invalid or unreadable WAR file : error in opening zip file 	at org.apache.naming.resources.WARDirContext.setDocBase(WARDirContext.java:138) 	at org.apache.catalina.core.StandardContext.resourcesStart(StandardContext.java:5055) 	at org.apache.catalina.core.StandardContext.startInternal(StandardContext.java:5235) 	at org.apache.catalina.util.LifecycleBase.start(LifecycleBase.java:150) 	at org.apache.catalina.core.ContainerBase.addChildInternal(ContainerBase.java:901) 	at org.apache.catalina.core.ContainerBase.addChild(ContainerBase.java:877) 	at org.apache.catalina.core.StandardHost.addChild(StandardHost.java:633) 	at org.apache.catalina.startup.HostConfig.deployWAR(HostConfig.java:983) 	at org.apache.catalina.startup.HostConfig$DeployWar.run(HostConfig.java:1660) 	at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:471) 	at java.util.concurrent.FutureTask$Sync.innerRun(FutureTask.java:334) 	at java.util.concurrent.FutureTask.run(FutureTask.java:166) 	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1145) 	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:615) 	at java.lang.Thread.run(Thread.java:724) Dec 27, 2013 3:34:04 PM org.apache.catalina.core.StandardContext startInternal SEVERE: Error in resourceStart() Dec 27, 2013 3:34:04 PM org.apache.catalina.core.StandardContext startInternal SEVERE: Error getConfigured Dec 27, 2013 3:34:04 PM org.apache.catalina.core.StandardContext startInternal SEVERE: Context [] startup failed due to previous errors Dec 27, 2013 3:34:14 PM org.apache.catalina.startup.HostConfig deleteRedeployResources INFO: Undeploying context [] Dec 27, 2013 3:34:14 PM org.apache.catalina.startup.HostConfig deployWAR INFO: Deploying web application archive /var/lib/tomcat7/webapps/ROOT.war Dec 27, 2013 3:34:14 PM org.apache.catalina.startup.ContextConfig init SEVERE: Exception fixing docBase for context [] java.util.zip.ZipException: error in opening zip file 	at java.util.zip.ZipFile.open(Native Method) 	at java.util.zip.ZipFile.&lt;init&gt;(ZipFile.java:215) 	at java.util.zip.ZipFile.&lt;init&gt;(ZipFile.java:145) 	at java.util.jar.JarFile.&lt;init&gt;(JarFile.java:153) 	at java.util.jar.JarFile.&lt;init&gt;(JarFile.java:90) 	at sun.net.www.protocol.jar.URLJarFile.&lt;init&gt;(URLJarFile.java:93) 	at sun.net.www.protocol.jar.URLJarFile.getJarFile(URLJarFile.java:69) 	at sun.net.www.protocol.jar.JarFileFactory.get(JarFileFactory.java:88) 	at sun.net.www.protocol.jar.JarURLConnection.connect(JarURLConnection.java:122) 	at sun.net.www.protocol.jar.JarURLConnection.getJarFile(JarURLConnection.java:89) 	at org.apache.catalina.startup.ExpandWar.expand(ExpandWar.java:113) 	at org.apache.catalina.startup.ContextConfig.fixDocBase(ContextConfig.java:722) 	at org.apache.catalina.startup.ContextConfig.init(ContextConfig.java:843) 	at org.apache.catalina.startup.ContextConfig.lifecycleEvent(ContextConfig.java:387) 	at org.apache.catalina.util.LifecycleSupport.fireLifecycleEvent(LifecycleSupport.java:119) 	at org.apache.catalina.util.LifecycleBase.fireLifecycleEvent(LifecycleBase.java:90) 	at org.apache.catalina.util.LifecycleBase.setStateInternal(LifecycleBase.java:402) 	at org.apache.catalina.util.LifecycleBase.init(LifecycleBase.java:110) 	at org.apache.catalina.util.LifecycleBase.start(LifecycleBase.java:139) 	at org.apache.catalina.core.ContainerBase.addChildInternal(ContainerBase.java:901) 	at org.apache.catalina.core.ContainerBase.addChild(ContainerBase.java:877) 	at org.apache.catalina.core.StandardHost.addChild(StandardHost.java:633) 	at org.apache.catalina.startup.HostConfig.deployWAR(HostConfig.java:983) 	at org.apache.catalina.startup.HostConfig$DeployWar.run(HostConfig.java:1660) 	at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:471) 	at java.util.concurrent.FutureTask$Sync.innerRun(FutureTask.java:334) 	at java.util.concurrent.FutureTask.run(FutureTask.java:166) 	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1145) 	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:615) 	at java.lang.Thread.run(Thread.java:724) Dec 27, 2013 3:34:14 PM org.apache.catalina.core.StandardContext resourcesStart SEVERE: Error starting static Resources java.lang.IllegalArgumentException: Invalid or unreadable WAR file : error in opening zip file 	at org.apache.naming.resources.WARDirContext.setDocBase(WARDirContext.java:138) 	at org.apache.catalina.core.StandardContext.resourcesStart(StandardContext.java:5055) 	at org.apache.catalina.core.StandardContext.startInternal(StandardContext.java:5235) 	at org.apache.catalina.util.LifecycleBase.start(LifecycleBase.java:150) 	at org.apache.catalina.core.ContainerBase.addChildInternal(ContainerBase.java:901) 	at org.apache.catalina.core.ContainerBase.addChild(ContainerBase.java:877) 	at org.apache.catalina.core.StandardHost.addChild(StandardHost.java:633) 	at org.apache.catalina.startup.HostConfig.deployWAR(HostConfig.java:983) 	at org.apache.catalina.startup.HostConfig$DeployWar.run(HostConfig.java:1660) 	at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:471) 	at java.util.concurrent.FutureTask$Sync.innerRun(FutureTask.java:334) 	at java.util.concurrent.FutureTask.run(FutureTask.java:166) 	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1145) 	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:615) 	at java.lang.Thread.run(Thread.java:724) Dec 27, 2013 3:34:14 PM org.apache.catalina.core.StandardContext startInternal SEVERE: Error in resourceStart() Dec 27, 2013 3:34:14 PM org.apache.catalina.core.StandardContext startInternal SEVERE: Error getConfigured Dec 27, 2013 3:34:14 PM org.apache.catalina.core.StandardContext startInternal SEVERE: Context [] startup failed due to previous errors Dec 27, 2013 3:34:21 PM org.apache.catalina.startup.HostConfig deployWAR INFO: Deploying web application archive /var/lib/tomcat7/webapps/ROOT.war Dec 27, 2013 3:34:21 PM org.apache.catalina.startup.HostConfig deployWAR SEVERE: Error deploying web application archive /var/lib/tomcat7/webapps/ROOT.war java.lang.IllegalArgumentException: addChild: Child name '' is not unique 	at org.apache.catalina.core.ContainerBase.addChildInternal(ContainerBase.java:887) 	at org.apache.catalina.core.ContainerBase.addChild(ContainerBase.java:877) 	at org.apache.catalina.core.StandardHost.addChild(StandardHost.java:633) 	at org.apache.catalina.startup.HostConfig.deployWAR(HostConfig.java:983) 	at org.apache.catalina.startup.HostConfig.deployApps(HostConfig.java:548) 	at org.apache.catalina.startup.HostConfig.check(HostConfig.java:1468) 	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) 	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57) 	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) 	at java.lang.reflect.Method.invoke(Method.java:606) 	at org.apache.tomcat.util.modeler.BaseModelMBean.invoke(BaseModelMBean.java:301) 	at com.sun.jmx.interceptor.DefaultMBeanServerInterceptor.invoke(DefaultMBeanServerInterceptor.java:819) 	at com.sun.jmx.mbeanserver.JmxMBeanServer.invoke(JmxMBeanServer.java:801) 	at org.apache.catalina.manager.ManagerServlet.check(ManagerServlet.java:1447) 	at org.apache.catalina.manager.ManagerServlet.deploy(ManagerServlet.java:679) 	at org.apache.catalina.manager.ManagerServlet.doPut(ManagerServlet.java:437) 	at javax.servlet.http.HttpServlet.service(HttpServlet.java:650) 	at javax.servlet.http.HttpServlet.service(HttpServlet.java:728) 	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:305) 	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:210) 	at org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51) 	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:243) 	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:210) 	at org.apache.catalina.filters.SetCharacterEncodingFilter.doFilter(SetCharacterEncodingFilter.java:108) 	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:243) 	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:210) 	at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:222) 	at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:123) 	at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:611) 	at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:171) 	at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:100) 	at org.apache.catalina.valves.AccessLogValve.invoke(AccessLogValve.java:953) 	at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:118) 	at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:408) 	at org.apache.coyote.http11.AbstractHttp11Processor.process(AbstractHttp11Processor.java:1041) 	at org.apache.coyote.AbstractProtocol$AbstractConnectionHandler.process(AbstractProtocol.java:603) 	at org.apache.tomcat.util.net.JIoEndpoint$SocketProcessor.run(JIoEndpoint.java:310) 	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1145) 	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:615) 	at java.lang.Thread.run(Thread.java:724) * After the auto-deploy fails, I can go into the HTML manager page and click the 'start' button, and the webapp does successfully start (tested the URL in the browser), but the WAR file still does not get unpacked into a directory. Doing the exact same thing to a different server running Tomcat 6.0.24 works correctly as expected. Any ideas here? Here is what I've ruled out so far: * I don't think it's a file permission issue (tomcat7 is the owner of the webapps directory, and everything works fine when run through the manager HTML interface). * The "Child name '' is not unique" sounded promising, but I could not find any duplicate ROOT webapps - there is no ROOT.war file or directory in the webapps directory prior to running the auto-deploy; there is no ROOT.xml file in the conf/Catalina/localhost directory, nor are there any context elements defined in the server.xml file. * I don't think that the .war file is corrupt - I can manually unzip the .war file in the webapps from the command line using the 'unzip' command, and as I pointed out in #2 above, everything works fine when it is uploaded using the manager HTML interface. If it would help to spin up a temporary new Ubuntu deployment and provide credentials to reproduce the problem, I'd be happy to do that.</column><column name="report_time">2013-12-27 15:41:22</column><column name="report_timestamp">1388180000</column><column name="status">resolved fixed</column><column name="commit">346e264</column><column name="commit_timestamp">1389270000</column><column name="files">java/org/apache/catalina/util/ContextName.java
test/org/apache/catalina/util/TestContextName.java</column><column name="result">308:java/org/apache/catalina/util/ContextName.java
372:test/org/apache/catalina/util/TestContextName.java</column></table><table name="tomcat"><column name="id">16</column><column name="bug_id">55939</column><column name="summary">Seeing issues with non-blocking io when writing lots of data</column><column name="description">Created attachment 31164 Unit test to replicate the problem I have a simple servlet which I'm running on Tomcat 8 trunk (1554057) with Java 7. It's using a non-blocking IO WriteListener to write 8k blocks of static data to the response. The number of blocks it will write is given as a request parameter. When I start out making individual requests to the server (1-1000 blocks) things are fine and those are handled without a problem. However once I start to send multiple requests using JMeter, requests begin to fail. It starts slowly with only a few requests failing and then proceeds to the point where every request fails. At that point, Tomcat will serve JSP pages and Servlets that use blocking IO, but it will not serve any requests that use the non-blocking IO apis (ReadListener / WriteListener). For example, if I try to hit the byte counter servlet or number writer servlet included in the examples then my browser will timeout or display the error "java.lang.IllegalStateException: getOutputStream() has already been called for this response". I put together a unit test that replicates the async context timeout issue. Code is attached. When run, you'll see that it processes some of the requests but fails due to a timeout. Note 1 out of 5 times on my laptop the attached test will pass, so you may need to run it a couple times to see the issue. More details on this email thread: http://tomcat.markmail.org/message/jcgwqb7i5dgqtcqz Thanks</column><column name="report_time">2013-12-29 19:40:03</column><column name="report_timestamp">1388360000</column><column name="status">resolved fixed</column><column name="commit">411e4cc</column><column name="commit_timestamp">1388430000</column><column name="files">java/org/apache/coyote/Response.java</column><column name="result">5:java/org/apache/coyote/Response.java</column></table><table name="tomcat"><column name="id">17</column><column name="bug_id">55905</column><column name="summary">Error message unhelpful when web.xml references a tld file that doesn't exist</column><column name="description">In your web-application web.xml add a taglib element but get the taglib-location wrong or forgot to include *.tld when packaging your archive &lt;jsp-config&gt; &lt;taglib&gt; &lt;taglib-uri&gt;http://www.example.org/mytaglib&lt;/taglib-uri&gt; &lt;taglib-location&gt;/WEB-INF/wrong.tld&lt;/taglib-location&gt; &lt;/taglib&gt; &lt;/jsp-config&gt; Start you web-app. Expected: Get a helpful message like WARN org.apache.catalina.startup.TldConfig - Failed to process TLD with path [/WEB-INF/wrong.tld] and URI [http://www.example.org/mytaglib] java.io.FileNotFoundException: /WEB-INF/wrong.tld ... Actual: WARN org.apache.catalina.startup.TldConfig - Failed to process TLD with path [http://www.example.org/mytaglib] and URI [/WEB-INF/wrong.tld] java.net.MalformedURLException: null ... Note also that with the current error message the path is labelled at the URI and vice versa, adding to the confusion.</column><column name="report_time">2013-12-18 14:30:15</column><column name="report_timestamp">1387400000</column><column name="status">resolved fixed</column><column name="commit">bcb9c58</column><column name="commit_timestamp">1387390000</column><column name="files">java/org/apache/jasper/servlet/TldScanner.java</column><column name="result">6:java/org/apache/jasper/servlet/TldScanner.java</column></table><table name="tomcat"><column name="id">18</column><column name="bug_id">55884</column><column name="summary">JSPs no longer compile in Java 8</column><column name="description">I would normally message the list first, but I am fairly certain this is a Tomcat bug, and I can't attach anything to the list. I have attached a WAR file with a simple application in it, compiled for Java 7. A few months ago this application ran fine on Tomcat 8.0 with Tomcat configured to compile JSPs using Ant and source/target 1.8. Now it doesn't. With Tomcat trunk and the standard JSP compilation configuration (Eclipse), the application runs fine. Go to http://localhost:8080/messaging1 and the JSP compiles and displays fine. However, if I add the following setenv.bat to the bin directory: set "CLASSPATH=C:\Program Files\Java\jdk8\lib\tools.jar;C:\Program Files\Apache Software Foundation\Ant\lib\ant.jar;C:\Program Files\Apache Software Foundation\Ant\lib\ant-launcher.jar" Then reconfigure the JspServlet like so: &lt;servlet&gt; &lt;servlet-name&gt;jsp&lt;/servlet-name&gt; &lt;servlet-class&gt;org.apache.jasper.servlet.JspServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;fork&lt;/param-name&gt; &lt;param-value&gt;false&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;xpoweredBy&lt;/param-name&gt; &lt;param-value&gt;false&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;compiler&lt;/param-name&gt; &lt;param-value&gt;modern&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;compilerSourceVM&lt;/param-name&gt; &lt;param-value&gt;1.8&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;compilerTargetVM&lt;/param-name&gt; &lt;param-value&gt;1.8&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;3&lt;/load-on-startup&gt; &lt;/servlet&gt; And finally test the application again, JSPs no longer compile. Instead, I get the following error in catalina.*.log. Again, this exact application worked in Tomcat 8.0 with the same JSP compilation configuration just a few months ago. I recently got and compiled the latest trunk to obtain a bug fix, and now this doesn't work. 14-Dec-2013 10:54:14.432 SEVERE [http-nio-8080-exec-4] org.apache.jasper.compiler.AntCompiler.generateClass Javac exception Compile failed; see the compiler error output for details. 	at org.apache.tools.ant.taskdefs.Javac.compile(Javac.java:1174) 	at org.apache.tools.ant.taskdefs.Javac.execute(Javac.java:930) 	at org.apache.jasper.compiler.AntCompiler.generateClass(AntCompiler.java:234) 	at org.apache.jasper.compiler.Compiler.compile(Compiler.java:380) 	at org.apache.jasper.compiler.Compiler.compile(Compiler.java:355) 	at org.apache.jasper.compiler.Compiler.compile(Compiler.java:342) 	at org.apache.jasper.JspCompilationContext.compile(JspCompilationContext.java:564) 	at org.apache.jasper.servlet.JspServletWrapper.service(JspServletWrapper.java:357) 	at org.apache.jasper.servlet.JspServlet.serviceJspFile(JspServlet.java:403) 	at org.apache.jasper.servlet.JspServlet.service(JspServlet.java:347) 	at javax.servlet.http.HttpServlet.service(HttpServlet.java:728) 	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:303) 	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:208) 	at org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51) 	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:241) 	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:208) 	at org.apache.logging.log4j.core.web.Log4jServletFilter.doFilter(Log4jServletFilter.java:59) 	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:241) 	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:208) 	at org.apache.catalina.core.ApplicationDispatcher.invoke(ApplicationDispatcher.java:729) 	at org.apache.catalina.core.ApplicationDispatcher.processRequest(ApplicationDispatcher.java:467) 	at org.apache.catalina.core.ApplicationDispatcher.doForward(ApplicationDispatcher.java:392) 	at org.apache.catalina.core.ApplicationDispatcher.forward(ApplicationDispatcher.java:319) 	at org.springframework.web.servlet.view.InternalResourceView.renderMergedOutputModel(InternalResourceView.java:209) 	at org.springframework.web.servlet.view.AbstractView.render(AbstractView.java:266) 	at org.springframework.web.servlet.DispatcherServlet.render(DispatcherServlet.java:1225) 	at org.springframework.web.servlet.DispatcherServlet.processDispatchResult(DispatcherServlet.java:1012) 	at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:959) 	at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:876) 	at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:931) 	at org.springframework.web.servlet.FrameworkServlet.doGet(FrameworkServlet.java:822) 	at javax.servlet.http.HttpServlet.service(HttpServlet.java:621) 	at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:807) 	at javax.servlet.http.HttpServlet.service(HttpServlet.java:728) 	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:303) 	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:208) 	at org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51) 	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:241) 	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:208) 	at org.apache.logging.log4j.core.web.Log4jServletFilter.doFilter(Log4jServletFilter.java:66) 	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:241) 	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:208) 	at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:222) 	at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:107) 	at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:504) 	at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:155) 	at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:76) 	at org.apache.catalina.valves.AccessLogValve.invoke(AccessLogValve.java:934) 	at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:90) 	at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:522) 	at org.apache.coyote.http11.AbstractHttp11Processor.process(AbstractHttp11Processor.java:1015) 	at org.apache.coyote.AbstractProtocol$AbstractConnectionHandler.process(AbstractProtocol.java:646) 	at org.apache.coyote.http11.Http11NioProtocol$Http11ConnectionHandler.process(Http11NioProtocol.java:223) 	at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1597) 	at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.run(NioEndpoint.java:1555) 	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142) 	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617) 	at java.lang.Thread.run(Thread.java:744) 14-Dec-2013 10:54:14.432 SEVERE [http-nio-8080-exec-4] org.apache.jasper.compiler.AntCompiler.generateClass Environment:Compile: javaFileName=C:\Program Files\Apache Software Foundation\Tomcat 8.0\work\Catalina\localhost\messaging1\org\apache\jsp\WEB_002dINF\jsp\view\login_jsp.java classpath=/C:/Program%20Files/Apache%20Software%20Foundation/Tomcat%208.0/webapps/messaging1/WEB-INF/classes/;/C:/Program%20Files/Apache%20Software%20Foundation/Tomcat%208.0/webapps/messaging1/WEB-INF/lib/aopalliance-1.0.jar;/C:/Program%20Files/Apache%20Software%20Foundation/Tomcat%208.0/webapps/messaging1/WEB-INF/lib/classmate-0.8.0.jar;/C:/Program%20Files/Apache%20Software%20Foundation/Tomcat%208.0/webapps/messaging1/WEB-INF/lib/commons-lang3-3.1.jar;/C:/Program%20Files/Apache%20Software%20Foundation/Tomcat%208.0/webapps/messaging1/WEB-INF/lib/commons-logging-1.1.1.jar;/C:/Program%20Files/Apache%20Software%20Foundation/Tomcat%208.0/webapps/messaging1/WEB-INF/lib/hibernate-validator-5.1.0.Alpha1.jar;/C:/Program%20Files/Apache%20Software%20Foundation/Tomcat%208.0/webapps/messaging1/WEB-INF/lib/jackson-annotations-2.3.0.jar;/C:/Program%20Files/Apache%20Software%20Foundation/Tomcat%208.0/webapps/messaging1/WEB-INF/lib/jackson-core-2.3.0.jar;/C:/Program%20Files/Apache%20Software%20Foundation/Tomcat%208.0/webapps/messaging1/WEB-INF/lib/jackson-databind-2.3.0.jar;/C:/Program%20Files/Apache%20Software%20Foundation/Tomcat%208.0/webapps/messaging1/WEB-INF/lib/jackson-datatype-jsr310-2.3.0-rc1.jar;/C:/Program%20Files/Apache%20Software%20Foundation/Tomcat%208.0/webapps/messaging1/WEB-INF/lib/javax.annotation-api-1.2.jar;/C:/Program%20Files/Apache%20Software%20Foundation/Tomcat%208.0/webapps/messaging1/WEB-INF/lib/javax.inject-1.jar;/C:/Program%20Files/Apache%20Software%20Foundation/Tomcat%208.0/webapps/messaging1/WEB-INF/lib/javax.servlet.jsp.jstl-1.2.2.jar;/C:/Program%20Files/Apache%20Software%20Foundation/Tomcat%208.0/webapps/messaging1/WEB-INF/lib/javax.servlet.jsp.jstl-api-1.2.1.jar;/C:/Program%20Files/Apache%20Software%20Foundation/Tomcat%208.0/webapps/messaging1/WEB-INF/lib/jboss-logging-3.1.3.GA.jar;/C:/Program%20Files/Apache%20Software%20Foundation/Tomcat%208.0/webapps/messaging1/WEB-INF/lib/log4j-api-2.0-beta9.jar;/C:/Program%20Files/Apache%20Software%20Foundation/Tomcat%208.0/webapps/messaging1/WEB-INF/lib/log4j-core-2.0-beta9.jar;/C:/Program%20Files/Apache%20Software%20Foundation/Tomcat%208.0/webapps/messaging1/WEB-INF/lib/log4j-jcl-2.0-beta9.jar;/C:/Program%20Files/Apache%20Software%20Foundation/Tomcat%208.0/webapps/messaging1/WEB-INF/lib/log4j-slf4j-impl-2.0-beta9.jar;/C:/Program%20Files/Apache%20Software%20Foundation/Tomcat%208.0/webapps/messaging1/WEB-INF/lib/log4j-taglib-2.0-beta9.jar;/C:/Program%20Files/Apache%20Software%20Foundation/Tomcat%208.0/webapps/messaging1/WEB-INF/lib/slf4j-api-1.7.5.jar;/C:/Program%20Files/Apache%20Software%20Foundation/Tomcat%208.0/webapps/messaging1/WEB-INF/lib/spring-aop-4.0.0.RELEASE.jar;/C:/Program%20Files/Apache%20Software%20Foundation/Tomcat%208.0/webapps/messaging1/WEB-INF/lib/spring-beans-4.0.0.RELEASE.jar;/C:/Program%20Files/Apache%20Software%20Foundation/Tomcat%208.0/webapps/messaging1/WEB-INF/lib/spring-context-4.0.0.RELEASE.jar;/C:/Program%20Files/Apache%20Software%20Foundation/Tomcat%208.0/webapps/messaging1/WEB-INF/lib/spring-core-4.0.0.RELEASE.jar;/C:/Program%20Files/Apache%20Software%20Foundation/Tomcat%208.0/webapps/messaging1/WEB-INF/lib/spring-expression-4.0.0.RELEASE.jar;/C:/Program%20Files/Apache%20Software%20Foundation/Tomcat%208.0/webapps/messaging1/WEB-INF/lib/spring-oxm-4.0.0.RELEASE.jar;/C:/Program%20Files/Apache%20Software%20Foundation/Tomcat%208.0/webapps/messaging1/WEB-INF/lib/spring-web-4.0.0.RELEASE.jar;/C:/Program%20Files/Apache%20Software%20Foundation/Tomcat%208.0/webapps/messaging1/WEB-INF/lib/spring-webmvc-4.0.0.RELEASE.jar;/C:/Program%20Files/Apache%20Software%20Foundation/Tomcat%208.0/webapps/messaging1/WEB-INF/lib/spring-websocket-4.0.0.RELEASE.jar;/C:/Program%20Files/Apache%20Software%20Foundation/Tomcat%208.0/webapps/messaging1/WEB-INF/lib/validation-api-1.1.0.Final.jar;C:\Program Files\Apache Software Foundation\Tomcat 8.0\work\Catalina\localhost\messaging1;/C:/Program Files/Apache Software Foundation/Tomcat 8.0/lib/;/C:/Program Files/Apache Software Foundation/Tomcat 8.0/lib/annotations-api.jar;/C:/Program Files/Apache Software Foundation/Tomcat 8.0/lib/catalina-ant.jar;/C:/Program Files/Apache Software Foundation/Tomcat 8.0/lib/catalina-ha.jar;/C:/Program Files/Apache Software Foundation/Tomcat 8.0/lib/catalina-storeconfig.jar;/C:/Program Files/Apache Software Foundation/Tomcat 8.0/lib/catalina-tribes.jar;/C:/Program Files/Apache Software Foundation/Tomcat 8.0/lib/catalina.jar;/C:/Program Files/Apache Software Foundation/Tomcat 8.0/lib/ecj-4.3.1.jar;/C:/Program Files/Apache Software Foundation/Tomcat 8.0/lib/el-api.jar;/C:/Program Files/Apache Software Foundation/Tomcat 8.0/lib/jasper-el.jar;/C:/Program Files/Apache Software Foundation/Tomcat 8.0/lib/jasper.jar;/C:/Program Files/Apache Software Foundation/Tomcat 8.0/lib/jsp-api.jar;/C:/Program Files/Apache Software Foundation/Tomcat 8.0/lib/servlet-api.jar;/C:/Program Files/Apache Software Foundation/Tomcat 8.0/lib/tomcat-api.jar;/C:/Program Files/Apache Software Foundation/Tomcat 8.0/lib/tomcat-coyote.jar;/C:/Program Files/Apache Software Foundation/Tomcat 8.0/lib/tomcat-dbcp.jar;/C:/Program Files/Apache Software Foundation/Tomcat 8.0/lib/tomcat-i18n-es.jar;/C:/Program Files/Apache Software Foundation/Tomcat 8.0/lib/tomcat-i18n-fr.jar;/C:/Program Files/Apache Software Foundation/Tomcat 8.0/lib/tomcat-i18n-ja.jar;/C:/Program Files/Apache Software Foundation/Tomcat 8.0/lib/tomcat-jdbc.jar;/C:/Program Files/Apache Software Foundation/Tomcat 8.0/lib/tomcat-jni.jar;/C:/Program Files/Apache Software Foundation/Tomcat 8.0/lib/tomcat-spdy.jar;/C:/Program Files/Apache Software Foundation/Tomcat 8.0/lib/tomcat-util-scan.jar;/C:/Program Files/Apache Software Foundation/Tomcat 8.0/lib/tomcat-util.jar;/C:/Program Files/Apache Software Foundation/Tomcat 8.0/lib/tomcat-websocket.jar;/C:/Program Files/Apache Software Foundation/Tomcat 8.0/lib/websocket-api.jar;/C:/Program Files/Java/jdk8/lib/tools.jar;/C:/Program Files/Apache Software Foundation/Ant/lib/ant.jar;/C:/Program Files/Apache Software Foundation/Ant/lib/ant-launcher.jar;/C:/Program Files/Apache Software Foundation/Tomcat 8.0/bin/bootstrap.jar;/C:/Program Files/Apache Software Foundation/Tomcat 8.0/bin/tomcat-juli.jar;/C:/Program Files/Java/jdk8/jre/lib/ext/access-bridge-64.jar;/C:/Program Files/Java/jdk8/jre/lib/ext/cldrdata.jar;/C:/Program Files/Java/jdk8/jre/lib/ext/dnsns.jar;/C:/Program Files/Java/jdk8/jre/lib/ext/jaccess.jar;/C:/Program Files/Java/jdk8/jre/lib/ext/jfxrt.jar;/C:/Program Files/Java/jdk8/jre/lib/ext/localedata.jar;/C:/Program Files/Java/jdk8/jre/lib/ext/nashorn.jar;/C:/Program Files/Java/jdk8/jre/lib/ext/sunec.jar;/C:/Program Files/Java/jdk8/jre/lib/ext/sunjce_provider.jar;/C:/Program Files/Java/jdk8/jre/lib/ext/sunmscapi.jar;/C:/Program Files/Java/jdk8/jre/lib/ext/sunpkcs11.jar;/C:/Program Files/Java/jdk8/jre/lib/ext/zipfs.jar cp=C:\Program Files\Java\jdk8\lib\tools.jar;C:\Program Files\Apache Software Foundation\Ant\lib\ant.jar;C:\Program Files\Apache Software Foundation\Ant\lib\ant-launcher.jar;C:\Program Files\Apache Software Foundation\Tomcat 8.0\bin\bootstrap.jar;C:\Program Files\Apache Software Foundation\Tomcat 8.0\bin\tomcat-juli.jar cp=C:\Program%20Files\Apache%20Software%20Foundation\Tomcat%208.0\webapps\messaging1\WEB-INF\classes cp=C:\Program%20Files\Apache%20Software%20Foundation\Tomcat%208.0\webapps\messaging1\WEB-INF\lib\aopalliance-1.0.jar cp=C:\Program%20Files\Apache%20Software%20Foundation\Tomcat%208.0\webapps\messaging1\WEB-INF\lib\classmate-0.8.0.jar cp=C:\Program%20Files\Apache%20Software%20Foundation\Tomcat%208.0\webapps\messaging1\WEB-INF\lib\commons-lang3-3.1.jar cp=C:\Program%20Files\Apache%20Software%20Foundation\Tomcat%208.0\webapps\messaging1\WEB-INF\lib\commons-logging-1.1.1.jar cp=C:\Program%20Files\Apache%20Software%20Foundation\Tomcat%208.0\webapps\messaging1\WEB-INF\lib\hibernate-validator-5.1.0.Alpha1.jar cp=C:\Program%20Files\Apache%20Software%20Foundation\Tomcat%208.0\webapps\messaging1\WEB-INF\lib\jackson-annotations-2.3.0.jar cp=C:\Program%20Files\Apache%20Software%20Foundation\Tomcat%208.0\webapps\messaging1\WEB-INF\lib\jackson-core-2.3.0.jar cp=C:\Program%20Files\Apache%20Software%20Foundation\Tomcat%208.0\webapps\messaging1\WEB-INF\lib\jackson-databind-2.3.0.jar cp=C:\Program%20Files\Apache%20Software%20Foundation\Tomcat%208.0\webapps\messaging1\WEB-INF\lib\jackson-datatype-jsr310-2.3.0-rc1.jar cp=C:\Program%20Files\Apache%20Software%20Foundation\Tomcat%208.0\webapps\messaging1\WEB-INF\lib\javax.annotation-api-1.2.jar cp=C:\Program%20Files\Apache%20Software%20Foundation\Tomcat%208.0\webapps\messaging1\WEB-INF\lib\javax.inject-1.jar cp=C:\Program%20Files\Apache%20Software%20Foundation\Tomcat%208.0\webapps\messaging1\WEB-INF\lib\javax.servlet.jsp.jstl-1.2.2.jar cp=C:\Program%20Files\Apache%20Software%20Foundation\Tomcat%208.0\webapps\messaging1\WEB-INF\lib\javax.servlet.jsp.jstl-api-1.2.1.jar cp=C:\Program%20Files\Apache%20Software%20Foundation\Tomcat%208.0\webapps\messaging1\WEB-INF\lib\jboss-logging-3.1.3.GA.jar cp=C:\Program%20Files\Apache%20Software%20Foundation\Tomcat%208.0\webapps\messaging1\WEB-INF\lib\log4j-api-2.0-beta9.jar cp=C:\Program%20Files\Apache%20Software%20Foundation\Tomcat%208.0\webapps\messaging1\WEB-INF\lib\log4j-core-2.0-beta9.jar cp=C:\Program%20Files\Apache%20Software%20Foundation\Tomcat%208.0\webapps\messaging1\WEB-INF\lib\log4j-jcl-2.0-beta9.jar cp=C:\Program%20Files\Apache%20Software%20Foundation\Tomcat%208.0\webapps\messaging1\WEB-INF\lib\log4j-slf4j-impl-2.0-beta9.jar cp=C:\Program%20Files\Apache%20Software%20Foundation\Tomcat%208.0\webapps\messaging1\WEB-INF\lib\log4j-taglib-2.0-beta9.jar cp=C:\Program%20Files\Apache%20Software%20Foundation\Tomcat%208.0\webapps\messaging1\WEB-INF\lib\slf4j-api-1.7.5.jar cp=C:\Program%20Files\Apache%20Software%20Foundation\Tomcat%208.0\webapps\messaging1\WEB-INF\lib\spring-aop-4.0.0.RELEASE.jar cp=C:\Program%20Files\Apache%20Software%20Foundation\Tomcat%208.0\webapps\messaging1\WEB-INF\lib\spring-beans-4.0.0.RELEASE.jar cp=C:\Program%20Files\Apache%20Software%20Foundation\Tomcat%208.0\webapps\messaging1\WEB-INF\lib\spring-context-4.0.0.RELEASE.jar cp=C:\Program%20Files\Apache%20Software%20Foundation\Tomcat%208.0\webapps\messaging1\WEB-INF\lib\spring-core-4.0.0.RELEASE.jar cp=C:\Program%20Files\Apache%20Software%20Foundation\Tomcat%208.0\webapps\messaging1\WEB-INF\lib\spring-expression-4.0.0.RELEASE.jar cp=C:\Program%20Files\Apache%20Software%20Foundation\Tomcat%208.0\webapps\messaging1\WEB-INF\lib\spring-oxm-4.0.0.RELEASE.jar cp=C:\Program%20Files\Apache%20Software%20Foundation\Tomcat%208.0\webapps\messaging1\WEB-INF\lib\spring-web-4.0.0.RELEASE.jar cp=C:\Program%20Files\Apache%20Software%20Foundation\Tomcat%208.0\webapps\messaging1\WEB-INF\lib\spring-webmvc-4.0.0.RELEASE.jar cp=C:\Program%20Files\Apache%20Software%20Foundation\Tomcat%208.0\webapps\messaging1\WEB-INF\lib\spring-websocket-4.0.0.RELEASE.jar cp=C:\Program%20Files\Apache%20Software%20Foundation\Tomcat%208.0\webapps\messaging1\WEB-INF\lib\validation-api-1.1.0.Final.jar cp=C:\Program Files\Apache Software Foundation\Tomcat 8.0\work\Catalina\localhost\messaging1 cp=C:\Program Files\Apache Software Foundation\Tomcat 8.0\lib cp=C:\Program Files\Apache Software Foundation\Tomcat 8.0\lib\annotations-api.jar cp=C:\Program Files\Apache Software Foundation\Tomcat 8.0\lib\catalina-ant.jar cp=C:\Program Files\Apache Software Foundation\Tomcat 8.0\lib\catalina-ha.jar cp=C:\Program Files\Apache Software Foundation\Tomcat 8.0\lib\catalina-storeconfig.jar cp=C:\Program Files\Apache Software Foundation\Tomcat 8.0\lib\catalina-tribes.jar cp=C:\Program Files\Apache Software Foundation\Tomcat 8.0\lib\catalina.jar cp=C:\Program Files\Apache Software Foundation\Tomcat 8.0\lib\ecj-4.3.1.jar cp=C:\Program Files\Apache Software Foundation\Tomcat 8.0\lib\el-api.jar cp=C:\Program Files\Apache Software Foundation\Tomcat 8.0\lib\jasper-el.jar cp=C:\Program Files\Apache Software Foundation\Tomcat 8.0\lib\jasper.jar cp=C:\Program Files\Apache Software Foundation\Tomcat 8.0\lib\jsp-api.jar cp=C:\Program Files\Apache Software Foundation\Tomcat 8.0\lib\servlet-api.jar cp=C:\Program Files\Apache Software Foundation\Tomcat 8.0\lib\tomcat-api.jar cp=C:\Program Files\Apache Software Foundation\Tomcat 8.0\lib\tomcat-coyote.jar cp=C:\Program Files\Apache Software Foundation\Tomcat 8.0\lib\tomcat-dbcp.jar cp=C:\Program Files\Apache Software Foundation\Tomcat 8.0\lib\tomcat-i18n-es.jar cp=C:\Program Files\Apache Software Foundation\Tomcat 8.0\lib\tomcat-i18n-fr.jar cp=C:\Program Files\Apache Software Foundation\Tomcat 8.0\lib\tomcat-i18n-ja.jar cp=C:\Program Files\Apache Software Foundation\Tomcat 8.0\lib\tomcat-jdbc.jar cp=C:\Program Files\Apache Software Foundation\Tomcat 8.0\lib\tomcat-jni.jar cp=C:\Program Files\Apache Software Foundation\Tomcat 8.0\lib\tomcat-spdy.jar cp=C:\Program Files\Apache Software Foundation\Tomcat 8.0\lib\tomcat-util-scan.jar cp=C:\Program Files\Apache Software Foundation\Tomcat 8.0\lib\tomcat-util.jar cp=C:\Program Files\Apache Software Foundation\Tomcat 8.0\lib\tomcat-websocket.jar cp=C:\Program Files\Apache Software Foundation\Tomcat 8.0\lib\websocket-api.jar cp=C:\Program Files\Java\jdk8\lib\tools.jar cp=C:\Program Files\Apache Software Foundation\Ant\lib\ant.jar cp=C:\Program Files\Apache Software Foundation\Ant\lib\ant-launcher.jar cp=C:\Program Files\Apache Software Foundation\Tomcat 8.0\bin\bootstrap.jar cp=C:\Program Files\Apache Software Foundation\Tomcat 8.0\bin\tomcat-juli.jar cp=C:\Program Files\Java\jdk8\jre\lib\ext\access-bridge-64.jar cp=C:\Program Files\Java\jdk8\jre\lib\ext\cldrdata.jar cp=C:\Program Files\Java\jdk8\jre\lib\ext\dnsns.jar cp=C:\Program Files\Java\jdk8\jre\lib\ext\jaccess.jar cp=C:\Program Files\Java\jdk8\jre\lib\ext\jfxrt.jar cp=C:\Program Files\Java\jdk8\jre\lib\ext\localedata.jar cp=C:\Program Files\Java\jdk8\jre\lib\ext\nashorn.jar cp=C:\Program Files\Java\jdk8\jre\lib\ext\sunec.jar cp=C:\Program Files\Java\jdk8\jre\lib\ext\sunjce_provider.jar cp=C:\Program Files\Java\jdk8\jre\lib\ext\sunmscapi.jar cp=C:\Program Files\Java\jdk8\jre\lib\ext\sunpkcs11.jar cp=C:\Program Files\Java\jdk8\jre\lib\ext\zipfs.jar work dir=C:\Program Files\Apache Software Foundation\Tomcat 8.0\work\Catalina\localhost\messaging1 extension dir=C:\Program Files\Java\jdk8\jre\lib\ext;C:\Windows\Sun\Java\lib\ext srcDir=C:\Program Files\Apache Software Foundation\Tomcat 8.0\work\Catalina\localhost\messaging1 compiler=modern compilerTargetVM=1.8 compilerSourceVM=1.8 include=org/apache/jsp/WEB_002dINF/jsp/view/login_jsp.java 14-Dec-2013 10:54:14.448 SEVERE [http-nio-8080-exec-4] org.apache.jasper.compiler.AntCompiler.generateClass Error compiling file: C:\Program Files\Apache Software Foundation\Tomcat 8.0\work\Catalina\localhost\messaging1\org\apache\jsp\WEB_002dINF\jsp\view\login_jsp.java [javac] warning: 'includeantruntime' was not set, defaulting to build.sysclasspath=last; set to false for repeatable builds [javac] Compiling 1 source file C:\Program Files\Apache Software Foundation\Tomcat 8.0\work\Catalina\localhost\messaging1\org\apache\jsp\WEB_002dINF\jsp\view\login_jsp.java:108: error: package org.apache.taglibs.standard.tag.rt.core does not exist org.apache.taglibs.standard.tag.rt.core.UrlTag _jspx_th_c_005furl_005f0 = (org.apache.taglibs.standard.tag.rt.core.UrlTag) _005fjspx_005ftagPool_005fc_005furl_0026_005fvalue_005fnobody.get(org.apache.taglibs.standard.tag.rt.core.UrlTag.class); ^ C:\Program Files\Apache Software Foundation\Tomcat 8.0\work\Catalina\localhost\messaging1\org\apache\jsp\WEB_002dINF\jsp\view\login_jsp.java:108: error: package org.apache.taglibs.standard.tag.rt.core does not exist org.apache.taglibs.standard.tag.rt.core.UrlTag _jspx_th_c_005furl_005f0 = (org.apache.taglibs.standard.tag.rt.core.UrlTag) _005fjspx_005ftagPool_005fc_005furl_0026_005fvalue_005fnobody.get(org.apache.taglibs.standard.tag.rt.core.UrlTag.class); ^ C:\Program Files\Apache Software Foundation\Tomcat 8.0\work\Catalina\localhost\messaging1\org\apache\jsp\WEB_002dINF\jsp\view\login_jsp.java:108: error: package org.apache.taglibs.standard.tag.rt.core does not exist org.apache.taglibs.standard.tag.rt.core.UrlTag _jspx_th_c_005furl_005f0 = (org.apache.taglibs.standard.tag.rt.core.UrlTag) _005fjspx_005ftagPool_005fc_005furl_0026_005fvalue_005fnobody.get(org.apache.taglibs.standard.tag.rt.core.UrlTag.class); ^ 3 errors</column><column name="report_time">2013-12-14 17:03:59</column><column name="report_timestamp">1387060000</column><column name="status">verified fixed</column><column name="commit">8a5179c</column><column name="commit_timestamp">1387210000</column><column name="files">java/org/apache/jasper/compiler/JspRuntimeContext.java</column><column name="result">9:java/org/apache/jasper/compiler/JspRuntimeContext.java</column></table><table name="tomcat"><column name="id">19</column><column name="bug_id">55820</column><column name="summary">Add 172.16/12 range to default internal proxies</column><column name="description">Currently documentation states [1] 172.16/12 has not been enabled by default because it is complex to describe with regular expressions The regular expression for 172.16/12 is 172\.1[6-9]{1}\.\d{1,3}\.\d{1,3}|172\.2[0-9]{1}\.\d{1,3}\.\d{1,3}|172\.3[0-1]{1}\.\d{1,3}\.\d{1,3} The entire expression would be 10\.\d{1,3}\.\d{1,3}\.\d{1,3}|192\.168\.\d{1,3}\.\d{1,3}|169\.254\.\d{1,3}\.\d{1,3}|127\.\d{1,3}\.\d{1,3}\.\d{1,3}|172\.1[6-9]{1}\.\d{1,3}\.\d{1,3}|172\.2[0-9]{1}\.\d{1,3}\.\d{1,3}|172\.3[0-1]{1}\.\d{1,3}\.\d{1,3} And the escaped java string is 10\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}|192\\.168\\.\\d{1,3}\\.\\d{1,3}|169\\.254\\.\\d{1,3}\\.\\d{1,3}|127\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}|172\\.1[6-9]{1}\\.\\d{1,3}\\.\\d{1,3}|172\\.2[0-9]{1}\\.\\d{1,3}\\.\\d{1,3}|172\\.3[0-1]{1}\\.\\d{1,3}\\.\\d{1,3} [1] http://tomcat.apache.org/tomcat-7.0-doc/api/org/apache/catalina/valves/RemoteIpValve.html</column><column name="report_time">2013-11-27 15:53:07</column><column name="report_timestamp">1385590000</column><column name="status">resolved fixed</column><column name="commit">c1be72f</column><column name="commit_timestamp">1386580000</column><column name="files">java/org/apache/catalina/filters/RemoteIpFilter.java
java/org/apache/catalina/valves/RemoteIpValve.java</column><column name="result">3:java/org/apache/catalina/valves/RemoteIpValve.java
4:java/org/apache/catalina/filters/RemoteIpFilter.java</column></table><table name="tomcat"><column name="id">20</column><column name="bug_id">55811</column><column name="summary">Do not parse web-fragment.xml files when empty absolute-ordering</column><column name="description">ContextConfig.webConfig() does the following: 1. Scans for web fragments &gt; Map&lt;String,WebXml&gt; fragments = processJarsForWebFragments(); This method a) returns a list of all JAR files, not ignored by jarsToSkip options b) parses "META-INF/web-fragment.xml" files when they are present 2. Filters and sorts them according to ordering &gt; orderedFragments = WebXml.orderWebFragments(webXml, fragments, sContext); 3. Uses the ordered set of fragments to look for SCI declarations &gt; processServletContainerInitializers(orderedFragments); 4. Uses the ordered set of fragments to - scan them for annotated classes - merge into main web.xml 5. Uses the original list of web fragments to scan for resources. &gt; processResourceJARs(resourceJars); I am saying that parsing of the fragments (step 1-b)) can be skipped when the web application is configured with an empty ordered-fragments element and web.xml validation is turned off (strict servlet compliance is off). Note that metadata-complete=true alone does not allow to skip that parsing, because we need fragment names to perform the ordering. It seems that skipping that parsing when validation is on would be a bad idea. We are still using those JARs for resources and thus I think we should validate them.</column><column name="report_time">2013-11-22 14:45:40</column><column name="report_timestamp">1385150000</column><column name="status">resolved fixed</column><column name="commit">f4da7dc</column><column name="commit_timestamp">1386450000</column><column name="files">java/org/apache/catalina/startup/ContextConfig.java
java/org/apache/jasper/servlet/JspCServletContext.java
java/org/apache/tomcat/util/descriptor/web/FragmentJarScannerCallback.java</column><column name="result">7:java/org/apache/tomcat/util/descriptor/web/FragmentJarScannerCallback.java
9:java/org/apache/catalina/startup/ContextConfig.java
18:java/org/apache/jasper/servlet/JspCServletContext.java</column></table><table name="tomcat"><column name="id">21</column><column name="bug_id">55801</column><column name="summary">Add ability to provide custom SSLContext for websocket client</column><column name="description">Created attachment 31059 Proposed patch Currently the only available customisation is setting trust store via SSL_TRUSTSTORE_PROPERTY. This is not enough in situations where custom trust manager has to be used. The most trivial example I can think of is accepting all certificates. My proposition is to use new property to pass SSLContext using user properties of ClientEndpointConfig. Attached is a proposed patch to add this capability.</column><column name="report_time">2013-11-20 09:57:24</column><column name="report_timestamp">1384960000</column><column name="status">resolved fixed</column><column name="commit">ef3f56e</column><column name="commit_timestamp">1386450000</column><column name="files">java/org/apache/tomcat/websocket/WsWebSocketContainer.java</column><column name="result">34:java/org/apache/tomcat/websocket/WsWebSocketContainer.java</column></table><table name="tomcat"><column name="id">22</column><column name="bug_id">55851</column><column name="summary">Tomcat SPNEGO authenticator incompatible with IBM JDK: Accept Security Context needs to be wrapped around a Privileged Action in order for server side authentication</column><column name="description">Created attachment 31098 Contains GNU unified diff of SpnegoAuthenticator and its modified format Hi Problem report:- In bug report 55760, a change was made in which system property javax.security.auth.useSubjectCredsOnly is no longer set to false. So it naturally follows that GSSAPI AcceptSecContext method is wrapped in a PrivilegedExceptionAction. It is found in IBM JDK that it fails otherwise. Cause of failure:- When IBM JDK tries to fetch credential in GSSAPI AcceptSecContext method, it does so from JAAS Subject. Since this call is not performed in Subject.doAs, the call fails as IBM JDK does not have access to a JAAS subject and cannot fetch a credential. Please find attached:- 1. File containing gnu unified diff format of SpnegoAuthenticator with its modified version. PLEASE NOTE THIS DIFF IS ON TOP OF BUG FIX REPORTED IN 55760. This file now also contains AcceptAction class which wraps GSSAPI AcceptSecContext as a PrivilegedExceptionAction. This fix solves the issue by allowing IBM JDK to fetch credential from JAAS Subject. Yours sincerely Arunav Sanyal</column><column name="report_time">2013-12-06 08:56:41</column><column name="report_timestamp">1386340000</column><column name="status">resolved fixed</column><column name="commit">bba9747</column><column name="commit_timestamp">1386360000</column><column name="files">java/org/apache/catalina/authenticator/SpnegoAuthenticator.java</column><column name="result">1:java/org/apache/catalina/authenticator/SpnegoAuthenticator.java</column></table><table name="tomcat"><column name="id">23</column><column name="bug_id">55842</column><column name="summary">response.setBufferSize() does not seem to work properly</column><column name="description">I found a problem with setting the buffer size for the ServletResponse. If I call 'response.setBufferSize(1,000,000);' and send about 20,000 characters, the response will be chunked even though it should not. The response is sent in several chunks and contains the 'Transfer-Encoding: chunked' response header. In my understanding in this case the response should be fully buffered on the server and then sent as a whole containing the Content-Length-header. This causes a problem in my application because I want to use a larger buffer to be able to redirect to an error page if an error occurs during rendering the response. I was able to reproduce this on Tomcat 7.0.39, 7.0.40, 7.0.42, 7.0.47. Tomcat 7.0.37 works fine and as expected. This is easily reproducable by using a JSP as follows: &lt;% response.setBufferSize(1000*1000); for (int i = 0; i &lt; 100; i++) { 	for (int j = 0; j &lt; 100; j++) { 		response.getWriter().write("X"); 	} response.getWriter().write("&lt;br /&gt;"); } %&gt;</column><column name="report_time">2013-12-04 15:56:09</column><column name="report_timestamp">1386190000</column><column name="status">resolved fixed</column><column name="commit">f4970a7</column><column name="commit_timestamp">1386330000</column><column name="files">java/org/apache/catalina/connector/OutputBuffer.java
java/org/apache/tomcat/util/buf/ByteChunk.java</column><column name="result">13:java/org/apache/catalina/connector/OutputBuffer.java
49:java/org/apache/tomcat/util/buf/ByteChunk.java</column></table><table name="tomcat"><column name="id">24</column><column name="bug_id">55837</column><column name="summary">ServletContext.getRealPath() returns null</column><column name="description">[code] String path = servletContext.getRealPath('/test'); if no file or folder named '/test' exist in webroot then path return null but int tomcat 5\6\7, it will return the correct value , ex /data/oschina/webapp/test</column><column name="report_time">2013-12-03 08:03:13</column><column name="report_timestamp">1386080000</column><column name="status">resolved fixed</column><column name="commit">a63bf3a</column><column name="commit_timestamp">1386180000</column><column name="files">java/org/apache/catalina/webresources/DirResourceSet.java
java/org/apache/catalina/webresources/EmptyResource.java
java/org/apache/catalina/webresources/StandardRoot.java
test/org/apache/catalina/webresources/AbstractTestResourceSet.java</column><column name="result">23:java/org/apache/catalina/webresources/StandardRoot.java
114:java/org/apache/catalina/webresources/EmptyResource.java
383:java/org/apache/catalina/webresources/DirResourceSet.java
431:test/org/apache/catalina/webresources/AbstractTestResourceSet.java</column></table><table name="tomcat"><column name="id">25</column><column name="bug_id">55804</column><column name="summary">SPNEGOAUTHENTICATOR - GSSCredential does not get renewed after RemainingLifeTime is less than zero</column><column name="description">In SpnegoAuthenticator, we check for request.getUserPrincipal() if it returns a prinicpal we do not do a fresh authentication. This happens even when the GSSCredential returned by GenericPrincipal has remainingLife time less than zero. This causes issues in delegating the credential as the credential is not valid any more. Can we add additional check to reauthenticate when the credental has expired and put GSSCredential in the same session?</column><column name="report_time">2013-11-20 19:23:11</column><column name="report_timestamp">1384990000</column><column name="status">resolved fixed</column><column name="commit">8f67335</column><column name="commit_timestamp">1385750000</column><column name="files">java/org/apache/catalina/connector/Request.java</column><column name="result">9:java/org/apache/catalina/connector/Request.java</column></table><table name="tomcat"><column name="id">26</column><column name="bug_id">55798</column><column name="summary">Enabling Manager App - process and description is inadequate</column><column name="description" /><column name="report_time">2013-11-19 23:03:23</column><column name="report_timestamp">1384920000</column><column name="status">resolved fixed</column><column name="commit">13c6551</column><column name="commit_timestamp">1384940000</column><column name="files">java/org/apache/catalina/users/MemoryUserDatabase.java</column><column name="result">256:java/org/apache/catalina/users/MemoryUserDatabase.java</column></table><table name="tomcat"><column name="id">27</column><column name="bug_id">55778</column><column name="summary">JNDIRealm: Authentication with GSSAPI to LDAP with SSL connection causes an exception</column><column name="description">Whenever i try to authenticate with GSSAPI to a LDAP server with a SSL connection (ldaps), the following exception is thrown: javax.naming.ServiceUnavailableException: myserver.at:636; socket closed; remaining name 'dc=example,dc=org' at com.sun.jndi.ldap.Connection.readReply(Connection.java:452) at com.sun.jndi.ldap.LdapClient.getSearchReply(LdapClient.java:631) at com.sun.jndi.ldap.LdapClient.search(LdapClient.java:554) at com.sun.jndi.ldap.LdapCtx.doSearch(LdapCtx.java:1985) at com.sun.jndi.ldap.LdapCtx.searchAux(LdapCtx.java:1847) at com.sun.jndi.ldap.LdapCtx.c_search(LdapCtx.java:1772) ... Steps to reproduce: 1. Configure the valve org.apache.catalina.authenticator.SpnegoAuthenticator in the server.xml with storeDelegatedCredential="true". 2. Configure the realm org.apache.catalina.realm.JNDIRealm in the server.xml with an SSL connection url (e.g. ldaps://myserver.at:636) 3. Configure an auth-method with SPNEGO, security-constraints and security-roles in the web.xml 4. Add required keystores to the jdk for the ldaps connection. 5. Try to authenticate I debugged into the JNDIRealm and figured out, that changing line 2082 from "context.addToEnvironment("javax.security.sasl.qop", "auth-conf");" to "context.addToEnvironment("javax.security.sasl.qop", "auth");" would solve the problem. I also tested the fix with a new written JNDIRealm. But i'm not sure, if this fix causes other security issues.</column><column name="report_time">2013-11-14 14:51:16</column><column name="report_timestamp">1384460000</column><column name="status">resolved fixed</column><column name="commit">27806aa</column><column name="commit_timestamp">1384540000</column><column name="files">java/org/apache/catalina/realm/JNDIRealm.java</column><column name="result">1:java/org/apache/catalina/realm/JNDIRealm.java</column></table><table name="tomcat"><column name="id">28</column><column name="bug_id">55776</column><column name="summary">if path include relative char, eg: ../, classloader will not find zhe file</column><column name="description">I use ibatis in my project, config file path include '..', tomcat can not find the file, command line show: Could not find resource ../ibatis/code/sendType.xml</column><column name="report_time">2013-11-14 06:14:50</column><column name="report_timestamp">1384430000</column><column name="status">resolved fixed</column><column name="commit">a1ad6ce</column><column name="commit_timestamp">1384530000</column><column name="files">java/org/apache/catalina/webresources/StandardRoot.java</column><column name="result">123:java/org/apache/catalina/webresources/StandardRoot.java</column></table><table name="tomcat"><column name="id">29</column><column name="bug_id">55772</column><column name="summary">Flushing AsyncContext response writer after ClientAbortException (BrokenPipe) causes request state to leak</column><column name="description">Created attachment 31040 Test case to reproduce request state (cookie) leakage This issue is easily reproducible with the attached test case. Request state is leaked between requests due to the ADAPTER_NOTES note on the coyote request containing the catalina connector request (which holds the cookies from the first request) and never gets cleaned up in this error case (and maybe others similar to it). It seems like it would be worthwhile to clear out the notes field from the coyote request when we recycle() it to prevent future issues like this.</column><column name="report_time">2013-11-13 04:45:21</column><column name="report_timestamp">1384340000</column><column name="status">resolved fixed</column><column name="commit">cb62f86</column><column name="commit_timestamp">1384520000</column><column name="files">java/org/apache/catalina/connector/CoyoteAdapter.java
java/org/apache/coyote/ActionCode.java
java/org/apache/coyote/ajp/AbstractAjpProcessor.java
java/org/apache/coyote/http11/AbstractHttp11Processor.java
java/org/apache/coyote/spdy/SpdyProcessor.java
test/org/apache/coyote/http11/TestAbstractHttp11Processor.java</column><column name="result">13:java/org/apache/coyote/http11/AbstractHttp11Processor.java
16:java/org/apache/coyote/ajp/AbstractAjpProcessor.java
29:java/org/apache/coyote/spdy/SpdyProcessor.java
161:java/org/apache/catalina/connector/CoyoteAdapter.java
304:test/org/apache/coyote/http11/TestAbstractHttp11Processor.java</column></table><table name="tomcat"><column name="id">30</column><column name="bug_id">55760</column><column name="summary">Tomcat SPNEGO authenticator incompatible with IBM JDK in case of Keytab based initiate and accept authentication</column><column name="description">Hi Our company has a use case in which our domain is a tomcat process. In our code, we support a parallel protocol which uses In memory based jaas configuration - public class OurLoginConfiguration extends Configuration In IBM JDK 7, we need to initiate using keytab which needs the system property javax.security.auth.useSubjectCredsOnly to be set to true for it to work. However Tomcat sets it in Inside SpnegoAuthenticator:- protected void initInternal() throws LifecycleException { super.initInternal(); // Kerberos configuration file location String krb5Conf = System.getProperty(Constants.KRB5_CONF_PROPERTY); if (krb5Conf == null) { // System property not set, use the Tomcat default File krb5ConfFile = new File(Bootstrap.getCatalinaBase(), Constants.DEFAULT_KRB5_CONF); System.setProperty(Constants.KRB5_CONF_PROPERTY, krb5ConfFile.getAbsolutePath()); } // JAAS configuration file location String jaasConf = System.getProperty(Constants.JAAS_CONF_PROPERTY); if (jaasConf == null) { // System property not set, use the Tomcat default File jaasConfFile = new File(Bootstrap.getCatalinaBase(), Constants.DEFAULT_JAAS_CONF); System.setProperty(Constants.JAAS_CONF_PROPERTY, jaasConfFile.getAbsolutePath()); } // This property must be false for SPNEGO to work System.setProperty(Constants.USE_SUBJECT_CREDS_ONLY_PROPERTY, "false"); } as false in the last line which causes havoc in the code. A multithreaded startup causes a breakdown in further authentication for keytab based logging. Now a little more investigation revealed that tomcat acts only as an acceptor. Now this property need not necessarily be set to false for it to work(in both IBM and SUN JDK). Source of claim - http://cr.openjdk.java.net/~weijun/special/krb5winguide-2/raw_files/new/kwin Excerpt:- 2. Direct JGSS: /* JGSS-API calls... */ In this case, the JAAS config file's entry name MUST be the standard entry name (com.sun.security.jgss.krb5.initiate), and you must set -Djavax.security.auth.useSubjectCredsOnly=false on the Java command line. Read [26]http://java.sun.com/javase/6/docs/technotes/guides/security/jgs s/tutorials/BasicClientServer.html for details. Which means only initiate based auth needs the system property. This is also confirmed in IBM with a sample program. PROPOSED FIX: COMMENT LAST LINE OF initInternal WHICH SETS THE SYSTEM PROPERTY IN THE FIRST PLACE AS FALSE.</column><column name="report_time">2013-11-08 11:48:18</column><column name="report_timestamp">1383930000</column><column name="status">resolved fixed</column><column name="commit">0a4e847</column><column name="commit_timestamp">1384160000</column><column name="files">java/org/apache/catalina/authenticator/SpnegoAuthenticator.java</column><column name="result">1:java/org/apache/catalina/authenticator/SpnegoAuthenticator.java</column></table><table name="tomcat"><column name="id">31</column><column name="bug_id">55749</column><column name="summary">Disabling SSLEngine in AprLifecycleListener leads to misleading error message at startup when SSL Connector is delcared</column><column name="description">Put a &lt;Listener className="org.apache.catalina.core.AprLifecycleListener" SSLEngine="off" /&gt; in you server.xml. Put the APR connector some weeks later in your server.xml: &lt;Connector protocol="org.apache.coyote.http11.Http11AprProtocol" port="@HTTPS_PORT@" connectionTimeout="20000" maxHttpHeaderSize="24576" maxThreads="250" URIEncoding="UTF-8" bufferSize="4096" scheme="https" secure="true" SSLEnabled="true" SSLProtocol="TLSv1"	 SSLCipherSuite="HIGH:!ADH" SSLCertificateFile="@SSL_CERT_FILE@" SSLCertificateKeyFile="@SSL_CERT_KEY_FILE@" SSLPassword="@SSL_PASSWORD@" /&gt; Start your Tomcat and receive following confusing message: Nov 06, 2013 1:30:39 PM org.apache.coyote.http11.Http11AprProtocol start SEVERE: Error starting endpoint java.lang.Exception: Socket bind failed: [226] Adresse bereits im Zugriff at org.apache.tomcat.util.net.AprEndpoint.init(AprEndpoint.java:671) at org.apache.tomcat.util.net.AprEndpoint.start(AprEndpoint.java:851) at org.apache.coyote.http11.Http11AprProtocol.start(Http11AprProtocol.java:139) at org.apache.catalina.connector.Connector.start(Connector.java:1196) at org.apache.catalina.core.StandardService.start(StandardService.java:540) at org.apache.catalina.core.StandardServer.start(StandardServer.java:754) at org.apache.catalina.startup.Catalina.start(Catalina.java:595) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:606) at org.apache.catalina.startup.Bootstrap.start(Bootstrap.java:289) at org.apache.catalina.startup.Bootstrap.main(Bootstrap.java:414) Nov 06, 2013 1:30:39 PM org.apache.catalina.core.StandardService start SEVERE: Failed to start connector [Connector[HTTP/1.1-8444]] LifecycleException: service.getName(): "Catalina"; Protocol handler start failed: java.lang.Exception: Socket bind failed: [226] Adresse bereits im Zugriff at org.apache.catalina.connector.Connector.start(Connector.java:1203) at org.apache.catalina.core.StandardService.start(StandardService.java:540) at org.apache.catalina.core.StandardServer.start(StandardServer.java:754) at org.apache.catalina.startup.Catalina.start(Catalina.java:595) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:606) at org.apache.catalina.startup.Bootstrap.start(Bootstrap.java:289) at org.apache.catalina.startup.Bootstrap.main(Bootstrap.java:414) This is of course not correct. The port IS availble but the SSL engine has been turned off. There should be a check at stratup which says that this is an illegal state.</column><column name="report_time">2013-11-06 12:32:17</column><column name="report_timestamp">1383760000</column><column name="status">resolved fixed</column><column name="commit">014cf1c</column><column name="commit_timestamp">1384110000</column><column name="files">java/org/apache/tomcat/util/net/AprEndpoint.java</column><column name="result">2:java/org/apache/tomcat/util/net/AprEndpoint.java</column></table><table name="tomcat"><column name="id">32</column><column name="bug_id">55735</column><column name="summary">Additional quote entity in html element attribute evaluated in tagx if attribute contains EL expression</column><column name="description">Well, after fix for Bug 55198, if a tag file contains &lt;a href="#" onclick="window.alert(&amp;quot;${text}&amp;quot;)"&gt;foobar&lt;/a&gt; It can now be correctly rendered as (if text='foobar') &lt;a href="#" onclick="window.alert(&amp;quot;foobar&amp;quot;)"&gt;foobar&lt;/a&gt; But, It is rendered completely wrongly as ***** IF text='&amp;amp;foobar' ***** &lt;a href="#" onclick="window.alert(&amp;quot;&amp;amp;amp;foobar&amp;quot;)"&gt;foobar&lt;/a&gt; The EL expression ${text} should be rendered without any escape, but now it is escaped just as other literal part in the attribute. Generally, a tagx file's compiler must not make any assumption that it's output is a well-formed XML or not, it should just keep the literal atrribute or text as is, and output any EL expression directly. It's the tagx file's author's reponsibility to determine whether a text variable should be escaped, e.g.: &lt;a href="#" onclick="window.alert(&amp;quot;${fn:escape(text)}&amp;quot;)"&gt;foobar&lt;/a&gt; Suppose we have: request.setAttribute("text", "2 &amp;gt; 1"); And in a tagx file: &lt;div title="&amp;quot;${text}&amp;quot;"&gt;&amp;quot;${text}&amp;quot;&lt;/div&gt; The correct output could be: &lt;div title="&amp;quot;2 &amp;gt; 1&amp;quot;"&gt;&amp;quot;2 &amp;gt; 1&amp;quot;&lt;/div&gt; But neither &lt;div title="&amp;quot;2 &amp;amp;gt; 1&amp;quot;"&gt;&amp;quot;2 &amp;gt; 1&amp;quot;&lt;/div&gt; nor &lt;div title=""2 &gt; 1""&gt;&amp;quot;2 &amp;gt; 1&amp;quot;&lt;/div&gt;</column><column name="report_time">2013-11-02 06:14:56</column><column name="report_timestamp">1383390000</column><column name="status">resolved fixed</column><column name="commit">7ee1275</column><column name="commit_timestamp">1383690000</column><column name="files">java/org/apache/jasper/compiler/Validator.java
java/org/apache/jasper/runtime/PageContextImpl.java
test/org/apache/jasper/compiler/TestParser.java
test/org/apache/jasper/compiler/TesterValidator.java
test/org/apache/jasper/runtime/TesterPageContextImpl.java</column><column name="result">22:java/org/apache/jasper/runtime/PageContextImpl.java
78:test/org/apache/jasper/compiler/TestParser.java
84:java/org/apache/jasper/compiler/Validator.java
214:test/org/apache/jasper/runtime/TesterPageContextImpl.java</column></table><table name="tomcat"><column name="id">33</column><column name="bug_id">55715</column><column name="summary">RemoteEndpoint.Async#sendText(String, SendHandler) can cause StackOverflowErrors and contradicts Oracle's JavaDoc</column><column name="description">See thread on users list [1]: Tomcat's current implementation of RemoteEndpoint.Async#sendText(String, SendHandler) can cause StackOverflowErrors (and seems to contradict Oracle's JavaDoc). In Tomcat, Async#sendText(...) seems to implemented so that when it could send all of the data immediately, then it directly calls SendHandler#onResult(...); whereas when it couldn't send the data immediately, the SendHandler will be called from another thread. Oracle's javadoc for RemoteEndpoint.Async says: "The completion handlers for the asynchronous methods are always called with a different thread from that which initiated the send." Now, imagine the case that you want to send 10000 very small text messages to a client (very unlikely, but possibly could happen). With synchronous I/O (RemoteEndpoint.Basic), you would do this in this way: RemoteEndpoint.Basic basic = session.getBasicRemote(); for (int i = 0; i &lt; 10000; i++) { basic.sendText("Hi, Count: " + i); } In this case, there is no problem. Now imagine you want to do this asynchronously (using a Callback to be informed when sending is completed), then you could do it this way (e.g. put the following code in onOpen() method of Tomcat's EchoEndpoint example): final AtomicInteger aint = new AtomicInteger(); final RemoteEndpoint.Async async = session.getAsyncRemote(); SendHandler handler = new SendHandler() { @Override public void onResult(SendResult result) { int nextVal = aint.incrementAndGet(); if (nextVal &lt; 10000) { async.sendText("Hi, Count: " + nextVal, this); } } }; async.sendText("Hi, Count: " + aint.get(), handler); The problem here is that because the messages are very short, Tomcat will be able to send them immediately, calling the SendHandler#onResult() directly from Async.sendText(), which will eventually cause a StackOverflowError. I think if SendHandler#onResult() was always called from a different thread than the one which calls Async.send... (like the Javadoc says), then although the performance would probably be worse, StackOverflowErrors shouldn't occur. [1] http://markmail.org/message/gpxzdwtxtrpynvux</column><column name="report_time">2013-10-28 15:34:56</column><column name="report_timestamp">1382990000</column><column name="status">resolved fixed</column><column name="commit">3f316f1</column><column name="commit_timestamp">1383130000</column><column name="files">java/org/apache/tomcat/websocket/server/Constants.java
java/org/apache/tomcat/websocket/server/WsContextListener.java
java/org/apache/tomcat/websocket/server/WsHttpUpgradeHandler.java
java/org/apache/tomcat/websocket/server/WsRemoteEndpointImplServer.java
java/org/apache/tomcat/websocket/server/WsServerContainer.java
java/org/apache/tomcat/websocket/server/WsWriteTimeout.java</column><column name="result">3:java/org/apache/tomcat/websocket/server/WsRemoteEndpointImplServer.java
40:java/org/apache/tomcat/websocket/server/WsServerContainer.java
137:java/org/apache/tomcat/websocket/server/WsHttpUpgradeHandler.java
169:java/org/apache/tomcat/websocket/server/WsWriteTimeout.java
926:java/org/apache/tomcat/websocket/server/Constants.java
1458:java/org/apache/tomcat/websocket/server/WsContextListener.java</column></table><table name="tomcat"><column name="id">34</column><column name="bug_id">55702</column><column name="summary">TLD cannot be loaded if CATALINA_HOME contains spaces</column><column name="description">A web application containing an own TLD within its WEB-INF directory fails to render a JSP page referencing that TLD if Tomcat it installed into a directory with spaces in the path, such as "C:\Program Files\...". After moving the entire Tomcat installation directory to a path without spaces (such as "C:\1\Tomcat8"), the application can render that same JSP page. Following stacktrace is printed. Note the %20 in the file path org.apache.jasper.JasperException: /jsp/layouts/standard.jsp (line: 7, column: 69) File "file:/C:/Program%20Files/Apache/Tomcat-8.0.0-RC5/webapps/mywebapp/WEB-INF/tlds/mywebapp-tags.tld" not found 	org.apache.jasper.compiler.DefaultErrorHandler.jspError(DefaultErrorHandler.java:42) 	org.apache.jasper.compiler.ErrorDispatcher.dispatch(ErrorDispatcher.java:276) 	org.apache.jasper.compiler.ErrorDispatcher.jspError(ErrorDispatcher.java:92) 	org.apache.jasper.compiler.TagLibraryInfoImpl.&lt;init&gt;(TagLibraryInfoImpl.java:166) 	org.apache.jasper.compiler.Parser.parseTaglibDirective(Parser.java:410) 	org.apache.jasper.compiler.Parser.parseDirective(Parser.java:476) 	org.apache.jasper.compiler.Parser.parseElements(Parser.java:1451) 	org.apache.jasper.compiler.Parser.parse(Parser.java:138) 	org.apache.jasper.compiler.ParserController.doParse(ParserController.java:242) 	org.apache.jasper.compiler.ParserController.parse(ParserController.java:102) 	org.apache.jasper.compiler.Compiler.generateJava(Compiler.java:198) 	org.apache.jasper.compiler.Compiler.compile(Compiler.java:373) 	org.apache.jasper.compiler.Compiler.compile(Compiler.java:353) 	org.apache.jasper.compiler.Compiler.compile(Compiler.java:340) 	org.apache.jasper.JspCompilationContext.compile(JspCompilationContext.java:606) 	org.apache.jasper.servlet.JspServletWrapper.service(JspServletWrapper.java:357) 	org.apache.jasper.servlet.JspServlet.serviceJspFile(JspServlet.java:403) 	org.apache.jasper.servlet.JspServlet.service(JspServlet.java:347) 	javax.servlet.http.HttpServlet.service(HttpServlet.java:728) Java version used: Oracle JDK 7 Update 45 (64 Bit) Active Tomcat connector: ["http-nio-8080"]</column><column name="report_time">2013-10-25 10:03:35</column><column name="report_timestamp">1382710000</column><column name="status">resolved fixed</column><column name="commit">ad50e54</column><column name="commit_timestamp">1383050000</column><column name="files">java/org/apache/jasper/compiler/TagLibraryInfoImpl.java</column><column name="result">8:java/org/apache/jasper/compiler/TagLibraryInfoImpl.java</column></table><table name="tomcat"><column name="id">35</column><column name="bug_id">55684</column><column name="summary">WebappClassLoader.getThread want an access to root ThreadGroup</column><column name="description">Tomcat may not have all permissions granted. The method WebappClassLoader.getThread try to access the root ThreadGroup in order to list all threads. You should either manage SecurityException or avoid to access the parent ThreadGroup of the thread which start Tomcat.</column><column name="report_time">2013-10-21 16:30:04</column><column name="report_timestamp">1382390000</column><column name="status">resolved fixed</column><column name="commit">d244284</column><column name="commit_timestamp">1383040000</column><column name="files">java/org/apache/catalina/loader/WebappClassLoader.java</column><column name="result">1:java/org/apache/catalina/loader/WebappClassLoader.java</column></table><table name="tomcat"><column name="id">36</column><column name="bug_id">55691</column><column name="summary">javax.el.ArrayELResolver.setValue not supporting arrays of primitives</column><column name="description">was working in tomcat 6.0.20 ERROR javax.faces.context.ExceptionHandlerWrapper - javax.faces.component.UpdateModelException: java.lang.ClassCastException: Unable to add an object of type [java.lang.Integer] to an array of objects of type [int] java.lang.ClassCastException: Unable to add an object of type [java.lang.Integer] to an array of objects of type [int] 	at javax.el.ArrayELResolver.setValue(ArrayELResolver.java:94) 	at com.sun.faces.el.DemuxCompositeELResolver._setValue(DemuxCompositeELResolver.java:255) 	at com.sun.faces.el.DemuxCompositeELResolver.setValue(DemuxCompositeELResolver.java:281) 	at org.apache.el.parser.AstValue.setValue(AstValue.java:158) 	at org.apache.el.ValueExpressionImpl.setValue(ValueExpressionImpl.java:249) 	at com.sun.faces.facelets.el.TagValueExpression.setValue(TagValueExpression.java:131) 	at javax.faces.component.UIInput.updateModel(UIInput.java:818) 	at javax.faces.component.UIInput.processUpdates(UIInput.java:735) 	at javax.faces.component.UIData.iterate(UIData.java:2001) 	at javax.faces.component.UIData.processUpdates(UIData.java:1253) 	at javax.faces.component.UIComponentBase.processUpdates(UIComponentBase.java:1242) 	at javax.faces.component.UIForm.processUpdates(UIForm.java:281) 	at javax.faces.component.UIComponentBase.processUpdates(UIComponentBase.java:1242) 	at javax.faces.component.UIComponentBase.processUpdates(UIComponentBase.java:1242) 	at javax.faces.component.UIViewRoot.processUpdates(UIViewRoot.java:1231) 	at com.sun.faces.lifecycle.UpdateModelValuesPhase.execute(UpdateModelValuesPhase.java:78) 	at com.sun.faces.lifecycle.Phase.doPhase(Phase.java:101) 	at com.sun.faces.lifecycle.LifecycleImpl.execute(LifecycleImpl.java:118) 	at javax.faces.webapp.FacesServlet.service(FacesServlet.java:593) 	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:290) 	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:206)</column><column name="report_time">2013-10-22 23:05:42</column><column name="report_timestamp">1382500000</column><column name="status">resolved fixed</column><column name="commit">b82c0c6</column><column name="commit_timestamp">1382990000</column><column name="files">java/javax/el/ArrayELResolver.java
java/javax/el/Util.java
test/javax/el/TestArrayELResolver.java</column><column name="result">6:java/javax/el/ArrayELResolver.java
9:test/javax/el/TestArrayELResolver.java
916:java/javax/el/Util.java</column></table><table name="tomcat"><column name="id">37</column><column name="bug_id">55681</column><column name="summary">JSR-356 message handling: NULL pointer being thrown when DecodeException is caught in PojoMessageHandlerWholeBase&lt;T&gt;.onMessage</column><column name="description">I am testing what happens when Encode/Decode Exceptions occur during JSR-356 communication. In our case, we do NOT use annotation, but we "extend Endpoint" and "implement Whole&lt;ThingworxMessage&gt;". I was forcing a DecodeException to occur - expecting to my onError to be called with the actual DecodeException. Instead, I got a Null. Stepping the following code in Tomcat: in onMessage, the ((WsSession)session) is NULL. As a result, the actual DecodeException (cause) is lost. // Can this message be decoded? Object payload; try { payload = decode(message); } catch (DecodeException de) { ((WsSession) session).getLocal().onError(session, de); return; } Tracing this further up the stack, I found that Util.getMessageHandlers is initializing it and passing NULL in for the session: if (decoderMatch.getTextDecoders().size() &gt; 0) { MessageHandlerResult result = new MessageHandlerResult( new PojoMessageHandlerWholeText(listener, m, null, endpointConfig, decoderMatch.getTextDecoders(), new Object[1], 0, false, -1, -1), MessageHandlerResultType.TEXT); results.add(result); } Please let me know if I can provide any more details. -bob</column><column name="report_time">2013-10-20 17:37:21</column><column name="report_timestamp">1382310000</column><column name="status">resolved fixed</column><column name="commit">514cefb</column><column name="commit_timestamp">1382300000</column><column name="files">java/org/apache/tomcat/websocket/Util.java
java/org/apache/tomcat/websocket/WsSession.java</column><column name="result">1:java/org/apache/tomcat/websocket/Util.java
9:java/org/apache/tomcat/websocket/WsSession.java</column></table><table name="tomcat"><column name="id">38</column><column name="bug_id">55664</column><column name="summary">[websocket] NPE in Util$DecoderMatch during application start</column><column name="description">Created attachment 30934 TestEncodingDecoding.patch NPE is thrown when WS endpoint has associated encoder or decoder with type using generics. Example: Decoder.Text&lt;List&lt;String&gt;&gt; Here I attach patch of org.apache.tomcat.websocket.pojo.TestEncodingDecoding illustrating the case.</column><column name="report_time">2013-10-17 19:01:26</column><column name="report_timestamp">1382050000</column><column name="status">resolved fixed</column><column name="commit">4e4a24a</column><column name="commit_timestamp">1382080000</column><column name="files">java/org/apache/tomcat/websocket/Util.java
test/org/apache/tomcat/websocket/TestUtil.java
test/org/apache/tomcat/websocket/pojo/TestEncodingDecoding.java</column><column name="result">1:java/org/apache/tomcat/websocket/Util.java
20:test/org/apache/tomcat/websocket/TestUtil.java
24:test/org/apache/tomcat/websocket/pojo/TestEncodingDecoding.java</column></table><table name="tomcat"><column name="id">39</column><column name="bug_id">55656</column><column name="summary">Server ClassLoader not used for Server creation</column><column name="description">Created attachment 30931 proposed patch When configuring server.loader in catalina.properties with libraries containing valves or realms and their dependencies, if those classes are set in server.xml a CNFE is thrown. The reason is Digester using StandardServer's ClassLoader and not context ClassLoader.</column><column name="report_time">2013-10-16 09:56:54</column><column name="report_timestamp">1381930000</column><column name="status">resolved fixed</column><column name="commit">86ec1f4</column><column name="commit_timestamp">1382020000</column><column name="files">java/org/apache/catalina/startup/Catalina.java</column><column name="result">8:java/org/apache/catalina/startup/Catalina.java</column></table><table name="tomcat"><column name="id">40</column><column name="bug_id">54095</column><column name="summary">[patch] support gzipped versions of static resources by DefaultServlet</column><column name="description">Created attachment 29546 patch that supports gzipped versions of files If you want to serve gzipped versions of files you often use a filter, valve or enable compression attribute on the connector. However this is suboptimal for several reasons. Compression has to be done in memory so the whole content has to be loaded into memory, the result is not cached meaning compression has to be done over agin and sendfile can't be used. The most efficient way to implement gzip serving to generate gzipped versions of the resources at build time. Then use a custom filter that forwards to the gzipped version if the user agent supports it. This way sendfile can be used and compression is only done once at build time. It would be nice if the DefaultServlet detected that there's a gzipped version of the resource and serves it when the client supports it. The Jetty DefaultServlet does exactly this: http://download.eclipse.org/jetty/stable-8/apidocs/org/eclipse/jetty/servlet/DefaultServlet.html Patch attached with tests and updated documentation.</column><column name="report_time">2012-11-03 20:49:45</column><column name="report_timestamp">1351990000</column><column name="status">resolved fixed</column><column name="commit">f0101d0</column><column name="commit_timestamp">1381440000</column><column name="files">java/org/apache/catalina/servlets/DefaultServlet.java
test/org/apache/catalina/servlets/TestDefaultServlet.java</column><column name="result">1:java/org/apache/catalina/servlets/DefaultServlet.java
18:test/org/apache/catalina/servlets/TestDefaultServlet.java</column></table><table name="tomcat"><column name="id">41</column><column name="bug_id">55251</column><column name="summary">JspC fails silently if directory for generated web.xml does not exist</column><column name="description">If the file specified for webXml (via call to setWebXml) cannot be created (for example if the directory does not exist), then JspC fails silently.</column><column name="report_time">2013-07-12 03:50:46</column><column name="report_timestamp">1373620000</column><column name="status">resolved fixed</column><column name="commit">06d8338</column><column name="commit_timestamp">1381410000</column><column name="files">java/org/apache/jasper/JspC.java</column><column name="result">1:java/org/apache/jasper/JspC.java</column></table><table name="tomcat"><column name="id">42</column><column name="bug_id">55642</column><column name="summary">TagPluginManager isConstantAttribute broken</column><column name="description">Function isConstantAttribute in TagPluginManager seems to be be broken. For value "order.status" it returns false. And for value "${order.state.name}" it returns true. According to javadoc it should be exact opposite. Problem seems to be in Node.isLiteral function. "el!= null" should probably be "el== null" But this function is being used elsewhere. /** * @return true if the attribute is specified and its value is a * translation-time constant. */ public boolean TagPluginManager.isConstantAttribute(String attribute){ Node.JspAttribute attr = getNodeAttribute(attribute); if (attr == null) return false; return attr.isLiteral(); } /** * @return true if the value is a string literal known at translation * time. */ public boolean isLiteral() { return !expression &amp;&amp; (el != null) &amp;&amp; !namedAttribute; }</column><column name="report_time">2013-10-09 13:02:21</column><column name="report_timestamp">1381340000</column><column name="status">resolved fixed</column><column name="commit">af49b44</column><column name="commit_timestamp">1381330000</column><column name="files">java/org/apache/jasper/compiler/Node.java
test/org/apache/jasper/compiler/TestNode.java</column><column name="result">7:java/org/apache/jasper/compiler/Node.java</column></table><table name="tomcat"><column name="id">43</column><column name="bug_id">55630</column><column name="summary">clean way to avoid setURLStreamHandlerFactory call</column><column name="description">A current method is to set WebappLoader.first via reflection (because private). I think the setURLStreamHandlerFactory should be move to Catalina.start ('first' static field can be move in Catalina). So we could have a static method in Catalina to prevent setURLStreamHandlerFactory call while first starting.</column><column name="report_time">2013-10-05 16:51:34</column><column name="report_timestamp">1381010000</column><column name="status">resolved fixed</column><column name="commit">bd56eea</column><column name="commit_timestamp">1381170000</column><column name="files">java/org/apache/catalina/webresources/TomcatURLStreamHandlerFactory.java</column><column name="result">1:java/org/apache/catalina/webresources/TomcatURLStreamHandlerFactory.java</column></table><table name="tomcat"><column name="id">44</column><column name="bug_id">55629</column><column name="summary">StatusManagerServlet does not remove JMX notification listener</column><column name="description">StatusManagerServlet.destroy should call mBeanServer.removeNotificationListener because init method call mBeanServer.addNotificationListener.</column><column name="report_time">2013-10-05 16:38:36</column><column name="report_timestamp">1381010000</column><column name="status">resolved fixed</column><column name="commit">95faaec</column><column name="commit_timestamp">1381130000</column><column name="files">java/org/apache/catalina/manager/StatusManagerServlet.java</column><column name="result">1:java/org/apache/catalina/manager/StatusManagerServlet.java</column></table><table name="tomcat"><column name="id">45</column><column name="bug_id">55317</column><column name="summary">Facilitate weaving by allowing ClassFileTransformer to be added to WebppClassLoader</column><column name="description">Most application servers provide a mechanism whereby web applications can instrument class bytecode. This is normally in the form of two or three instrumentation methods on the ClassLoader implementation responsible for web application class loading. Spring Framework, for example, provides a way to automatically detect and use the various instrumentable ClassLoaders provided by different application servers. However, since Tomcat's o.a.catalina.loader.WebappClassLoader is not instrumentable, Spring cannot use it directly. Instead, it provides a class that extends WebappClassLoader to implement the instrumentation. Users must place this special spring-instrument-tomcat.jar file in $TOMCAT_HOME/lib and put a loader declaration in META-INF/context.xml in order to get this to work--rather a pain in the rear. Spring's changes in the extended WebappClassLoader are really very trivial and involve only 2 classes: a helper class called WeavingTransformer [1] and the extended TomcatInstrumentableClassLoader [2]. I intend to port these changes to Tomcat for Tomcat 7 and 8 and submit a patch. However, before I get started I needed to get two answers from the community: 1) Is there any objection to such a simple addition to WebappClassLoader? I think it would be an easy-but-big improvement to Tomcat. 2) What steps do I need to take to get this Spring code officially "donated" to Tomcat so that all legal requirements are met? The code is licensed Apache 2.0, so that at least should make it easier. [1] https://github.com/SpringSource/spring-framework/blob/master/spring-instrument-tomcat/src/main/java/org/springframework/instrument/classloading/WeavingTransformer.java [2] https://github.com/SpringSource/spring-framework/blob/master/spring-instrument-tomcat/src/main/java/org/springframework/instrument/classloading/tomcat/TomcatInstrumentableClassLoader.java</column><column name="report_time">2013-07-28 07:17:28</column><column name="report_timestamp">1375010000</column><column name="status">resolved fixed</column><column name="commit">dd0cba7</column><column name="commit_timestamp">1380240000</column><column name="files">java/org/apache/catalina/loader/WebappClassLoader.java
java/org/apache/tomcat/InstrumentableClassLoader.java
test/org/apache/catalina/loader/TestWebappClassLoaderWeaving.java
test/org/apache/catalina/loader/TesterNeverWeavedClass.java
test/org/apache/catalina/loader/TesterUnweavedClass.java</column><column name="result">14:java/org/apache/catalina/loader/WebappClassLoader.java</column></table><table name="tomcat"><column name="id">46</column><column name="bug_id">55576</column><column name="summary">Order of ServletRequest parameters is not preserved</column><column name="description">The ServletRequest interface provides two methods to iterate through request parameters: Enumeration&lt;String&gt; getParameterNames(), and Map&lt;String, String[]&gt; getParameterMap() Unfortunately, the underlying implementation in Tomcat is a HashMap, which fails to preserve the order of parameters as they are specified in the request. An alternate implementation should be used to preserve request order. LinkedHashMap, for example, is capable of preserving insertion order. The Servlet Specification (v3.0) speaks only to the relative ordering of query string data and post body data. However, section 17.13.3 of the HTML specification (v4.01) titled "Processing form data", clearly states that "control names/values are listed in the order they appear in the document." Therefore, I do not see a valid interpretation of either specification to rationalize Tomcat's implementation. To receive a request with an ordered list of parameters and represent them in an implementation that is guaranteed not to preserve this order is difficult to rationalize.</column><column name="report_time">2013-09-20 21:14:32</column><column name="report_timestamp">1379730000</column><column name="status">resolved fixed</column><column name="commit">90556a9</column><column name="commit_timestamp">1379970000</column><column name="files">java/org/apache/catalina/util/ParameterMap.java
java/org/apache/tomcat/util/http/Parameters.java</column><column name="result">12:java/org/apache/tomcat/util/http/Parameters.java
377:java/org/apache/catalina/util/ParameterMap.java</column></table><table name="tomcat"><column name="id">47</column><column name="bug_id">55582</column><column name="summary">Concurrent issue of TagFileProcessor</column><column name="description">Created attachment 30871 Unsynchronized getting wrapper from RuntimeContext The following code has concurrent issue. JspRuntimeContext rctxt = ctxt.getRuntimeContext(); JspServletWrapper wrapper = rctxt.getWrapper(wrapperUri); synchronized (rctxt) { if (wrapper == null) { .... It creates duplicated JspServletWrapper in this scenario, A.jsp --&gt; C.tag B.jsp --&gt; C.tag A.jsp and B.jsp are both compiling and come to the given lines. Two threads all get null from JspRuntimeContext(JspServletWrapper == null). So two instances of JspServletWrapper was created.</column><column name="report_time">2013-09-22 10:00:36</column><column name="report_timestamp">1379860000</column><column name="status">resolved fixed</column><column name="commit">f627cc8</column><column name="commit_timestamp">1379940000</column><column name="files">java/org/apache/jasper/compiler/TagFileProcessor.java</column><column name="result">1:java/org/apache/jasper/compiler/TagFileProcessor.java</column></table><table name="tomcat"><column name="id">48</column><column name="bug_id">55570</column><column name="summary">SpnegoAuthenticator: Resource file is missing placeholders for exceptions.</column><column name="description">In java/org/apache/catalina/authenticator/SpnegoAuthenticator.java problems are logged with an exception. The exception does not show up in the logging. The exception only shows up if I hack java/org/apache/catalina/authenticator/LocalStrings.properties in catalina.jar, and add a placeholder. REPRODUCE: - Configure SP-NEGO with Kerberos. - Mess up your principal in com.sun.security.jgss.krb5.accept in jaas.config. - Try to login. - See that you get something like: FINE [org.apache.catalina.authenticator.SpnegoAuthenticator authenticate] Failed to validate client supplied ticket FIX: In java/org/apache/catalina/authenticator/LocalStrings.properties please add [{0}] to the following lines: spnegoAuthenticator.ticketValidateFail=Failed to validate client supplied ticket spnegoAuthenticator.serviceLoginFail=Unable to login as the service principal In SpnegoAuthenticator.java you can verify that exceptions are indeed passed to the log. VALIDATE: - Reproduce again - See that you now get Failed to validate client supplied ticket [GSSException: Failure unspecified at GSS-API level (Mechanism level: Invalid argument (400) - Cannot find key of appropriate type to decrypt AP REP - RC4 with HMAC)] The exception is not super-helpful, but at least it's something.</column><column name="report_time">2013-09-19 12:48:43</column><column name="report_timestamp">1379610000</column><column name="status">resolved fixed</column><column name="commit">910d4d9</column><column name="commit_timestamp">1379600000</column><column name="files">java/org/apache/catalina/authenticator/SpnegoAuthenticator.java</column><column name="result">1:java/org/apache/catalina/authenticator/SpnegoAuthenticator.java</column></table><table name="tomcat"><column name="id">49</column><column name="bug_id">46727</column><column name="summary">DefaultServlet - serving multiple encodings</column><column name="description">Created attachment 23272 Minor refactor of DefaultServlet Hi, It had to happen sooner or later. In one of my tomcat applications I now have to serve multiple collections of static content which may have various encodings. We depend heavily on DefaultServlet, but in its current state it is not possible to control encoding on a resource-by-resource basis. One can set the "fileEncoding" parameter, but this controls all static resources. The structure of the current code makes this impossible to solve by extending the class, since fileEncoding is a global instance variable. The attached refactoring mitigates this primarily by changing the method signature of serveResource() to contain an encoding argument. The extending class may override this method on every call if necessary.</column><column name="report_time">2009-02-17 15:01:26</column><column name="report_timestamp">1234900000</column><column name="status">resolved fixed</column><column name="commit">f74257e</column><column name="commit_timestamp">1379510000</column><column name="files">java/org/apache/catalina/servlets/DefaultServlet.java</column><column name="result">1:java/org/apache/catalina/servlets/DefaultServlet.java</column></table><table name="tomcat"><column name="id">50</column><column name="bug_id">52558</column><column name="summary">CometConnectionManagerValve is adding non-serializable Request[] to Session</column><column name="description">CometConnectionManagerValve is adding HttpServletRequest[] to HttpSession which is preventing the Session being serialized in a Clustered setup. We're resolving this locally using a serializable ConnectionList class with a transient Request[] i.e. public class ConnectionList implements Serializable { 	 	transient Request[] connectionList = null; 	 	ConnectionList(Request[] connectionList){ 		this.connectionList = connectionList; 	} 	 	public Request[] get(){ 		return connectionList; 	} }</column><column name="report_time">2012-01-30 10:46:47</column><column name="report_timestamp">1327940000</column><column name="status">resolved fixed</column><column name="commit">b284611</column><column name="commit_timestamp">1378980000</column><column name="files">java/org/apache/catalina/valves/CometConnectionManagerValve.java</column><column name="result">1:java/org/apache/catalina/valves/CometConnectionManagerValve.java</column></table><table name="tomcat"><column name="id">51</column><column name="bug_id">55552</column><column name="summary">Potential NullPointerException in compiled JSPs if expected EL result is of primitive type</column><column name="description">Created attachment 30821 Web application with required libraries and JSP file to repredouce the NPE If JSP includes a line "&lt;c:if test="${nonExisting}"&gt;Hello,world!&lt;/c:if&gt;" where "nonExisting" is attribute that does not exist, then NullPointerException will be thrown. The cause is at org.apache.jasper.compiler.JspUtil.java at line #421 which generates something like: ((java.lang.Boolean) org.apache.jasper.runtime.PageContextImpl.proprietaryEvaluate("${nonExisting}", java.lang.Boolean.class, (javax.servlet.jsp.PageContext)_jspx_page_context, null, false)).booleanValue() The result of proprietaryEvaluate() is null (because of EL 3.0 changes regarding coercing), hence calling booleanValue() will throw NPE. The latest changes in EL specification does require guarding against such null pointer access (otherwise it will break lots of existing applications). I really hope that NPE is not intended behavior. Steps to reproduce: * put jstl 1.2+ required jar files in WEB-INF/lib (or tomcat/lib) * Create a simple JSP file with line above (&lt;c:if test="${nonExisting}"&gt;Hello,world!&lt;/c:if&gt;) * Exception is thrown upon invoking jsp: java.lang.NullPointerException 	org.apache.jsp.index_jsp._jspx_meth_c_005fif_005f0(index_jsp.java:109) 	org.apache.jsp.index_jsp._jspService(index_jsp.java:81) 	org.apache.jasper.runtime.HttpJspBase.service(HttpJspBase.java:70) 	javax.servlet.http.HttpServlet.service(HttpServlet.java:728) 	org.apache.jasper.servlet.JspServletWrapper.service(JspServletWrapper.java:432) 	org.apache.jasper.servlet.JspServlet.serviceJspFile(JspServlet.java:403) 	org.apache.jasper.servlet.JspServlet.service(JspServlet.java:347) 	javax.servlet.http.HttpServlet.service(HttpServlet.java:728) 	org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:91) As far as I understand, this is direct result of incompatibility between EL 3.0 (http://download.oracle.com/otndocs/jcp/el-3_0-fr-eval-spec/index.html) and 2.2 as stated in EL spec this is intended behavior of EL. Here's the citation (Section A.4): "The default coercion for nulls to non-primitive types (except String) returns nulls. For instance, a null coerced to Boolean now returns a null, while a null coerced to boolean returns false."</column><column name="report_time">2013-09-12 06:19:31</column><column name="report_timestamp">1378980000</column><column name="status">resolved fixed</column><column name="commit">66932c4</column><column name="commit_timestamp">1378980000</column><column name="files">java/org/apache/jasper/compiler/JspUtil.java</column><column name="result">13:java/org/apache/jasper/compiler/JspUtil.java</column></table><table name="tomcat"><column name="id">52</column><column name="bug_id">54693</column><column name="summary">Add a validationQueryTimeout property</column><column name="description">While it's possible to set the query timeout using the QueryTimeoutInterceptor, this will set the same timeout for all queries. It would be nice to be able to set an independent timeout for the validation query. In addition, DBCP supports this feature [1], so it would be nice to have this feature for compatibility / migration purposes. [1] - https://issues.apache.org/jira/browse/DBCP-226 Thanks</column><column name="report_time">2013-03-13 20:04:20</column><column name="report_timestamp">1363220000</column><column name="status">resolved fixed</column><column name="commit">b022c5746</column><column name="commit_timestamp">1378720000</column><column name="files">modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/ConnectionPool.java
modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/DataSourceFactory.java
modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/DataSourceProxy.java
modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/PoolConfiguration.java
modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/PoolProperties.java
modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/PooledConnection.java
modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/jmx/ConnectionPool.java
modules/jdbc-pool/src/test/java/org/apache/tomcat/jdbc/test/TestValidationQueryTimeout.java</column><column name="result">1:modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/jmx/ConnectionPool.java
2:modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/PoolProperties.java
3:modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/DataSourceProxy.java
4:modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/PoolConfiguration.java
12:modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/PooledConnection.java
48:modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/DataSourceFactory.java
49:modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/ConnectionPool.java</column></table><table name="tomcat"><column name="id">53</column><column name="bug_id">55521</column><column name="summary">Race Condition in HttpSession#invalidate() / HttpServletRequest#getSession(boolean)</column><column name="description">Created attachment 30798 code flow that exhibits the race condition For session fixation protection, we have to discard a user's session and create a new one whenever the user's login state changes. For this we rely on Spring Security's SessionFixationProtectionStrategy that, at its core, uses the following commands: session.invalidate(); session = request.getSession(true); Yesterday, we had a message in the log that indicates the latter command returned the same session that was invalidated in the line before: "Your servlet container did not change the session ID when a new session was created. You will not be adequately protected against session-fixation attacks (catalina-exec-339, org.springframework.security.web.authentication.session.SessionFixationProtectionStrategy, SessionFixationProtectionStrategy.java:102)" When I investigated this issue, I found there is in fact a race condition if two threads (associated with requests from the same client) enter the session fixation protection code in parallel. I attached a TXT file that illustrates the code flow that leads to the race condition: When thread B calls session.invalidate(), the call returns immediately becuase the session is already in the "expiring" state. Since the session is not invalid yet, the call to request.getSession(true) won't create a new session, though. So in effect, thread B cannot obtain a new session. The documentation at http://tomcat.apache.org/tomcat-7.0-doc/servletapi/ has no indication that a session may not yet be invalid when session.invalidate() returns. The session interface neither provides a way to detect "expiring" session. The error message appears only once in the production log files that go some weeks back, so it seems to be an infrequent event. Nevertheless, it should be possible to implement session fixation without a race condition. Regards Christoph</column><column name="report_time">2013-09-04 10:24:05</column><column name="report_timestamp">1378300000</column><column name="status">resolved fixed</column><column name="commit">262c069</column><column name="commit_timestamp">1378400000</column><column name="files">java/org/apache/catalina/ha/session/DeltaSession.java
java/org/apache/catalina/session/StandardSession.java</column><column name="result">23:java/org/apache/catalina/session/StandardSession.java
60:java/org/apache/catalina/ha/session/DeltaSession.java</column></table><table name="tomcat"><column name="id">54</column><column name="bug_id">55527</column><column name="summary">JSSESocketFactory conditionally converts alias to lower case; condition is unwise</column><column name="description">JSSESocketFactory conditionally converts the alias to lower case. The condition is coded as follows: private static final String defaultKeystoreType = "JKS"; ... if (JSSESocketFactory.defaultKeystoreType.equals(keystoreType)) { alias = alias.toLowerCase(Locale.ENGLISH); } If the intention is to downcase only JKS store aliases, then the comparison should be made with "JKS", not a constant that happens to contain "JKS" at present. Using a specific comparator would both clarify the code and protect against a possible change to the default (albeit very unlikely).</column><column name="report_time">2013-09-05 09:05:01</column><column name="report_timestamp">1378390000</column><column name="status">resolved fixed</column><column name="commit">f126b5a</column><column name="commit_timestamp">1378380000</column><column name="files">java/org/apache/tomcat/util/net/jsse/JSSESocketFactory.java</column><column name="result">1:java/org/apache/tomcat/util/net/jsse/JSSESocketFactory.java</column></table><table name="tomcat"><column name="id">55</column><column name="bug_id">55343</column><column name="summary">Add flag to ignore exceptions while creating initial pool</column><column name="description">I want my initial pool to be of some size i.e. not empty AND start even if it fails to create all or some of connections. If pool fails to create initial connections for some reason it just throws exceptions. To workaround that I have to set initial pool size to 0. It can be handy to add a flag to ignore (just log them) exceptions that occur while creating initial connections.</column><column name="report_time">2013-08-02 06:05:03</column><column name="report_timestamp">1375440000</column><column name="status">resolved fixed</column><column name="commit">4aa42d7</column><column name="commit_timestamp">1378280000</column><column name="files">modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/ConnectionPool.java
modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/DataSourceFactory.java
modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/DataSourceProxy.java
modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/PoolConfiguration.java
modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/PoolProperties.java
modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/jmx/ConnectionPool.java</column><column name="result">1:modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/ConnectionPool.java
3:modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/jmx/ConnectionPool.java
4:modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/PoolConfiguration.java
6:modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/DataSourceProxy.java
10:modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/PoolProperties.java
167:modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/DataSourceFactory.java</column></table><table name="tomcat"><column name="id">56</column><column name="bug_id">55342</column><column name="summary">Lost interruption</column><column name="description">org.apache.tomcat.jdbc.pool.ConnectionPool#close should not call Thread.interrupted() because interrupt was already reset by code that thrown InterruptedException. } catch (InterruptedException ex) { if (getPoolProperties().getPropagateInterruptState()) { Thread.currentThread().interrupt(); - } else { - Thread.interrupted(); } }</column><column name="report_time">2013-08-02 05:54:35</column><column name="report_timestamp">1375440000</column><column name="status">resolved fixed</column><column name="commit">41225cd</column><column name="commit_timestamp">1378260000</column><column name="files">modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/ConnectionPool.java</column><column name="result">5:modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/ConnectionPool.java</column></table><table name="tomcat"><column name="id">57</column><column name="bug_id">55500</column><column name="summary">AsyncListener.onTimeout is not called via AJP AjpNioProtocol connector</column><column name="description">The AsyncListener.onTimeout is not called, when timeout occurs, when traffic routed via AJP connector configured with AjpNioProtocol protocol.</column><column name="report_time">2013-08-29 12:21:17</column><column name="report_timestamp">1377790000</column><column name="status">resolved fixed</column><column name="commit">cf1e104</column><column name="commit_timestamp">1378200000</column><column name="files">java/org/apache/coyote/ajp/AbstractAjpProcessor.java
java/org/apache/coyote/ajp/AjpAprProcessor.java
java/org/apache/coyote/ajp/AjpNioProcessor.java
java/org/apache/coyote/ajp/AjpProcessor.java</column><column name="result">5:java/org/apache/coyote/ajp/AbstractAjpProcessor.java
7:java/org/apache/coyote/ajp/AjpNioProcessor.java
20:java/org/apache/coyote/ajp/AjpProcessor.java
25:java/org/apache/coyote/ajp/AjpAprProcessor.java</column></table><table name="tomcat"><column name="id">58</column><column name="bug_id">55494</column><column name="summary">JNDIRealm throws exception after timeout / Connection reset</column><column name="description">Our tomcat is configured to use Windows 2012 AD with JNDI-Realm When the application is running for some hours, the Tomcat logs exceptions because of timeouts. Here is a stacktrace: WARNING: Exception performing authentication javax.naming.CommunicationException: Connection reset [Root exception is java.net.SocketException: Connection reset]; remaining name 'xxx' 	at com.sun.jndi.ldap.LdapCtx.doSearch(Unknown Source) 	at com.sun.jndi.ldap.LdapCtx.searchAux(Unknown Source) 	at com.sun.jndi.ldap.LdapCtx.c_search(Unknown Source) 	at com.sun.jndi.toolkit.ctx.ComponentDirContext.p_search(Unknown Source) 	at com.sun.jndi.toolkit.ctx.PartialCompositeDirContext.search(Unknown Source) 	at com.sun.jndi.toolkit.ctx.PartialCompositeDirContext.search(Unknown Source) 	at javax.naming.directory.InitialDirContext.search(Unknown Source) 	at org.apache.catalina.realm.JNDIRealm.getUserBySearch(JNDIRealm.java:1438) 	at org.apache.catalina.realm.JNDIRealm.getUser(JNDIRealm.java:1289) 	at org.apache.catalina.realm.JNDIRealm.getUser(JNDIRealm.java:1225) 	at org.apache.catalina.realm.JNDIRealm.getPrincipal(JNDIRealm.java:2086) 	at org.apache.catalina.realm.JNDIRealm.getPrincipal(JNDIRealm.java:2005) 	at org.apache.catalina.realm.RealmBase.authenticate(RealmBase.java:523) 	at org.apache.catalina.realm.CombinedRealm.authenticate(CombinedRealm.java:295) 	at org.apache.catalina.realm.LockOutRealm.authenticate(LockOutRealm.java:249) 	at org.apache.catalina.authenticator.SpnegoAuthenticator.authenticate(SpnegoAuthenticator.java:250) 	at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:544) 	at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:171) 	at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:99) 	at org.apache.catalina.valves.AccessLogValve.invoke(AccessLogValve.java:953) 	at org.apache.catalina.authenticator.SingleSignOn.invoke(SingleSignOn.java:341) 	at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:118) 	at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:408) 	at org.apache.coyote.ajp.AjpAprProcessor.process(AjpAprProcessor.java:197) 	at org.apache.coyote.AbstractProtocol$AbstractConnectionHandler.process(AbstractProtocol.java:589) 	at org.apache.tomcat.util.net.AprEndpoint$SocketProcessor.run(AprEndpoint.java:1852) 	at java.util.concurrent.ThreadPoolExecutor.runWorker(Unknown Source) 	at java.util.concurrent.ThreadPoolExecutor$Worker.run(Unknown Source) 	at java.lang.Thread.run(Unknown Source) Caused by: java.net.SocketException: Connection reset 	at java.net.SocketInputStream.read(Unknown Source) 	at java.net.SocketInputStream.read(Unknown Source) 	at java.io.BufferedInputStream.fill(Unknown Source) 	at java.io.BufferedInputStream.read1(Unknown Source) 	at java.io.BufferedInputStream.read(Unknown Source) 	at com.sun.jndi.ldap.Connection.run(Unknown Source) 	... 1 more It seems that the LDAP-Lookup tries to search for the user within LDAP but the server already closed the Connection. Looks like this cause: http://stackoverflow.com/questions/10911897/tomcat-7-0-14-ldap-authentication</column><column name="report_time">2013-08-28 12:54:09</column><column name="report_timestamp">1377710000</column><column name="status">resolved fixed</column><column name="commit">7e74aee</column><column name="commit_timestamp">1377700000</column><column name="files">java/org/apache/catalina/realm/JNDIRealm.java</column><column name="result">1:java/org/apache/catalina/realm/JNDIRealm.java</column></table><table name="tomcat"><column name="id">59</column><column name="bug_id">55453</column><column name="summary">AJP send Body with Status 304</column><column name="description">When Status 304 is set to the Response, AJP send the Body to Apache2. In the HTTP-Connector there is a check against 304, see Method "prepareResponse" in Class org.apache.coyote.http11.AbstractHttp11Processor. 304 with Body will corrupt Apache2, see Bug https://issues.apache.org/bugzilla/show_bug.cgi?id=23181</column><column name="report_time">2013-08-20 04:48:03</column><column name="report_timestamp">1376990000</column><column name="status">resolved fixed</column><column name="commit">6d99103</column><column name="commit_timestamp">1377690000</column><column name="files">java/org/apache/coyote/ajp/AbstractAjpProcessor.java
test/org/apache/coyote/ajp/TestAbstractAjpProcessor.java</column><column name="result">2:java/org/apache/coyote/ajp/AbstractAjpProcessor.java
16:test/org/apache/coyote/ajp/TestAbstractAjpProcessor.java</column></table><table name="tomcat"><column name="id">60</column><column name="bug_id">51526</column><column name="summary">Process web application context config with embedded Tomcat.addWebApp(...)</column><column name="description">It would be nice if org.apache.catalina.startup.Tomcat.addWebApp(...) would process the web application's META-INF/context.xml if found. The current implementation skips META-INF/context.xml loading, and does not appear to offer any hook to enable it--the StandardContext is instantiated and initialized with a null configFile in the single call to addWebApp(...).</column><column name="report_time">2011-07-18 23:08:06</column><column name="report_timestamp">1311040000</column><column name="status">resolved fixed</column><column name="commit">058f044</column><column name="commit_timestamp">1377630000</column><column name="files">java/org/apache/catalina/startup/Tomcat.java
test/org/apache/catalina/startup/TestTomcat.java</column><column name="result">5:java/org/apache/catalina/startup/Tomcat.java
15:test/org/apache/catalina/startup/TestTomcat.java</column></table><table name="tomcat"><column name="id">61</column><column name="bug_id">55469</column><column name="summary">Missing HTML closing tags in Manager application</column><column name="description">Created attachment 30751 Patch to fix it on trunk for Tomcat 7 trunk. In the "WAR file to deploy" that allows you to upload a war file, after the closing form tag, it is missing closing off the td and tr tag opened before form tag.</column><column name="report_time">2013-08-22 20:05:22</column><column name="report_timestamp">1377220000</column><column name="status">resolved fixed</column><column name="commit">9a22360</column><column name="commit_timestamp">1377240000</column><column name="files">java/org/apache/catalina/manager/HTMLManagerServlet.java</column><column name="result">36:java/org/apache/catalina/manager/HTMLManagerServlet.java</column></table><table name="tomcat"><column name="id">62</column><column name="bug_id">55454</column><column name="summary">NullPointerException caused by invalid contentType, e.g. trailing semicolon</column><column name="description">possible related to 53353 When having an invalid contenttype like: &lt;jsp:directive.page language="java" contentType="text/html;"/&gt; (note the trailing ";") Tomcat throws a NullPointerException like this: java.lang.NullPointerException 	org.apache.tomcat.util.http.parser.HttpParser.parseMediaType(HttpParser.java:217) 	org.apache.tomcat.util.http.parser.MediaTypeCache.parse(MediaTypeCache.java:54) 	org.apache.catalina.connector.Response.setContentType(Response.java:805) 	org.apache.catalina.connector.ResponseFacade.setContentType(ResponseFacade.java:245) 	javax.servlet.ServletResponseWrapper.setContentType(ServletResponseWrapper.java:123) After removing the extra ";" or entering a charset like this: &lt;jsp:directive.page language="java" contentType="text/html; charset=UTF-8"/&gt; it works as expected. My desired behaviour would be: Don't crash with a NPE. Other Tomcat versions seem to handly this different.</column><column name="report_time">2013-08-20 09:30:09</column><column name="report_timestamp">1377010000</column><column name="status">resolved fixed</column><column name="commit">8b03dcf</column><column name="commit_timestamp">1377010000</column><column name="files">java/org/apache/tomcat/util/http/parser/HttpParser.java
test/org/apache/tomcat/util/http/parser/TestMediaType.java</column><column name="result">1:test/org/apache/tomcat/util/http/parser/TestMediaType.java
12:java/org/apache/tomcat/util/http/parser/HttpParser.java</column></table><table name="tomcat"><column name="id">63</column><column name="bug_id">55442</column><column name="summary">EL Constructor throws exception</column><column name="description">In the EL 3.0 Spec, section 1.22.3 "Constructor Reference" states "A class name reference, followed by arguments in parenthesis, such as "Boolean(true)" denotes the invocation of the constructor of the class with the supplied arguments." This leads me to believe that the following test should work: @Test public void testImport03() { 	ELProcessor processor = new ELProcessor(); Object result = processor.getValue("Integer('1000')", Integer.class); Assert.assertEquals(Integer.valueOf(1000), result); } Unfortunately, this fails with the following error. javax.el.ELException: Function ':Integer' not found 	at org.apache.el.parser.AstFunction.getValue(AstFunction.java:136) 	at org.apache.el.ValueExpressionImpl.getValue(ValueExpressionImpl.java:188) 	at javax.el.ELProcessor.getValue(ELProcessor.java:45) 	at org.apache.el.parser.TestAstIdentifier.testImport03(TestAstIdentifier.java:53)  Thanks</column><column name="report_time">2013-08-17 13:39:06</column><column name="report_timestamp">1376760000</column><column name="status">resolved fixed</column><column name="commit">ab70f07</column><column name="commit_timestamp">1376990000</column><column name="files">java/org/apache/el/parser/AstFunction.java
test/org/apache/el/parser/TestAstFunction.java</column><column name="result">2:java/org/apache/el/parser/AstFunction.java</column></table><table name="tomcat"><column name="id">64</column><column name="bug_id">55438</column><column name="summary">Non Blocking API's onAllDataRead being called twice</column><column name="description">Created attachment 30738 Patch against TestNonBlockingAPI.java I have a simple echo servlet which uses the Servlet 3.1 Non-Blocking IO API. It creates a ReadListener, that reads the request's input, buffers it, creates a WriteListener that takes the buffered input and echoes it back to the response. Most of the time this works OK, but when I send a request with no input data I get the following error. 6-Aug-2013 11:18:09.523 INFO [main] org.apache.catalina.startup.Catalina.start Server startup in 1452 ms java.lang.IllegalStateException: The non-blocking write listener has already been set at org.apache.coyote.Response.setWriteListener(Response.java:583) at org.apache.catalina.connector.OutputBuffer.setWriteListener(OutputBuffer.java:665) at org.apache.catalina.connector.CoyoteOutputStream.setWriteListener(CoyoteOutputStream.java:162) at com.pivotal.demos.nbio.EchoNbioServlet$1.onAllDataRead(EchoNbioServlet.java:77) at org.apache.catalina.connector.CoyoteAdapter.asyncDispatch(CoyoteAdapter.java:384) at org.apache.coyote.http11.AbstractHttp11Processor.asyncDispatch(AbstractHttp11Processor.java:1607) at org.apache.coyote.AbstractProtocol$AbstractConnectionHandler.process(AbstractProtocol.java:622) at org.apache.coyote.http11.Http11NioProtocol$Http11ConnectionHandler.process(Http11NioProtocol.java:223) at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1592) at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.run(NioEndpoint.java:1550) at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1145) at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:615) at java.lang.Thread.run(Thread.java:724) 16-Aug-2013 11:20:13.205 SEVERE [http-nio-8080-exec-7] org.apache.catalina.connector.CoyoteAdapter.asyncDispatch Exception while processing an asynchronous request java.lang.NullPointerException at org.apache.catalina.connector.CoyoteAdapter.asyncDispatch(CoyoteAdapter.java:429) at org.apache.coyote.http11.AbstractHttp11Processor.asyncDispatch(AbstractHttp11Processor.java:1607) at org.apache.coyote.AbstractProtocol$AbstractConnectionHandler.process(AbstractProtocol.java:622) at org.apache.coyote.http11.Http11NioProtocol$Http11ConnectionHandler.process(Http11NioProtocol.java:223) at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1592) at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.run(NioEndpoint.java:1550) at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1145) at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:615) at java.lang.Thread.run(Thread.java:724) Looking into it, what appears to be happening is that the "ReadListener.onAllDataRead()" method is being called twice. Because I'm setting the WriteListener in the "onAllDataRead" method, the second invocation of "onAllDataRead" causes the IllegalStateException. I was assuming that "onAllDataRead" should only be called once and so it would be OK to set the WriteListener in that method. Can "onAllDataRead" be legitimately called multiple times? Mark&gt; No. Any chance you could convert the code below into a Tomcat unit test? Attaching unit test to replicate the issue.</column><column name="report_time">2013-08-16 18:51:10</column><column name="report_timestamp">1376690000</column><column name="status">resolved fixed</column><column name="commit">7f6ea48</column><column name="commit_timestamp">1376920000</column><column name="files">java/org/apache/catalina/connector/InputBuffer.java
java/org/apache/catalina/connector/Request.java
java/org/apache/coyote/Request.java
test/org/apache/catalina/nonblocking/TestNonBlockingAPI.java</column><column name="result">21:java/org/apache/coyote/Request.java
24:java/org/apache/catalina/connector/InputBuffer.java
29:java/org/apache/catalina/connector/Request.java
65:test/org/apache/catalina/nonblocking/TestNonBlockingAPI.java</column></table><table name="tomcat"><column name="id">65</column><column name="bug_id">55434</column><column name="summary">The path /foo/a/a/bar causes IllegalArgumentException when WsServerContainer creates UriTemplate</column><column name="description">WsFilter calls WsServerContainer.findMapping("/foo/a/a/bar"), which in turn calls new UriTemplate(path). If the path contains repeated segments, it causes the following code in the UriTemplate constructor to throw an exception: Segment old = this.segments.put(segment, new Segment(index, segment)); if (old != null) { throw new IllegalArgumentException( sm.getString("uriTemplate.duplicateName", segment)); } This would be valid if the duplicates were URI variable names but not when their plain path segments.</column><column name="report_time">2013-08-16 17:31:48</column><column name="report_timestamp">1376690000</column><column name="status">resolved fixed</column><column name="commit">98ee5b4</column><column name="commit_timestamp">1376850000</column><column name="files">java/org/apache/tomcat/websocket/server/UriTemplate.java
test/org/apache/tomcat/websocket/server/TestUriTemplate.java</column><column name="result">1:java/org/apache/tomcat/websocket/server/UriTemplate.java
3:test/org/apache/tomcat/websocket/server/TestUriTemplate.java</column></table><table name="tomcat"><column name="id">66</column><column name="bug_id">55354</column><column name="summary">JNDIRealm.getPrincipal(context,username,gssCredential) corrupts realm context</column><column name="description">The getPrincipal(context,username,gssCredential) method in JNDIRealm is designed to allow delegated credentials to be applied to the directory server connection as part of SPNEGO authentication. This is done by manipulation of a number of the directory context's environment parameters. However, as currently implemented, these environment parameters are forcibly cleared after the getUser() call regardless of whether the values were even changed (i.e. if isUseDelegatedCredential() returned false). If the container realm is defined to use GSSAPI authentication, only the first SPNEGO authentication request will succeed. All subsequent requests will fail with this exception: javax.naming.NamingException: [LDAP: error code 1 - 000004DC: LdapErr: DSID-0C0906DC, comment: In order to perform this operation a successful bind must be completed on the connection., data 0, v1db0 The exception is due to the Context.SECURITY_AUTHENTICATION being cleared by getPrincipal() - resulting in a attempted "simple" bind with no username/password (i.e. anonymous). A workaround is to ensure that the connectionName and connectionPassword parameters are specified in the realm definition - however, if one is using GSSAPI - this shouldn't be necessary and certainly defeats the purpose of using GSSAPI in the first place. The code should preserve pre-existing environment parameters in the context before changing them, then restore those values afterwards - rather than just clearing the settings completely.</column><column name="report_time">2013-08-05 02:53:29</column><column name="report_timestamp">1375690000</column><column name="status">resolved fixed</column><column name="commit">135e2c4</column><column name="commit_timestamp">1376600000</column><column name="files">java/org/apache/catalina/realm/JNDIRealm.java</column><column name="result">1:java/org/apache/catalina/realm/JNDIRealm.java</column></table><table name="tomcat"><column name="id">67</column><column name="bug_id">55357</column><column name="summary">Cannot deserialize session when it contains Externalizable objects (using PersistentManager)</column><column name="description">I'm using PersistentManager with JDBCStore to store sessions in my database. But in my webapplication, there is an object in my session which is an instance of org.apache.el.MethodExpressionImpl. This class implements the Externalizable interface but in this readExternal method it uses org.apache.el.util.ReflectionUtil.forName(String) which use Thread.currentThread().getContextClassLoader() as its ClassLoader. It seems to be incorrect because this method return a StandardClassLoader which cannot find my classes in WEB-INF/lib directory of my webapp. Is it the problem of the MethodExpressionImpl class which use this method or the JDBCStore which does not set the thread contextClassLoader as the WebappClassLoader ? Here is the stacktrace : SEVERE: Error processing request java.lang.IllegalStateException: Erreur lors de la dsrialisation de la session 1634C328D27A31CB9FC4D52392FDB05F: {1} 	at org.apache.catalina.session.PersistentManagerBase.swapIn(PersistentManagerBase.java:713) 	at org.apache.catalina.session.PersistentManagerBase.findSession(PersistentManagerBase.java:503) 	at org.apache.catalina.connector.Request.isRequestedSessionIdValid(Request.java:2391) 	at org.apache.catalina.connector.CoyoteAdapter.parseSessionCookiesId(CoyoteAdapter.java:954) 	at org.apache.catalina.connector.CoyoteAdapter.postParseRequest(CoyoteAdapter.java:688) 	at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:402) 	at org.apache.coyote.http11.AbstractHttp11Processor.process(AbstractHttp11Processor.java:1002) 	at org.apache.coyote.AbstractProtocol$AbstractConnectionHandler.process(AbstractProtocol.java:585) 	at org.apache.tomcat.util.net.JIoEndpoint$SocketProcessor.run(JIoEndpoint.java:312) 	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1145) 	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:615) 	at java.lang.Thread.run(Thread.java:722) Caused by: java.lang.ClassNotFoundException: javax.faces.event.ActionEvent 	at java.net.URLClassLoader$1.run(URLClassLoader.java:366) 	at java.net.URLClassLoader$1.run(URLClassLoader.java:355) 	at java.security.AccessController.doPrivileged(Native Method) 	at java.net.URLClassLoader.findClass(URLClassLoader.java:354) 	at java.lang.ClassLoader.loadClass(ClassLoader.java:423) 	at java.lang.ClassLoader.loadClass(ClassLoader.java:356) 	at java.lang.Class.forName0(Native Method) 	at java.lang.Class.forName(Class.java:266) 	at org.apache.el.util.ReflectionUtil.forName(ReflectionUtil.java:62) 	at org.apache.el.util.ReflectionUtil.toTypeArray(ReflectionUtil.java:88) 	at org.apache.el.MethodExpressionImpl.readExternal(MethodExpressionImpl.java:290) 	at java.io.ObjectInputStream.readExternalData(ObjectInputStream.java:1835) 	at java.io.ObjectInputStream.readOrdinaryObject(ObjectInputStream.java:1794) 	at java.io.ObjectInputStream.readObject0(ObjectInputStream.java:1348) 	at java.io.ObjectInputStream.readObject(ObjectInputStream.java:370) 	at com.sun.facelets.el.TagMethodExpression.readExternal(TagMethodExpression.java:101) 	at java.io.ObjectInputStream.readExternalData(ObjectInputStream.java:1835) 	at java.io.ObjectInputStream.readOrdinaryObject(ObjectInputStream.java:1794) 	at java.io.ObjectInputStream.readObject0(ObjectInputStream.java:1348) 	at java.io.ObjectInputStream.readArray(ObjectInputStream.java:1704) 	at java.io.ObjectInputStream.readObject0(ObjectInputStream.java:1342) 	at java.io.ObjectInputStream.defaultReadFields(ObjectInputStream.java:1989) 	at java.io.ObjectInputStream.readSerialData(ObjectInputStream.java:1913) 	at java.io.ObjectInputStream.readOrdinaryObject(ObjectInputStream.java:1796) 	at java.io.ObjectInputStream.readObject0(ObjectInputStream.java:1348) 	at java.io.ObjectInputStream.readObject(ObjectInputStream.java:370) 	at java.util.ArrayList.readObject(ArrayList.java:733) 	at sun.reflect.GeneratedMethodAccessor90.invoke(Unknown Source) 	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) 	at java.lang.reflect.Method.invoke(Method.java:601) 	at java.io.ObjectStreamClass.invokeReadObject(ObjectStreamClass.java:1004) 	at java.io.ObjectInputStream.readSerialData(ObjectInputStream.java:1891) 	at java.io.ObjectInputStream.readOrdinaryObject(ObjectInputStream.java:1796) 	at java.io.ObjectInputStream.readObject0(ObjectInputStream.java:1348) 	at java.io.ObjectInputStream.readArray(ObjectInputStream.java:1704) 	at java.io.ObjectInputStream.readObject0(ObjectInputStream.java:1342) 	at java.io.ObjectInputStream.readArray(ObjectInputStream.java:1704) 	at java.io.ObjectInputStream.readObject0(ObjectInputStream.java:1342) 	at java.io.ObjectInputStream.readArray(ObjectInputStream.java:1704) 	at java.io.ObjectInputStream.readObject0(ObjectInputStream.java:1342) 	at java.io.ObjectInputStream.readArray(ObjectInputStream.java:1704) 	at java.io.ObjectInputStream.readObject0(ObjectInputStream.java:1342) 	at java.io.ObjectInputStream.readArray(ObjectInputStream.java:1704) 	at java.io.ObjectInputStream.readObject0(ObjectInputStream.java:1342) 	at java.io.ObjectInputStream.readArray(ObjectInputStream.java:1704) 	at java.io.ObjectInputStream.readObject0(ObjectInputStream.java:1342) 	at java.io.ObjectInputStream.readArray(ObjectInputStream.java:1704) 	at java.io.ObjectInputStream.readObject0(ObjectInputStream.java:1342) 	at java.io.ObjectInputStream.readArray(ObjectInputStream.java:1704) 	at java.io.ObjectInputStream.readObject0(ObjectInputStream.java:1342) 	at java.io.ObjectInputStream.readArray(ObjectInputStream.java:1704) 	at java.io.ObjectInputStream.readObject0(ObjectInputStream.java:1342) 	at java.io.ObjectInputStream.readArray(ObjectInputStream.java:1704) 	at java.io.ObjectInputStream.readObject0(ObjectInputStream.java:1342) 	at java.io.ObjectInputStream.readArray(ObjectInputStream.java:1704) 	at java.io.ObjectInputStream.readObject0(ObjectInputStream.java:1342) 	at java.io.ObjectInputStream.readArray(ObjectInputStream.java:1704) 	at java.io.ObjectInputStream.readObject0(ObjectInputStream.java:1342) 	at java.io.ObjectInputStream.readArray(ObjectInputStream.java:1704) 	at java.io.ObjectInputStream.readObject0(ObjectInputStream.java:1342) 	at java.io.ObjectInputStream.defaultReadFields(ObjectInputStream.java:1989) 	at java.io.ObjectInputStream.readSerialData(ObjectInputStream.java:1913) 	at java.io.ObjectInputStream.readOrdinaryObject(ObjectInputStream.java:1796) 	at java.io.ObjectInputStream.readObject0(ObjectInputStream.java:1348) 	at java.io.ObjectInputStream.readObject(ObjectInputStream.java:370) 	at java.util.HashMap.readObject(HashMap.java:1155) 	at sun.reflect.GeneratedMethodAccessor89.invoke(Unknown Source) 	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) 	at java.lang.reflect.Method.invoke(Method.java:601) 	at java.io.ObjectStreamClass.invokeReadObject(ObjectStreamClass.java:1004) 	at java.io.ObjectInputStream.readSerialData(ObjectInputStream.java:1891) 	at java.io.ObjectInputStream.readOrdinaryObject(ObjectInputStream.java:1796) 	at java.io.ObjectInputStream.readObject0(ObjectInputStream.java:1348) 	at java.io.ObjectInputStream.readObject(ObjectInputStream.java:370) 	at java.util.HashMap.readObject(HashMap.java:1155) 	at sun.reflect.GeneratedMethodAccessor89.invoke(Unknown Source) 	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) 	at java.lang.reflect.Method.invoke(Method.java:601) 	at java.io.ObjectStreamClass.invokeReadObject(ObjectStreamClass.java:1004) 	at java.io.ObjectInputStream.readSerialData(ObjectInputStream.java:1891) 	at java.io.ObjectInputStream.readOrdinaryObject(ObjectInputStream.java:1796) 	at java.io.ObjectInputStream.readObject0(ObjectInputStream.java:1348) 	at java.io.ObjectInputStream.defaultReadFields(ObjectInputStream.java:1989) 	at java.io.ObjectInputStream.defaultReadObject(ObjectInputStream.java:499) 	at org.ajax4jsf.application.AjaxStateHolder.readObject(AjaxStateHolder.java:204) 	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) 	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57) 	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) 	at java.lang.reflect.Method.invoke(Method.java:601) 	at java.io.ObjectStreamClass.invokeReadObject(ObjectStreamClass.java:1004) 	at java.io.ObjectInputStream.readSerialData(ObjectInputStream.java:1891) 	at java.io.ObjectInputStream.readOrdinaryObject(ObjectInputStream.java:1796) 	at java.io.ObjectInputStream.readObject0(ObjectInputStream.java:1348) 	at java.io.ObjectInputStream.readObject(ObjectInputStream.java:370) 	at org.apache.catalina.session.StandardSession.readObject(StandardSession.java:1595) 	at org.apache.catalina.session.StandardSession.readObjectData(StandardSession.java:1060) 	at org.apache.catalina.session.JDBCStore.load(JDBCStore.java:657) 	at org.apache.catalina.session.PersistentManagerBase.swapIn(PersistentManagerBase.java:707) 	... 11 more</column><column name="report_time">2013-08-05 15:15:18</column><column name="report_timestamp">1375730000</column><column name="status">resolved fixed</column><column name="commit">e19e794</column><column name="commit_timestamp">1376580000</column><column name="files">java/org/apache/catalina/session/FileStore.java
java/org/apache/catalina/session/JDBCStore.java</column><column name="result">8:java/org/apache/catalina/session/FileStore.java
30:java/org/apache/catalina/session/JDBCStore.java</column></table><table name="tomcat"><column name="id">68</column><column name="bug_id">55400</column><column name="summary">WsFilter not compatible with async sample applications</column><column name="description">$ output/build/bin/catalina.sh run http://localhost:8080/examples/async/async0 java.lang.IllegalStateException: Not supported. 	org.apache.catalina.connector.Request.startAsync(Request.java:1621) 	org.apache.catalina.connector.Request.startAsync(Request.java:1614) 	org.apache.catalina.connector.RequestFacade.startAsync(RequestFacade.java:1033) 	async.Async0.service(Async0.java:44) 	javax.servlet.http.HttpServlet.service(HttpServlet.java:728) 	org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:91) 	org.apache.catalina.filters.SetCharacterEncodingFilter.doFilter(SetCharacterEncodingFilter.java:108) I'm not sure if this filter supports Async or whether it should not be applied for these Servlets.</column><column name="report_time">2013-08-10 20:20:50</column><column name="report_timestamp">1376180000</column><column name="status">resolved fixed</column><column name="commit">3490f73</column><column name="commit_timestamp">1376480000</column><column name="files">java/org/apache/tomcat/websocket/server/WsServerContainer.java</column><column name="result">2:java/org/apache/tomcat/websocket/server/WsServerContainer.java</column></table><table name="tomcat"><column name="id">69</column><column name="bug_id">55404</column><column name="summary">ContextConfig#validateSecurityRoles emits three info log messages which contain a warning</column><column name="description">ContextConfig#validateSecurityRoles emits three info log messages but the messages start with 'WARNING:'. This is quite irrtating. &gt; contextConfig.role.auth=WARNING: Security role name {0} used in an &lt;auth-constraint&gt; without being defined in a &lt;security-role&gt; &gt; contextConfig.role.link=WARNING: Security role name {0} used in a &lt;role-link&gt; without being defined in a &lt;security-role&gt; &gt; contextConfig.role.runas=WARNING: Security role name {0} used in a &lt;run-as&gt; without being defined in a &lt;security-role&gt; Remove the warning and set the log level from info to warning.</column><column name="report_time">2013-08-12 13:09:52</column><column name="report_timestamp">1376330000</column><column name="status">resolved fixed</column><column name="commit">df02b95</column><column name="commit_timestamp">1376320000</column><column name="files">java/org/apache/catalina/startup/ContextConfig.java</column><column name="result">1:java/org/apache/catalina/startup/ContextConfig.java</column></table><table name="tomcat"><column name="id">70</column><column name="bug_id">52092</column><column name="summary">Please make AsyncFileHandler and OneLineFormatter the default for logging.properties</column><column name="description">Apache Tomcat 7 has created some very important enhancements to logging, and we should exploit them. Please make the org.apache.juli.AsyncFileHandler and org.apache.juli.OneLineFormatter the defaults for shipped conf/logging.properties. These enhancements have been vetted with over 20 releases of Apache Tomcat, let's give them some first class status.</column><column name="report_time">2011-10-26 11:49:26</column><column name="report_timestamp">1319640000</column><column name="status">resolved fixed</column><column name="commit">7d0408e</column><column name="commit_timestamp">1375910000</column><column name="files">java/org/apache/juli/FileHandler.java</column><column name="result">3:java/org/apache/juli/FileHandler.java</column></table><table name="tomcat"><column name="id">71</column><column name="bug_id">55345</column><column name="summary">Webresources class AbstractResourceSet throws exception upon callong ServletContext.getRealPath("")</column><column name="description">As described on user list: Tomcat 8, unlike Tomcat 7.0.42, throws IllegalArgumentException upon calling ServletContext.getRealPath(""). It seems that TC8 expects that argument provided to getRealPath is non-empty string. I believe that ServletContext.getRealPath should allow empty string as argument. -Ognjen Stack trace: [ERROR] java.lang.IllegalArgumentException java.lang.IllegalArgumentException at org.apache.catalina.webresources.AbstractResourceSet.checkPath(AbstractResourceSet.java:39) at org.apache.catalina.webresources.DirResourceSet.getResource(DirResourceSet.java:91) at org.apache.catalina.webresources.StandardRoot.getResourceInternal(StandardRoot.java:176) at org.apache.catalina.webresources.CachedResource.validate(CachedResource.java:62) at org.apache.catalina.webresources.Cache.getResource(Cache.java:78) at org.apache.catalina.webresources.StandardRoot.getResource(StandardRoot.java:163) at org.apache.catalina.core.StandardContext.getRealPath(StandardContext.java:4528) at org.apache.catalina.core.ApplicationContext.getRealPath(ApplicationContext.java:398) at org.apache.catalina.core.ApplicationContextFacade.getRealPath(ApplicationContextFacade.java:335) at org.apache.axis2.deployment.WarBasedAxisConfigurator.&lt;init&gt;(WarBasedAxisConfigurator.java:103) at org.apache.axis2.transport.http.AxisServlet.initConfigContext(AxisServlet.java:584) at org.apache.axis2.transport.http.AxisServlet.init(AxisServlet.java:454) at org.apache.catalina.core.StandardWrapper.initServlet(StandardWrapper.java:1235) at org.apache.catalina.core.StandardWrapper.loadServlet(StandardWrapper.java:1148) at org.apache.catalina.core.StandardWrapper.load(StandardWrapper.java:1044) at org.apache.catalina.core.StandardContext.loadOnStartup(StandardContext.java:5025) at org.apache.catalina.core.StandardContext.startInternal(StandardContext.java:5322) at org.apache.catalina.util.LifecycleBase.start(LifecycleBase.java:150) at org.apache.catalina.core.ContainerBase.addChildInternal(ContainerBase.java:726) at org.apache.catalina.core.ContainerBase.addChild(ContainerBase.java:702) at org.apache.catalina.core.StandardHost.addChild(StandardHost.java:698) at org.apache.catalina.startup.HostConfig.deployWAR(HostConfig.java:968) at org.apache.catalina.startup.HostConfig$DeployWar.run(HostConfig.java:1742) at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:471) at java.util.concurrent.FutureTask$Sync.innerRun(FutureTask.java:334) at java.util.concurrent.FutureTask.run(FutureTask.java:166) at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1145) at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:615) at java.lang.Thread.run(Thread.java:724)</column><column name="report_time">2013-08-02 11:52:04</column><column name="report_timestamp">1375460000</column><column name="status">closed fixed</column><column name="commit">aa15bac</column><column name="commit_timestamp">1375470000</column><column name="files">java/org/apache/catalina/core/StandardContext.java</column><column name="result">1:java/org/apache/catalina/core/StandardContext.java</column></table><table name="tomcat"><column name="id">72</column><column name="bug_id">55333</column><column name="summary">JDBCRealm Digest authentication Flow is not working throws Function sequence error</column><column name="description">Issue: Digest authentication flow is not working Error Thrown : Function sequence error PackageName: org.apache.catalina.realm ClassName : JDBCRealm MethodName: String getPassword(String username) Snapshot from above mentioned method =================================== stmt = credentials(dbConnection, username); rs = stmt.executeQuery(); // Due to this connection commit, resultset is nullified dbConnection.commit(); // While executing this statement it throws Function sequence error if (rs.next()) { dbCredentials = rs.getString(1); } =================================== Above explanation has been validate by placing 7.0.41 catalina.jar where the above changes are not there due to fix of 55071 bug Below snapshot is the error observed while trying for Digest authentication ========================================================================== Jul 31, 2013 3:43:40 PM org.apache.catalina.realm.JDBCRealm getPassword SEVERE: Exception performing authentication java.sql.SQLException: [TimesTen][TimesTen 11.2.2.5.0 ODBC Driver]Function sequence error at com.timesten.jdbc.JdbcOdbc.createSQLException(JdbcOdbc.java:3238) at com.timesten.jdbc.JdbcOdbc.standardError(JdbcOdbc.java:3387) at com.timesten.jdbc.JdbcOdbc.SQLFetch(JdbcOdbc.java:921) at com.timesten.jdbc.JdbcOdbcResultSet.next(JdbcOdbcResultSet.java:409) at org.apache.catalina.realm.JDBCRealm.getPassword(JDBCRealm.java:558) at org.apache.catalina.realm.RealmBase.getDigest(RealmBase.java:1189) at org.apache.catalina.realm.RealmBase.authenticate(RealmBase.java:409) at com.kodiak.digest.authentication.KnDigestAuthenticator$KnDigestInfo.authenticate(KnDigestAuthenticator.java:733) at com.kodiak.digest.authentication.KnDigestAuthenticator.authenticate(KnDigestAuthenticator.java:275) at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:574) at org.apache.catalina.valves.AccessLogValve.invoke(AccessLogValve.java:953) at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:171) at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:99) at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:118) at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:408) at org.apache.coyote.http11.AbstractHttp11Processor.process(AbstractHttp11Processor.java:1023) at org.apache.coyote.AbstractProtocol$AbstractConnectionHandler.process(AbstractProtocol.java:589) at org.apache.tomcat.util.net.JIoEndpoint$SocketProcessor.run(JIoEndpoint.java:312) at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1145) at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:615) at java.lang.Thread.run(Thread.java:724) Jul 31, 2013 3:43:40 PM org.apache.catalina.realm.JDBCRealm getPassword SEVERE: Exception performing authentication java.sql.SQLException: [TimesTen][TimesTen 11.2.2.5.0 ODBC Driver]Function sequence error at com.timesten.jdbc.JdbcOdbc.createSQLException(JdbcOdbc.java:3238) at com.timesten.jdbc.JdbcOdbc.standardError(JdbcOdbc.java:3387) at com.timesten.jdbc.JdbcOdbc.SQLFetch(JdbcOdbc.java:921) at com.timesten.jdbc.JdbcOdbcResultSet.next(JdbcOdbcResultSet.java:409) at org.apache.catalina.realm.JDBCRealm.getPassword(JDBCRealm.java:558) at org.apache.catalina.realm.RealmBase.getDigest(RealmBase.java:1189) at org.apache.catalina.realm.RealmBase.authenticate(RealmBase.java:409) "localhost.2013-07-31.log" 50L, 3800C Cheers, Mahaaboob</column><column name="report_time">2013-07-31 17:44:41</column><column name="report_timestamp">1375310000</column><column name="status">resolved fixed</column><column name="commit">6cd42af</column><column name="commit_timestamp">1375350000</column><column name="files">java/org/apache/catalina/realm/JDBCRealm.java</column><column name="result">1:java/org/apache/catalina/realm/JDBCRealm.java</column></table><table name="tomcat"><column name="id">73</column><column name="bug_id">55316</column><column name="summary">Ugly error log when WS client disconnects unexpectedly</column><column name="description">When a WS browser client disconnects unexpectedly (e.g. in the SNake sample if the user just closes the browser or loads another page) you get ugle ERROR logs in the Tomcat server. E.g. 2013-07-27 12:04:34.424 ERROR 31847 --- [nio-8080-exec-7] org.apache.tomcat.websocket.WsSession : Failed to send close message to remote endpoint java.io.IOException: java.util.concurrent.ExecutionException: java.io.EOFException 	at org.apache.tomcat.websocket.WsRemoteEndpointImplBase.startMessageBlock(WsRemoteEndpointImplBase.java:221) 	at org.apache.tomcat.websocket.WsSession.sendCloseMessage(WsSession.java:466) 	at org.apache.tomcat.websocket.WsSession.onClose(WsSession.java:430) 	at org.apache.tomcat.websocket.server.WsHttpUpgradeHandler.close(WsHttpUpgradeHandler.java:172) 	at org.apache.tomcat.websocket.server.WsHttpUpgradeHandler.access$200(WsHttpUpgradeHandler.java:45) 	at org.apache.tomcat.websocket.server.WsHttpUpgradeHandler$WsReadListener.onDataAvailable(WsHttpUpgradeHandler.java:198) 	at org.apache.coyote.http11.upgrade.AbstractServletInputStream.onDataAvailable(AbstractServletInputStream.java:169) 	at org.apache.coyote.http11.upgrade.AbstractProcessor.upgradeDispatch(AbstractProcessor.java:95) 	at org.apache.coyote.AbstractProtocol$AbstractConnectionHandler.process(AbstractProtocol.java:630) 	at org.apache.coyote.http11.Http11NioProtocol$Http11ConnectionHandler.process(Http11NioProtocol.java:223) 	at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1585) 	at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.run(NioEndpoint.java:1543) 	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1145) 	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:615) 	at java.lang.Thread.run(Thread.java:724) Caused by: java.util.concurrent.ExecutionException: java.io.EOFException 	at org.apache.tomcat.websocket.WsRemoteEndpointImplBase$FutureToSendHandler.get(WsRemoteEndpointImplBase.java:779) 	at org.apache.tomcat.websocket.WsRemoteEndpointImplBase.startMessageBlock(WsRemoteEndpointImplBase.java:217) 	... 14 common frames omitted Caused by: java.io.EOFException: null 	at org.apache.tomcat.websocket.server.WsRemoteEndpointImplServer.doClose(WsRemoteEndpointImplServer.java:126) 	at org.apache.tomcat.websocket.WsRemoteEndpointImplBase.close(WsRemoteEndpointImplBase.java:531) 	at org.apache.tomcat.websocket.server.WsRemoteEndpointImplServer.onWritePossible(WsRemoteEndpointImplServer.java:107) 	at org.apache.tomcat.websocket.server.WsRemoteEndpointImplServer.doWrite(WsRemoteEndpointImplServer.java:71) 	at org.apache.tomcat.websocket.WsRemoteEndpointImplBase.writeMessagePart(WsRemoteEndpointImplBase.java:353) 	at org.apache.tomcat.websocket.WsRemoteEndpointImplBase.startMessage(WsRemoteEndpointImplBase.java:254) 	at org.apache.tomcat.websocket.WsRemoteEndpointImplBase.startMessageBlock(WsRemoteEndpointImplBase.java:211) 	... 14 common frames omitted Presumably this is expected to be relatively normal, so I'd expect a lot less noise (and no ERROR) in the log?</column><column name="report_time">2013-07-27 11:07:08</column><column name="report_timestamp">1374940000</column><column name="status">resolved fixed</column><column name="commit">d370084</column><column name="commit_timestamp">1375280000</column><column name="files">java/org/apache/tomcat/websocket/WsSession.java</column><column name="result">10:java/org/apache/tomcat/websocket/WsSession.java</column></table><table name="tomcat"><column name="id">74</column><column name="bug_id">55312</column><column name="summary">No SCI scan in embedded Tomcat</column><column name="description">I like the fact that SCI scanning is off by default in a Tomcat embedded instance, but I'd lik eto be able to switch it on. It might even be possible already, but the API is non-obvious. Maybe a method in Tomcat or associated friendly helper? Would also be nice in Tomcat 7.</column><column name="report_time">2013-07-26 15:37:46</column><column name="report_timestamp">1374870000</column><column name="status">resolved fixed</column><column name="commit">7540e90</column><column name="commit_timestamp">1375280000</column><column name="files">java/org/apache/tomcat/util/scan/StandardJarScanner.java</column><column name="result">4:java/org/apache/tomcat/util/scan/StandardJarScanner.java</column></table><table name="tomcat"><column name="id">75</column><column name="bug_id">55309</column><column name="summary">Concurrent issue of TagPluginManager</column><column name="description">Created attachment 30629 Patch on TagPluginManager TagPluginManager is shared within ServletContext. But it contains a variable "PageInfo pageInfo". PageInfo should be aligned with specified page. PageInfo is used for holding page information, such as "Import". So when there are two pages are compiled in parallel. It encounters concurrent issue. One of the page can't be compiled unless the server is restarted.</column><column name="report_time">2013-07-26 04:38:23</column><column name="report_timestamp">1374830000</column><column name="status">resolved fixed</column><column name="commit">11c05b7</column><column name="commit_timestamp">1375130000</column><column name="files">java/org/apache/jasper/compiler/TagPluginManager.java</column><column name="result">1:java/org/apache/jasper/compiler/TagPluginManager.java</column></table><table name="tomcat"><column name="id">76</column><column name="bug_id">55287</column><column name="summary">ServletContainerInitializer in parent classloader may not be found</column><column name="description">To include the JasperInitializer in the test environment I added an entry in testclasses/META-INF/services. This is not picked up when the parent classloader is searched because this path is a directory not a JAR file. It would be picked up if the "scanAllDirectories" extension was enabled but that should not be necessary if the search is to be semantically equivalent to j.u.ServiceLoader (which does locate it).</column><column name="report_time">2013-07-21 20:44:47</column><column name="report_timestamp">1374450000</column><column name="status">resolved fixed</column><column name="commit">6e514c0</column><column name="commit_timestamp">1375050000</column><column name="files">java/org/apache/catalina/startup/ContextConfig.java
java/org/apache/catalina/startup/WebappServiceLoader.java
test/org/apache/catalina/startup/TestWebappServiceLoader.java</column><column name="result">2:java/org/apache/catalina/startup/ContextConfig.java</column></table><table name="tomcat"><column name="id">77</column><column name="bug_id">55267</column><column name="summary">NIO thread locked</column><column name="description">Did some load test and thread got stuck, see dump. Basically I just simulate 100 users that connect and disconnect.</column><column name="report_time">2013-07-15 11:38:25</column><column name="report_timestamp">1373900000</column><column name="status">resolved fixed</column><column name="commit">11bf498</column><column name="commit_timestamp">1374590000</column><column name="files">java/org/apache/coyote/ajp/AjpNioProcessor.java
java/org/apache/coyote/http11/InternalNioOutputBuffer.java
java/org/apache/coyote/http11/upgrade/NioServletOutputStream.java
java/org/apache/tomcat/util/net/NioEndpoint.java</column><column name="result">3:java/org/apache/tomcat/util/net/NioEndpoint.java
47:java/org/apache/coyote/http11/InternalNioOutputBuffer.java
57:java/org/apache/coyote/ajp/AjpNioProcessor.java
109:java/org/apache/coyote/http11/upgrade/NioServletOutputStream.java</column></table><table name="tomcat"><column name="id">78</column><column name="bug_id">55291</column><column name="summary">Bug in WsServerContainer leading to NPE</column><column name="description">Created attachment 30612 Patch showing fix The registerAuthenticatedSession method appears to have a bug. It looks like it's trying to find Set&lt;WsSession&gt; or create it if it is null. But the null check is against the input argument (wsSession) not against set of WsSession's. See attached patch.</column><column name="report_time">2013-07-22 13:33:53</column><column name="report_timestamp">1374510000</column><column name="status">resolved fixed</column><column name="commit">ab6f21d</column><column name="commit_timestamp">1374500000</column><column name="files">java/org/apache/tomcat/websocket/server/WsServerContainer.java</column><column name="result">1:java/org/apache/tomcat/websocket/server/WsServerContainer.java</column></table><table name="tomcat"><column name="id">79</column><column name="bug_id">55262</column><column name="summary">Duplicate preludes and codas in same &lt;jsp-property-group&gt; are ignored</column><column name="description">If a &lt;jsp-property-group&gt; contains multiple &lt;include-prelude&gt; elements that happen to refer to the same file only one include is performed. The same applies to codas. This happens because WebXml stores these in a LinkedHashSet rather than a List. When multiple &lt;jsp-property-group&gt;s are combined, JspConfig uses a Vector and so preserves duplicates as required by the JSP spec. I have a test case demonstrating this but before committing a fix I would like confirmation that WebXml's behaviour is incorrect.</column><column name="report_time">2013-07-14 01:44:18</column><column name="report_timestamp">1373780000</column><column name="status">resolved fixed</column><column name="commit">85f611e</column><column name="commit_timestamp">1374350000</column><column name="files">java/org/apache/tomcat/util/descriptor/web/JspPropertyGroup.java
test/org/apache/jasper/compiler/TestCompiler.java
test/org/apache/jasper/servlet/TestJspCServletContext.java
test/org/apache/tomcat/util/descriptor/web/TestJspPropertyGroup.java</column><column name="result">2:java/org/apache/tomcat/util/descriptor/web/JspPropertyGroup.java
36:test/org/apache/jasper/compiler/TestCompiler.java
270:test/org/apache/jasper/servlet/TestJspCServletContext.java</column></table><table name="tomcat"><column name="id">80</column><column name="bug_id">55259</column><column name="summary">Unnecessary work in JspConfig</column><column name="description">JspProperty is the same for all url patterns in a group; the current code creates a new one each iteration</column><column name="report_time">2013-07-13 04:34:34</column><column name="report_timestamp">1373700000</column><column name="status">resolved fixed</column><column name="commit">c6a45a6</column><column name="commit_timestamp">1373750000</column><column name="files">java/org/apache/jasper/compiler/JspConfig.java</column><column name="result">1:java/org/apache/jasper/compiler/JspConfig.java</column></table><table name="tomcat"><column name="id">81</column><column name="bug_id">55245</column><column name="summary">Add test cases for JspC</column><column name="description">The test suite should include tests for the JspC Ant task</column><column name="report_time">2013-07-12 02:05:02</column><column name="report_timestamp">1373610000</column><column name="status">resolved fixed</column><column name="commit">c0c5017</column><column name="commit_timestamp">1373620000</column><column name="files">test/org/apache/jasper/TestJspC.java</column><column name="result" /></table><table name="tomcat"><column name="id">82</column><column name="bug_id">55250</column><column name="summary">JspC does not initialize tldLocationsCache resulting in NPE</column><column name="description">Change in how ServletContext was created missed initialization of tldLocationsCache</column><column name="report_time">2013-07-12 03:37:02</column><column name="report_timestamp">1373610000</column><column name="status">resolved fixed</column><column name="commit">186a782</column><column name="commit_timestamp">1373620000</column><column name="files">java/org/apache/jasper/JspC.java</column><column name="result">1:java/org/apache/jasper/JspC.java</column></table><table name="tomcat"><column name="id">83</column><column name="bug_id">55244</column><column name="summary">JspC throws ClassNotFoundException from Digester</column><column name="description">Created attachment 30583 log file from ant run When run from Ant, the &lt;jasper&gt; task ia unable to location descriptor classes used in an ObjectCreateRule. The Digester does not have a classloader configured and is configured to use the TCCL but that is Ant's classloader and not the task's.</column><column name="report_time">2013-07-12 02:01:45</column><column name="report_timestamp">1373610000</column><column name="status">resolved fixed</column><column name="commit">8d6537d</column><column name="commit_timestamp">1373620000</column><column name="files">java/org/apache/jasper/servlet/JspCServletContext.java
java/org/apache/tomcat/util/descriptor/web/WebXmlParser.java</column><column name="result">2:java/org/apache/jasper/servlet/JspCServletContext.java
104:java/org/apache/tomcat/util/descriptor/web/WebXmlParser.java</column></table><table name="tomcat"><column name="id">84</column><column name="bug_id">55240</column><column name="summary">[websocket] SOE in NioEndpoint</column><column name="description">Created attachment 30581 StackOverflowError websocket load test reveals StackOverflowError in NioEndpoint</column><column name="report_time">2013-07-11 11:54:55</column><column name="report_timestamp">1373560000</column><column name="status">resolved fixed</column><column name="commit">68f6f6f</column><column name="commit_timestamp">1373570000</column><column name="files">java/org/apache/coyote/http11/upgrade/AbstractProcessor.java
java/org/apache/coyote/http11/upgrade/AprProcessor.java
java/org/apache/coyote/http11/upgrade/BioProcessor.java
java/org/apache/coyote/http11/upgrade/NioProcessor.java
java/org/apache/tomcat/util/net/NioEndpoint.java</column><column name="result">1:java/org/apache/tomcat/util/net/NioEndpoint.java
76:java/org/apache/coyote/http11/upgrade/NioProcessor.java
147:java/org/apache/coyote/http11/upgrade/AprProcessor.java</column></table><table name="tomcat"><column name="id">85</column><column name="bug_id">55238</column><column name="summary">[websocket] NPE in clearHandler(WsRemoteEndpointImplServer.java:156)</column><column name="description" /><column name="report_time">2013-07-11 08:11:07</column><column name="report_timestamp">1373540000</column><column name="status">resolved fixed</column><column name="commit">4758796</column><column name="commit_timestamp">1373560000</column><column name="files">java/org/apache/tomcat/websocket/server/WsRemoteEndpointImplServer.java</column><column name="result">1:java/org/apache/tomcat/websocket/server/WsRemoteEndpointImplServer.java</column></table><table name="tomcat"><column name="id">86</column><column name="bug_id">55228</column><column name="summary">AbstractHttp11Processor overwrites Date header, even when set by application</column><column name="description">If the application sets the Date header, then it is most likely for caching purposes and Tomcat needs to return it as is. A consistent Date header is very important for proper Age/Max-Age calculations. http://www.w3.org/Protocols/HTTP/Issues/add-age.html</column><column name="report_time">2013-07-10 00:35:33</column><column name="report_timestamp">1373430000</column><column name="status">resolved fixed</column><column name="commit">95ee699</column><column name="commit_timestamp">1373560000</column><column name="files">java/org/apache/coyote/http11/AbstractHttp11Processor.java</column><column name="result">1:java/org/apache/coyote/http11/AbstractHttp11Processor.java</column></table><table name="tomcat"><column name="id">87</column><column name="bug_id">55207</column><column name="summary">In XML syntax, jsp:text does not error on sub-elements from other namespaces</column><column name="description">Created attachment 30557 patch to reject on any element inside &lt;jsp:text&gt; JspDocumentParser does check for sub-elements within a jsp:text element but only fails if they are from the jsp namespace</column><column name="report_time">2013-07-07 01:11:30</column><column name="report_timestamp">1373170000</column><column name="status">resolved fixed</column><column name="commit">6c54031</column><column name="commit_timestamp">1373480000</column><column name="files">java/org/apache/jasper/compiler/JspDocumentParser.java</column><column name="result">11:java/org/apache/jasper/compiler/JspDocumentParser.java</column></table><table name="tomcat"><column name="id">88</column><column name="bug_id">55231</column><column name="summary">NPE and incorrect version detection in JspC</column><column name="description">JspC's JspConfig now reads version and jsp-config information from the ServletContext. It uses getMajorVersion() which returns the maximum version supported by the container. It should use getEffectiveVersion() to use the version of the web application. ServletContext.getJspConfigDescriptor() can return null if there is no &lt;jsp-config&gt; in the web.xml. JspConfig does not allow for this and will throw a NPE e.g. if there is no web.xml in the application.</column><column name="report_time">2013-07-10 04:10:10</column><column name="report_timestamp">1373440000</column><column name="status">closed fixed</column><column name="commit">c8376e8</column><column name="commit_timestamp">1373460000</column><column name="files">java/org/apache/jasper/compiler/JspConfig.java</column><column name="result">3:java/org/apache/jasper/compiler/JspConfig.java</column></table><table name="tomcat"><column name="id">89</column><column name="bug_id">55218</column><column name="summary">Upgrade Digester to be based on DefaultHandler2 and use LexicalHandler to detect publicId</column><column name="description">Digester uses SAX2 features but is still based the SAX1 DefaultHandler. By upgrading to DefaultHandler2 it would be able to handle baseURIs when resolving entities and would have a default implementation of a LexicalHandler. Using LexicalHandler would allow it to respond directly to the startDTD event that reports the DOCTYPE (if present) so that it would not need to infer that from the first attempt to resolve an entity.</column><column name="report_time">2013-07-09 07:27:23</column><column name="report_timestamp">1373370000</column><column name="status">closed fixed</column><column name="commit">aa7896b</column><column name="commit_timestamp">1373360000</column><column name="files">java/org/apache/catalina/core/StandardContext.java
java/org/apache/tomcat/util/descriptor/web/WebXml.java
java/org/apache/tomcat/util/digester/Digester.java
test/javax/servlet/resources/TestSchemaValidation.java
test/org/apache/tomcat/util/descriptor/web/TestWebXml.java</column><column name="result">3:java/org/apache/tomcat/util/digester/Digester.java
4:java/org/apache/catalina/core/StandardContext.java
76:java/org/apache/tomcat/util/descriptor/web/WebXml.java
984:test/org/apache/tomcat/util/descriptor/web/TestWebXml.java</column></table><table name="tomcat"><column name="id">90</column><column name="bug_id">55217</column><column name="summary">Common EntityResolver that can be used by Catalina and Jasper</column><column name="description">Duplicate functionality exists in both SchemaResolver and ParserUtils.MyEntityResolver. There's also a basic version in Digester.</column><column name="report_time">2013-07-09 07:09:00</column><column name="report_timestamp">1373370000</column><column name="status">closed fixed</column><column name="commit">5344de0</column><column name="commit_timestamp">1373360000</column><column name="files">java/org/apache/tomcat/util/descriptor/LocalResolver.java
java/org/apache/tomcat/util/descriptor/XmlIdentifiers.java
test/org/apache/tomcat/util/descriptor/TestLocalResolver.java</column><column name="result" /></table><table name="tomcat"><column name="id">91</column><column name="bug_id">55166</column><column name="summary">schemaLocation references between servlet and jsp XSDs are invalid</column><column name="description">The javax/servlet/resources package does not contain the JSP specification XSDs. These are referenced from the web-app or web-common xsds and define elements like &lt;jsp-config&gt;.</column><column name="report_time">2013-06-30 20:03:24</column><column name="report_timestamp">1372640000</column><column name="status">resolved fixed</column><column name="commit">f554475</column><column name="commit_timestamp">1373280000</column><column name="files">java/org/apache/catalina/startup/Constants.java</column><column name="result">5:java/org/apache/catalina/startup/Constants.java</column></table><table name="tomcat"><column name="id">92</column><column name="bug_id">55210</column><column name="summary">SEVERE: The ServletContentInitializer [# Licensed to the Apache Software Foundation (ASF) under one or more] could not be created</column><column name="description">According to the Javadoc for java.util.ServiceLoader (http://docs.oracle.com/javase/6/docs/api/java/util/ServiceLoader.html): [quote]A service provider is identified by placing a provider-configuration file in the resource directory META-INF/services. The file's name is the fully-qualified binary name of the service's type. The file contains a list of fully-qualified binary names of concrete provider classes, one per line. Space and tab characters surrounding each name, as well as blank lines, are ignored. The comment character is '#' ('\u0023', NUMBER SIGN); on each line all characters following the first comment character are ignored. The file must be encoded in UTF-8.[/quote] However, based on the error below it appears that Tomcat does not abide by this requirement. The Log4j Core JAR for 2.0-beta8 will have a ServletContainerInitializer in it, and the provider-configuration file for this SCI contains a copyright statement. Tomcat barfs and fails to deploy the application due to this copyright statement. This problem exists in both Tomcat 7 and Tomcat 8. SEVERE: The ServletContentInitializer [# Licensed to the Apache Software Foundation (ASF) under one or more] could not be created java.lang.ClassNotFoundException: # Licensed to the Apache Software Foundation (ASF) under one or more 	at org.apache.catalina.loader.WebappClassLoader.loadClass(WebappClassLoader.java:1465) 	at org.apache.catalina.loader.WebappClassLoader.loadClass(WebappClassLoader.java:1310) 	at java.lang.Class.forName0(Native Method) 	at java.lang.Class.forName(Class.java:339) 	at org.apache.catalina.startup.ContextConfig.getServletContainerInitializer(ContextConfig.java:1526) 	at org.apache.catalina.startup.ContextConfig.processServletContainerInitializers(ContextConfig.java:1436) 	at org.apache.catalina.startup.ContextConfig.webConfig(ContextConfig.java:1174) 	at org.apache.catalina.startup.ContextConfig.configureStart(ContextConfig.java:814) 	at org.apache.catalina.startup.ContextConfig.lifecycleEvent(ContextConfig.java:321) 	at org.apache.catalina.util.LifecycleSupport.fireLifecycleEvent(LifecycleSupport.java:119) 	at org.apache.catalina.util.LifecycleBase.fireLifecycleEvent(LifecycleBase.java:90) 	at org.apache.catalina.core.StandardContext.startInternal(StandardContext.java:5100) 	at org.apache.catalina.util.LifecycleBase.start(LifecycleBase.java:150) 	at org.apache.catalina.core.ContainerBase.addChildInternal(ContainerBase.java:726) 	at org.apache.catalina.core.ContainerBase.addChild(ContainerBase.java:702) 	at org.apache.catalina.core.StandardHost.addChild(StandardHost.java:698) 	at org.apache.catalina.startup.HostConfig.manageApp(HostConfig.java:1491) 	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) 	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57) 	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) 	at java.lang.reflect.Method.invoke(Method.java:491) 	at org.apache.tomcat.util.modeler.BaseModelMBean.invoke(BaseModelMBean.java:300) 	at com.sun.jmx.interceptor.DefaultMBeanServerInterceptor.invoke(DefaultMBeanServerInterceptor.java:819) 	at com.sun.jmx.mbeanserver.JmxMBeanServer.invoke(JmxMBeanServer.java:792) 	at org.apache.catalina.mbeans.MBeanFactory.createStandardContext(MBeanFactory.java:468) 	at org.apache.catalina.mbeans.MBeanFactory.createStandardContext(MBeanFactory.java:415) 	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) 	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57) 	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) 	at java.lang.reflect.Method.invoke(Method.java:491) 	at org.apache.tomcat.util.modeler.BaseModelMBean.invoke(BaseModelMBean.java:300) 	at com.sun.jmx.interceptor.DefaultMBeanServerInterceptor.invoke(DefaultMBeanServerInterceptor.java:819) 	at com.sun.jmx.mbeanserver.JmxMBeanServer.invoke(JmxMBeanServer.java:792) 	at javax.management.remote.rmi.RMIConnectionImpl.doOperation(RMIConnectionImpl.java:1465) 	at javax.management.remote.rmi.RMIConnectionImpl.access$300(RMIConnectionImpl.java:75) 	at javax.management.remote.rmi.RMIConnectionImpl$PrivilegedOperation.run(RMIConnectionImpl.java:1306) 	at javax.management.remote.rmi.RMIConnectionImpl.doPrivilegedOperation(RMIConnectionImpl.java:1398) 	at javax.management.remote.rmi.RMIConnectionImpl.invoke(RMIConnectionImpl.java:827) 	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) 	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57) 	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) 	at java.lang.reflect.Method.invoke(Method.java:491) 	at sun.rmi.server.UnicastServerRef.dispatch(UnicastServerRef.java:322) 	at sun.rmi.transport.Transport$1.run(Transport.java:177) 	at sun.rmi.transport.Transport$1.run(Transport.java:174) 	at java.security.AccessController.doPrivileged(Native Method) 	at sun.rmi.transport.Transport.serviceCall(Transport.java:173) 	at sun.rmi.transport.tcp.TCPTransport.handleMessages(TCPTransport.java:556) 	at sun.rmi.transport.tcp.TCPTransport$ConnectionHandler.run0(TCPTransport.java:811) 	at sun.rmi.transport.tcp.TCPTransport$ConnectionHandler.run(TCPTransport.java:670) 	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1145) 	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:615) 	at java.lang.Thread.run(Thread.java:724)</column><column name="report_time">2013-07-07 21:44:14</column><column name="report_timestamp">1373250000</column><column name="status">resolved fixed</column><column name="commit">b932ace</column><column name="commit_timestamp">1373270000</column><column name="files">java/org/apache/catalina/startup/ContextConfig.java</column><column name="result">71:java/org/apache/catalina/startup/ContextConfig.java</column></table><table name="tomcat"><column name="id">93</column><column name="bug_id">55200</column><column name="summary">[websocket] Problem writing many subsequent binary messages</column><column name="description">I see sometimes failing connections due to IOException (see below). This happens when trying to send thousands of binary messages (1024 bytes each) without any delay between the subsequent messages. Having look at the code in AsyncChannelWrapperSecure$WriteTask.run(219), I think it is not correct to assume that if not all of the bytes in the buffer are written, this shall produce IOException. I think in this case, there shall be an attempt to write the rest of the bytes in a cycle. Here one exception I got during the test: Exception is :java.io.IOException: java.util.concurrent.ExecutionException: java.io.IOException: Only wrote [460] of [1,098] bytes 	at org.apache.tomcat.websocket.WsRemoteEndpointImplBase.startMessageBlock(WsRemoteEndpointImplBase.java:204) 	at org.apache.tomcat.websocket.WsRemoteEndpointImplBase.sendBytes(WsRemoteEndpointImplBase.java:113) 	at org.apache.tomcat.websocket.WsRemoteEndpointBasic.sendBinary(WsRemoteEndpointBasic.java:43) 	at WebsocketsTestManager$TestThread.run(WebsocketsTestManager.java:271) Caused by: java.util.concurrent.ExecutionException: java.io.IOException: Only wrote [460] of [1,098] bytes 	at org.apache.tomcat.websocket.WsRemoteEndpointImplBase$FutureToSendHandler.get(WsRemoteEndpointImplBase.java:729) 	at org.apache.tomcat.websocket.WsRemoteEndpointImplBase.startMessageBlock(WsRemoteEndpointImplBase.java:202) 	... 3 more Caused by: java.io.IOException: Only wrote [460] of [1,098] bytes 	at org.apache.tomcat.websocket.AsyncChannelWrapperSecure$WriteTask.run(AsyncChannelWrapperSecure.java:220) 	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1145) 	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:615) 	at java.lang.Thread.run(Thread.java:789)</column><column name="report_time">2013-07-05 14:27:48</column><column name="report_timestamp">1373050000</column><column name="status">resolved fixed</column><column name="commit">00e4f3f</column><column name="commit_timestamp">1373040000</column><column name="files">java/org/apache/tomcat/websocket/AsyncChannelWrapperSecure.java</column><column name="result">4:java/org/apache/tomcat/websocket/AsyncChannelWrapperSecure.java</column></table><table name="tomcat"><column name="id">94</column><column name="bug_id">55186</column><column name="summary">useIPVHosts=true , incorrect to get Request.localName</column><column name="description">I configured useIPVHosts=true. &amp;set up two hosts : &lt;Host name="localhost" appBase="webapps" /&gt; &lt;Host name="www.jm.com" appBase="webapps2" /&gt; &amp;my pc has two ip: 10.10.4.48 and 192.168.56.1 &amp;HOSTS file is: ~~~~~~~~~~~~~~~~~~ 127.0.0.1 localhost 192.168.56.1 www.jm.com ~~~~~~~~~~~~~~~~~~ &amp; the Host localhost has a app named examples. the other Host www.jm.com has a app named examples2. start Tomcat, visit http://www.jm.com:8080/examples2/test/ is ok. but i changed to visit http://localhost:8080/examples/test without restart tc, it didn't work. then i traced the codes,i found that : ~~~~~~~~~~~~~~~~~~~~~~~ if (connector.getUseIPVHosts()) { serverName = req.localName(); //line 624 if (serverName.isNull()) { // well, they did ask for it res.action(ActionCode.REQ_LOCAL_NAME_ATTRIBUTE, null); } } else { serverName = req.serverName(); } ~~~~~~~~~~~~~~~~~~~~~~~ at line 624 the value of serverName is still "www.jm.com" . it will still find the Host www.jm.com to handle with the request.but this host doesn't have the examples app, so it can't make it. if i annotate the "if condition" , it works. ~~~~~~~~~~~~~~~~~~~~~ if (connector.getUseIPVHosts()) { serverName = req.localName(); //line 624 //if (serverName.isNull()) { //annotate if , execute action every time. // well, they did ask for it res.action(ActionCode.REQ_LOCAL_NAME_ATTRIBUTE, null); //} } else { serverName = req.serverName(); } ~~~~~~~~~~~~~~~~~~~~</column><column name="report_time">2013-07-03 00:54:24</column><column name="report_timestamp">1372830000</column><column name="status">resolved fixed</column><column name="commit">2eb065f</column><column name="commit_timestamp">1373030000</column><column name="files">java/org/apache/coyote/Request.java</column><column name="result">5:java/org/apache/coyote/Request.java</column></table><table name="tomcat"><column name="id">95</column><column name="bug_id">55184</column><column name="summary">NPE in PojoMethodMapping getMessageHandler</column><column name="description">Created attachment 30525 PojoMethodMapping.patch A check for null value is missed. Here is the patch</column><column name="report_time">2013-07-02 13:14:35</column><column name="report_timestamp">1372790000</column><column name="status">resolved fixed</column><column name="commit">a267dbf</column><column name="commit_timestamp">1372780000</column><column name="files">java/org/apache/tomcat/websocket/pojo/PojoMethodMapping.java</column><column name="result">1:java/org/apache/tomcat/websocket/pojo/PojoMethodMapping.java</column></table><table name="tomcat"><column name="id">96</column><column name="bug_id">55183</column><column name="summary">Missing WS Protocol Header in session negotiatedHeaders</column><column name="description">Created attachment 30524 patch in WsWebSocketContainer There is case sensitive check for ws protocol header name in WsWebSocketContainer Here is a fix and a test case checking subprotocol negotiation</column><column name="report_time">2013-07-02 12:04:47</column><column name="report_timestamp">1372780000</column><column name="status">resolved fixed</column><column name="commit">a634d85</column><column name="commit_timestamp">1372780000</column><column name="files">java/org/apache/tomcat/websocket/Constants.java
java/org/apache/tomcat/websocket/WsWebSocketContainer.java
test/org/apache/tomcat/websocket/TestWsSubprotocols.java</column><column name="result">2:java/org/apache/tomcat/websocket/WsWebSocketContainer.java
27:java/org/apache/tomcat/websocket/Constants.java</column></table><table name="tomcat"><column name="id">97</column><column name="bug_id">55165</column><column name="summary">subprotocols not available with  annotated serverendpoint</column><column name="description">Created attachment 30507 adds subprotocols in serverendpoint initialization During initialization of annotated serverendpoint the subprotocols configurations is not handled. Here is the patch.</column><column name="report_time">2013-06-30 19:49:03</column><column name="report_timestamp">1372640000</column><column name="status">resolved fixed</column><column name="commit">b069c78</column><column name="commit_timestamp">1372760000</column><column name="files">java/org/apache/tomcat/websocket/server/WsServerContainer.java</column><column name="result">4:java/org/apache/tomcat/websocket/server/WsServerContainer.java</column></table><table name="tomcat"><column name="id">98</column><column name="bug_id">55181</column><column name="summary">Ping and Pong messages should have identical application data</column><column name="description">Created attachment 30520 PingPongMessages.patch As described in RFC 6455 Ping and Pong should have identical application data. http://tools.ietf.org/html/rfc6455#section-5.5.3 Current implementation can return application data ByteBuffer with extra bytes hence have different length from "ping" message which means that those are not identical. Here is a patch + test case cheers niki</column><column name="report_time">2013-07-02 08:01:55</column><column name="report_timestamp">1372770000</column><column name="status">resolved fixed</column><column name="commit">19c0bd3</column><column name="commit_timestamp">1372750000</column><column name="files">java/org/apache/tomcat/websocket/WsPongMessage.java
test/org/apache/tomcat/websocket/TestWsPingPongMessages.java</column><column name="result">8:java/org/apache/tomcat/websocket/WsPongMessage.java</column></table><table name="tomcat"><column name="id">99</column><column name="bug_id">55180</column><column name="summary">connectionTimeout="-1" causes timeout can't be negative</column><column name="description">I configured server.xml like this: connectionTimeout="-1" disableUploadTimeout="false" connectionUploadTimeout="200" (maybe it is stupid to configure like this,if connectionTimeout=-1,can i make disableUploadTimeout=false?). It will cause : java.lang.IllegalArgumentException: timeout can't be negative 	at sun.nio.ch.SocketAdaptor.setSoTimeout(SocketAdaptor.java:361) 	at org.apache.coyote.http11.Http11NioProcessor.setSocketTimeout(Http11NioProcessor.java:251) ...... because of : if (!disableUploadTimeout) { //endpoint.getSoTimeout()=-1. setSocketTimeout(endpoint.getSoTimeout()); } ~~~~~~~~~~~~~~~~~~~~~~~~~ another thing: if i configure connectionTimeout="0". in NioBlockingSelector.read(ByteBuffer buf, NioChannel socket, long readTimeout),readTimeout = 0, in case socket.read(buf) == 0, it make timeout=true. if (readTimeout &gt;= 0 &amp;&amp; (keycount == 0)) timedout = (System.currentTimeMillis() - time) &gt;= readTimeout; then throw the SocketTimeoutException(). thank you.</column><column name="report_time">2013-07-02 00:01:40</column><column name="report_timestamp">1372740000</column><column name="status">resolved fixed</column><column name="commit">4da2de0</column><column name="commit_timestamp">1372750000</column><column name="files">java/org/apache/coyote/http11/AbstractHttp11Processor.java</column><column name="result">4:java/org/apache/coyote/http11/AbstractHttp11Processor.java</column></table><table name="tomcat"><column name="id">100</column><column name="bug_id">55174</column><column name="summary">[jsr 356][websocket] MessageHandler never gets notified again after it throws exception</column><column name="description">I have a test which adds a MessageHandler which gets notified on text messages. If its implementation method onMessage(String text) throws some exception (e.g. runtime exception), this MessageHandler will never ever be notified again for any new text messages received by the session. I suppose this happens because the exception actually kills the underlying thread in which the notification has happened. I think the client side implementation shall be more robust and expect and be prepared for exceptions coming from calls to user code.</column><column name="report_time">2013-07-01 12:14:30</column><column name="report_timestamp">1372700000</column><column name="status">resolved fixed</column><column name="commit">ddd73d0</column><column name="commit_timestamp">1372720000</column><column name="files">java/org/apache/tomcat/websocket/WsFrameBase.java</column><column name="result">9:java/org/apache/tomcat/websocket/WsFrameBase.java</column></table><table name="tomcat"><column name="id">101</column><column name="bug_id">55179</column><column name="summary">Incorrect Parameter Name in RemoteIpValve Examples</column><column name="description">The RemoteIpValve sample configurations incorrectly refer to a "remoteIpProxiesHeader" property, rather than the "proxiesHeader" property. http://tomcat.apache.org/tomcat-7.0-doc/api/org/apache/catalina/valves/RemoteIpValve.html</column><column name="report_time">2013-07-01 20:54:45</column><column name="report_timestamp">1372730000</column><column name="status">resolved fixed</column><column name="commit">21f0a5c</column><column name="commit_timestamp">1372710000</column><column name="files">java/org/apache/catalina/valves/RemoteIpValve.java</column><column name="result">1:java/org/apache/catalina/valves/RemoteIpValve.java</column></table><table name="tomcat"><column name="id">102</column><column name="bug_id">55177</column><column name="summary">connectionTimeout=-1 causes high CPU</column><column name="description">Created attachment 30514 fix Setting connectionTimeout to -1 in server.xml causes each request to have high CPU java full version "1.6.0_51-b11-457" Example: &lt;Connector port="8080" protocol="HTTP/1.1" connectionTimeout="-1" redirectPort="8443" /&gt; Everywhere I looked there seemed to be a if statement looking to see if it was below zero except in Http11Processor class. Attached is patch file. Which has resolved the issue on my server.</column><column name="report_time">2013-07-01 19:49:21</column><column name="report_timestamp">1372720000</column><column name="status">resolved fixed</column><column name="commit">df6cee7</column><column name="commit_timestamp">1372710000</column><column name="files">java/org/apache/coyote/http11/Http11Processor.java</column><column name="result">78:java/org/apache/coyote/http11/Http11Processor.java</column></table><table name="tomcat"><column name="id">103</column><column name="bug_id">53777</column><column name="summary">Ability to bundle JAAS Configuration in Webappp</column><column name="description">I would like to let JAASRealm to load JAAS Configuration from a .properties file bundled in a web application (either in WEB-INF/classes or in any JAR on the classpath of the context) Actually (7.0.29) JAASRealm creates a LoginContext using the 2-args constructor loginContext = new LoginContext(appName, callbackHandler); I propose to add a new configuration parameter on JAASRealm to let it load a javax.security.auth.login.Configuration from the ContextClassLoader this new Configuration has to be passed to the 4-args constructor loginContext = new LoginContext(appName, subject, callbackHandler, configuration); http://docs.oracle.com/javase/6/docs/api/javax/security/auth/login/LoginContext.html#LoginContext%28java.lang.String,%20javax.security.auth.Subject,%20javax.security.auth.callback.CallbackHandler,%20javax.security.auth.login.Configuration%29</column><column name="report_time">2012-08-24 13:50:52</column><column name="report_timestamp">1345830000</column><column name="status">resolved fixed</column><column name="commit">6871d4c</column><column name="commit_timestamp">1372690000</column><column name="files">java/org/apache/catalina/realm/JAASRealm.java</column><column name="result">2:java/org/apache/catalina/realm/JAASRealm.java</column></table><table name="tomcat"><column name="id">104</column><column name="bug_id">55160</column><column name="summary">NIO connectionUploadTimeout can't work</column><column name="description">when i configure disableUploadTimeout="false" and connectionTimeout="20000" ,connectionUploadTimeout="30000" . I found the connectionUploadTimeout doesn't work, because the code in internalNioInputBuffer.readSocket(): ~~~~~~~~~~~~~~~~~~~~~~~~~~~~ try { NioEndpoint.KeyAttachment att = (NioEndpoint.KeyAttachment)socket.getAttachment(false); if ( att == null ) throw new IOException("Key must be cancelled."); nRead = pool.read(socket.getBufHandler().getReadBuffer(),socket,selector,att.getTimeout()); } catch ( EOFException eof ) { nRead = -1; } finally { if ( selector != null ) pool.put(selector); } ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ att.getTimeout() is the connectionTimeout ,not the connectionUploadTimeout. so , in NioBlockingSelector.read(), the readTimeout is connectionTimeout</column><column name="report_time">2013-06-29 21:35:09</column><column name="report_timestamp">1372560000</column><column name="status">resolved fixed</column><column name="commit">9a01f2d</column><column name="commit_timestamp">1372690000</column><column name="files">java/org/apache/coyote/http11/InternalNioInputBuffer.java</column><column name="result">1:java/org/apache/coyote/http11/InternalNioInputBuffer.java</column></table><table name="tomcat"><column name="id">105</column><column name="bug_id">55158</column><column name="summary">Wasted work in AttributeNamesEnumerator constructor</column><column name="description">Created attachment 30498 patch The problem appears in version 7.0.41 and in revision 1497999. I attached a two-line patch that fixes it. In the "AttributeNamesEnumerator" constructor, the loop over "specials" keeps overriding "last" with "i". Therefore, only the last written value is visible out of the loop and all the other writes and iterations are not necessary. The patch iterates from the end of "specials" and breaks the first time when "last" is set.</column><column name="report_time">2013-06-29 18:55:30</column><column name="report_timestamp">1372550000</column><column name="status">resolved fixed</column><column name="commit">ca956bd</column><column name="commit_timestamp">1372680000</column><column name="files">java/org/apache/catalina/core/ApplicationHttpRequest.java</column><column name="result">1:java/org/apache/catalina/core/ApplicationHttpRequest.java</column></table><table name="tomcat"><column name="id">106</column><column name="bug_id">55159</column><column name="summary">Wasted work in ErrorReportValve.getPartialServletStackTrace</column><column name="description">Created attachment 30499 patch The problem appears in version 7.0.41 and in revision 1497999. I attached a two-line patch (patch.diff) that fixes it. In method "ErrorReportValve.getPartialServletStackTrace", the loop over "elements" keeps overriding "pos" with "i". Therefore, only the last written value is visible out of the loop and all the other writes and iterations are not necessary. The patch iterates from the end of "elements" and breaks the first time when "pos" is set. The above fix (in patch.diff) is certainly correct (it's easy to see through code inspection), but I think we can have an even shorter patch (one line, in patchShort.diff): just break as soon as "pos" is set, without reversion the loop order. patchShort.diff is correct only if there can be only one "elements[i]" with class name "org.apache.catalina.core.ApplicationFilterChain" and method name "internalDoFilter" or if it doesn't matter which such "elements[i]" is detected (the last, like in the original code, or the first, like in patchShort.diff).</column><column name="report_time">2013-06-29 19:12:03</column><column name="report_timestamp">1372550000</column><column name="status">resolved fixed</column><column name="commit">b7cad6b</column><column name="commit_timestamp">1372680000</column><column name="files">java/org/apache/catalina/valves/ErrorReportValve.java</column><column name="result">1:java/org/apache/catalina/valves/ErrorReportValve.java</column></table><table name="tomcat"><column name="id">107</column><column name="bug_id">55017</column><column name="summary">Ability to configure RMI bind address</column><column name="description">Created attachment 30319 Patch to provider bind rmi bind address setup ability There is a patch which adds rmiBindAddress property to JmxRemoteLifecycleListener, which allows to bind RMI server to specific interface instead of 0.0.0.0. It may useful for binding RMI to localhost and avoiding firewall configuration (and then monitoring through SSH tunnel). Unfortunatly using of rmiBindAddress incompatible with rmiSSL, but i think it's not an issue because of rarely intersecting use cases.</column><column name="report_time">2013-05-24 14:50:10</column><column name="report_timestamp">1369420000</column><column name="status">resolved fixed</column><column name="commit">45f59bb</column><column name="commit_timestamp">1372670000</column><column name="files">java/org/apache/catalina/mbeans/JmxRemoteLifecycleListener.java</column><column name="result">1:java/org/apache/catalina/mbeans/JmxRemoteLifecycleListener.java</column></table><table name="tomcat"><column name="id">108</column><column name="bug_id">55151</column><column name="summary">Fix in MsgByte encoder and decoder TestEncodingDecoding websocket test</column><column name="description">Created attachment 30492 TestEncodingDecoding.patch The bytebuffer needs to be flipped during encoding and position doesn't need to be changed during decoding (it was already changed during willDecode call)</column><column name="report_time">2013-06-27 18:00:57</column><column name="report_timestamp">1372370000</column><column name="status">resolved fixed</column><column name="commit">d71136a</column><column name="commit_timestamp">1372360000</column><column name="files">test/org/apache/tomcat/websocket/pojo/TestEncodingDecoding.java</column><column name="result">1:test/org/apache/tomcat/websocket/pojo/TestEncodingDecoding.java</column></table><table name="tomcat"><column name="id">109</column><column name="bug_id">55102</column><column name="summary">Add ability to report time taken to prepare response</column><column name="description">Created attachment 30438 Patch against trunk@r1493385 to record and output time to commit Tomcat's AccessLogValve is able to report the time taken to send an entire request using %D. This is the total processing time and may be affected by network conditions. It is sometimes useful to be able to record the time taken by the server to prepare the response and send the first content to the client. Attached is a patch that records the time the response is committed and then allows that to be reported in the access log using a '%F' pattern (which is the same as used by the mod-log-firstbyte module for HTTPD).</column><column name="report_time">2013-06-15 17:09:47</column><column name="report_timestamp">1371330000</column><column name="status">closed fixed</column><column name="commit">7aea9cb</column><column name="commit_timestamp">1372020000</column><column name="files">java/org/apache/catalina/valves/AccessLogValve.java
java/org/apache/coyote/Response.java</column><column name="result">142:java/org/apache/catalina/valves/AccessLogValve.java
157:java/org/apache/coyote/Response.java</column></table><table name="tomcat"><column name="id">110</column><column name="bug_id">55125</column><column name="summary">Tomcat does not shut down if LifecycleListener throws an exception</column><column name="description">Created attachment 30467 Logs I needed to shut down Tomcat if an application fails to start. I was advised that a LifecycleListener could shut down Tomcat by throwing an IllegalStateException from its lifecycleEvent method. However, this produces severe errors in the logs, but Tomcat does not shut down. I saw this behaviour on Tomcat 7.0.41 and 7.0.40 using the test web application from here: https://github.com/cloudfoundry/java-test-applications and v1.0.0 of the listener from here: https://github.com/cloudfoundry/java-buildpack-support (v1.1.0 of the listener was re-coded to halt the JVM). I attach catalina.out. Mark Thomas suggested I raise this bug, so he believes that Tomcat should shut down.</column><column name="report_time">2013-06-21 11:23:54</column><column name="report_timestamp">1371830000</column><column name="status">resolved fixed</column><column name="commit">3a36a8f</column><column name="commit_timestamp">1372020000</column><column name="files">java/org/apache/catalina/core/StandardService.java
java/org/apache/catalina/startup/Catalina.java</column><column name="result">43:java/org/apache/catalina/startup/Catalina.java
110:java/org/apache/catalina/core/StandardService.java</column></table><table name="tomcat"><column name="id">111</column><column name="bug_id">55127</column><column name="summary">Encoders init and destroy methods are never called</column><column name="description">Created attachment 30470 encoders lifecycle patch Non of the lifecycle methods (init and destroy) related to the encoders are get called. Here is a patch with extended test case (TestEncodingDecoding). The provides the implementation. (It is a proposal impl.) I think we need CLOSING state checked in WsSession as the decoders destroy are called during that phase and current implementation of checkState() method does not consider this state. Mark, this time I used the checkstyle.xml found in res folder and hope that at least the sources are in proper shape from syntax point of view. cheers</column><column name="report_time">2013-06-22 06:04:48</column><column name="report_timestamp">1371900000</column><column name="status">resolved fixed</column><column name="commit">93bcdde</column><column name="commit_timestamp">1371910000</column><column name="files">java/org/apache/tomcat/websocket/WsRemoteEndpointImplBase.java
java/org/apache/tomcat/websocket/WsRemoteEndpointImplClient.java
java/org/apache/tomcat/websocket/WsSession.java
java/org/apache/tomcat/websocket/WsWebSocketContainer.java
java/org/apache/tomcat/websocket/server/WsHttpUpgradeHandler.java
java/org/apache/tomcat/websocket/server/WsRemoteEndpointImplServer.java
test/org/apache/tomcat/websocket/pojo/TestEncodingDecoding.java</column><column name="result">111:java/org/apache/tomcat/websocket/WsRemoteEndpointImplBase.java
143:java/org/apache/tomcat/websocket/server/WsHttpUpgradeHandler.java
211:java/org/apache/tomcat/websocket/WsSession.java
216:test/org/apache/tomcat/websocket/pojo/TestEncodingDecoding.java
259:java/org/apache/tomcat/websocket/WsWebSocketContainer.java
914:java/org/apache/tomcat/websocket/server/WsRemoteEndpointImplServer.java
1249:java/org/apache/tomcat/websocket/WsRemoteEndpointImplClient.java</column></table><table name="tomcat"><column name="id">112</column><column name="bug_id">55126</column><column name="summary">IAE is thrown during deployment of ServerEndPoint having multiple text decoders</column><column name="description">Created attachment 30468 Patch in PojoMethodMapping MessageMethod PojoMethodMappin.MessageMethod can throw IAE when there are multiple text decoders. The looping through the text decoders should be breaked. Here I attach the patch.</column><column name="report_time">2013-06-21 13:16:22</column><column name="report_timestamp">1371840000</column><column name="status">resolved fixed</column><column name="commit">366ddff</column><column name="commit_timestamp">1371850000</column><column name="files">java/org/apache/tomcat/websocket/pojo/PojoMethodMapping.java</column><column name="result">39:java/org/apache/tomcat/websocket/pojo/PojoMethodMapping.java</column></table><table name="tomcat"><column name="id">113</column><column name="bug_id">55101</column><column name="summary">BasicAuthenticator parser and associated unit tests</column><column name="description">Created attachment 30435 new inner class to parse credentials Now that tomcat uses a single Base64 decoder, I returned to the issues discussed in https://issues.apache.org/bugzilla/show_bug.cgi?id=54729. Mark's change to the primitive Basic parser in svn commit: r1459289 was my starting point, but I wanted to write a comprehensive set of unit tests that examined all the relevant edge cases under the new Base64 decoder. I felt the most sympathetic approach would be to mirror the way DigestAuthenticator uses an inner class which encapsulates the parsing logic and provides trivial accessor methods for the authentication tokens. A suitable signature for the inner class would allow me to instantiate and test it exhaustively without having to haul up a tomcat instance for each test case. I accept the previous advice that the best framework for testing authentication is by running tomcat and examining the output to the client, but this overhead is not necessary in every single edge case. As I developed the code, I quickly realised there would be no benefit in splitting the parser code (as DigestAuthenticator does), where some of it would have been moved to a new HttpParser.parseAuthorizationDigest method. The logic for parsing a Basic header seemed to be more clear when it was performed entirely by the new inner class. In particular, following Konstantin's comments, it would be unecessarily complex and slow to convert the ByteChunk to a StringReader for the required simple parsing process, and then returning the tokens as a HashMap. Having decided there was no point in slavishly following the parseAuthorizationDigest model, I have closed bz54729. At this stage, I only made two small changes to TestNonLoginAndBasicAuthenticator. Some of the tests will eventually be removed as redundant, but there is no harm keeping them initially to demonstrate backward compatibility. Two of the test cases in this suite now "fail" because they anticipate rejection from the old parser, while the new parser is more tolerant - exactly as described in the existing TODOs (which are now removed). My new test suite org.apache.catalina.authenticator.TestBasicAuthParser has three checkstyle errors that I am not sure how to resolve. I followed the "normal" junit style to have static imports for my two hamcrest assertions, but they are flagged with errors, e.g. "Using a static member import should be avoided - org.hamcrest.MatcherAssert.assertThat". Now that hamcrest core is no longer shipped within junit, do we need another checkstle rule? I hope you find these changes acceptable.</column><column name="report_time">2013-06-15 15:01:40</column><column name="report_timestamp">1371320000</column><column name="status">resolved fixed</column><column name="commit">c4a50f5</column><column name="commit_timestamp">1371760000</column><column name="files">java/org/apache/catalina/authenticator/BasicAuthenticator.java
test/org/apache/catalina/authenticator/TestBasicAuthParser.java
test/org/apache/catalina/authenticator/TestNonLoginAndBasicAuthenticator.java</column><column name="result">1:java/org/apache/catalina/authenticator/BasicAuthenticator.java
2:test/org/apache/catalina/authenticator/TestNonLoginAndBasicAuthenticator.java</column></table><table name="tomcat"><column name="id">114</column><column name="bug_id">54745</column><column name="summary">Tomcat JarScanning does not work when Tomcat started with Java Web Start</column><column name="description">Created attachment 30097 Patch to resolve issue As long as you correctly structure your JARs and call setParentClassLoader() with the current thread class loader on the Engine, Host, Server and Service, you can run Embedded Tomcat using Java Web Start. It's actually pretty neat. The only problem is that JarScanning doesn't work. In Java Web Start, all JAR URLs obtained from the class loader are the full http(s) URLs from where they were downloaded. Java has them cached locally, so accessing them is just as efficient because they're really coming from the local file system. However, the StandardJarScanner ignores JAR URLs that don't start with "file:" or "jndi:". This was an easy patch and everything else appears to still work normally. I propose that the patch be applied to trunk AND 7.0.</column><column name="report_time">2013-03-22 23:07:06</column><column name="report_timestamp">1364010000</column><column name="status">resolved fixed</column><column name="commit">c7c30b6</column><column name="commit_timestamp">1371740000</column><column name="files">java/org/apache/tomcat/util/scan/StandardJarScanner.java</column><column name="result">1:java/org/apache/tomcat/util/scan/StandardJarScanner.java</column></table><table name="tomcat"><column name="id">115</column><column name="bug_id">53987</column><column name="summary">Log uncovered HTTP methods in combined security constraints</column><column name="description">It is usually an error (and a security hole) if security constraints are defined for some but not all HTTP methods for a given URL. If such a situation is detected on web application start, log it.</column><column name="report_time">2012-10-09 19:02:28</column><column name="report_timestamp">1349820000</column><column name="status">resolved fixed</column><column name="commit">f78c1a4</column><column name="commit_timestamp">1371680000</column><column name="files">java/org/apache/catalina/core/StandardContext.java</column><column name="result">1:java/org/apache/catalina/core/StandardContext.java</column></table><table name="tomcat"><column name="id">116</column><column name="bug_id">55073</column><column name="summary">wasted work in ValidateVisitor.isExpression()</column><column name="description">Created attachment 30404 patch The problem appears in version 7.0.40 and in revision 1490425. I attached a two-line patch that fixes it. In method "ValidateVisitor.isExpression", the loop over "nodes" should break immediately after "elExpression" is set to "true". All the iterations after "elExpression" is set to "true" do not perform any useful work, at best they just set "elExpression" again to "true". Method "startInternal" in class "StandardHost" has a similar loop (over "valves"), and this loop breaks immediately after "found" is set to "true", just like in the proposed patch. Other methods (e.g., "MapperListener.findDefaultHost", "CollectVisitor.checkSeen", "JspDocumentParser.processChars", "ParameterParser.isOneOf") also have similar loops with similar breaks, just like in the proposed patch.</column><column name="report_time">2013-06-07 14:23:24</column><column name="report_timestamp">1370630000</column><column name="status">resolved fixed</column><column name="commit">3e2ceee</column><column name="commit_timestamp">1371540000</column><column name="files">java/org/apache/jasper/compiler/Validator.java</column><column name="result">1:java/org/apache/jasper/compiler/Validator.java</column></table><table name="tomcat"><column name="id">117</column><column name="bug_id">55108</column><column name="summary">Wasted work in "AbstractReplicatedMap.excludeFromSet"</column><column name="description">Created attachment 30448 patch The problem appears in version 7.0.41 and in revision 1493861. I attached a one-line patch that fixes it. In method "AbstractReplicatedMap.excludeFromSet", the loop over "mbrs" should break immediately after "include" is set to "false". All the iterations after "include" is set to "false" do not perform any useful work, at best they just set "include" again to "false". Method "inSet" in the same class "AbstractReplicatedMap" (right above the definition of "excludeFromSet") has a similar loop (over "set"), and this loop breaks immediately after "result" is set to "true", just like in the proposed patch. Other methods (e.g., "MapperListener.findDefaultHost", "CollectVisitor.checkSeen", "JspDocumentParser.processChars", "ParameterParser.isOneOf") also have similar loops with similar breaks, just like in the proposed patch.</column><column name="report_time">2013-06-17 18:12:00</column><column name="report_timestamp">1371510000</column><column name="status">resolved fixed</column><column name="commit">4979721</column><column name="commit_timestamp">1371540000</column><column name="files">java/org/apache/catalina/tribes/tipis/AbstractReplicatedMap.java</column><column name="result">1:java/org/apache/catalina/tribes/tipis/AbstractReplicatedMap.java</column></table><table name="tomcat"><column name="id">118</column><column name="bug_id">55109</column><column name="summary">Wasted work in "WebdavServlet.isLocked"</column><column name="description">Created attachment 30449 patch The problem appears in version 7.0.41 and in revision 1493861. I attached a two-line patch that fixes it. In method "WebdavServlet.isLocked", the two loops over "tokenList" should break immediately after "tokenMatch" is set to "true". All the iterations after "tokenMatch" is set to "true" do not perform any useful work, at best they just set "tokenMatch" again to "true". Method "startInternal" in class "StandardHost" has a similar loop (over "valves"), and this loop breaks immediately after "found" is set to "true", just like in the proposed patch. Other methods (e.g., "MapperListener.findDefaultHost", "CollectVisitor.checkSeen", "JspDocumentParser.processChars", "ParameterParser.isOneOf") also have similar loops with similar breaks, just like in the proposed patch.</column><column name="report_time">2013-06-17 18:24:46</column><column name="report_timestamp">1371510000</column><column name="status">resolved fixed</column><column name="commit">82bccd2</column><column name="commit_timestamp">1371540000</column><column name="files">java/org/apache/catalina/servlets/WebdavServlet.java</column><column name="result">1:java/org/apache/catalina/servlets/WebdavServlet.java</column></table><table name="tomcat"><column name="id">119</column><column name="bug_id">55110</column><column name="summary">Wasted work in "TestNonLoginAndBasicAuthenticator.doTestBasic"</column><column name="description">Created attachment 30450 patch The problem appears in version 7.0.41 and in revision 1493861. I attached a one-line patch (patch.diff) that fixes it. In method "TestNonLoginAndBasicAuthenticator.doTestBasic", the loop over "authHeaders" should break immediately after "methodFound" is set to "true". All the iterations after "methodFound" is set to "true" do not perform any useful work, at best they just set "methodFound" again to "true". Method "TestWsWebSocketContainer.testSessionExpiryContainer" has a similar problem (the loop over "setA" should break immediately after "isOpen" is set to true). I attached another one-line patch (patch2.diff) for this problem. Method "startInternal" in class "StandardHost" has a similar loop (over "valves"), and this loop breaks immediately after "found" is set to "true", just like in the proposed patches. Other methods (e.g., "MapperListener.findDefaultHost", "CollectVisitor.checkSeen", "JspDocumentParser.processChars", "ParameterParser.isOneOf") also have similar loops with similar breaks, just like in the proposed patches.</column><column name="report_time">2013-06-17 18:37:18</column><column name="report_timestamp">1371510000</column><column name="status">resolved fixed</column><column name="commit">c48a2ed</column><column name="commit_timestamp">1371540000</column><column name="files">test/org/apache/catalina/authenticator/TestNonLoginAndBasicAuthenticator.java
test/org/apache/tomcat/websocket/TestWsWebSocketContainer.java</column><column name="result">1:test/org/apache/catalina/authenticator/TestNonLoginAndBasicAuthenticator.java
51:test/org/apache/tomcat/websocket/TestWsWebSocketContainer.java</column></table><table name="tomcat"><column name="id">120</column><column name="bug_id">55052</column><column name="summary">[JULI] Make ClassLoaderLogManager.getProperty() to try unprefixed property if prefixed one does not exist</column><column name="description">The following issue was reported by "Edson" via comments system at http://tomcat.apache.org/tomcat-7.0-doc/logging.html [quote] I would like to have a section explaining how to use SimpleFormatter.format, because I can't make log behave as expected when using JULI. Seems that Tomcat always ignore my attemps - unless I set in catalina.sh the system property: -Djava.util.logging.SimpleFormatter.format="[%1$tY-%1$tm-%1$td %1$tH:%1$tM:%1$tS.%1$tL] %4$s: %5$s %6$s %n" Would this be clarified in documentation? [/quote] I am confirming this behaviour with with the current Tomcat 7.0.x (7.0.40) and JDK 7u21. Actual: ======= If add the following line to logging.properties logging output does not change, as reported in the comment: [[[ java.util.logging.SimpleFormatter.format=[%1$tY-%1$tm-%1$td %1$tH:%1$tM:%1$tS.%1$tL] %4$s: %5$s %6$s %n ]]] But, if I add the following line, the output changes for all handlers. (At least for the console one, catalina.DATE.log and localhost.DATE.log files. Other log files are empty by default). [[[ 1catalina.java.util.logging.SimpleFormatter.format=[%1$tY-%1$tm-%1$td %1$tH:%1$tM:%1$tS.%1$tL] %4$s: %5$s %6$s %n ]]] Problem: ======== Oracle's SimpleFormatter.format is a static field, an thus is initialized only once. While it is good that prefixed "1catalina.*" property works, this specific formatter cannot be configured per-handler. (One is free to implement their own formatter that does not use a static field there, or file an enhancement request to Oracle or OpenJDK). The code in question is ClassLoaderLogManager.getProperty(String) which does [[[ if (prefix != null) { name = prefix + name; } ]]] Thus is a prefix is active it tries only prefixed value of a property and never tries an unprefixed one. Expected: ========= With SimpleFormatter it would be more sense to configure it using an unprefixed property, regardless of which Handler is initialized first. Workaround =========== Change the values of "handlers", ".handlers" properties so that an unprefixed handler is listed first. In the default configuration that will be ConsoleHandler: [[[ handlers = java.util.logging.ConsoleHandler, 1catalina.org.apache.juli.FileHandler, 2localhost.org.apache.juli.FileHandler, 3manager.org.apache.juli.FileHandler, 4host-manager.org.apache.juli.FileHandler .handlers = java.util.logging.ConsoleHandler, 1catalina.org.apache.juli.FileHandler ]]] Alternatively, you can remove a prefix from one of other handlers. If you do so, and if that handler uses a SimpleFormatter, then the unprefixed configuration property will work: [[[ java.util.logging.SimpleFormatter.format=[%1$tY-%1$tm-%1$td %1$tH:%1$tM:%1$tS.%1$tL] %4$s: %5$s %6$s %n ]]]</column><column name="report_time">2013-06-03 13:08:20</column><column name="report_timestamp">1370280000</column><column name="status">resolved fixed</column><column name="commit">99562d3</column><column name="commit_timestamp">1370350000</column><column name="files">java/org/apache/juli/ClassLoaderLogManager.java</column><column name="result">1:java/org/apache/juli/ClassLoaderLogManager.java</column></table><table name="tomcat"><column name="id">121</column><column name="bug_id">55046</column><column name="summary">CORS Filter</column><column name="description">Created attachment 30363 A patch file containing CORS filter source code, units tests, and changes to tomcat documentation's filter.xml. CORS Filter implementation This is an enhancement request to include CORS Filter as one of Tomcat's container provided filters. CORS (Cross Origin Resource Sharing) is a W3C specification (http://www.w3.org/TR/cors/) that defines a mechanism to enable cross origin requests. This is a Java Servlet Filter implementation of server-side CORS. Here are few reasons that makes this implementation is a good fit: * Implements all required sections of the spec for servers. Handles simple/actual and pre-flight requests as per the specification. * Written specifically to fit well with Tomcat's source, and is formatted the same as Tomcat's source. * Filter implementation is just one class and is well Javadoc'd * Includes ample unit tests to validate the implementation against the spec * Simple to configure minimally and use * Easy to override default configuration, if required * Protects against CRLF injection / response splitting attacks. We(eBay) would like to contribute this implementation to Apache Software Foundation, to be included in Tomcat 8. And, I would also like to maintain and develop it, going forward. It's true that as a Servlet Filter, any webapp developer may add it to their app whether Tomcat includes it or not, but we believe that this is fundamental server behavior that should be present and easy to enable in the server, as it is in some other servers.</column><column name="report_time">2013-06-02 00:48:49</column><column name="report_timestamp">1370150000</column><column name="status">resolved fixed</column><column name="commit">72edec7</column><column name="commit_timestamp">1370340000</column><column name="files">java/org/apache/catalina/filters/CorsFilter.java
test/org/apache/catalina/filters/TestCorsFilter.java
test/org/apache/catalina/filters/TesterFilterChain.java
test/org/apache/catalina/filters/TesterFilterConfigs.java
test/org/apache/catalina/filters/TesterHttpServletRequest.java
test/org/apache/catalina/filters/TesterHttpServletResponse.java
test/org/apache/catalina/filters/TesterServletContext.java</column><column name="result" /></table><table name="tomcat"><column name="id">122</column><column name="bug_id">55035</column><column name="summary">Deploy ROOT webapp with version through text manager using Ant</column><column name="description">Currently Ant "deploy" task does not support separate parameter "version" and, thanks to URLEncoder, there is no workaround for that. But for apps with not empty context it's possible to define version using ##, like setting path to "/someContext#someVersion". For apps with empty context we receive error: Case #1: &lt;deploy url="{tomcat.manager}/text" username="${username}", password="${password}" path="/ROOT##12345" war="${pathtowar}" /&gt; Result: Failed to deploy application at context path /ROOT##12345 Case #1: &lt;deploy url="{tomcat.manager}/text" username="${username}", password="${password}" path="/##12345" war="${pathtowar}" /&gt; Result: Failed to deploy application at context path /##12345</column><column name="report_time">2013-05-31 16:05:20</column><column name="report_timestamp">1370030000</column><column name="status">resolved fixed</column><column name="commit">712a351</column><column name="commit_timestamp">1370290000</column><column name="files">java/org/apache/catalina/ant/DeployTask.java</column><column name="result">12:java/org/apache/catalina/ant/DeployTask.java</column></table><table name="tomcat"><column name="id">123</column><column name="bug_id">54999</column><column name="summary">JSESSIONIDSSO not re-created upon re-authentication on the same request - logout() and login(username,password)</column><column name="description">In testing I found that the JSESSIONIDSSO was not re-created upon re-authentication via logout() and login(username,password) in the same request. The problem stemmed from the REQ_SSOID_NOTE that was was not reset upon request.logout(), whereas the documentation indicates that a logout() from any web-app should logout() from all web-apps. When the REQ_SSOID_NOTE is not removed upon logout(), a subsequent login(username,password) on the same request will re-create a JSESSIONID for the current web-app but fails to re-create a JSESSIONIDSSO since the REQ_SSO_ID_NOTE still lingers on the request. AuthenticatorBase.java adjustment for logout(request) that removes the REQ_SSOID_NOTE so that a subsequent login(username,password) will work on the same request: @Override public void logout(Request request) throws ServletException { register(request, request.getResponse(), null, null, null, null); 	request.removeNote(Constants.REQ_SSOID_NOTE); } I'll upload a diff-patch against the trunk and for 7.0.40.</column><column name="report_time">2013-05-21 19:50:48</column><column name="report_timestamp">1369180000</column><column name="status">resolved fixed</column><column name="commit">6d789fe</column><column name="commit_timestamp">1369920000</column><column name="files">java/org/apache/catalina/authenticator/AuthenticatorBase.java</column><column name="result">1:java/org/apache/catalina/authenticator/AuthenticatorBase.java</column></table><table name="tomcat"><column name="id">124</column><column name="bug_id">54997</column><column name="summary">SSL Handshake implementation in AsycnChannelWrapperSecure does not handle SSLEngineResult.Status.BUFFER_UNDERFLOW and SSLEngineResult.Status.BUFFER_OVERFLOW states</column><column name="description">When SSLEngineResult.Status.BUFFER_UNDERFLOW and SSLEngineResult.Status.BUFFER_OVERFLOW states occur during ssl handshake the implementation throws SSLException instead of continuing the procedure described here http://docs.oracle.com/javase/7/docs/api/javax/net/ssl/SSLEngine.html</column><column name="report_time">2013-05-21 07:22:32</column><column name="report_timestamp">1369140000</column><column name="status">resolved fixed</column><column name="commit">6c6b25c</column><column name="commit_timestamp">1369820000</column><column name="files">java/org/apache/tomcat/websocket/AsyncChannelWrapperSecure.java</column><column name="result">4:java/org/apache/tomcat/websocket/AsyncChannelWrapperSecure.java</column></table><table name="tomcat"><column name="id">125</column><column name="bug_id">54971</column><column name="summary">javax.servlet.http.Part.write(String fileName) is not properly implemented</column><column name="description">1. fileName parameter / relative vs absolute filaName parameter specification in &lt;1&gt;&lt;JSR-000315 Java Servlet 3.0 Final Release javadocs&gt; is different from the &lt;2&gt;&lt;javax API tomcat refers to&gt;. &lt;1&gt; &lt;JSR-000315 Java Servlet 3.0 Final Release javadocs&gt; Parameters:fileName - the name of the file to which the stream will be written. The file is created relative to the location as specified in the MultipartConfig &lt;2&gt; javax. API tomcat refers to * @param fileName The location into which the uploaded part should be * stored. Relative locations are relative to {@link * javax.servlet.MultipartConfigElement#getLocation()} Tomcat is implemented as specified in &lt;2&gt; so that it can process "absolute path", but it should only accept "relative path" as specified in &lt;1&gt; &lt;JSR-000315 Java Servlet 3.0 Final Release javadocs&gt; 2. If MultiPartConfig.location is not set, write( String relative path ) throws FileNotFound Exception. A default location needs to be set in order to avoid such exception. example) os: windows8 part.write("/test"); java.io.IOException: java.io.FileNotFoundException: \test (Access is denied) 	at org.apache.catalina.core.ApplicationPart.write(ApplicationPart.java:123) 	at servlet.multipart.MultipleUploadServlet.doPost(MultipleUploadServlet.java:76) 	at javax.servlet.http.HttpServlet.service(HttpServlet.java:647) 	at javax.servlet.http.HttpServlet.service(HttpServlet.java:728) 	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:305) 	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:210) 	at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:222) 	at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:123) 	at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:472) 	at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:171) 	at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:99) 	at org.apache.catalina.valves.AccessLogValve.invoke(AccessLogValve.java:947) 	at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:118) 	at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:408) 	at org.apache.coyote.http11.AbstractHttp11Processor.process(AbstractHttp11Processor.java:1009) 	at org.apache.coyote.AbstractProtocol$AbstractConnectionHandler.process(AbstractProtocol.java:589) 	at org.apache.tomcat.util.net.JIoEndpoint$SocketProcessor.run(JIoEndpoint.java:312) 	at java.util.concurrent.ThreadPoolExecutor$Worker.runTask(ThreadPoolExecutor.java:895) 	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:918) 	at java.lang.Thread.run(Thread.java:662)</column><column name="report_time">2013-05-15 02:16:03</column><column name="report_timestamp">1368600000</column><column name="status">resolved fixed</column><column name="commit">cccd0ac</column><column name="commit_timestamp">1369750000</column><column name="files">java/org/apache/catalina/connector/Request.java
java/org/apache/catalina/core/ApplicationPart.java</column><column name="result">1:java/org/apache/catalina/connector/Request.java
14:java/org/apache/catalina/core/ApplicationPart.java</column></table><table name="tomcat"><column name="id">126</column><column name="bug_id">54964</column><column name="summary">Class loading issue of "TagPlugin" in TagPluginManager</column><column name="description">Created attachment 30281 Patch for TagPluginManager.java TagPluginManager is using "Class.forName" to load extensions of TagPlugin. It can't work when these extensions are put under the WEB-INF/lib. Here is the code, String pluginClassStr = pluginClassNode.getBody(); TagPlugin tagPlugin = null; try { Class&lt;?&gt; pluginClass = Class.forName(pluginClassStr); tagPlugin = (TagPlugin) pluginClass.newInstance(); } catch (Exception e) { throw new JasperException(e); }</column><column name="report_time">2013-05-14 06:57:34</column><column name="report_timestamp">1368530000</column><column name="status">resolved fixed</column><column name="commit">65ab66e</column><column name="commit_timestamp">1369740000</column><column name="files">java/org/apache/jasper/compiler/TagPluginManager.java</column><column name="result">1:java/org/apache/jasper/compiler/TagPluginManager.java</column></table><table name="tomcat"><column name="id">127</column><column name="bug_id">54963</column><column name="summary">Concurrent issue of Spdy/NetSupportSocket</column><column name="description">Created attachment 30280 Patch for NetSupportSocket Duplicated Threads were started for doing "onBlockingSocket" in NetSupportSocket.java When a socket is coming, Listener creates a Runnable and executes the runnable with Thread Pool. In "onAccept", it invokes the method "onBlockingSocket". And the same method will be invoked in "ctx.getExecutor().execute(ch.inputThread);" as well. It means there are two threads work on one sinle Socket. This cause concurrent issue. Here is the orginal code, @Override public void onAccept(Object socket) { SpdyConnectionSocket ch = new SpdyConnectionSocket(ctx, (Socket) socket); ctx.getExecutor().execute(ch.inputThread); ch.onBlockingSocket(); } Just remove the line "ctx.getExecutor().execute(ch.inputThread);" will fix this issue.</column><column name="report_time">2013-05-14 06:50:20</column><column name="report_timestamp">1368530000</column><column name="status">resolved fixed</column><column name="commit">6272fca</column><column name="commit_timestamp">1369740000</column><column name="files">java/org/apache/tomcat/spdy/NetSupportSocket.java</column><column name="result">1:java/org/apache/tomcat/spdy/NetSupportSocket.java</column></table><table name="tomcat"><column name="id">128</column><column name="bug_id">54961</column><column name="summary">Make "compress" configurable in SpdyProxyProtocol</column><column name="description">I tried to setup SpdyProtocol in Tomcat and make it cordinating with HAProxy. Spdy from tomcat 8 supports NPN(Next Protocol Negotiation) by using JNI modules from APR. It's not easy to deploy APR in different System. So we are tring to make NPN running in Load Balancer and Tomcat 8 only takes the role of pure SPDY server. Here is the detail of this model. http://www.igvita.com/2012/10/31/simple-spdy-and-npn-negotiation-with-haproxy/ HAProxy takes the role of Load Balancer and it supports NPN. HAProxy talks with SPDY server in "compress" mode. However the "compress" mode can't be configurable in SpdyProxyProtocol. So I suggest let's make it configurable. Attached a patch for this enhancment.</column><column name="report_time">2013-05-14 02:56:42</column><column name="report_timestamp">1368510000</column><column name="status">resolved fixed</column><column name="commit">c25112b</column><column name="commit_timestamp">1369740000</column><column name="files">java/org/apache/coyote/spdy/SpdyProxyProtocol.java</column><column name="result">1:java/org/apache/coyote/spdy/SpdyProxyProtocol.java</column></table><table name="tomcat"><column name="id">129</column><column name="bug_id">54947</column><column name="summary">Http11NioProtocol generates HTTP 505 responses on valid requests if request is split across multiple packets</column><column name="description">If an HTTP request is broken up across multiple packets *and* the first packet contains a GET request up to "\r" AND the "\n" terminating the first line of the request is included in the next packet Tomcat incorrectly throws an HTTP "505 Version Not Supported" response. This is with the Http11NioProtocol connector only - the default HTTP/1.1 connector does not exhibit this problem. An example request: Packet 1: GET / HTTP/1.1\r Packet 2: \nHost: localhost\r\n Packet 3: Connection: Close\r\n\r\n Response: HTTP/1.1 505 HTTP Version Not Supported Server: Apache-Coyote/1.1 Date: Thu, 09 May 2013 20:23:58 GMT Connection: close The following Python program reproduces the problem for me in both Tomcat 6.0.37 and Tomcat 7.0.39: """ #!/usr/bin/python import socket import time s = socket.socket() s.connect(("localhost",8080)) s.sendall("GET / HTTP/1.1\r") time.sleep(1.5) # make sure the above goes out in its own packet s.sendall("\nHost: localhost\r\n") s.sendall("Connection: close\r\n\r\n") print s.makefile().read() """ Moving the "\n" to from the second sendall to the end of the first sendall causes Tomcat to respond correctly.</column><column name="report_time">2013-05-09 20:27:01</column><column name="report_timestamp">1368150000</column><column name="status">resolved fixed</column><column name="commit">f763975</column><column name="commit_timestamp">1369740000</column><column name="files">java/org/apache/coyote/http11/InternalNioInputBuffer.java
test/org/apache/catalina/startup/SimpleHttpClient.java
test/org/apache/coyote/http11/TestInternalInputBuffer.java</column><column name="result">39:java/org/apache/coyote/http11/InternalNioInputBuffer.java
123:test/org/apache/catalina/startup/SimpleHttpClient.java
155:test/org/apache/coyote/http11/TestInternalInputBuffer.java</column></table><table name="tomcat"><column name="id">130</column><column name="bug_id">54944</column><column name="summary">Enhancements to TestFormAuthenticator</column><column name="description">Created attachment 30266 svn diff: update to test class I have attached an extensive patch to this existing test class. The main benefit is better comments and self-documenting arguments to the common worker methods, which should be helpful to anyone investigating tomcat authentication behaviour but who does not have a detailed understanding of its internal logic. The motive and techniques used here bring the source into line with an earlier enhancement to the TestNonLoginAndBasicAuthenticator, i.e. https://issues.apache.org/bugzilla/show_bug.cgi?id=54190#c4 All tests should pass with the latest trunk. Code style should be acceptable.</column><column name="report_time">2013-05-09 14:33:23</column><column name="report_timestamp">1368120000</column><column name="status">resolved fixed</column><column name="commit">0de078e</column><column name="commit_timestamp">1369740000</column><column name="files">test/org/apache/catalina/authenticator/TestFormAuthenticator.java</column><column name="result">1:test/org/apache/catalina/authenticator/TestFormAuthenticator.java</column></table><table name="tomcat"><column name="id">131</column><column name="bug_id">55019</column><column name="summary">&lt;jsp:include page="blabla" flush="true"/&gt; failed to compile under security manager</column><column name="description">Created attachment 30328 Patch to fix the problem With 2 JSP on including the other with &lt;jsp:include page="blabla" flush="true"/&gt; you get: java.lang.RuntimePermission accessClassInPackage.org.apache.coyote.http11 when calling the jsp the first time subsequent requests are working.</column><column name="report_time">2013-05-27 12:55:28</column><column name="report_timestamp">1369670000</column><column name="status">resolved fixed</column><column name="commit">76a7098</column><column name="commit_timestamp">1369670000</column><column name="files">java/org/apache/coyote/http11/AbstractOutputBuffer.java</column><column name="result">10:java/org/apache/coyote/http11/AbstractOutputBuffer.java</column></table><table name="tomcat"><column name="id">132</column><column name="bug_id">54984</column><column name="summary">multipart/form-data is not always read with correct encoding</column><column name="description">The bug occurs when form data is posted as multipart/form-data and using Servlet 3 API to get posted files. In a servlet, if we set the encoding: request.setCharacterEncoding("UTF-8"); Then invoke: request.getParts() And then invoke: String text = request.getParameter("sometextfield"); UTF-8 characters in the text have been garbled. Order of method calls are significant, if a getParameter is called before getParts, the correct encoding will be used. However, the order which you invoke the methods should not matter.</column><column name="report_time">2013-05-16 11:15:20</column><column name="report_timestamp">1368720000</column><column name="status">resolved fixed</column><column name="commit">7558546</column><column name="commit_timestamp">1369420000</column><column name="files">java/org/apache/catalina/connector/Request.java
test/org/apache/catalina/connector/TestRequest.java</column><column name="result">2:java/org/apache/catalina/connector/Request.java
54:test/org/apache/catalina/connector/TestRequest.java</column></table><table name="tomcat"><column name="id">133</column><column name="bug_id">54928</column><column name="summary">IllegalStateException: Calling [asyncError()] is not valid for a request with Async state [COMPLETING]</column><column name="description">In an async scenario (request.startAsync), when the client goes away, trying to write to the response raises an IOException. If I then call asyncContext.complete() in order to finalize and clean up the request, soon after the following exception occurs: java.lang.IllegalStateException: Calling [asyncError()] is not valid for a request with Async state [COMPLETING] at org.apache.coyote.AsyncStateMachine.asyncError(AsyncStateMachine.java:304) at org.apache.coyote.http11.AbstractHttp11Processor.action(AbstractHttp11Processor.java:793) at org.apache.coyote.Request.action(Request.java:373) at org.apache.catalina.core.AsyncContextImpl.setErrorState(AsyncContextImpl.java:441) at org.apache.catalina.connector.CoyoteAdapter.asyncDispatch(CoyoteAdapter.java:312) at org.apache.coyote.http11.AbstractHttp11Processor.asyncDispatch(AbstractHttp11Processor.java:1509) at org.apache.coyote.http11.Http11NioProcessor.asyncDispatch(Http11NioProcessor.java:221) at org.apache.coyote.AbstractProtocol$AbstractConnectionHandler.process(AbstractProtocol.java:619) at org.apache.coyote.http11.Http11NioProtocol$Http11ConnectionHandler.process(Http11NioProtocol.java:223) at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1581) at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.run(NioEndpoint.java:1540) at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1110) at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:603) at java.lang.Thread.run(Thread.java:722) It looks like an attempt to maybe to send an error event to AsyncListener's but asyncContext.complete has already been called. Is calling asyncContext.complete() a reasonable way to handle an IOException from the response in order to finalize the request and release any resorces associated with it?</column><column name="report_time">2013-05-04 12:41:30</column><column name="report_timestamp">1367690000</column><column name="status">resolved fixed</column><column name="commit">3960b22</column><column name="commit_timestamp">1369400000</column><column name="files">test/org/apache/catalina/connector/TestCoyoteAdapter.java</column><column name="result">204:test/org/apache/catalina/connector/TestCoyoteAdapter.java</column></table><table name="tomcat"><column name="id">134</column><column name="bug_id">54955</column><column name="summary">Mapping to application context root returns 404 after reload</column><column name="description">Created attachment 30273 A minimum war file to reproduce the bug with sources attached URL mapping specified as ""(empty string) maps a servlet to the context root according to servlet specification. This feature is working when an application is deployed, but broken when it's reloaded. A reload will result in 404 error. (Other url mappings are OK, only "") Steps to reproduce: 1) Create a servlet with URL mapping as empty string, you can either use @WebServlet("") annotation or &lt;url-pattern&gt;&lt;/url-pattern&gt; in web.xml 2) If you deploy it in Tomcat 7.0.40, it will work. (e.g. http://localhost:8080/myapp/) 3) But if you reload the app (say using the manager app), http://localhost:8080/myapp/ will give 404 error. Servlet in step 1 is never called this time. Actual Results: 404 Not Found Expected Results: Show the context root page. Env: Tomcat 7.0.40, Java 7, Windows 8</column><column name="report_time">2013-05-13 03:50:12</column><column name="report_timestamp">1368430000</column><column name="status">resolved fixed</column><column name="commit">cdbf6b0</column><column name="commit_timestamp">1369080000</column><column name="files">java/org/apache/catalina/mapper/Mapper.java</column><column name="result">48:java/org/apache/catalina/mapper/Mapper.java</column></table><table name="tomcat"><column name="id">135</column><column name="bug_id">54981</column><column name="summary">ServletContext.getJspConfigDescriptor() should return null when there is no jsp configuration</column><column name="description">According to Servlet 3.0 javadoc ServletContext.getJspConfigDescriptor() must return NULL when there is no jsp configuration: " Returns: the &lt;jsp-config&gt; related configuration that was aggregated from the web.xml and web-fragment.xml descriptor files of the web application represented by this ServletContext, or null if no such configuration exists "</column><column name="report_time">2013-05-16 08:02:36</column><column name="report_timestamp">1368710000</column><column name="status">resolved fixed</column><column name="commit">aabef09</column><column name="commit_timestamp">1368690000</column><column name="files">java/org/apache/catalina/core/ApplicationContext.java
test/org/apache/catalina/core/TestApplicationContext.java</column><column name="result">2:java/org/apache/catalina/core/ApplicationContext.java
82:test/org/apache/catalina/core/TestApplicationContext.java</column></table><table name="tomcat"><column name="id">136</column><column name="bug_id">54974</column><column name="summary">SessionCookieConfig.setXXX methods must throw IllegalStateException when invoked after initialization phase</column><column name="description">According to Servlet 3.0 javadoc javax.servlet.SessionCookieConfig setter methods must throw IllegalStateException when invoked after initialization phase setComment(String) setDomain(String) setHttpOnly(boolean) setMaxAge(int) setName(String) setPath(String) setSecure(boolean) " Throws: java.lang.IllegalStateException - if the ServletContext from which this SessionCookieConfig was acquired has already been initialized "</column><column name="report_time">2013-05-15 08:23:39</column><column name="report_timestamp">1368620000</column><column name="status">resolved fixed</column><column name="commit">41462ca</column><column name="commit_timestamp">1368610000</column><column name="files">java/org/apache/catalina/core/ApplicationContext.java
java/org/apache/catalina/core/ApplicationSessionCookieConfig.java
test/org/apache/catalina/core/TestApplicationSessionCookieConfig.java</column><column name="result">2:java/org/apache/catalina/core/ApplicationSessionCookieConfig.java
3:java/org/apache/catalina/core/ApplicationContext.java</column></table><table name="tomcat"><column name="id">137</column><column name="bug_id">54703</column><column name="summary">Nullpointer exception in HttpParser.parseMediaType</column><column name="description">input for parseMediaType() is ---------- multipart/signed; protocol="application/pkcs7-signature"; micalg=sha-256; 	boundary="----=_Part_121_929034657.1363355797756" ---------- exception trace java.lang.NullPointerException at org.apache.tomcat.util.http.parser.HttpParser.parseMediaType(HttpParser.java:215) at org.apache.tomcat.util.http.parser.MediaTypeCache.parse(MediaTypeCache.java:54) at org.apache.catalina.connector.Response.setContentType(Response.java:806) at org.apache.catalina.connector.Response.checkSpecialHeader(Response.java:1119) at org.apache.catalina.connector.Response.setHeader(Response.java:1446) at org.apache.catalina.connector.ResponseFacade.setHeader(ResponseFacade.java:535)</column><column name="report_time">2013-03-15 14:09:19</column><column name="report_timestamp">1363370000</column><column name="status">resolved fixed</column><column name="commit">7aeab0e</column><column name="commit_timestamp">1367940000</column><column name="files">java/org/apache/tomcat/util/http/parser/HttpParser.java
test/org/apache/tomcat/util/http/parser/TestMediaType.java</column><column name="result">4:test/org/apache/tomcat/util/http/parser/TestMediaType.java
11:java/org/apache/tomcat/util/http/parser/HttpParser.java</column></table><table name="tomcat"><column name="id">138</column><column name="bug_id">54906</column><column name="summary">WebappClassLoader.loadedByThisOrChild can throw ConcurrentModificationException</column><column name="description">Created attachment 30240 Patch to catch ConcurrentModificationException while iterating over a collection This is related to bug 54497. A common exception seen in 7.0.33 during stop is a ConcurrentModification in loadedByThisOrChild. java.util.concurrent.ExecutionException: org.apache.catalina.LifecycleException: Failed to stop component [StandardEngine[Tomcat].StandardHost[localhost].StandardContext[/mobile/login/oauth]] 	at java.util.concurrent.FutureTask$Sync.innerGet(FutureTask.java:252) 	at java.util.concurrent.FutureTask.get(FutureTask.java:111) 	at org.apache.catalina.core.ContainerBase.stopInternal(ContainerBase.java:1179) 	at org.apache.catalina.util.LifecycleBase.stop(LifecycleBase.java:232) 	at org.apache.catalina.core.ContainerBase$StopChild.call(ContainerBase.java:1575) 	at org.apache.catalina.core.ContainerBase$StopChild.call(ContainerBase.java:1564) 	at java.util.concurrent.FutureTask$Sync.innerRun(FutureTask.java:334) 	at java.util.concurrent.FutureTask.run(FutureTask.java:166) 	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1145) 	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:615) 	at java.lang.Thread.run(Thread.java:722) Caused by: org.apache.catalina.LifecycleException: Failed to stop component [StandardEngine[Tomcat].StandardHost[localhost].StandardContext[/mobile/login/oauth]] 	at org.apache.catalina.util.LifecycleBase.stop(LifecycleBase.java:236) 	... 7 more Caused by: org.apache.catalina.LifecycleException: Failed to stop component [WebappLoader[/mobile/login/oauth]] 	at org.apache.catalina.util.LifecycleBase.stop(LifecycleBase.java:236) 	at org.apache.catalina.core.StandardContext.stopInternal(StandardContext.java:5521) 	at org.apache.catalina.util.LifecycleBase.stop(LifecycleBase.java:232) 	... 7 more Caused by: java.util.ConcurrentModificationException 	at java.util.Vector$Itr.checkForComodification(Vector.java:1156) 	at java.util.Vector$Itr.next(Vector.java:1133) 	at org.apache.catalina.loader.WebappClassLoader.loadedByThisOrChild(WebappClassLoader.java:2599) 	at org.apache.catalina.loader.WebappClassLoader.checkThreadLocalMapForLeaks(WebappClassLoader.java:2515) 	at org.apache.catalina.loader.WebappClassLoader.checkThreadLocalsForLeaks(WebappClassLoader.java:2455) 	at org.apache.catalina.loader.WebappClassLoader.clearReferences(WebappClassLoader.java:1996) 	at org.apache.catalina.loader.WebappClassLoader.stop(WebappClassLoader.java:1902) 	at org.apache.catalina.loader.WebappLoader.stopInternal(WebappLoader.java:661) 	at org.apache.catalina.util.LifecycleBase.stop(LifecycleBase.java:232) 	... 9 more The fix for 54497 stops the exception from failing the stop but it still fails the rest of the ThreadLocal leak check. It would be better if ConcurrentModificationException was caught in loadedByThisOrChild and only that one check fails.</column><column name="report_time">2013-04-29 19:25:04</column><column name="report_timestamp">1367280000</column><column name="status">resolved fixed</column><column name="commit">c06707c</column><column name="commit_timestamp">1367700000</column><column name="files">java/org/apache/catalina/loader/WebappClassLoader.java</column><column name="result">1:java/org/apache/catalina/loader/WebappClassLoader.java</column></table><table name="tomcat"><column name="id">139</column><column name="bug_id">54926</column><column name="summary">WsFilter performs handshake validation even if it doesn't have a mapped endpoint</column><column name="description">WsFilter performs several validations on WebSocket requests before checking if there is a registered Endpoint. I think the check for registered Endponts (and delegation to the next Filter) should take place first and the filter should do no further processing if there is mapped Endpoint for that URL. For example a SockJS protocol test send a POST request with a connection and upgrade headers but no ws version header and expects back a 405 (invalid HTTP method) where WsFilter sends 426 even though it has no Endpoint mapped at that URL.</column><column name="report_time">2013-05-04 01:23:20</column><column name="report_timestamp">1367650000</column><column name="status">resolved fixed</column><column name="commit">2df191f</column><column name="commit_timestamp">1367660000</column><column name="files">java/org/apache/tomcat/websocket/server/WsFilter.java</column><column name="result">1:java/org/apache/tomcat/websocket/server/WsFilter.java</column></table><table name="tomcat"><column name="id">140</column><column name="bug_id">54888</column><column name="summary">TagPlugin "ForEach" doesn't support CSV items</column><column name="description">Created attachment 30225 Patch for "ForEach" In JSTL, "forEach" supports items with String value. The string can be a CSV format. For example, &lt;c:foreach items="1,2,3,4,5" var="i"&gt;&lt;/c:foreach&gt; However, it doesn't support in tagPlugin "ForEach". Provided a patch for this issue.</column><column name="report_time">2013-04-24 16:49:45</column><column name="report_timestamp">1366840000</column><column name="status">resolved fixed</column><column name="commit">d440ae2</column><column name="commit_timestamp">1367240000</column><column name="files">java/org/apache/jasper/tagplugins/jstl/core/ForEach.java
test/org/apache/jasper/tagplugins/jstl/core/TestForEach.java</column><column name="result">3:java/org/apache/jasper/tagplugins/jstl/core/ForEach.java
18:test/org/apache/jasper/tagplugins/jstl/core/TestForEach.java</column></table><table name="tomcat"><column name="id">141</column><column name="bug_id">54801</column><column name="summary">EL-like expressions in jsp:scriptlet break compilation of JSP XML documents</column><column name="description">Created attachment 30152 helloWorld.tagx Steps to reproduce: 1. Go to webapps\examples\WEB-INF\tags\ 2. Delete "helloWorld.tag" file and put there "helloWorld.tagx" file attached to this issue. The file contains the following plus AL header: &lt;?xml version="1.0" encoding="utf-8" ?&gt; &lt;jsp:root xmlns:jsp="http://java.sun.com/JSP/Page" version="2.0"&gt; &lt;jsp:scriptlet&gt;&lt;![CDATA[// // ${foo} out.println("Hello, world!!"); ]]&gt;&lt;/jsp:scriptlet&gt; &lt;/jsp:root&gt; 3. Start Tomcat and try to open the following page in a browser: http://localhost:8080/examples/jsp/jsp2/tagfiles/hello.jsp ACTUAL result: in current TC8 trunk: org.xml.sax.SAXException: Body of scriptlet element must not contain any XML elements org.apache.jasper.compiler.JspDocumentParser.checkScriptingBody(JspDocumentParser.java:1332) org.apache.jasper.compiler.JspDocumentParser.endElement(JspDocumentParser.java:650) 	 This behaviour is caused by "${foo}" being present inside the scriptlet. If I remove that line, the page is displayed successfully. EXPECTED RESULT I think EL expressions should not be recognized inside of jsp:scriptlet, jsp:declaration or jsp:expression and should not trigger such an error. As a confirmation, the following "helloWorld.tag" in JSP syntax compiles and executes successfully. Thus this issue is with XML syntax only, &lt;% // ${foo} %&gt; Hello, world!++ Alternative solution could be to change the error message, but I think it is not the issue here, s/ any XML elements / any XML elements or EL expressions/</column><column name="report_time">2013-04-04 22:24:00</column><column name="report_timestamp">1365130000</column><column name="status">resolved fixed</column><column name="commit">1631be1</column><column name="commit_timestamp">1366900000</column><column name="files">java/org/apache/jasper/compiler/JspDocumentParser.java
test/org/apache/jasper/compiler/TestJspDocumentParser.java</column><column name="result">12:java/org/apache/jasper/compiler/JspDocumentParser.java
90:test/org/apache/jasper/compiler/TestJspDocumentParser.java</column></table><table name="tomcat"><column name="id">142</column><column name="bug_id">54178</column><column name="summary">[CVE-2013-2071] runtime exception in onComplete of AsyncListener, will make org.apache.catalina.connector.Request not recycled (orginally reported MESSAGE POST to tomcat, but it called doGet)</column><column name="description">one HTTP request use POST method, but in tomcat it calls doGet() what is really strage. as I only tested in 7.0.23, and 7.0.32. in 7.0.32, 7.0.32 is more reproduceable than 7.0.23. I know it must be a very strange issue, as tomcat has so many release. I can't believe it if I didn't see it with my own eyes. so I attache the image.</column><column name="report_time">2012-11-21 08:22:00</column><column name="report_timestamp">1353500000</column><column name="status">resolved fixed</column><column name="commit">4171baf</column><column name="commit_timestamp">1366800000</column><column name="files">java/org/apache/catalina/core/AsyncContextImpl.java
test/org/apache/catalina/core/TestAsyncContextImpl.java</column><column name="result">3:java/org/apache/catalina/core/AsyncContextImpl.java
6:test/org/apache/catalina/core/TestAsyncContextImpl.java</column></table><table name="tomcat"><column name="id">143</column><column name="bug_id">54708</column><column name="summary">Use base file name ("ROOT") as the work directory for the default webapp instead of "_"</column><column name="description">[1] http://tomcat.apache.org/tomcat-7.0-doc/config/context.html#Naming There is documentation [1] on relation between context name, context path, context version and the base file name of a Context. There is one place where Tomcat 7 does not follow [1]: naming of javax.servlet.context.tempdir directory (aka work directory) for the application. It uses "_" for the default application. I propose to replace that with "ROOT", a) for consistency b) to avoid conflict if someone deploys web application named "_", e.g. in pursue of short URLs BTW, if someone is really facing such conflict, it could be remedied by specifying workDir attribute on a &lt;Context&gt;. (Though a bit hard to make the path unique without knowing the engine and host names).</column><column name="report_time">2013-03-15 22:22:13</column><column name="report_timestamp">1363400000</column><column name="status">resolved fixed</column><column name="commit">59a0676</column><column name="commit_timestamp">1366750000</column><column name="files">java/org/apache/catalina/core/StandardContext.java</column><column name="result">3:java/org/apache/catalina/core/StandardContext.java</column></table><table name="tomcat"><column name="id">144</column><column name="bug_id">54781</column><column name="summary">NPE in WsServerContainer if there is no matching path</column><column name="description">Created attachment 30129 A proposed fix WsServerContainer.findMapping fails with a NullPointerException if there is no matching WsMappingResult. Also WsFilter needs a conditional clause to let the request through if there is no matching mapping. Attached is a patch.</column><column name="report_time">2013-04-01 19:32:18</column><column name="report_timestamp">1364860000</column><column name="status">resolved fixed</column><column name="commit">67ed3e7</column><column name="commit_timestamp">1366750000</column><column name="files">java/org/apache/tomcat/websocket/server/WsFilter.java
java/org/apache/tomcat/websocket/server/WsServerContainer.java</column><column name="result">1:java/org/apache/tomcat/websocket/server/WsServerContainer.java
50:java/org/apache/tomcat/websocket/server/WsFilter.java</column></table><table name="tomcat"><column name="id">145</column><column name="bug_id">54792</column><column name="summary">IllegalStateException with chat sample</column><column name="description">This looks related to 54659 and 54724 but possibly a new issue. To reproduce, open the chat sample page, send a message or two, and then close the browser tab. The following exception appears in the log and it doesn't seem to step from anything done in the application: java.lang.IllegalStateException: The WebSocket session has been closed and no method (apart from close()) may be called on a closed session at org.apache.tomcat.websocket.WsSession.checkState(WsSession.java:516) at org.apache.tomcat.websocket.WsSession.getMessageHandlers(WsSession.java:191) at org.apache.tomcat.websocket.pojo.PojoEndpointBase.onClose(PojoEndpointBase.java:113) at org.apache.tomcat.websocket.WsSession.fireEndpointOnClose(WsSession.java:392) at org.apache.tomcat.websocket.WsSession.onClose(WsSession.java:370) at org.apache.tomcat.websocket.server.WsHttpUpgradeHandler.close(WsHttpUpgradeHandler.java:166) at org.apache.tomcat.websocket.server.WsHttpUpgradeHandler.access$200(WsHttpUpgradeHandler.java:44) at org.apache.tomcat.websocket.server.WsHttpUpgradeHandler$WsReadListener.onDataAvailable(WsHttpUpgradeHandler.java:192) at org.apache.coyote.http11.upgrade.AbstractServletInputStream.onDataAvailable(AbstractServletInputStream.java:169) at org.apache.coyote.http11.upgrade.AbstractProcessor.upgradeDispatch(AbstractProcessor.java:94) at org.apache.coyote.AbstractProtocol$AbstractConnectionHandler.process(AbstractProtocol.java:618) at org.apache.coyote.http11.Http11NioProtocol$Http11ConnectionHandler.process(Http11NioProtocol.java:223) at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1581) at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.run(NioEndpoint.java:1537) at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1110) at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:603) at java.lang.Thread.run(Thread.java:722)</column><column name="report_time">2013-04-02 20:54:28</column><column name="report_timestamp">1364950000</column><column name="status">resolved fixed</column><column name="commit">e26d61d</column><column name="commit_timestamp">1366730000</column><column name="files">webapps/examples/WEB-INF/classes/websocket/chat/ChatAnnotation.java</column><column name="result">123:webapps/examples/WEB-INF/classes/websocket/chat/ChatAnnotation.java</column></table><table name="tomcat"><column name="id">146</column><column name="bug_id">54800</column><column name="summary">Possible thread/memory leak with use of WebSocketContainer</column><column name="description">Whenever WebSocketContainer is used to connect to a server endpoint, the following message appears when Tomcat shuts down: SEVERE: The web application [/websocket-test] appears to have started a thread named [Thread-4] but has failed to stop it. This is very likely to create a memory leak. The message is repeated for 6 different threads. I don't have proof this is caused by the use of WebSocketContainer but the messages don't appear when it isn't used. The Endpoint used to connect is very simple. It sends a message when the session is opened to the EchoEndpoint on the server side, and prints the response and closes when the message is echoed back.</column><column name="report_time">2013-04-04 21:47:00</column><column name="report_timestamp">1365130000</column><column name="status">resolved fixed</column><column name="commit">d2630df</column><column name="commit_timestamp">1366730000</column><column name="files">java/org/apache/tomcat/websocket/WsWebSocketContainer.java</column><column name="result">6:java/org/apache/tomcat/websocket/WsWebSocketContainer.java</column></table><table name="tomcat"><column name="id">147</column><column name="bug_id">54807</column><column name="summary">[jsr356] java.lang.ClassCastException: org.apache.tomcat.websocket.server.WsServerContainer$TemplatePathMatch</column><column name="description">Caused by: java.lang.ClassCastException: org.apache.tomcat.websocket.server.WsServerContainer$TemplatePathMatch cannot be cast to java.lang.Comparable 	at java.util.TreeMap.compare(TreeMap.java:1188) 	at java.util.TreeMap.put(TreeMap.java:531) 	at java.util.TreeSet.add(TreeSet.java:255) 	at org.apache.tomcat.websocket.server.WsServerContainer.addEndpoint(WsServerContainer.java:144) 	at org.apache.tomcat.websocket.server.WsSci.onStartup(WsSci.java:118) 	at org.apache.catalina.core.StandardContext.startInternal(StandardContext.java:5195) 	at org.apache.catalina.util.LifecycleBase.start(LifecycleBase.java:150) 	... 11 more Reproducible when a path is defined as {path}. For example: @Override public Set&lt;ServerEndpointConfig&gt; getEndpointConfigs(Set&lt;Class&lt;? extends Endpoint&gt;&gt; endpointClasses) { logger.debug("{} detected", JSR356ServerEndpointConfig.class.getName()); return new HashSet&lt;ServerEndpointConfig&gt;() {{ add(ServerEndpointConfig.Builder.create(JSR356Endpoint.class, "/{path}").configurator(c).build()); }}; }</column><column name="report_time">2013-04-05 15:38:39</column><column name="report_timestamp">1365190000</column><column name="status">resolved fixed</column><column name="commit">0339fec</column><column name="commit_timestamp">1366400000</column><column name="files">java/org/apache/tomcat/websocket/server/WsServerContainer.java
test/org/apache/tomcat/websocket/server/TestWebSocketServerContainer.java</column><column name="result">1:java/org/apache/tomcat/websocket/server/WsServerContainer.java</column></table><table name="tomcat"><column name="id">148</column><column name="bug_id">54822</column><column name="summary">URL with Query String can't work over SPDY</column><column name="description">Created attachment 30173 Patch for SpdyProcessor I setup SPDY over tomcat 8. For normal URL such as https://localhost/test.jsp, it can work. However if the URL contains Query String, such as https://localhost/test.jsp?test=abc A SC_NOT_FOUND (404) will be given by Mapper. The root cause is SpdyProcessor missing the QueryString parsing. Attached a patch for it.</column><column name="report_time">2013-04-10 07:13:22</column><column name="report_timestamp">1365590000</column><column name="status">resolved fixed</column><column name="commit">3da2133</column><column name="commit_timestamp">1366380000</column><column name="files">java/org/apache/coyote/spdy/SpdyProcessor.java</column><column name="result">4:java/org/apache/coyote/spdy/SpdyProcessor.java</column></table><table name="tomcat"><column name="id">149</column><column name="bug_id">54851</column><column name="summary">Folder without web-fragment.xml should not impact the status of distributable</column><column name="description">Created attachment 30200 patch revision 889701 "JARs without any web.xml fragments should not impact the status of distributable" was applied to scan(JarURLConnection jarConn), but was not applied to scan(File file). I ran into this while trying to run cluster nodes from inside eclipse/wtp which supplies some folders to WebappClassLoader.addRepository(), e.g. &lt;another workspace project&gt;/classes. This causes the app to be marked as distributable=false, regardless of supplying the &lt;distributable/&gt; tag in the web.xml. The attached patch resolved the issue for me. Thanks.</column><column name="report_time">2013-04-16 08:47:44</column><column name="report_timestamp">1366120000</column><column name="status">resolved fixed</column><column name="commit">e97e158</column><column name="commit_timestamp">1366120000</column><column name="files">java/org/apache/catalina/startup/ContextConfig.java</column><column name="result">1:java/org/apache/catalina/startup/ContextConfig.java</column></table><table name="tomcat"><column name="id">150</column><column name="bug_id">54755</column><column name="summary">Type-based Endpoint's cannot be deployed by instance</column><column name="description">For type-based Endpoint's, WsServlet instantiates the Endpoint via reflection instead of using the Configurator as is done in PojoEndpointServer: sec.getConfigurator().getEndpointInstance(sec.getEndpointClass())</column><column name="report_time">2013-03-26 14:52:29</column><column name="report_timestamp">1364320000</column><column name="status">resolved fixed</column><column name="commit">d025179</column><column name="commit_timestamp">1364330000</column><column name="files">java/org/apache/tomcat/websocket/server/WsServlet.java</column><column name="result">7:java/org/apache/tomcat/websocket/server/WsServlet.java</column></table><table name="tomcat"><column name="id">151</column><column name="bug_id">54748</column><column name="summary">IOException in echo WebSocket example</column><column name="description">The IOException "New frame received after a close control frame" is raised after pressing Disconnect. The exception can be detected by adding an onError method to EchoEndpoint.</column><column name="report_time">2013-03-25 09:23:09</column><column name="report_timestamp">1364220000</column><column name="status">resolved fixed</column><column name="commit">cf0c064</column><column name="commit_timestamp">1364250000</column><column name="files">java/org/apache/tomcat/websocket/WsFrameBase.java
java/org/apache/tomcat/websocket/WsFrameClient.java
java/org/apache/tomcat/websocket/server/WsFrameServer.java</column><column name="result">24:java/org/apache/tomcat/websocket/WsFrameBase.java
50:java/org/apache/tomcat/websocket/WsFrameClient.java
69:java/org/apache/tomcat/websocket/server/WsFrameServer.java</column></table><table name="tomcat"><column name="id">152</column><column name="bug_id">54732</column><column name="summary">StatementCache interceptor does not forward calls to Statement.close() which causes memory leaks</column><column name="description">ML ref: http://mail-archives.apache.org/mod_mbox/tomcat-users/201303.mbox/browser When using Tomcat's jdbc-pool with the StatementCache interceptor (the default for TomEE 1.5.1), the actual java.sql.Statement.close() method is not called on the Statements. This causes severe memory leaks, at least with the MySQL driver. I see what could be a bug in StatementCache#closeInvoked() which is called by the above method. Here is the code with my own comments added: @Override public void closeInvoked() { boolean shouldClose = true; if (cacheSize.get() &lt; maxCacheSize) { // omitted for brievety } closed = true; // [1] I think "delegate = null" is done too soon delegate = null; if (shouldClose) { // check its body below super.closeInvoked(); } } // This is super.closeInvoked() public void closeInvoked() { if (getDelegate()!=null) { // never true when coming from // StatementCache#closeInvoked() // because of [1] try { getDelegate().close(); }catch (SQLException ignore) { } } closed = true; delegate = null; } To test this, step into org.apache.tomcat.jdbc.test.TestStatementCache tests testPreparedStatementCache and testPreparedStatementCache2. The calls to Statement.close() are intercepted but never forwarded to the actual Statement. Perhaps some kind of mock could be used to make sure Statement.close() is called on each created Statement.</column><column name="report_time">2013-03-20 16:09:31</column><column name="report_timestamp">1363810000</column><column name="status">resolved fixed</column><column name="commit">8cf47b4</column><column name="commit_timestamp">1363960000</column><column name="files">modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/interceptor/StatementCache.java
modules/jdbc-pool/src/test/java/org/apache/tomcat/jdbc/pool/interceptor/StatementCounterInterceptor.java
modules/jdbc-pool/src/test/java/org/apache/tomcat/jdbc/test/TestStatementCache.java</column><column name="result">1:modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/interceptor/StatementCache.java
8:modules/jdbc-pool/src/test/java/org/apache/tomcat/jdbc/test/TestStatementCache.java</column></table><table name="tomcat"><column name="id">153</column><column name="bug_id">54599</column><column name="summary">DataSource password is exposed to applications via toString method</column><column name="description">On the server side, create a DataSource using "org.apache.tomcat.jdbc.pool.DataSourceFactory". Ex: &lt;Resource auth="Container" description="" name="jdbc/testTomcatJdbc" factory="org.apache.tomcat.jdbc.pool.DataSourceFactory" type="javax.sql.DataSource" username="sa" password="super-secret" driverClassName="org.h2.Driver" url="jdbc:h2:mem:test" minIdle="1" initialSize="1" /&gt; In a web application, create a JSP file, add the following: &lt;%@ page import="javax.naming.*" session="false" %&gt; &lt;!DOCTYPE HTML&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;Display Password!&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;toString for Tomcat JDBC&lt;/h1&gt; &lt;% dataSource = (javax.sql.DataSource) ctx.lookup("java:/comp/env/jdbc/testTomcatJdbc"); out.println("&lt;p&gt;" + dataSource.toString() + "&lt;/p&gt;"); %&gt; &lt;/body&gt; &lt;/html&gt; Access the JSP in your browser. The output from toString on the DataSource will display the password that was configured in the &lt;Resource/&gt; tag. Example Output: toString for Tomcat JDBC org.apache.tomcat.jdbc.pool.DataSource@75cae120{ConnectionPool[defaultAutoCommit=null; defaultReadOnly=null; defaultTransactionIsolation=-1; defaultCatalog=null; driverClassName=org.h2.Driver; maxActive=100; maxIdle=100; minIdle=1; initialSize=1; maxWait=30000; testOnBorrow=false; testOnReturn=false; timeBetweenEvictionRunsMillis=5000; numTestsPerEvictionRun=0; minEvictableIdleTimeMillis=60000; testWhileIdle=false; testOnConnect=false; password=super-secret; url=jdbc:h2:mem:test; username=sa; validationQuery=null; validatorClassName=null; validationInterval=30000; accessToUnderlyingConnectionAllowed=true; removeAbandoned=false; removeAbandonedTimeout=60; logAbandoned=false; connectionProperties=null; initSQL=null; jdbcInterceptors=null; jmxEnabled=true; fairQueue=true; useEquals=true; abandonWhenPercentageFull=0; maxAge=0; useLock=false; dataSource=null; dataSourceJNDI=null; suspectTimeout=0; alternateUsernameAllowed=false; commitOnReturn=false; rollbackOnReturn=false; useDisposableConnectionFacade=true; logValidationErrors=false; propagateInterruptState=false; }</column><column name="report_time">2013-02-22 16:37:23</column><column name="report_timestamp">1361570000</column><column name="status">resolved fixed</column><column name="commit">8445d9a</column><column name="commit_timestamp">1363940000</column><column name="files">modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/PoolProperties.java</column><column name="result">2:modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/PoolProperties.java</column></table><table name="tomcat"><column name="id">154</column><column name="bug_id">54724</column><column name="summary">WsSession does not throw IllegalStateException if closed when methods on it are called</column><column name="description">Spec JavaDoc says: "Once the session is closed, it is no longer valid for use by applications. Calling any of its methods once the session has been closed will result in an IllegalStateException being thrown. Developers should retrieve any information from the session during the Endpoint.onClose(Session, CloseReason) method." Of course, the rules of Closeable also apply here, and calling Session#close(...) more than once should have no effect subsequent times. There are actually three problems here: 1) None of the methods throw IllegalStateException if the session is closed. Instead, they return things (like the basic remote, for example), and some methods in the endpoint implementation will not notice concurrent exceptions from the socket and then block forever waiting four the Countdown to clear. 2) The Session#state is never actually changed to State.CLOSED unless Session#onClose is called. However, Session#onClose is never actually called that I can find (though I will look harder before I make changes). 3) Even in Session#onClose, the state is incorrectly changed to State.CLOSED BEFORE Endpoint#onClose is called, when it should be changed AFTER. I'm working on a patch for this.</column><column name="report_time">2013-03-19 13:22:56</column><column name="report_timestamp">1363710000</column><column name="status">resolved fixed</column><column name="commit">12f89ff</column><column name="commit_timestamp">1363720000</column><column name="files">java/org/apache/tomcat/websocket/WsSession.java
test/org/apache/tomcat/websocket/TestWsWebSocketContainer.java</column><column name="result">7:java/org/apache/tomcat/websocket/WsSession.java
34:test/org/apache/tomcat/websocket/TestWsWebSocketContainer.java</column></table><table name="tomcat"><column name="id">155</column><column name="bug_id">54721</column><column name="summary">RemoteEndpoint blocks indefinitely if sendObject called with BinaryStream of TextStream encoders</column><column name="description">Created attachment 30076 Patch to resolve issue If I specify a j.w.Encoder.BinaryStream&lt;T&gt; or j.w.Encoder.TextStream&lt;T&gt; as the encoder for my endpoint, sendObject() never completes. This is because (A) sendObjectByCompletion does not close the OutputStream or Reader (methods that accept closeable resources as arguments should not close those resources; the calling method should) AND (B) onResult is never called on the SendHandler in sendObjectByCompletion for these two cases. Patch attached. Thread dump below. "http-nio-8080-exec-10@4030" daemon prio=5 tid=0x38 nid=NA waiting java.lang.Thread.State: WAITING 	 at sun.misc.Unsafe.park(Unsafe.java:-1) 	 at java.util.concurrent.locks.LockSupport.park(LockSupport.java:175) 	 at java.util.concurrent.locks.AbstractQueuedSynchronizer.parkAndCheckInterrupt(AbstractQueuedSynchronizer.java:834) 	 at java.util.concurrent.locks.AbstractQueuedSynchronizer.doAcquireSharedInterruptibly(AbstractQueuedSynchronizer.java:995) 	 at java.util.concurrent.locks.AbstractQueuedSynchronizer.acquireSharedInterruptibly(AbstractQueuedSynchronizer.java:1302) 	 at java.util.concurrent.CountDownLatch.await(CountDownLatch.java:231) 	 at org.apache.tomcat.websocket.WsRemoteEndpointImplBase$FutureToSendHandler.get(WsRemoteEndpointImplBase.java:703) 	 at org.apache.tomcat.websocket.WsRemoteEndpointImplBase$FutureToSendHandler.get(WsRemoteEndpointImplBase.java:666) 	 at org.apache.tomcat.websocket.WsRemoteEndpointImplBase.sendObject(WsRemoteEndpointImplBase.java:406) 	 at org.apache.tomcat.websocket.WsRemoteEndpointBasic.sendObject(WsRemoteEndpointBasic.java:74) 	 at com.wrox.chat.ChatEndpoint.onOpen(ChatEndpoint.java:92) 	 at sun.reflect.NativeMethodAccessorImpl.invoke0(NativeMethodAccessorImpl.java:-1) 	 at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57) 	 at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) 	 at java.lang.reflect.Method.invoke(Method.java:487) 	 at org.apache.tomcat.websocket.pojo.PojoEndpointBase.doOnOpen(PojoEndpointBase.java:51) 	 at org.apache.tomcat.websocket.pojo.PojoEndpointServer.onOpen(PojoEndpointServer.java:69) 	 at org.apache.tomcat.websocket.server.WsProtocolHandler.init(WsProtocolHandler.java:109) 	 at org.apache.coyote.http11.upgrade.AbstractProcessor.&lt;init&gt;(AbstractProcessor.java:51) 	 at org.apache.coyote.http11.upgrade.NioProcessor.&lt;init&gt;(NioProcessor.java:31) 	 at org.apache.coyote.http11.Http11NioProtocol$Http11ConnectionHandler.createUpgradeProcessor(Http11NioProtocol.java:309) 	 at org.apache.coyote.AbstractProtocol$AbstractConnectionHandler.process(AbstractProtocol.java:634) 	 at org.apache.coyote.http11.Http11NioProtocol$Http11ConnectionHandler.process(Http11NioProtocol.java:223) 	 at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1581) 	 at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.run(NioEndpoint.java:1540) 	 - locked &lt;0x13a6&gt; (a org.apache.tomcat.util.net.NioChannel) 	 at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1110) 	 at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:603) 	 at java.lang.Thread.run(Thread.java:722)</column><column name="report_time">2013-03-18 22:01:43</column><column name="report_timestamp">1363660000</column><column name="status">resolved fixed</column><column name="commit">80ef59a</column><column name="commit_timestamp">1363700000</column><column name="files">java/org/apache/tomcat/websocket/WsRemoteEndpointImplBase.java</column><column name="result">8:java/org/apache/tomcat/websocket/WsRemoteEndpointImplBase.java</column></table><table name="tomcat"><column name="id">156</column><column name="bug_id">54710</column><column name="summary">Java WebSocket specification says @OnMessage methods can have InputStream/Reader parameters; @OnClose can have CloseReason parameters</column><column name="description">Created attachment 30057 Patch to address issue Title pretty much explains it all. The specification says that @OnMessage methods may have an InputStream parameter (and no boolean parameter) for binary messages, or a Reader parameter (and no boolean parameter) for text messages. However, the current implementation does not support that; an IllegalArgumentException is thrown when Tomcat processes the endpoint annotations. Also, the specification says that @OnClose methods may have a CloseReason parameter, but the current implementation does not support that. It was difficult for me to separate these issues, so I have combined them and the patch for them.</column><column name="report_time">2013-03-17 09:59:10</column><column name="report_timestamp">1363530000</column><column name="status">resolved fixed</column><column name="commit">06800eb</column><column name="commit_timestamp">1363640000</column><column name="files">java/org/apache/tomcat/websocket/pojo/PojoEndpointBase.java
java/org/apache/tomcat/websocket/pojo/PojoMessageHandlerBase.java
java/org/apache/tomcat/websocket/pojo/PojoMessageHandlerPartialBase.java
java/org/apache/tomcat/websocket/pojo/PojoMessageHandlerPartialBinary.java
java/org/apache/tomcat/websocket/pojo/PojoMessageHandlerPartialText.java
java/org/apache/tomcat/websocket/pojo/PojoMessageHandlerWholeBase.java
java/org/apache/tomcat/websocket/pojo/PojoMessageHandlerWholeBinary.java
java/org/apache/tomcat/websocket/pojo/PojoMessageHandlerWholePong.java
java/org/apache/tomcat/websocket/pojo/PojoMessageHandlerWholeText.java
java/org/apache/tomcat/websocket/pojo/PojoMethodMapping.java</column><column name="result">9:java/org/apache/tomcat/websocket/pojo/PojoEndpointBase.java
10:java/org/apache/tomcat/websocket/pojo/PojoMethodMapping.java
15:java/org/apache/tomcat/websocket/pojo/PojoMessageHandlerWholeBase.java
22:java/org/apache/tomcat/websocket/pojo/PojoMessageHandlerWholePong.java
29:java/org/apache/tomcat/websocket/pojo/PojoMessageHandlerWholeText.java
31:java/org/apache/tomcat/websocket/pojo/PojoMessageHandlerWholeBinary.java
62:java/org/apache/tomcat/websocket/pojo/PojoMessageHandlerPartialBase.java
1164:java/org/apache/tomcat/websocket/pojo/PojoMessageHandlerBase.java
1187:java/org/apache/tomcat/websocket/pojo/PojoMessageHandlerPartialText.java
1198:java/org/apache/tomcat/websocket/pojo/PojoMessageHandlerPartialBinary.java</column></table><table name="tomcat"><column name="id">157</column><column name="bug_id">54709</column><column name="summary">Official schemes for WebSocket are "ws"/"wss"; WsWebSocketContainer only allows "http"/"https"</column><column name="description">Created attachment 30056 Patch to address issue According to the WebSocket specification RFC6455 [1], the official URI schemes for the WebSocket protocol are "ws" and "wss." However, o.a.t.websocket.WsWebSocketContainer#connectToServer(...) throws an exception if anything other than "http" or "https" are specified. I agree with allowing "http" and "https" for reasons of friendliness (although the correctness of this could be debated; I did not address that in my patch), but "ws" and "wss" should ALWAYS be allowed here. Also, one should be allowed to specify a port for EITHER ws/http OR wss/https. However, the way it was written, you could only specify a port for ws/http, and wss/https always tried to use 443 (I understand that SSL wasn't fully implemented here yet). Imagine the scenario where Tomcat is running on 8080/8443. You would need to specify 8443 as the wss/https port. I have attached a patch that addresses these issues. [1] http://tools.ietf.org/html/rfc6455#page-54</column><column name="report_time">2013-03-17 08:54:31</column><column name="report_timestamp">1363520000</column><column name="status">resolved fixed</column><column name="commit">ad148dd</column><column name="commit_timestamp">1363550000</column><column name="files">java/org/apache/tomcat/websocket/WsWebSocketContainer.java
test/org/apache/tomcat/websocket/TestWsRemoteEndpoint.java
test/org/apache/tomcat/websocket/TestWsWebSocketContainer.java
test/org/apache/tomcat/websocket/pojo/TestEncodingDecoding.java
test/org/apache/tomcat/websocket/pojo/TestPojoMethodMapping.java</column><column name="result">1:java/org/apache/tomcat/websocket/WsWebSocketContainer.java
47:test/org/apache/tomcat/websocket/TestWsWebSocketContainer.java
92:test/org/apache/tomcat/websocket/pojo/TestPojoMethodMapping.java
348:test/org/apache/tomcat/websocket/pojo/TestEncodingDecoding.java
407:test/org/apache/tomcat/websocket/TestWsRemoteEndpoint.java</column></table><table name="tomcat"><column name="id">158</column><column name="bug_id">54712</column><column name="summary">Prefer Locale.ENGLISH over Locale.US for case conversion</column><column name="description">Created attachment 30060 Convert Locale.US to Locale.ENGLISH in case conversion methods Case-conversion using toLowerCase or toUpperCase needs a Locale parameter to avoid using the default (with possibly unexpected results in some Locales). The code currently uses Locale.US in several places. However most of the code uses Locale.ENGLISH. The code should standardise on ENGLISH. Or perhaps consider using Locale.ROOT (@since 1.6)?</column><column name="report_time">2013-03-17 12:54:09</column><column name="report_timestamp">1363540000</column><column name="status">resolved fixed</column><column name="commit">dc16474</column><column name="commit_timestamp">1363530000</column><column name="files">java/org/apache/catalina/connector/Connector.java
java/org/apache/tomcat/util/buf/B2CConverter.java
java/org/apache/tomcat/util/http/parser/HttpParser.java
java/org/apache/tomcat/util/http/parser/MediaType.java
modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/PoolProperties.java
test/org/apache/catalina/startup/SimpleHttpClient.java</column><column name="result">26:java/org/apache/tomcat/util/http/parser/MediaType.java
42:java/org/apache/tomcat/util/buf/B2CConverter.java
44:modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/PoolProperties.java
46:java/org/apache/catalina/connector/Connector.java
152:java/org/apache/tomcat/util/http/parser/HttpParser.java
255:test/org/apache/catalina/startup/SimpleHttpClient.java</column></table><table name="tomcat"><column name="id">159</column><column name="bug_id">54631</column><column name="summary">@PathParam is not working with @OnMessage</column><column name="description">I have defined server end-point as: @ServerEndpoint(value = "/ws/{mid}/{rid}/{uid}") When using @PathParam with @OnMessage, values are null. Other annotations like @OnOpen and @OnClose print values specified in URL. @OnMessage public void onTextMessage(@PathParam("mid") Long mid, @PathParam("rid") Integer rid, @PathParam("uid") Long uid, Session session, String message, boolean pair) { 	log.debug("[TEXT]" + " : " + mid + " : " + rid + " : " + uid + message + " : " + session.getRequestURI()); }</column><column name="report_time">2013-03-04 05:03:35</column><column name="report_timestamp">1362390000</column><column name="status">resolved fixed</column><column name="commit">7fd7279</column><column name="commit_timestamp">1363380000</column><column name="files">test/org/apache/tomcat/websocket/pojo/TestPojoMethodMapping.java</column><column name="result" /></table><table name="tomcat"><column name="id">160</column><column name="bug_id">54702</column><column name="summary">File descriptor leak at web.xml loading</column><column name="description">Hello I think I've found a file descriptor leak in file /tomcat/trunk/java/org/apache/catalina/startup/ContextConfig.java (method getGlobalWebXmlSource). A stream is from file "web.xml" is not closed. private WebXml getDefaultWebXmlFragment() { ... 1284	 InputSource globalWebXml = getGlobalWebXmlSource(); ... 1337	 // Parse global web.xml if present 1338	 if (globalWebXml == null) { 1339	 // This is unusual enough to log 1340	 log.info(sm.getString("contextConfig.defaultMissing")); 1341	 } else { 1342	 parseWebXml(globalWebXml, webXmlDefaultFragment, false); 1343	 } Here is the full stack trace [java.io.FileInputStream.&lt;init&gt;(FileInputStream.java:109)] [org.apache.catalina.startup.ContextConfig.getWebXmlSource(ContextConfig.java:1837)] [org.apache.catalina.startup.ContextConfig.getGlobalWebXmlSource(ContextConfig.java:1744)] [org.apache.catalina.startup.ContextConfig.getDefaultWebXmlFragment(ContextConfig.java:1417)] [org.apache.catalina.startup.ContextConfig.webConfig(ContextConfig.java:1253)] [org.apache.catalina.startup.ContextConfig.configureStart(ContextConfig.java:878)] [org.apache.catalina.startup.ContextConfig.lifecycleEvent(ContextConfig.java:369)] [org.apache.catalina.util.LifecycleSupport.fireLifecycleEvent(LifecycleSupport.java:119)] [org.apache.catalina.util.LifecycleBase.fireLifecycleEvent(LifecycleBase.java:90)] [org.apache.catalina.core.StandardContext.startInternal(StandardContext.java:5173)] [org.apache.catalina.util.LifecycleBase.start(LifecycleBase.java:150)] [org.apache.catalina.core.ContainerBase.addChildInternal(ContainerBase.java:901)] [org.apache.catalina.core.ContainerBase.addChild(ContainerBase.java:877)] [org.apache.catalina.core.StandardHost.addChild(StandardHost.java:633)] [org.apache.catalina.startup.HostConfig.deployWAR(HostConfig.java:977)] [org.apache.catalina.startup.HostConfig.deployApps(HostConfig.java:542)] [org.apache.catalina.startup.HostConfig.check(HostConfig.java:1462)] [sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)] [sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)] [sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)] [java.lang.reflect.Method.invoke(Method.java:597)] [org.apache.tomcat.util.modeler.BaseModelMBean.invoke(BaseModelMBean.java:301)] [com.sun.jmx.interceptor.DefaultMBeanServerInterceptor.invoke(DefaultMBeanServerInterceptor.java:836)] [com.sun.jmx.mbeanserver.JmxMBeanServer.invoke(JmxMBeanServer.java:761)] [org.apache.catalina.manager.ManagerServlet.check(ManagerServlet.java:1445)] [org.apache.catalina.manager.HTMLManagerServlet.upload(HTMLManagerServlet.java:301)] [org.apache.catalina.manager.HTMLManagerServlet.doPost(HTMLManagerServlet.java:208)] [javax.servlet.http.HttpServlet.service(HttpServlet.java:647)] [javax.servlet.http.HttpServlet.service(HttpServlet.java:728)] [org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:305)] [org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:210)] [org.apache.catalina.filters.CsrfPreventionFilter.doFilter(CsrfPreventionFilter.java:213)] [org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:243)] [org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:210)] [org.apache.catalina.filters.SetCharacterEncodingFilter.doFilter(SetCharacterEncodingFilter.java:108)] [org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:243)] [org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:210)] [org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:222)] [org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:123)] [org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:581)] [org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:171)] [org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:99)] [org.apache.catalina.valves.AccessLogValve.invoke(AccessLogValve.java:931)] [org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:118)] [org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:407)] [org.apache.coyote.http11.AbstractHttp11Processor.process(AbstractHttp11Processor.java:1004)] [org.apache.coyote.AbstractProtocol$AbstractConnectionHandler.process(AbstractProtocol.java:589)] [org.apache.tomcat.util.net.AprEndpoint$SocketProcessor.run(AprEndpoint.java:1822)] [java.util.concurrent.ThreadPoolExecutor$Worker.runTask(ThreadPoolExecutor.java:886)] [java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:908)] [java.lang.Thread.run(Thread.java:662)]</column><column name="report_time">2013-03-15 08:53:36</column><column name="report_timestamp">1363350000</column><column name="status">resolved fixed</column><column name="commit">7c88af9</column><column name="commit_timestamp">1363360000</column><column name="files">java/org/apache/catalina/startup/ContextConfig.java</column><column name="result">1:java/org/apache/catalina/startup/ContextConfig.java</column></table><table name="tomcat"><column name="id">161</column><column name="bug_id">54658</column><column name="summary">Implement Part#getSubmittedFileName from SERVLET_SPEC-57</column><column name="description">Created attachment 30030 Implemented method http://java.net/jira/browse/SERVLET_SPEC-57 You will find a patch attached to complete this. - Added javax.servlet.http.Part#getSubmittedFileName - Added o.a.c.core.ApplicationPart#getSubmittedFileName - Deprecated o.a.c.core.ApplicationPart#getFilename and wrapped it around getSubmittedFileName - Changed o.a.c.connector.Request to use getSubmittedFileName instead of getFilename</column><column name="report_time">2013-03-09 21:46:36</column><column name="report_timestamp">1362880000</column><column name="status">resolved fixed</column><column name="commit">ca205c1</column><column name="commit_timestamp">1363290000</column><column name="files">java/javax/servlet/http/Part.java
java/org/apache/catalina/connector/Request.java
java/org/apache/catalina/core/ApplicationPart.java
java/org/apache/catalina/manager/HTMLManagerServlet.java</column><column name="result">1:java/javax/servlet/http/Part.java
2:java/org/apache/catalina/connector/Request.java
14:java/org/apache/catalina/manager/HTMLManagerServlet.java
52:java/org/apache/catalina/core/ApplicationPart.java</column></table><table name="tomcat"><column name="id">162</column><column name="bug_id">54660</column><column name="summary">AccessLogValve fileDateFormat can not be changed through JMX</column><column name="description">When an AccessLogValve is added to a catalina host with the JMX addVale() operation on the Host object name, the valve will start with the default fileDateFormat. Changing the attribute on the valve through it's JMX object name has no effect because the valve is already started. Executing a rotate() operation on the valve does also have no effect. Steps to Reproduce: - Start tomcat server - Add Host using JMX - Add valve to Host using JMX - Set valve attribute fileDateFormat to something else than yyyy-MM-dd, for example yy-MM Actual Results: The access log file format will include the default fileDateFormat of yyyy-MM-dd Expected Results: The access log file format with yy-MM, as from the example.</column><column name="report_time">2013-03-10 07:09:11</column><column name="report_timestamp">1362910000</column><column name="status">resolved fixed</column><column name="commit">2a03ca6</column><column name="commit_timestamp">1363280000</column><column name="files">java/org/apache/catalina/valves/AccessLogValve.java</column><column name="result">1:java/org/apache/catalina/valves/AccessLogValve.java</column></table><table name="tomcat"><column name="id">163</column><column name="bug_id">54690</column><column name="summary">HTTPS BIO/NIO connector does not enable TLS 1.1 and TLS 1.2 by default</column><column name="description">As users already noted [1], default HTTPS BIO/NIO connector in Tomcat 7.0.37 enables only SSLv3 and TLSv1, while Tomcat 6.0.36 enables SSLv3, TLSv1, TLSv1.1 and TLSv1.2. The reason for this change of behavior is that: 1. Tomcat 6, with default HTTPS connector configuration, does not call socket.setEnabledProtocols, thus enabling SSLv3, TLSv1, TLSv1.1 and TLSv1.2, while 2. Tomcat 7, with default HTTPS connector configuration, calls socket.setEnabledProtocols(enabledProtocols), where enabledProtocols is obtained with: context.getDefaultSSLParameters().getProtocols(). This, contrary to not calling setEnabledProtocols at all, results in enabling only SSLv3 and TLSv1. I propose that Tomcat 7 mimics Tomcat 6 behavior, and if attribute sslEnabledProtocols (in HTTPS connector in server.xml) is not set, then method socket.setEnabledProtocols is not invoked. Everything is tested with Oracle JDK 1.7.0_15. More details on post on Tomcat dev list [2]. [1] https://twitter.com/ivanristic/status/303798231920431104 [2] http://www.mail-archive.com/dev@tomcat.apache.org/msg71522.html</column><column name="report_time">2013-03-13 17:07:20</column><column name="report_timestamp">1363210000</column><column name="status">closed fixed</column><column name="commit">fedf189</column><column name="commit_timestamp">1363270000</column><column name="files">java/org/apache/tomcat/util/net/jsse/JSSESocketFactory.java</column><column name="result">7:java/org/apache/tomcat/util/net/jsse/JSSESocketFactory.java</column></table><table name="tomcat"><column name="id">164</column><column name="bug_id">54671</column><column name="summary">Spec says ServerContainerProvider#getServerContainer() should be public, but implemented package-private in Tomcat 8.0</column><column name="description">Created attachment 30039 Patch to resolve issue Fixed with attached patch.</column><column name="report_time">2013-03-11 22:31:14</column><column name="report_timestamp">1363060000</column><column name="status">resolved fixed</column><column name="commit">28c599f</column><column name="commit_timestamp">1363040000</column><column name="files">java/javax/websocket/server/ServerContainerProvider.java</column><column name="result">1:java/javax/websocket/server/ServerContainerProvider.java</column></table><table name="tomcat"><column name="id">165</column><column name="bug_id">54628</column><column name="summary">there is something wrong when send binary data by websocket.</column><column name="description">there is something wrong when send binary data by websocket. see org.apache.catalina.websocket.WsOutbound.doWriteBytes(ByteBuffer, boolean) I think // Write the content upgradeOutbound.write(buffer.array(), 0, buffer.limit()); upgradeOutbound.flush(); should change to : // Write the content upgradeOutbound.write(buffer.array(), buffer.arrayOffset(), buffer.limit()); upgradeOutbound.flush(); For example: byte[] bts = new byte[]{1,2,3,4,5} ByteBuffer bf = ByteBuffer.wrap(bts, 2, 2); out.writeBinaryMessage(bf); I mean write [3,4] to the client, but in fact [1,2,3,4] be sent;</column><column name="report_time">2013-03-02 08:37:25</column><column name="report_timestamp">1362230000</column><column name="status">resolved fixed</column><column name="commit">e1d16fd</column><column name="commit_timestamp">1362600000</column><column name="files">java/org/apache/catalina/websocket/WsOutbound.java</column><column name="result">1:java/org/apache/catalina/websocket/WsOutbound.java</column></table><table name="tomcat"><column name="id">166</column><column name="bug_id">54624</column><column name="summary">Form authenticator hangs on re-authentication of POST request behind mod_proxy_ajp</column><column name="description">Setup: Tomcat AJP connector behind mod_proxy_ajp, form-based authentication. When session expires and a POST request is submitted, Tomcat shows login form, user logs in, authenticator tries to restore the original POST request. Doing that, it tries to swallow the AJP message body before replacing the body of the request with the original POST request body. It tries to read the first 4 bytes of the AJP message (the message length) and blocks forever waiting for those 4 bytes.</column><column name="report_time">2013-02-28 21:44:55</column><column name="report_timestamp">1362110000</column><column name="status">resolved fixed</column><column name="commit">c9e056c</column><column name="commit_timestamp">1362600000</column><column name="files">java/org/apache/catalina/authenticator/FormAuthenticator.java</column><column name="result">4:java/org/apache/catalina/authenticator/FormAuthenticator.java</column></table><table name="tomcat"><column name="id">167</column><column name="bug_id">54612</column><column name="summary">Fatal Error when trying to send data to WebSocket with conection closed</column><column name="description">Created attachment 29997 Crash report by Java VM Occures: When try to send data to WebSocet using org.apache.catalina.websocket.WsOutbound but socket is closed and onClose method has not managed to work out and remove connection from the collection. Expected behavior: throw IOException; Actual behavior: Fatal Error EXCEPTION_ACCESS_VIOLATION Java: JDK-7.15 Tomcat: 7.0.37 Actual DLL version 1.1.27 (not 24) Note. This works well on Linux but crash Tomcat on Windows</column><column name="report_time">2013-02-27 06:32:43</column><column name="report_timestamp">1361960000</column><column name="status">resolved fixed</column><column name="commit">1255d32</column><column name="commit_timestamp">1362590000</column><column name="files">java/org/apache/catalina/websocket/WsOutbound.java</column><column name="result">15:java/org/apache/catalina/websocket/WsOutbound.java</column></table><table name="tomcat"><column name="id">168</column><column name="bug_id">54638</column><column name="summary">/manager/status?XML=true</column><column name="description">Hi all, in /manager/status?XML=true, informations about memory pools are incorrect. for every row all the values (initial,committed,maximum,used) are the same: Memory Pools Name:Eden Space	Type:Heap memory	Initial:143130624	Committed:143130624	Maximum:143130624	Used:143130624 Name:Survivor Space	Type:Heap memory	Initial:17891328	Committed:17891328	Maximum:17891328	Used:17891328 Name:Tenured Gen	Type:Heap memory	Initial:357957632	Committed:357957632	Maximum:357957632	Used:357957632 Name:Code Cache	Type:Non-heap memory	Initial:163840	Committed:8421376	Maximum:33554432	Used:163840 Name:Perm Gen	Type:Non-heap memory	Initial:12582912	Committed:23330816	Maximum:67108864	Used:12582912 Name:Perm Gen [shared-ro]	Type:Non-heap memory	Initial:10485760	Committed:10485760	Maximum:10485760	Used:10485760 Name:Perm Gen [shared-rw]	Type:Non-heap memory	Initial:12582912	Committed:12582912	Maximum:12582912	Used:12582912 Instead in the gui page values are correct.</column><column name="report_time">2013-03-05 12:29:57</column><column name="report_timestamp">1362500000</column><column name="status">resolved fixed</column><column name="commit">78b3c10</column><column name="commit_timestamp">1362530000</column><column name="files">java/org/apache/catalina/manager/StatusTransformer.java</column><column name="result">2:java/org/apache/catalina/manager/StatusTransformer.java</column></table><table name="tomcat"><column name="id">169</column><column name="bug_id">54585</column><column name="summary">WebappLoader doesn't honor delegate attr while constructing jsp_classpath</column><column name="description">If custom WebappClassLoader is created with delegate=true then parent-first classloading model is used. Everything works here as expected. However jsp_classpath is always constructed in the following manner: customWebappClassLoader.urls;parent.urls;parent...parent.urls Whereas it is expected to me that if delegate=true then parent's urls should come first.</column><column name="report_time">2013-02-19 20:50:13</column><column name="report_timestamp">1361330000</column><column name="status">resolved fixed</column><column name="commit">9ad4904</column><column name="commit_timestamp">1362010000</column><column name="files">java/org/apache/catalina/loader/WebappLoader.java</column><column name="result">2:java/org/apache/catalina/loader/WebappLoader.java</column></table><table name="tomcat"><column name="id">170</column><column name="bug_id">54602</column><column name="summary">B2CConverter character decode underflow leaves bytes in buffer</column><column name="description">If a request contains a uri that ends in a multi byte character which is missing a byte the extra bytes are left in a buffer which is reused by a future request. The problem comes from two different things: 1) If B2CConverter tries to convert a ByteChunk which ends in a character underflow it does not convert that last character and it is left in a buffer in B2CConver. 2) The B2CConverter in org.apache.catalina.connector.Request is not recycled with the rest of the objects. It looks like this is done intentionally based on the comment above it's declaration. The issue with B2CConverter can be demonstrated with the code below, which is a simplification of what is done inside of CoyoteAdapter.convertURI(): &lt;code&gt; B2CConverter conv = new B2CConverter("UTF-8"); ByteChunk bc = new ByteChunk(); CharChunk cc = new CharChunk(); byte[] bytes = { 0x61, 0x62, 0x63, 0x64, -8, -69, -73, -77 }; bc.append(bytes, 0, bytes.length); cc.allocate(bc.getLength(), -1); conv.convert(bc, cc, cc.getBuffer().length - cc.getEnd()); System.out.println(cc); cc.recycle(); bc.recycle(); bc.append(bytes, 0, bytes.length); cc.allocate(bc.getLength(), -1); conv.convert(bc, cc, cc.getBuffer().length - cc.getEnd()); System.out.println(cc); &lt;/code&gt; If the B2CConverter was recycled with everything else in Request this would prevent a previous request from corrupting the next request but it doesn't fix the issue that a character is dropped from the initial decode. I tried playing with B2CConverter and the only way I could get the convert to get everything was by ignoring the limit argument and reading to the end of the stream. It looks like tomcat8 is moving in this direction with the move to NIO, however I tried playing with the latest B2CConverter and was still seeing issues with the given byte sequence.</column><column name="report_time">2013-02-22 20:06:36</column><column name="report_timestamp">1361580000</column><column name="status">resolved fixed</column><column name="commit">b2f0e7c</column><column name="commit_timestamp">1361570000</column><column name="files">java/org/apache/catalina/connector/CoyoteAdapter.java</column><column name="result">1:java/org/apache/catalina/connector/CoyoteAdapter.java</column></table><table name="tomcat"><column name="id">171</column><column name="bug_id">54203</column><column name="summary">Part class missing documentation</column><column name="description">The Part class, at https://tomcat.apache.org/tomcat-7.0-doc/servletapi/javax/servlet/http/Part.html lacks any documentation of its methods.</column><column name="report_time">2012-11-25 09:02:17</column><column name="report_timestamp">1353850000</column><column name="status">resolved fixed</column><column name="commit">81eaf63</column><column name="commit_timestamp">1360750000</column><column name="files">java/javax/servlet/http/Part.java</column><column name="result">1:java/javax/servlet/http/Part.java</column></table><table name="tomcat"><column name="id">172</column><column name="bug_id">54552</column><column name="summary">Completed Servlet 3.1 spec for changeSessionId, HttpSessionIdListener</column><column name="description">Created attachment 29940 Patch to apply changes See attached diff and provide feedback, please. This should complete HttpServletRequest#changeSessionId(), HttpSessionIdListener.</column><column name="report_time">2013-02-12 13:56:32</column><column name="report_timestamp">1360700000</column><column name="status">resolved fixed</column><column name="commit">c11952d</column><column name="commit_timestamp">1360750000</column><column name="files">java/javax/servlet/http/HttpServletRequest.java
java/javax/servlet/http/HttpServletRequestWrapper.java
java/javax/servlet/http/HttpSessionIdListener.java
java/org/apache/catalina/connector/Request.java
java/org/apache/catalina/connector/RequestFacade.java
java/org/apache/catalina/core/ApplicationContext.java
java/org/apache/catalina/core/StandardContext.java
java/org/apache/catalina/ha/session/DeltaManager.java
java/org/apache/catalina/session/ManagerBase.java
java/org/apache/catalina/websocket/WsHttpServletRequestWrapper.java</column><column name="result">1:java/org/apache/catalina/ha/session/DeltaManager.java
3:java/org/apache/catalina/session/ManagerBase.java
7:java/org/apache/catalina/connector/Request.java
9:java/org/apache/catalina/core/StandardContext.java
18:java/javax/servlet/http/HttpServletRequest.java
43:java/org/apache/catalina/core/ApplicationContext.java
50:java/javax/servlet/http/HttpServletRequestWrapper.java
70:java/org/apache/catalina/websocket/WsHttpServletRequestWrapper.java
99:java/org/apache/catalina/connector/RequestFacade.java</column></table><table name="tomcat"><column name="id">173</column><column name="bug_id">54536</column><column name="summary">ErrorReportValve doesn't respect HttpServletResponse.sendError(int sc, String msg)</column><column name="description">The changes of the ErrorSupportValve introduced in catalina-v7.0.30 does not respect HttpServletResponse.sendError(int sc, String msg) because when a msg is provided with a status which is not present in the LocalStrings.properties of the 'org.apache.catalina.valves' package, the error page won't be forwarded to the response body. This issue was triggered due to the following change which was performed at revision 1348777: The change of the report = sm.getString("http." + statusCode, message); to report = sm.getString("http." + statusCode); results in 'report==null' for custom status codes returning a response without the error page body. if (report == null) { return; }</column><column name="report_time">2013-02-07 12:33:41</column><column name="report_timestamp">1360260000</column><column name="status">resolved fixed</column><column name="commit">ef9ed07</column><column name="commit_timestamp">1360700000</column><column name="files">java/org/apache/catalina/valves/ErrorReportValve.java
test/org/apache/catalina/valves/TestErrorReportValve.java</column><column name="result">1:java/org/apache/catalina/valves/ErrorReportValve.java
8:test/org/apache/catalina/valves/TestErrorReportValve.java</column></table><table name="tomcat"><column name="id">174</column><column name="bug_id">54239</column><column name="summary">Extensible EL Interpreter</column><column name="description">Created attachment 29684 Interface of ELInterpreter In some cases, applications need doing code generation for EL to make EL evaluation more faster. It's better for tomcat to provide an extensible EL Interpreter. So application can inject it's own ELInterpreter to replace the default JspUtil.interpreterCall. Attached an implementation.</column><column name="report_time">2012-12-04 06:56:18</column><column name="report_timestamp">1354620000</column><column name="status">resolved fixed</column><column name="commit">f8ac6a0</column><column name="commit_timestamp">1360680000</column><column name="files">java/org/apache/jasper/compiler/ELInterpreter.java
java/org/apache/jasper/compiler/ELInterpreterFactory.java
java/org/apache/jasper/compiler/Generator.java
test/org/apache/jasper/compiler/TestELInterpreterFactory.java</column><column name="result">76:java/org/apache/jasper/compiler/Generator.java</column></table><table name="tomcat"><column name="id">175</column><column name="bug_id">54456</column><column name="summary">ChunkedInputFilter returning EOF when client closes connection without sending end chunk</column><column name="description">Created attachment 29874 Patch to fix the bug In my case client is processing user's InputStream and then sending data in chunks to server. At server end I read till EOF. Client can be simple Java program or a web application. I am facing issue when client gets error on user's InputStream and closes connection with server. In that case ChunkedInputFilter is returning -1. I have added logs and confirmed that endChunk is false. Issue was fixed after I added following just before "return result;" if (result == -1 &amp;&amp; !endChunk) 			throw new EOFException("Unexpected end of stream while reading chunk body"); I think ChunkedInputFilter should return -1 only when it gets endChunk. Also, from client end I am always sending complete chunk. So, in ChunkedInputFilter I should get EOF from socket stream while reading next chunk header (which is handled properly in ChunkedInputFilter) but that is not happening. I have attached patch. Patch was generated against tomcat/tc7.0.x/trunk</column><column name="report_time">2013-01-21 16:45:51</column><column name="report_timestamp">1358800000</column><column name="status">resolved fixed</column><column name="commit">cc2f8db</column><column name="commit_timestamp">1360240000</column><column name="files">java/org/apache/coyote/http11/filters/ChunkedInputFilter.java</column><column name="result">1:java/org/apache/coyote/http11/filters/ChunkedInputFilter.java</column></table><table name="tomcat"><column name="id">176</column><column name="bug_id">54521</column><column name="summary">DigestAuthenticator: nonceCountValid() fails in case of simultaneous asynchronous requests of the same client</column><column name="description">Concerned components: org.apache.catalina.authenticator.DigestAuthenticator org.apache.catalina.authenticator.DigestAuthenticator.NonceInfo Scenario: A multithreaded client sends two requests within one millisecond. The DigestAuthenticator creates for each request a nonce as well as a NonceInfo instance. The two nonces are equal, as they were created within the same millisecond. When writing data into the cache (method generateNonce()), the second NonceInfo instance overwrites the first one (same key!). Problem: The two client threads then send a second request with a digest authentication header. In both requests, nc (nonce count) is equal 1, as the nonce has been newly created. In the NonceInfo of the first request, array seen is set to true for index ((nonceCount + offset) % seen.length). In the second request the same NonceInfo instance is used, as the instance is retrieved from map nonces using nonce as a key, that is, in both requests the same key is used. Consequently, method nonceCountValid() returns false, as seen[(nonceCount + offset) % seen.length)] has already been set to true. Therefore the authentication fails, although the client has sent a valid digest authentication header. Conclusion: Working with multi-threaded clients with many requests, digest authentication does not function reliably.</column><column name="report_time">2013-02-04 10:54:16</column><column name="report_timestamp">1359990000</column><column name="status">resolved fixed</column><column name="commit">b68bbb8</column><column name="commit_timestamp">1360230000</column><column name="files">java/org/apache/catalina/authenticator/DigestAuthenticator.java
test/org/apache/catalina/authenticator/TestDigestAuthenticator.java</column><column name="result">1:java/org/apache/catalina/authenticator/DigestAuthenticator.java
14:test/org/apache/catalina/authenticator/TestDigestAuthenticator.java</column></table><table name="tomcat"><column name="id">177</column><column name="bug_id">54534</column><column name="summary">JMX connection may load servlet with invalid ClassLoader</column><column name="description">Created attachment 29929 Project for reproduction of bug I've recently observed a bug in Tomcat 7 that is causing our servers to fail to start-up, with the root cause being that, in response to a JMX request, Tomcat 7 is loading our servlet on a Thread whose contextClassLoader is NOT that of the web application. This may lead to various problems; in our case, it leads to failure of Spring to find the requisite XSDs that are present in jars in our web app's WEB-INF/lib directory. Here is the stack trace that is reported for Tomcat7.0.35 + Spring 3.1.1: org.springframework.beans.factory.parsing.BeanDefinitionParsingException: Configuration problem: Unable to locate Spring NamespaceHandler for XML schema namespace [http://www.springframework.org/schema/context] Offending resource: ServletContext resource [/WEB-INF/spring-servlet.xml] 	at org.springframework.beans.factory.parsing.FailFastProblemReporter.error(FailFastProblemReporter.java:68) 	at org.springframework.beans.factory.parsing.ReaderContext.error(ReaderContext.java:85) 	at org.springframework.beans.factory.parsing.ReaderContext.error(ReaderContext.java:80) 	at org.springframework.beans.factory.xml.BeanDefinitionParserDelegate.error(BeanDefinitionParserDelegate.java:316) 	at org.springframework.beans.factory.xml.BeanDefinitionParserDelegate.parseCustomElement(BeanDefinitionParserDelegate.java:1416) 	at org.springframework.beans.factory.xml.BeanDefinitionParserDelegate.parseCustomElement(BeanDefinitionParserDelegate.java:1409) 	at org.springframework.beans.factory.xml.DefaultBeanDefinitionDocumentReader.parseBeanDefinitions(DefaultBeanDefinitionDocumentReader.java:184) 	at org.springframework.beans.factory.xml.DefaultBeanDefinitionDocumentReader.doRegisterBeanDefinitions(DefaultBeanDefinitionDocumentReader.java:140) 	at org.springframework.beans.factory.xml.DefaultBeanDefinitionDocumentReader.registerBeanDefinitions(DefaultBeanDefinitionDocumentReader.java:111) 	at org.springframework.beans.factory.xml.XmlBeanDefinitionReader.registerBeanDefinitions(XmlBeanDefinitionReader.java:493) 	at org.springframework.beans.factory.xml.XmlBeanDefinitionReader.doLoadBeanDefinitions(XmlBeanDefinitionReader.java:390) 	at org.springframework.beans.factory.xml.XmlBeanDefinitionReader.loadBeanDefinitions(XmlBeanDefinitionReader.java:334) 	at org.springframework.beans.factory.xml.XmlBeanDefinitionReader.loadBeanDefinitions(XmlBeanDefinitionReader.java:302) 	at org.springframework.beans.factory.support.AbstractBeanDefinitionReader.loadBeanDefinitions(AbstractBeanDefinitionReader.java:174) 	at org.springframework.beans.factory.support.AbstractBeanDefinitionReader.loadBeanDefinitions(AbstractBeanDefinitionReader.java:209) 	at org.springframework.beans.factory.support.AbstractBeanDefinitionReader.loadBeanDefinitions(AbstractBeanDefinitionReader.java:180) 	at org.springframework.web.context.support.XmlWebApplicationContext.loadBeanDefinitions(XmlWebApplicationContext.java:125) 	at org.springframework.web.context.support.XmlWebApplicationContext.loadBeanDefinitions(XmlWebApplicationContext.java:94) 	at org.springframework.context.support.AbstractRefreshableApplicationContext.refreshBeanFactory(AbstractRefreshableApplicationContext.java:131) 	at org.springframework.context.support.AbstractApplicationContext.obtainFreshBeanFactory(AbstractApplicationContext.java:522) 	at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:436) 	at org.springframework.web.servlet.FrameworkServlet.configureAndRefreshWebApplicationContext(FrameworkServlet.java:631) 	at org.springframework.web.servlet.FrameworkServlet.createWebApplicationContext(FrameworkServlet.java:588) 	at org.springframework.web.servlet.FrameworkServlet.createWebApplicationContext(FrameworkServlet.java:645) 	at org.springframework.web.servlet.FrameworkServlet.initWebApplicationContext(FrameworkServlet.java:508) 	at org.springframework.web.servlet.FrameworkServlet.initServletBean(FrameworkServlet.java:449) 	at org.springframework.web.servlet.HttpServletBean.init(HttpServletBean.java:133) 	at javax.servlet.GenericServlet.init(GenericServlet.java:160) 	at org.apache.catalina.core.StandardWrapper.initServlet(StandardWrapper.java:1274) 	at org.apache.catalina.core.StandardWrapper.loadServlet(StandardWrapper.java:1186) 	at org.apache.catalina.core.StandardWrapper.allocate(StandardWrapper.java:858) 	at org.apache.catalina.core.StandardWrapper.isSingleThreadModel(StandardWrapper.java:592) 	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) 	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) 	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25) 	at java.lang.reflect.Method.invoke(Method.java:597) 	at org.apache.tomcat.util.modeler.BaseModelMBean.getAttribute(BaseModelMBean.java:190) 	at org.apache.tomcat.util.modeler.BaseModelMBean.getAttributes(BaseModelMBean.java:234) 	at com.sun.jmx.interceptor.DefaultMBeanServerInterceptor.getAttributes(DefaultMBeanServerInterceptor.java:726) 	at com.sun.jmx.mbeanserver.JmxMBeanServer.getAttributes(JmxMBeanServer.java:665) 	at javax.management.remote.rmi.RMIConnectionImpl.doOperation(RMIConnectionImpl.java:1408) 	at javax.management.remote.rmi.RMIConnectionImpl.access$200(RMIConnectionImpl.java:72) 	at javax.management.remote.rmi.RMIConnectionImpl$PrivilegedOperation.run(RMIConnectionImpl.java:1265) 	at javax.management.remote.rmi.RMIConnectionImpl.doPrivilegedOperation(RMIConnectionImpl.java:1360) 	at javax.management.remote.rmi.RMIConnectionImpl.getAttributes(RMIConnectionImpl.java:636) 	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) 	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) 	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25) 	at java.lang.reflect.Method.invoke(Method.java:597) 	at sun.rmi.server.UnicastServerRef.dispatch(UnicastServerRef.java:303) 	at sun.rmi.transport.Transport$1.run(Transport.java:159) 	at java.security.AccessController.doPrivileged(Native Method) 	at sun.rmi.transport.Transport.serviceCall(Transport.java:155) 	at sun.rmi.transport.tcp.TCPTransport.handleMessages(TCPTransport.java:535) 	at sun.rmi.transport.tcp.TCPTransport$ConnectionHandler.run0(TCPTransport.java:790) 	at sun.rmi.transport.tcp.TCPTransport$ConnectionHandler.run(TCPTransport.java:649) 	at java.util.concurrent.ThreadPoolExecutor$Worker.runTask(ThreadPoolExecutor.java:886) 	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:908) 	at java.lang.Thread.run(Thread.java:680) I've attached a simple Maven-based WAR project that can reproduce this -- see the README for exact steps. In this case, the exception will occur, but after the artificially imposed 30 second delay completes, the servlet appears to load fine. In our actual systems, the servlet appears to remain in an incompletely loaded state. My hypothesis is that this is timing-related... if StandardWrapper.allocate does not complete before the main thread that is loading the web application correctly, then I think the main thread adds a reference to the mis-loaded servlet, and the subsequent deallocate call in StandardWrapper.isSingleThreadModel does not unload the servlet, causing it to remain in its impaired state. Please investigate this bug, since it is likely to affect users combining Tomcat + Spring WebMVC + JMX monitoring, which I believe to be a common use case.</column><column name="report_time">2013-02-06 19:14:48</column><column name="report_timestamp">1360200000</column><column name="status">resolved fixed</column><column name="commit">a993d7c2</column><column name="commit_timestamp">1360230000</column><column name="files">java/org/apache/catalina/core/StandardWrapper.java</column><column name="result">35:java/org/apache/catalina/core/StandardWrapper.java</column></table><table name="tomcat"><column name="id">178</column><column name="bug_id">54513</column><column name="summary">NullPointerException in AprEndpoint$Poller.run</column><column name="description">Trunk at r1441188, running the test suite with APR connector, Native 1.1.26 Windows 32-bit with JDK 7u11. I encountered the following when running org.apache.catalina.loader.TestVirtualContext test On second re-run of the test the same issue happened, so it is as if there is something specific here. I have not encountered the issue with the rest of testsuite yet. [[[ Feb 01, 2013 2:07:26 AM org.apache.tomcat.util.net.AprEndpoint$Poller run WARNING: Unexpected poller error java.lang.NullPointerException 	at org.apache.tomcat.util.net.AprEndpoint$AprSocketWrapper.access$200(AprEndpoint.java:2198) 	at org.apache.tomcat.util.net.AprEndpoint$Poller.run(AprEndpoint.java:1632) 	at java.lang.Thread.run(Thread.java:722) ]]] The code at AprEndpoint$Poller.run(AprEndpoint.java:1632) is 1628 for (int n = 0; n &lt; rv; n++) { 1629 timeouts.remove(desc[n*2+1]); 1630 AprSocketWrapper wrapper = connections.get( 1631 Long.valueOf(desc[n*2+1])); 1632 wrapper.pollerFlags = wrapper.pollerFlags &amp; ~((int) desc[n*2]); I suspect that "wrapper" is null here. The above code is specific to Tomcat trunk and is not present in 7.0.x. When this happened, the test hung for 15 minutes (1000 secs) waiting on a socket read. When time out passed, it continued to run all the other tests. [[[ Testcase: testAdditionalWebInfClassesPaths took 1006,735 sec 	Caused an ERROR Read timed out java.net.SocketTimeoutException: Read timed out 	at java.net.SocketInputStream.socketRead0(Native Method) 	at java.net.SocketInputStream.read(SocketInputStream.java:150) 	at java.net.SocketInputStream.read(SocketInputStream.java:121) 	at java.io.BufferedInputStream.fill(BufferedInputStream.java:235) 	at java.io.BufferedInputStream.read1(BufferedInputStream.java:275) 	at java.io.BufferedInputStream.read(BufferedInputStream.java:334) 	at sun.net.www.http.HttpClient.parseHTTPHeader(HttpClient.java:633) 	at sun.net.www.http.HttpClient.parseHTTP(HttpClient.java:579) 	at sun.net.www.protocol.http.HttpURLConnection.getInputStream(HttpURLConnection.java:1322) 	at java.net.HttpURLConnection.getResponseCode(HttpURLConnection.java:468) 	at org.apache.catalina.startup.TomcatBaseTest.methodUrl(TomcatBaseTest.java:247) 	at org.apache.catalina.startup.TomcatBaseTest.getUrl(TomcatBaseTest.java:219) 	at org.apache.catalina.startup.TomcatBaseTest.getUrl(TomcatBaseTest.java:213) 	at org.apache.catalina.startup.TomcatBaseTest.getUrl(TomcatBaseTest.java:202) 	at org.apache.catalina.loader.TestVirtualContext.assertPageContains(TestVirtualContext.java:326) 	at org.apache.catalina.loader.TestVirtualContext.assertPageContains(TestVirtualContext.java:320) 	at org.apache.catalina.loader.TestVirtualContext.testAdditionalWebInfClassesPaths(TestVirtualContext.java:311) ]]]</column><column name="report_time">2013-01-31 23:15:59</column><column name="report_timestamp">1359690000</column><column name="status">resolved fixed</column><column name="commit">bbb13f6</column><column name="commit_timestamp">1359840000</column><column name="files">java/org/apache/tomcat/util/net/AprEndpoint.java</column><column name="result">1:java/org/apache/tomcat/util/net/AprEndpoint.java</column></table><table name="tomcat"><column name="id">179</column><column name="bug_id">54497</column><column name="summary">RuntimeException in WebappClassLoader.checkThreadLocalMapForLeaks() causes LifecycleException</column><column name="description">Observed this when testing Tomcat trunk at r1438747, at WinXP 32-bit, JDK 7u11. (running TestWsWebSocketContainer with APR, Tomcat-Native 1.1.26 RC) There occurred an NPE in WebappClassLoader.checkThreadLocalMapForLeaks(). It was uncaught and caused LifecycleException and ultimately a failure to stop Tomcat. =============== In stderr: SEVERE: A child container failed during stop java.util.concurrent.ExecutionException: org.apache.catalina.LifecycleException: Failed to stop component [StandardEngine[Tomcat].StandardHost[localhost].StandardContext[]] 	at java.util.concurrent.FutureTask$Sync.innerGet(FutureTask.java:252) 	at java.util.concurrent.FutureTask.get(FutureTask.java:111) 	at org.apache.catalina.core.ContainerBase.stopInternal(ContainerBase.java:974) 	at org.apache.catalina.util.LifecycleBase.stop(LifecycleBase.java:232) 	at org.apache.catalina.core.ContainerBase$StopChild.call(ContainerBase.java:1404) 	at org.apache.catalina.core.ContainerBase$StopChild.call(ContainerBase.java:1393) 	at java.util.concurrent.FutureTask$Sync.innerRun(FutureTask.java:334) 	at java.util.concurrent.FutureTask.run(FutureTask.java:166) 	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1110) 	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:603) 	at java.lang.Thread.run(Thread.java:722) Caused by: org.apache.catalina.LifecycleException: Failed to stop component [StandardEngine[Tomcat].StandardHost[localhost].StandardContext[]] 	at org.apache.catalina.util.LifecycleBase.stop(LifecycleBase.java:236) 	... 7 more Caused by: org.apache.catalina.LifecycleException: Failed to stop component [WebappLoader[]] 	at org.apache.catalina.util.LifecycleBase.stop(LifecycleBase.java:236) 	at org.apache.catalina.core.StandardContext.stopInternal(StandardContext.java:5365) 	at org.apache.catalina.util.LifecycleBase.stop(LifecycleBase.java:232) 	... 7 more Caused by: java.lang.NullPointerException 	at sun.reflect.UnsafeFieldAccessorImpl.ensureObj(UnsafeFieldAccessorImpl.java:54) 	at sun.reflect.UnsafeObjectFieldAccessorImpl.get(UnsafeObjectFieldAccessorImpl.java:36) 	at java.lang.reflect.Field.get(Field.java:372) 	at org.apache.catalina.loader.WebappClassLoader.checkThreadLocalMapForLeaks(WebappClassLoader.java:2247) 	at org.apache.catalina.loader.WebappClassLoader.checkThreadLocalsForLeaks(WebappClassLoader.java:2188) 	at org.apache.catalina.loader.WebappClassLoader.clearReferences(WebappClassLoader.java:1731) 	at org.apache.catalina.loader.WebappClassLoader.stop(WebappClassLoader.java:1641) 	at org.apache.catalina.loader.WebappLoader.stopInternal(WebappLoader.java:491) 	at org.apache.catalina.util.LifecycleBase.stop(LifecycleBase.java:232) 	... 9 more =============== In testcase: Testcase: testSmallTextBufferClientTextMessage took 2,328 sec 	Caused an ERROR Failed to stop component [StandardServer[-1]] org.apache.catalina.LifecycleException: Failed to stop component [StandardServer[-1]] 	at org.apache.catalina.util.LifecycleBase.stop(LifecycleBase.java:236) 	at org.apache.catalina.startup.Tomcat.stop(Tomcat.java:336) 	at org.apache.catalina.startup.TomcatBaseTest.tearDown(TomcatBaseTest.java:163) Caused by: org.apache.catalina.LifecycleException: Failed to stop component [StandardService[Tomcat]] 	at org.apache.catalina.util.LifecycleBase.stop(LifecycleBase.java:236) 	at org.apache.catalina.core.StandardServer.stopInternal(StandardServer.java:766) 	at org.apache.catalina.util.LifecycleBase.stop(LifecycleBase.java:232) Caused by: org.apache.catalina.LifecycleException: Failed to stop component [StandardEngine[Tomcat]] 	at org.apache.catalina.util.LifecycleBase.stop(LifecycleBase.java:236) 	at org.apache.catalina.core.StandardService.stopInternal(StandardService.java:501) 	at org.apache.catalina.util.LifecycleBase.stop(LifecycleBase.java:232) Caused by: org.apache.catalina.LifecycleException: A child container failed during stop 	at org.apache.catalina.core.ContainerBase.stopInternal(ContainerBase.java:981) 	at org.apache.catalina.util.LifecycleBase.stop(LifecycleBase.java:232) =============== Thoughts: 1. We should catch throwables in those checkFor**Leaks methods. It should not cause a "failed to stop component" failure. 2. In that method there are many calls to "table[j]". The array member should be evaluated only once, so that it does not become null unexpectedly.</column><column name="report_time">2013-01-25 23:16:17</column><column name="report_timestamp">1359170000</column><column name="status">resolved fixed</column><column name="commit">ea16bda</column><column name="commit_timestamp">1359720000</column><column name="files">java/org/apache/catalina/loader/WebappClassLoader.java</column><column name="result">1:java/org/apache/catalina/loader/WebappClassLoader.java</column></table><table name="tomcat"><column name="id">180</column><column name="bug_id">54496</column><column name="summary">..tribes.membership.MemberImpl.toString() might be better using .getClass().getName()</column><column name="description">public String toString() { StringBuilder buf = new StringBuilder("org.apache.catalina.tribes.membership.MemberImpl["); Might be better to use .getClass().getName() to cover StaticMember and any other sub-classes that might arise.</column><column name="report_time">2013-01-25 18:34:53</column><column name="report_timestamp">1359160000</column><column name="status">resolved fixed</column><column name="commit">e1e4e4e</column><column name="commit_timestamp">1359390000</column><column name="files">java/org/apache/catalina/tribes/membership/MemberImpl.java</column><column name="result">1:java/org/apache/catalina/tribes/membership/MemberImpl.java</column></table><table name="tomcat"><column name="id">181</column><column name="bug_id">53869</column><column name="summary">Performance tuning solution to resolve too many cascaded JspContextWrapper issue</column><column name="description">Created attachment 29372 Patch for JspContextWrapper.java JspContextWrapper.getServletContext, JspContextWrapper.findAttribute and JspContextWrapper.getELContext take much time because there are many cascaded tag files. For example: &lt;tag1&gt; &lt;tag2&gt; &lt;tag3&gt; &lt;tag4/&gt; &lt;/tag3&gt; &lt;/tag2&gt; &lt;/tag1&gt; When calling JspContextWrapper(tag4).getServletContext from tag4, it will call JspContextWrapper(tag3).getServletContext --&gt; JspContextWrapper(tag2).getServletContext --&gt; JspContextWrapper(tag1).getServletContext --&gt; PageContext.getServletContext. If the root PageContext can be held in JspConextWrapper, those page,session,application scopes calling can go directy to this root PageContext. Please check out the attached diff file (JspContextWrapper.diff) to get more detail about this change.</column><column name="report_time">2012-09-13 13:56:24</column><column name="report_timestamp">1347560000</column><column name="status">resolved fixed</column><column name="commit">ce55f25</column><column name="commit_timestamp">1359120000</column><column name="files">java/org/apache/jasper/runtime/JspContextWrapper.java</column><column name="result">1:java/org/apache/jasper/runtime/JspContextWrapper.java</column></table><table name="tomcat"><column name="id">182</column><column name="bug_id">54476</column><column name="summary">incorrect param specification in javadoc ...tribes.group.GroupChannel send methods</column><column name="description">* @param destination Member[] - destination.length &gt; 1 I believe this should be: * @param destination Member[] - destination.length &gt; 0</column><column name="report_time">2013-01-23 20:05:14</column><column name="report_timestamp">1358990000</column><column name="status">resolved fixed</column><column name="commit">6647531</column><column name="commit_timestamp">1359020000</column><column name="files">java/org/apache/catalina/tribes/group/GroupChannel.java</column><column name="result">1:java/org/apache/catalina/tribes/group/GroupChannel.java</column></table><table name="tomcat"><column name="id">183</column><column name="bug_id">54466</column><column name="summary">No file name information in detail error when compiling the java file generated from a tag file</column><column name="description">Created attachment 29879 Patch for DefaultErrorHandler org.apache.jasper.JasperException: Unable to compile class for JSP: An error occurred at line: 634 in the generated java file Syntax error, insert "}" to complete Statement An error occurred at line: 644 in the generated java file Syntax error on tokens, delete these tokens Stacktrace: at org.apache.jasper.compiler.DefaultErrorHandler.javacError(DefaultErrorHandler.java:102) at org.apache.jasper.compiler.ErrorDispatcher.javacError(ErrorDispatcher.java:331) at org.apache.jasper.compiler.JDTCompiler.generateClass(JDTCompiler.java:473) at org.apache.jasper.compiler.Compiler.compile(Compiler.java:378) at org.apache.jasper.compiler.Compiler.compile(Compiler.java:353) at org.apache.jasper.compiler.Compiler.compile(Compiler.java:340) at org.apache.jasper.JspCompilationContext.compile(JspCompilationContext.java:646) at org.apache.jasper.servlet.JspServletWrapper.loadTagFile(JspServletWrapper.java:240) at org.apache.jasper.compiler.TagFileProcessor.loadTagFile(TagFileProcessor.java:578) at org.apache.jasper.compiler.TagFileProcessor.access$0(TagFileProcessor.java:518) at org.apache.jasper.compiler.TagFileProcessor$TagFileLoaderVisitor.visit(TagFileProcessor.java:655) at org.apache.jasper.compiler.Node$CustomTag.accept(Node.java:1539) at org.apache.jasper.compiler.Node$Nodes.visit(Node.java:2376) at org.apache.jasper.compiler.Node$Visitor.visitBody(Node.java:2428) at org.apache.jasper.compiler.TagFileProcessor$TagFileLoaderVisitor.visit(TagFileProcessor.java:659) at org.apache.jasper.compiler.Node$CustomTag.accept(Node.java:1539) at org.apache.jasper.compiler.Node$Nodes.visit(Node.java:2376) at org.apache.jasper.compiler.Node$Visitor.visitBody(Node.java:2428) at org.apache.jasper.compiler.TagFileProcessor$TagFileLoaderVisitor.visit(TagFileProcessor.java:659) at org.apache.jasper.compiler.Node$CustomTag.accept(Node.java:1539) at org.apache.jasper.compiler.Node$Nodes.visit(Node.java:2376) at org.apache.jasper.compiler.Node$Visitor.visitBody(Node.java:2428) at org.apache.jasper.compiler.Node$Visitor.visit(Node.java:2434) at org.apache.jasper.compiler.Node$Root.accept(Node.java:475) at org.apache.jasper.compiler.Node$Nodes.visit(Node.java:2376) at org.apache.jasper.compiler.TagFileProcessor.loadTagFiles(TagFileProcessor.java:673) at org.apache.jasper.compiler.Compiler.generateJava(Compiler.java:229) at org.apache.jasper.compiler.Compiler.compile(Compiler.java:373) at org.apache.jasper.compiler.Compiler.compile(Compiler.java:353) at org.apache.jasper.compiler.Compiler.compile(Compiler.java:340) at org.apache.jasper.JspCompilationContext.compile(JspCompilationContext.java:646) at org.apache.jasper.servlet.JspServletWrapper.loadTagFile(JspServletWrapper.java:240) at org.apache.jasper.compiler.TagFileProcessor.loadTagFile(TagFileProcessor.java:578) at org.apache.jasper.compiler.TagFileProcessor.access$0(TagFileProcessor.java:518) at org.apache.jasper.compiler.TagFileProcessor$TagFileLoaderVisitor.visit(TagFileProcessor.java:655) at org.apache.jasper.compiler.Node$CustomTag.accept(Node.java:1539) at org.apache.jasper.compiler.Node$Nodes.visit(Node.java:2376) at org.apache.jasper.compiler.Node$Visitor.visitBody(Node.java:2428) at org.apache.jasper.compiler.Node$Visitor.visit(Node.java:2434) at org.apache.jasper.compiler.Node$Root.accept(Node.java:475) at org.apache.jasper.compiler.Node$Nodes.visit(Node.java:2376) at org.apache.jasper.compiler.TagFileProcessor.loadTagFiles(TagFileProcessor.java:673) at org.apache.jasper.compiler.Compiler.generateJava(Compiler.java:229) at org.apache.jasper.compiler.Compiler.compile(Compiler.java:373) at org.apache.jasper.compiler.Compiler.compile(Compiler.java:353) at org.apache.jasper.compiler.Compiler.compile(Compiler.java:340) at org.apache.jasper.JspCompilationContext.compile(JspCompilationContext.java:646) at org.apache.jasper.servlet.JspServletWrapper.loadTagFile(JspServletWrapper.java:240) at org.apache.jasper.compiler.TagFileProcessor.loadTagFile(TagFileProcessor.java:578) at org.apache.jasper.compiler.TagFileProcessor.access$0(TagFileProcessor.java:518) at org.apache.jasper.compiler.TagFileProcessor$TagFileLoaderVisitor.visit(TagFileProcessor.java:655) at org.apache.jasper.compiler.Node$CustomTag.accept(Node.java:1539) at org.apache.jasper.compiler.Node$Nodes.visit(Node.java:2376) at org.apache.jasper.compiler.Node$Visitor.visitBody(Node.java:2428) at org.apache.jasper.compiler.TagFileProcessor$TagFileLoaderVisitor.visit(TagFileProcessor.java:659) at org.apache.jasper.compiler.Node$CustomTag.accept(Node.java:1539) at org.apache.jasper.compiler.Node$Nodes.visit(Node.java:2376) at org.apache.jasper.compiler.Node$Visitor.visitBody(Node.java:2428) at org.apache.jasper.compiler.TagFileProcessor$TagFileLoaderVisitor.visit(TagFileProcessor.java:659) at org.apache.jasper.compiler.Node$CustomTag.accept(Node.java:1539) at org.apache.jasper.compiler.Node$Nodes.visit(Node.java:2376) at org.apache.jasper.compiler.Node$Visitor.visitBody(Node.java:2428) at org.apache.jasper.compiler.Node$Visitor.visit(Node.java:2434) at org.apache.jasper.compiler.Node$Root.accept(Node.java:475) at org.apache.jasper.compiler.Node$Nodes.visit(Node.java:2376) at org.apache.jasper.compiler.TagFileProcessor.loadTagFiles(TagFileProcessor.java:673) at org.apache.jasper.compiler.Compiler.generateJava(Compiler.java:229) at org.apache.jasper.compiler.Compiler.compile(Compiler.java:373) at org.apache.jasper.compiler.Compiler.compile(Compiler.java:353) at org.apache.jasper.compiler.Compiler.compile(Compiler.java:340) at org.apache.jasper.JspCompilationContext.compile(JspCompilationContext.java:646) at org.apache.jasper.servlet.JspServletWrapper.loadTagFile(JspServletWrapper.java:240) at org.apache.jasper.compiler.TagFileProcessor.loadTagFile(TagFileProcessor.java:578) at org.apache.jasper.compiler.TagFileProcessor.access$0(TagFileProcessor.java:518) at org.apache.jasper.compiler.TagFileProcessor$TagFileLoaderVisitor.visit(TagFileProcessor.java:655) at org.apache.jasper.compiler.Node$CustomTag.accept(Node.java:1539) at org.apache.jasper.compiler.Node$Nodes.visit(Node.java:2376) at org.apache.jasper.compiler.Node$Visitor.visitBody(Node.java:2428) at org.apache.jasper.compiler.TagFileProcessor$TagFileLoaderVisitor.visit(TagFileProcessor.java:659) at org.apache.jasper.compiler.Node$CustomTag.accept(Node.java:1539) at org.apache.jasper.compiler.Node$Nodes.visit(Node.java:2376) at org.apache.jasper.compiler.Node$Visitor.visitBody(Node.java:2428) at org.apache.jasper.compiler.TagFileProcessor$TagFileLoaderVisitor.visit(TagFileProcessor.java:659) at org.apache.jasper.compiler.Node$CustomTag.accept(Node.java:1539) at org.apache.jasper.compiler.Node$Nodes.visit(Node.java:2376) at org.apache.jasper.compiler.Node$Visitor.visitBody(Node.java:2428) at org.apache.jasper.compiler.Node$Visitor.visit(Node.java:2434) at org.apache.jasper.compiler.Node$Root.accept(Node.java:475) at org.apache.jasper.compiler.Node$Nodes.visit(Node.java:2376) at org.apache.jasper.compiler.TagFileProcessor.loadTagFiles(TagFileProcessor.java:673) at org.apache.jasper.compiler.Compiler.generateJava(Compiler.java:229) at org.apache.jasper.compiler.Compiler.compile(Compiler.java:373) at org.apache.jasper.compiler.Compiler.compile(Compiler.java:353) at org.apache.jasper.compiler.Compiler.compile(Compiler.java:340) at org.apache.jasper.JspCompilationContext.compile(JspCompilationContext.java:646) at org.apache.jasper.servlet.JspServletWrapper.service(JspServletWrapper.java:357) at org.apache.jasper.servlet.JspServlet.serviceJspFile(JspServlet.java:390) at org.apache.jasper.servlet.JspServlet.service(JspServlet.java:334) at javax.servlet.http.HttpServlet.service(HttpServlet.java:668) at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:305) at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:210) at org.apache.catalina.core.ApplicationDispatcher.invoke(ApplicationDispatcher.java:684) at org.apache.catalina.core.ApplicationDispatcher.doInclude(ApplicationDispatcher.java:593) at org.apache.catalina.core.ApplicationDispatcher.include(ApplicationDispatcher.java:530) at com.ebay.raptor.web.JspPrecompileCommand.execute(JspPrecompileCommand.java:112) at com.ebay.raptor.web.JspPrecompileCommand.execute(JspPrecompileCommand.java:85) at com.ebay.raptor.web.RaptorFrontController.doPost(RaptorFrontController.java:216) at com.ebay.raptor.web.RaptorFrontController.doGet(RaptorFrontController.java:96) at javax.servlet.http.HttpServlet.service(HttpServlet.java:575) at javax.servlet.http.HttpServlet.service(HttpServlet.java:668) at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:305) at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:210) at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:225) at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:169) at org.apache.geronimo.tomcat.GeronimoStandardContext$SystemMethodValve.invoke(GeronimoStandardContext.java:731) at org.apache.geronimo.tomcat.valve.GeronimoBeforeAfterValve.invoke(GeronimoBeforeAfterValve.java:48) at org.apache.geronimo.tomcat.valve.ProtectedTargetValve.invoke(ProtectedTargetValve.java:53) at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:168) at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:98) at com.ebay.raptor.valve.RaptorDispatchValve.invoke(RaptorDispatchValve.java:53) at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:118) at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:407) at org.apache.coyote.http11.AbstractHttp11Processor.process(AbstractHttp11Processor.java:999) at org.apache.coyote.AbstractProtocol$AbstractConnectionHandler.process(AbstractProtocol.java:565) at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.run(NioEndpoint.java:1620) at org.apache.geronimo.pool.ThreadPool$1.run(ThreadPool.java:267) at org.apache.geronimo.pool.ThreadPool$ContextClassLoaderRunnable.run(ThreadPool.java:397) at java.util.concurrent.ThreadPoolExecutor$Worker.runTask(ThreadPoolExecutor.java:897) at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:919) at java.lang.Thread.run(Thread.java:736)</column><column name="report_time">2013-01-22 09:07:46</column><column name="report_timestamp">1358860000</column><column name="status">resolved fixed</column><column name="commit">d7f744c</column><column name="commit_timestamp">1358970000</column><column name="files">java/org/apache/jasper/compiler/DefaultErrorHandler.java</column><column name="result">10:java/org/apache/jasper/compiler/DefaultErrorHandler.java</column></table><table name="tomcat"><column name="id">184</column><column name="bug_id">54458</column><column name="summary">DataSourceRealm should provide more info on SQLException</column><column name="description">The getPassword() method of the DataSourceRealm does not log enough information when it encounters an SQL error. The catch block is: } catch(SQLException e) { containerLog.error( sm.getString("dataSourceRealm.getPassword.exception", username)); } finally { it would be really helpful to have some details of what the SQLException is. I am getting this intermittently, and have resorted to subclassing getPassword() in an attempt to figure out what is going wrong.</column><column name="report_time">2013-01-21 21:56:02</column><column name="report_timestamp">1358820000</column><column name="status">resolved fixed</column><column name="commit">07a930d</column><column name="commit_timestamp">1358960000</column><column name="files">java/org/apache/catalina/realm/DataSourceRealm.java</column><column name="result">1:java/org/apache/catalina/realm/DataSourceRealm.java</column></table><table name="tomcat"><column name="id">185</column><column name="bug_id">54450</column><column name="summary">Injection fails when part of the servlet properties uses @Resource and the other uses 'injection-target'</column><column name="description">Hi, I have a servlet with: - annotated properties - and injection-target declarations in web.xml When I try to request this servlet I receive: javax.naming.NameNotFoundException: Name [envEntry1] is not bound in this Context. Unable to find [envEntry1]. 	at org.apache.naming.NamingContext.lookup(NamingContext.java:820) 	at org.apache.naming.NamingContext.lookup(NamingContext.java:154) 	at org.apache.naming.NamingContext.lookup(NamingContext.java:831) 	at org.apache.naming.NamingContext.lookup(NamingContext.java:168) 	at org.apache.catalina.core.DefaultInstanceManager.lookupMethodResource(DefaultInstanceManager.java:622) 	at org.apache.catalina.core.DefaultInstanceManager.processAnnotations(DefaultInstanceManager.java:466) 	at org.apache.catalina.core.DefaultInstanceManager.newInstance(DefaultInstanceManager.java:157) 	at org.apache.catalina.core.DefaultInstanceManager.newInstance(DefaultInstanceManager.java:138) 	at org.apache.catalina.core.StandardWrapper.loadServlet(StandardWrapper.java:1137) 	at org.apache.catalina.core.StandardWrapper.allocate(StandardWrapper.java:858) 	at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:136) 	at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:123) 	at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:472) 	at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:171) 	at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:99) 	at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:118) 	at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:407) 	at org.apache.coyote.http11.AbstractHttp11Processor.process(AbstractHttp11Processor.java:1004) 	at org.apache.coyote.AbstractProtocol$AbstractConnectionHandler.process(AbstractProtocol.java:589) 	at org.apache.tomcat.util.net.JIoEndpoint$SocketProcessor.run(JIoEndpoint.java:310) 	at java.util.concurrent.ThreadPoolExecutor$Worker.runTask(ThreadPoolExecutor.java:886) 	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:908) 	at java.lang.Thread.run(Thread.java:680) The problem is that when the application uses 'injection-target' declarations in org.apache.catalina.core.DefaultInstanceManager.populateAnnotationsCache(Class&lt;?&gt;, Map&lt;String, String&gt;) only the first setter method is evaluated and the rest are skipped. I would like to propose a patch and test case. I'm looking forward to your comments. Regards Violeta</column><column name="report_time">2013-01-18 18:18:08</column><column name="report_timestamp">1358550000</column><column name="status">resolved fixed</column><column name="commit">ac78456</column><column name="commit_timestamp">1358940000</column><column name="files">java/org/apache/catalina/core/DefaultInstanceManager.java
test/org/apache/catalina/startup/TestContextConfig.java
test/org/apache/catalina/startup/TesterServletWithAnnotations.java</column><column name="result">1:java/org/apache/catalina/core/DefaultInstanceManager.java
69:test/org/apache/catalina/startup/TestContextConfig.java
463:test/org/apache/catalina/startup/TesterServletWithAnnotations.java</column></table><table name="tomcat"><column name="id">186</column><column name="bug_id">54448</column><column name="summary">Field of primitive type, annotated with @Resource is not recognized as env entry</column><column name="description">Hi, I have a servlet with one field of primitive type. The field is annotated with @Resource. public class MyServlet extends HttpServlet { @Resource(mappedName = "1") private int envEntry; protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { ... } } When I request this servlet I receive the following exception: SEVERE: Allocate exception for servlet MyServlet javax.naming.NamingException: Cannot create resource instance 	at org.apache.naming.factory.ResourceEnvFactory.getObjectInstance(ResourceEnvFactory.java:117) 	at javax.naming.spi.NamingManager.getObjectInstance(NamingManager.java:304) 	at org.apache.naming.NamingContext.lookup(NamingContext.java:843) 	at org.apache.naming.NamingContext.lookup(NamingContext.java:154) 	at org.apache.naming.NamingContext.lookup(NamingContext.java:831) 	at org.apache.naming.NamingContext.lookup(NamingContext.java:168) 	at org.apache.catalina.core.DefaultInstanceManager.lookupFieldResource(DefaultInstanceManager.java:581) 	at org.apache.catalina.core.DefaultInstanceManager.processAnnotations(DefaultInstanceManager.java:470) 	at org.apache.catalina.core.DefaultInstanceManager.newInstance(DefaultInstanceManager.java:157) 	at org.apache.catalina.core.DefaultInstanceManager.newInstance(DefaultInstanceManager.java:138) 	at org.apache.catalina.core.StandardWrapper.loadServlet(StandardWrapper.java:1137) 	at org.apache.catalina.core.StandardWrapper.allocate(StandardWrapper.java:858) 	at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:136) 	at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:123) 	at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:472) 	at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:171) 	at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:99) 	at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:118) 	at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:407) 	at org.apache.coyote.http11.AbstractHttp11Processor.process(AbstractHttp11Processor.java:1004) 	at org.apache.coyote.AbstractProtocol$AbstractConnectionHandler.process(AbstractProtocol.java:589) 	at org.apache.tomcat.util.net.JIoEndpoint$SocketProcessor.run(JIoEndpoint.java:310) 	at java.util.concurrent.ThreadPoolExecutor$Worker.runTask(ThreadPoolExecutor.java:886) 	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:908) 	at java.lang.Thread.run(Thread.java:680) That's because in the method below the primitive types are not 'converted' to their corresponding wrappers and this field is interpreted not as env entry but as resource env ref. org.apache.catalina.startup.WebAnnotationSet.addResource(Context, Resource, String, String) I'm attaching a patch that solves this issue and a test case. I'm looking forward to your comments. Regards Violeta</column><column name="report_time">2013-01-17 21:48:35</column><column name="report_timestamp">1358480000</column><column name="status">resolved fixed</column><column name="commit">74f5b3a</column><column name="commit_timestamp">1358940000</column><column name="files">java/org/apache/catalina/deploy/NamingResources.java
java/org/apache/catalina/startup/WebAnnotationSet.java
java/org/apache/catalina/util/Introspection.java
test/org/apache/catalina/startup/TestContextConfig.java
test/org/apache/catalina/startup/TesterServletWithAnnotations.java</column><column name="result">15:java/org/apache/catalina/startup/WebAnnotationSet.java
38:java/org/apache/catalina/deploy/NamingResources.java
57:test/org/apache/catalina/startup/TestContextConfig.java
109:java/org/apache/catalina/util/Introspection.java</column></table><table name="tomcat"><column name="id">187</column><column name="bug_id">54324</column><column name="summary">Support is required to disable TLS compression to prevent against CRIME attacks</column><column name="description">Support is required to disable TLS compression to prevent against CRIME attacks. Please see: https://community.qualys.com/blogs/securitylabs/2012/09/14/crime-information-leakage-attack-against-ssltls This security issue is flagged for Tomcat during PCI compliance scan.</column><column name="report_time">2012-12-18 21:51:15</column><column name="report_timestamp">1355890000</column><column name="status">resolved fixed</column><column name="commit">ab44514</column><column name="commit_timestamp">1358450000</column><column name="files">java/org/apache/coyote/http11/Http11AprProtocol.java
java/org/apache/tomcat/jni/SSL.java
java/org/apache/tomcat/util/net/AprEndpoint.java</column><column name="result">23:java/org/apache/tomcat/jni/SSL.java
66:java/org/apache/tomcat/util/net/AprEndpoint.java
76:java/org/apache/coyote/http11/Http11AprProtocol.java</column></table><table name="tomcat"><column name="id">188</column><column name="bug_id">54438</column><column name="summary">Bug fix 52953 introduces NullPointerException in RealmBase.java line 409 when user not found in JDBC</column><column name="description">The fix to bug 52953 introduces a NullPointerException at line 409 in RealBase.java For example compare: http://svn.apache.org/repos/asf/tomcat/tc7.0.x/tags/TOMCAT_7_0_26/java/org/apache/catalina/realm/RealmBase.java and http://svn.apache.org/repos/asf/tomcat/tc7.0.x/tags/TOMCAT_7_0_27/java/org/apache/catalina/realm/RealmBase.java String md5a1 = getDigest(username, realm); was changed to String md5a1 = getDigest(username, realm).toLowerCase(Locale.ENGLISH); If getDigest(username,realm) returns null if the user is not found and as a result you get a NPE when toLowerCase() is invoked on the null. I looked in the trunk, and the code hasn't changed. Seems like there should already be a bug posted on this as it makes digest authentication useless, but I can't find one!</column><column name="report_time">2013-01-16 21:14:31</column><column name="report_timestamp">1358390000</column><column name="status">resolved fixed</column><column name="commit">c8d5d88</column><column name="commit_timestamp">1358430000</column><column name="files">java/org/apache/catalina/realm/RealmBase.java</column><column name="result">1:java/org/apache/catalina/realm/RealmBase.java</column></table><table name="tomcat"><column name="id">189</column><column name="bug_id">54440</column><column name="summary">TagPluginManager.init() throws NPE when used in Ant &lt;jasper&gt; task</column><column name="description">In 7.0.35, I see the following NPE when compiling JSPX files via the &lt;jasper&gt; Ant task: [jasper] java.lang.NullPointerException [jasper] 	at org.apache.jasper.compiler.TagPluginManager.init(TagPluginManager.java:83) [jasper] 	at org.apache.jasper.compiler.TagPluginManager.apply(TagPluginManager.java:57) [jasper] 	at org.apache.jasper.compiler.Compiler.generateJava(Compiler.java:240) [jasper] 	at org.apache.jasper.compiler.Compiler.compile(Compiler.java:373) [jasper] 	at org.apache.jasper.JspC.processFile(JspC.java:1179) [jasper] 	at org.apache.jasper.JspC.execute(JspC.java:1329) [jasper] 	at org.apache.tools.ant.UnknownElement.execute(UnknownElement.java:291) [jasper] 	at sun.reflect.GeneratedMethodAccessor4.invoke(Unknown Source) [jasper] 	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) [jasper] 	at java.lang.reflect.Method.invoke(Method.java:601) [jasper] 	at org.apache.tools.ant.dispatch.DispatchUtils.execute(DispatchUtils.java:106) [jasper] 	at org.apache.tools.ant.Task.perform(Task.java:348) [jasper] 	at org.apache.tools.ant.Target.execute(Target.java:390) [jasper] 	at org.apache.tools.ant.Target.performTasks(Target.java:411) [jasper] 	at org.apache.tools.ant.Project.executeSortedTargets(Project.java:1399) [jasper] 	at org.apache.tools.ant.Project.executeTarget(Project.java:1368) [jasper] 	at org.apache.tools.ant.helper.DefaultExecutor.executeTargets(DefaultExecutor.java:41) [jasper] 	at org.apache.tools.ant.Project.executeTargets(Project.java:1251) [jasper] 	at org.apache.tools.ant.Main.runBuild(Main.java:809) [jasper] 	at org.apache.tools.ant.Main.startAnt(Main.java:217) [jasper] 	at org.apache.tools.ant.launch.Launcher.run(Launcher.java:280) [jasper] 	at org.apache.tools.ant.launch.Launcher.main(Launcher.java:109) This didn't happen in 7.0.34. Given the line and change from 7.0.34 (http://svn.apache.org/viewvc/tomcat/tc7.0.x/trunk/java/org/apache/jasper/compiler/TagPluginManager.java?r1=1402119&amp;r2=1431228&amp;diff_format=h) I assume that in... urls = ctxt.getClassLoader().getResources( 84	 	 META_INF_JASPER_TAG_PLUGINS_XML); the ClassLoader is null, since ctxt was used here before and evidently not null. Fall back to Thread.currentThread().getContextClassLoader() in this case? My Ant snippet: &lt;import file="${tomcat.home}/bin/catalina-tasks.xml"/&gt; ... &lt;jasper validateXml="false" failonerror="true" listerrors="true" trimspaces="true" uriroot="${module.web.basedir}/docs" outputDir="${module.web.basedir}/gen" package="*****" xpoweredBy="false"/&gt;</column><column name="report_time">2013-01-17 03:29:19</column><column name="report_timestamp">1358410000</column><column name="status">resolved fixed</column><column name="commit">297b26a</column><column name="commit_timestamp">1358430000</column><column name="files">java/org/apache/jasper/JspC.java
java/org/apache/jasper/servlet/JspCServletContext.java</column><column name="result">3:java/org/apache/jasper/JspC.java
261:java/org/apache/jasper/servlet/JspCServletContext.java</column></table><table name="tomcat"><column name="id">190</column><column name="bug_id">54406</column><column name="summary">NIO and BIO connectors handle unsupported SSL ciphers and sslEnabledProtocols differently</column><column name="description">The NIO and BIO connectors share (most of) a JSSE based SSLImplementation, but differ in their handling of the ciphers and sslEnabledProtocols attributes. The NIO connector sets the configured values for both attributes directly on the SSLEngine, which will fail immediately if any of them are unsupported. This makes creating a portable/superset collection of ciphers impossible - i.e. IBM JDKs do not support many of the cipher suite names used by JSSE and vice versa (usually TLS_ vs SSL_ prefixes differ) and the supported options differ between Java 6/7 etc. The BIO connector attempts to filter the specified values down to those supported by the SSL implementation, but has issues as well: if none of the specified ciphers/protocols are supported it will silently use the defaults of the SSL implementation, which can lead to unexpectedly (and unwittingly) insecure configurations. I propose to: - modify the NIO connector to use the same logic as the BIO connector to filter requested ciphers/protocols to supported values (by placing these operations on the SSLUtil interface). - modify the ciphers/protocols filtering logic to treat an explicit list of unsupported options as setting no supported ciphers/protocols and warn when this is done (it will also fail visibly with errors if SSL connections are attempted).</column><column name="report_time">2013-01-10 21:09:19</column><column name="report_timestamp">1357870000</column><column name="status">resolved fixed</column><column name="commit">9f657ac</column><column name="commit_timestamp">1358110000</column><column name="files">java/org/apache/tomcat/util/net/NioEndpoint.java
java/org/apache/tomcat/util/net/SSLUtil.java
java/org/apache/tomcat/util/net/jsse/JSSESocketFactory.java</column><column name="result">1:java/org/apache/tomcat/util/net/NioEndpoint.java
14:java/org/apache/tomcat/util/net/jsse/JSSESocketFactory.java
80:java/org/apache/tomcat/util/net/SSLUtil.java</column></table><table name="tomcat"><column name="id">191</column><column name="bug_id">54387</column><column name="summary">Having servlets with same url should at least cause warning</column><column name="description">I've found this interesting "mal functioning" in a application where I just copied the mapping portion of web.xml for a new created servlet, but forgot to change de URI. Tomcat deployed the application without any warning, but when running the application only the last referenced servlet was working (like if the mapping of the first has been overwritten by the last in the XML file). I made additional tests using annotations in servlets, and the behavior of having more than one servlet with same mapping causes random access to one or another (I cannot determine a predictable way). In order to prevent breaking existing applications, I would like to have just a "big warning" in the log at startup and/or deployment of the application that have more than one servlet mapped to same URL. Examples of the problem: Example 1: Web.xml ... &lt;servlet&gt; &lt;servlet-name&gt;PrintDacteServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;br.com.simfreteV1.web.PrintDacteServlet&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet&gt; &lt;servlet-name&gt;CotacaoReportServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;br.com.simfreteV1.web.CotacaoReportServlet&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;PrintDacteServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/secure/relatorios/Action&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;CotacaoReportServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/secure/relatorios/Action&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; ... Example 2: annotations in java servlet files @WebServlet(name = "PdfReportPrint", urlPatterns = {"/secure/relatorios/doReport"}) public class PdfReportPrint extends AbstractBaseServlet { ... @WebServlet(name = "PrintBoletoServlet", urlPatterns = {"/secure/relatorios/doReport"}) public class PrintBoletoServlet extends HttpServlet { ...</column><column name="report_time">2013-01-08 12:58:37</column><column name="report_timestamp">1357670000</column><column name="status">resolved fixed</column><column name="commit">334c466</column><column name="commit_timestamp">1357820000</column><column name="files">java/org/apache/catalina/deploy/WebXml.java
test/org/apache/catalina/deploy/TestWebXml.java</column><column name="result">1:java/org/apache/catalina/deploy/WebXml.java
751:test/org/apache/catalina/deploy/TestWebXml.java</column></table><table name="tomcat"><column name="id">192</column><column name="bug_id">54379</column><column name="summary">Implement support for post-construct and pre-destroy elements in web.xml</column><column name="description">There appears to be a feature that web[-fragment].xml file can contain such elements as &lt;post-construct&gt; and &lt;pre-destroy&gt;, and they are treated as equivalents to @PostConstruct and @PreDestroy annotations being present on the classes mentioned in them. This feature is 1. mentioned in the Java EE 6 Platform Specification, chapter "EE.5.2.5 Annotations and Injection" [1] 2. mentioned in chapter "8.2.3 Assembling the descriptor from web.xml, webfragment.xml and annotations", see points "k." and "l." on page 81 (103/230) of servlet-3_0-mrel-spec.pdf [1] javaee_platform-6_0-fr-spec.pdf http://jcp.org/aboutJava/communityprocess/final/jsr316/index.html An example can be found in Jetty wiki: http://wiki.eclipse.org/Jetty/Feature/Annotations#Lifecycle_callbacks:_PostConstruct_PreDestroy Searching by the tag names, I do not see any code in the current trunk that processes those XML elements.</column><column name="report_time">2013-01-07 04:07:15</column><column name="report_timestamp">1357550000</column><column name="status">resolved fixed</column><column name="commit">71d075e</column><column name="commit_timestamp">1357820000</column><column name="files">java/org/apache/catalina/Context.java
java/org/apache/catalina/core/DefaultInstanceManager.java
java/org/apache/catalina/core/StandardContext.java
java/org/apache/catalina/deploy/WebXml.java
java/org/apache/catalina/startup/FailedContext.java
java/org/apache/catalina/startup/WebRuleSet.java
java/org/apache/catalina/util/Introspection.java
test/org/apache/catalina/core/TestStandardContext.java
test/org/apache/catalina/core/TesterContext.java
test/org/apache/catalina/deploy/TestWebXml.java
test/org/apache/catalina/startup/TestContextConfig.java
test/org/apache/catalina/startup/TestWebRuleSet.java
test/org/apache/catalina/startup/TesterServletWithLifeCycleMethods.java</column><column name="result">1:java/org/apache/catalina/core/DefaultInstanceManager.java
2:java/org/apache/catalina/core/StandardContext.java
5:java/org/apache/catalina/deploy/WebXml.java
7:java/org/apache/catalina/Context.java
11:java/org/apache/catalina/startup/WebRuleSet.java
20:test/org/apache/catalina/startup/TestContextConfig.java
23:java/org/apache/catalina/startup/FailedContext.java
26:test/org/apache/catalina/core/TesterContext.java
156:test/org/apache/catalina/startup/TestWebRuleSet.java
297:test/org/apache/catalina/core/TestStandardContext.java
378:test/org/apache/catalina/deploy/TestWebXml.java
931:java/org/apache/catalina/util/Introspection.java</column></table><table name="tomcat"><column name="id">193</column><column name="bug_id">54382</column><column name="summary">Nullpointer Exception after activating SSI and loading of any html-file with a specific comment</column><column name="description">1. Activate SSI on Tomcat and restart Tomcat 2. create an any html-file with a comment like this "&lt;!--#--&gt;" 3. put this html-file to the webapp folder of tomcat 4. when you now go to the html file via tomcat, you will get an Nullpointer Exception. The SSIServlet.class and other necessary SSI-classes cannot be found</column><column name="report_time">2013-01-07 23:56:21</column><column name="report_timestamp">1357620000</column><column name="status">resolved fixed</column><column name="commit">d83a5e5</column><column name="commit_timestamp">1357680000</column><column name="files">java/org/apache/catalina/ssi/SSIProcessor.java</column><column name="result">10:java/org/apache/catalina/ssi/SSIProcessor.java</column></table><table name="tomcat"><column name="id">194</column><column name="bug_id">54381</column><column name="summary">Websocket StreamInbound never reports receipt of a Pong</column><column name="description">The tomcat websocket api now allows the send of a Ping frame by the server (as of 7.0.33), via WsOutbound, but never reports the receipt of a Pong. See StreamInbound in the onData() method... } else if (opCode == Constants.OPCODE_PONG) { // NO-OP } As the intended use of Pings is for heartbeat messages, allowing a Ping without informing the server extension of the returned Pong leaves out half the utility. I would suggest these changes to StreamInbound as a fix... 1) In the onData() method... } else if (opCode == Constants.OPCODE_PONG) { onPong(frame.getPayLoad()); } 2) Add a method onPong (ByteBuffer buffer)... protected void onPong(ByteBuffer buffer) { // NO-OP } ...which implementations may now override to handle Pong receipt and heartbeat logic. This is necessary as onData() is marked final, so there's no alternate workaround.</column><column name="report_time">2013-01-07 19:44:37</column><column name="report_timestamp">1357610000</column><column name="status">resolved fixed</column><column name="commit">5f7af1b</column><column name="commit_timestamp">1357680000</column><column name="files">java/org/apache/catalina/websocket/StreamHandler.java</column><column name="result">3:java/org/apache/catalina/websocket/StreamHandler.java</column></table><table name="tomcat"><column name="id">195</column><column name="bug_id">54377</column><column name="summary">RemoteIpFilter does not correctly set request attributes for AccessLog</column><column name="description">In RemoteIpFilter class, there is code that publishes the new request attributes to AccessLog (see below). 821 if (requestAttributesEnabled) { 822 request.setAttribute(AccessLog.REMOTE_ADDR_ATTRIBUTE, 823 request.getRemoteAddr()); 824 request.setAttribute(AccessLog.REMOTE_HOST_ATTRIBUTE, 825 request.getRemoteHost()); 826 request.setAttribute(AccessLog.PROTOCOL_ATTRIBUTE, 827 request.getProtocol()); 828 request.setAttribute(AccessLog.SERVER_PORT_ATTRIBUTE, 829 Integer.valueOf(request.getServerPort())); 830 } The problem is that the source values should come from xRequest, e.g. xRequest.getRemoteAddr() and xRequest.getRemoteHost(), etc. As it is written above, RemoteIpFilter simply republishes the current values, and AccessLog therefore does not display the correct values.</column><column name="report_time">2013-01-05 23:52:37</column><column name="report_timestamp">1357450000</column><column name="status">resolved fixed</column><column name="commit">95e6056</column><column name="commit_timestamp">1357680000</column><column name="files">java/org/apache/catalina/filters/RemoteIpFilter.java
test/org/apache/catalina/filters/TestRemoteIpFilter.java
test/org/apache/catalina/valves/TestRemoteIpValve.java</column><column name="result">1:java/org/apache/catalina/filters/RemoteIpFilter.java
3:test/org/apache/catalina/filters/TestRemoteIpFilter.java
24:test/org/apache/catalina/valves/TestRemoteIpValve.java</column></table><table name="tomcat"><column name="id">196</column><column name="bug_id">54380</column><column name="summary">In MapperListener.lifecycleEvent(..): check state of parent before calling registerWrapper()</column><column name="description">In r1429745 I added a test to trunk that test what happens if the first attempt to start a Context fails, the cause of the failure is removed, and then the context is started for the second time. The test is TestStandardContext.testBug46243(). It runs successfully, but the following message is logged: Jan 07, 2013 3:02:07 PM org.apache.catalina.mapper.Mapper addWrapper SEVERE: No context found: This happens when the context is started for the second time. If I put a breakpoint on the line that logs the message, the stack trace is (running Tomcat trunk): Mapper.addWrapper(String, String, String, String, Wrapper, boolean, boolean) line: 319	 MapperListener.registerWrapper(Wrapper) line: 417	 MapperListener.lifecycleEvent(LifecycleEvent) line: 433	 LifecycleSupport.fireLifecycleEvent(String, Object) line: 119	 Tomcat$ExistingStandardWrapper(LifecycleBase).fireLifecycleEvent(String, Object) line: 90	 Tomcat$ExistingStandardWrapper(LifecycleBase).setStateInternal(LifecycleState, Object, boolean) line: 402	 Tomcat$ExistingStandardWrapper(LifecycleBase).start() line: 168	 StandardContext.startInternal() line: 5009	 StandardContext(LifecycleBase).start() line: 150	 TestStandardContext.testBug46243() line: 109	 ================================================ My understanding is the following: 1. When Tomcat starts, registration into the mapper is performed by StandardService.startInternal(). Stack trace: Mapper.addHost(String, String[], Host) line: 89	 MapperListener.registerHost(Host) line: 287	 MapperListener.startInternal() line: 107	 MapperListener(LifecycleBase).start() line: 150	 StandardService.startInternal() line: 450	 StandardService(LifecycleBase).start() line: 150	 StandardServer.startInternal() line: 745	 StandardServer(LifecycleBase).start() line: 150	 TomcatBaseTest$TomcatWithFastSessionIDs(Tomcat).start() line: 326	 TomcatBaseTest$TomcatWithFastSessionIDs.start() line: 421	 TestStandardContext.testBug46243() line: 89	 2. The Context that failed to start is skipped by MapperListener.registerHost(), thanks to getState().isAvailable() check there. 3. The Mapper.addWrapper() call (the one that prints that "No context found" message) happens when AFTER_START_EVENT is processed for the Wrapper. At this moment the StandardContext.startInternal() has not completed yet and thus the context has not been registered by the mapper. 4. Nothing serious happens, besides the message, because when StandardContext.startInternal() completes, the AFTER_START_EVENT for the Context is processed. This is when the Context and the Wrappers that it contains are registered. Thus I think there should be a check either in MapperListener.lifecycleEvent() or in MapperListener.registerWrapper() that tests whether getContainer().getState().isAvailable() is true.</column><column name="report_time">2013-01-07 12:37:27</column><column name="report_timestamp">1357580000</column><column name="status">resolved fixed</column><column name="commit">3a9990b</column><column name="commit_timestamp">1357630000</column><column name="files">java/org/apache/catalina/mapper/MapperListener.java</column><column name="result">1:java/org/apache/catalina/mapper/MapperListener.java</column></table><table name="tomcat"><column name="id">197</column><column name="bug_id">54248</column><column name="summary">Retrieving content that contains a BOM via request.getReader() issue</column><column name="description">If a request contains Content that includes the BOM - in my case Content-Type: application/xml; charset-utf-16 - and the content has a BOM (FF FE), when fetched utilizing the BufferedReader from getReader() - the first request serviced on the AJP thread works correctly (encoded correctly, only characters fetched), however, any subsequent request on the thread which includes the BOM has the BOM being delivered to the application. It appears via review of the Tomcat code, that the recycle() method in B2CConverter simply ensures the socket's data has been completely flushed and the underlying InputStream doesn't get reset (don't really know if there is a way to do this without re-instantiating it) to ensure subsequent requests BOM is consumed. I proved this as a test by adding a call to reset() within the recycle() method which re-instantiates the underlying InputStreams and the problem resolved itself. I've temporarily resolved the issue in my application code by using request.getInputStream() and using request.getCharacterEncoding() and encoding the content inside my application.</column><column name="report_time">2012-12-05 11:56:08</column><column name="report_timestamp">1354730000</column><column name="status">resolved fixed</column><column name="commit">f7fc27a</column><column name="commit_timestamp">1357600000</column><column name="files">java/org/apache/tomcat/util/buf/B2CConverter.java
test/org/apache/tomcat/util/buf/TestB2CConverter.java</column><column name="result">11:java/org/apache/tomcat/util/buf/B2CConverter.java</column></table><table name="tomcat"><column name="id">198</column><column name="bug_id">54284</column><column name="summary">Util.objectNameValueNeedsQuote throws NPE for anonymous Filters</column><column name="description">How to reproduce? From inside the contextInitialized-Method of an ServletContextListener instance, call context.addFilter(null, new ArbitraryFilter(pathPrefix)).addMappingForUrlPatterns(null, false, pathPrefix); What happens? Dec 12, 2012 3:59:03 PM org.apache.catalina.core.StandardContext filterStart SEVERE: Exception starting filter null java.lang.NullPointerException at org.apache.tomcat.util.modeler.Util.objectNameValueNeedsQuote(Util.java:26) at org.apache.catalina.core.ApplicationFilterConfig.registerJMX(ApplicationFilterConfig.java:421) at org.apache.catalina.core.ApplicationFilterConfig.initFilter(ApplicationFilterConfig.java:282) at org.apache.catalina.core.ApplicationFilterConfig.&lt;init&gt;(ApplicationFilterConfig.java:108) at org.apache.catalina.core.StandardContext.filterStart(StandardContext.java:4650) at org.apache.catalina.core.StandardContext.startInternal(StandardContext.java:5306) at org.apache.catalina.util.LifecycleBase.start(LifecycleBase.java:150) at org.apache.catalina.core.ContainerBase.addChildInternal(ContainerBase.java:901) at org.apache.catalina.core.ContainerBase.addChild(ContainerBase.java:877) at org.apache.catalina.core.StandardHost.addChild(StandardHost.java:633) at org.apache.catalina.startup.HostConfig.deployDescriptor(HostConfig.java:657) at org.apache.catalina.startup.HostConfig$DeployDescriptor.run(HostConfig.java:1637) at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:471) at java.util.concurrent.FutureTask$Sync.innerRun(FutureTask.java:334) at java.util.concurrent.FutureTask.run(FutureTask.java:166) at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1110) at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:603) at java.lang.Thread.run(Thread.java:722) Dec 12, 2012 3:59:03 PM org.apache.catalina.core.StandardContext startInternal SEVERE: Error filterStart Dec 12, 2012 3:59:03 PM org.apache.catalina.core.StandardContext startInternal SEVERE: Context [] startup failed due to previous errors What should happen? Either - if null is not an allowed filter name, throw a IllegalArgumentException on context.addFilter(...) Or, if it is an allowed filter name, handle null-values gracefully</column><column name="report_time">2012-12-12 15:51:40</column><column name="report_timestamp">1355350000</column><column name="status">resolved fixed</column><column name="commit">113c0bd7</column><column name="commit_timestamp">1357590000</column><column name="files">java/org/apache/catalina/core/ApplicationContext.java
java/org/apache/catalina/deploy/FilterDef.java
java/org/apache/catalina/deploy/ServletDef.java
test/org/apache/catalina/core/TestApplicationContext.java
test/org/apache/catalina/deploy/TestFilterDef.java
test/org/apache/catalina/deploy/TestServletDef.java</column><column name="result">8:java/org/apache/catalina/core/ApplicationContext.java
208:java/org/apache/catalina/deploy/FilterDef.java
414:test/org/apache/catalina/core/TestApplicationContext.java
492:java/org/apache/catalina/deploy/ServletDef.java</column></table><table name="tomcat"><column name="id">199</column><column name="bug_id">54262</column><column name="summary">An empty &lt;absolute-ordering /&gt; should turn off all web-fragments</column><column name="description">The use of an &lt;absolute-ordering&gt; element does disable ServletContainerInitializer classpath scanning as discussed also in issue 53619. However, it does seem to require having at least one web-fragment name to be listed. In other words I would this: &lt;absolute-ordering /&gt; To turn off all web-fragments since none are named. A workaround is to list a web-fragment even if it doesn't exist but that shouldn't be necessary.</column><column name="report_time">2012-12-07 22:00:09</column><column name="report_timestamp">1354940000</column><column name="status">resolved fixed</column><column name="commit">5418e2b</column><column name="commit_timestamp">1357580000</column><column name="files">java/org/apache/catalina/deploy/WebXml.java
java/org/apache/catalina/startup/WebRuleSet.java
test/org/apache/catalina/startup/TestContextConfig.java</column><column name="result">3:java/org/apache/catalina/deploy/WebXml.java
4:java/org/apache/catalina/startup/WebRuleSet.java
44:test/org/apache/catalina/startup/TestContextConfig.java</column></table><table name="tomcat"><column name="id">200</column><column name="bug_id">54370</column><column name="summary">NPE mapping method in EL</column><column name="description">Created attachment 29808 Patch NPE when using null parameters in some cases: https://issues.jboss.org/browse/AS7-3177 I did put a workaround for it, but I don't know how legitimate it is. It looks a bit similar to the NPE with a null toString that got reverted, where a null object is used as an argument.</column><column name="report_time">2013-01-03 14:20:38</column><column name="report_timestamp">1357240000</column><column name="status">resolved fixed</column><column name="commit">5361e86</column><column name="commit_timestamp">1357230000</column><column name="files">java/org/apache/el/util/ReflectionUtil.java
test/org/apache/el/util/TestReflectionUtil.java
test/org/apache/el/util/Tester.java</column><column name="result">532:java/org/apache/el/util/ReflectionUtil.java</column></table><table name="tomcat"><column name="id">201</column><column name="bug_id">54260</column><column name="summary">JSP unloading - NullPointerException when using ".tag" files</column><column name="description">Since Tomcat 7.0.30 (currently using version 7.0.33) we are faced with the following NullPointerException: Dec 7, 2012 2:10:28 PM org.apache.catalina.core.ContainerBase$ContainerBackgroundProcessor processChildren SEVERE: Exception invoking periodic operation: java.lang.NullPointerException at org.apache.jasper.util.FastRemovalDequeue$Entry.access$700(FastRemovalDe queue.java:254) at org.apache.jasper.util.FastRemovalDequeue.remove(FastRemovalDequeue.java :177) at org.apache.jasper.compiler.JspRuntimeContext.checkUnload(JspRuntimeConte xt.java:610) at org.apache.jasper.servlet.JspServlet.periodicEvent(JspServlet.java:360) at org.apache.catalina.core.StandardWrapper.backgroundProcess(StandardWrapp er.java:709) at org.apache.catalina.core.ContainerBase$ContainerBackgroundProcessor.proc essChildren(ContainerBase.java:1530) at org.apache.catalina.core.ContainerBase$ContainerBackgroundProcessor.proc essChildren(ContainerBase.java:1540) at org.apache.catalina.core.ContainerBase$ContainerBackgroundProcessor.proc essChildren(ContainerBase.java:1540) at org.apache.catalina.core.ContainerBase$ContainerBackgroundProcessor.proc essChildren(ContainerBase.java:1540) at org.apache.catalina.core.ContainerBase$ContainerBackgroundProcessor.run( ContainerBase.java:1519) at java.lang.Thread.run(Thread.java:662) Investigation results: I was able to debug and trace the exception and found that the Excpetion is caused by a '.tag', I'm including in my JSP, which has no UnloadHandle assigned when processed in org.apache.jasper.compiler.JspRuntimeContext.checkUnload() line 610: jspQueue.remove(jsw.getUnloadHandle()); Because jsw.getUnloadHandle() returns null, jspQueue.remove() fails and is throwing the NullPointerException everytime, aborting the "unload". Reproducing the exceptiopn: It looks like the exception appears only when "maxLoadedJsps" and " jspIdleTimeout" are set to a value &gt;0 in tomcat/conf/web.xml and ".tag" files are used with jsp-scriptlets. Web.xml changes: &lt;init-param&gt; &lt;param-name&gt;maxLoadedJsps&lt;/param-name&gt; &lt;param-value&gt;1000&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;jspIdleTimeout&lt;/param-name&gt; &lt;param-value&gt;5&lt;/param-value&gt; &lt;/init-param&gt; The exception can be observed in the example "Tag Files" -&gt; "Display Products Example" but you have to edit the WEB-INF/tags/displayProducts.tag and append the following example scriptlet: &lt;% String test = "this is ="; if (normalPrice != null) test = test + normalPrice + " something"; else test = test + onSale + "="; StringBuilder tags=new StringBuilder(test); tags.append(".").append(test).append("..."); // change here test = tags.toString(); request.setAttribute("test", test); %&gt; &lt;%=test %&gt; Start Tomcat and invoke the example jsp http://localhost:8080/examples/jsp/jsp2/tagfiles/products.jsp Wait and observe the catalina.out (or tomcat output) for exceptions. Normaly the exception won't appear. Now edit the previously added scriplet in WEB-INF/tags/displayProducts.tag modifying any string in one of the append statements. Call the example jsp again, tomcat should recompile the tag, wait and observe again your tomcat output. Do not shutdown or restart tomcat between these steps! Tomcat should recompile the tag on the fly. We were able to reproduce the exception on Tomcat 7.0.30, 7.0.32 and 7.0.33 on different machines using the described steps.</column><column name="report_time">2012-12-07 17:58:25</column><column name="report_timestamp">1354920000</column><column name="status">resolved fixed</column><column name="commit">94da507</column><column name="commit_timestamp">1357220000</column><column name="files">java/org/apache/jasper/util/FastRemovalDequeue.java</column><column name="result">452:java/org/apache/jasper/util/FastRemovalDequeue.java</column></table><table name="tomcat"><column name="id">202</column><column name="bug_id">54256</column><column name="summary">Enhance Exception reporting on JAR file error</column><column name="description">(I posted this to the mailing list on Oct 28, 2011, but didn't end up creating a report on it until now. I have the same error with Tomcat 7.) PROBLEM DESCRIPTION: I have an exception (appended below), and I think it would be nice to have more information about what is going on. If I had more context, it would help me find the cause of my problem much more quickly. For example, if the exception indicated what the file/resource that was having the problem was, it would speed up troubleshooting immensely. HOW TO REPRODUCE: In a JAR file contained in WAR file's WEB-INF/lib folder: Change the MANIFEST.MF file in the JAR file. Put in a line with ONLY "Class-Path:". Note there is no space after the period, which is what causes the error. During load of the application, the exception which I have appended at the end of this message will show up. SUGGESTED IMPROVEMENT: My suggestion would be to modify ExtensionValidator.validateApplication(...), around line 195. This is the location that actually knows about what the resource is. It would be nice if the IOException was caught, and information about the Resource was added to the exception, probably by wrapping the exception. Because I have not gone through the overhead of getting a version of Tomcat running from source, these changes have not been compiled and tested, but I think the suggestion is relatively straight-forward. Here are the suggested code changes: First code change - move the definition of "resource" outside of the try/catch: // Locate the Manifests for all bundled JARs Resource resource = null; // ADDED NamingEnumeration&lt;Binding&gt; ne = null; Second code change - make the existing declaration of "resource" just an assignment: resource = (Resource) obj; // MODIFIED inputStream = resource.streamContent(); Manifest jmanifest = getManifest(inputStream); Third code change: add a catch clause and re-throw: } catch (NamingException nex) { // Jump out of the check for this application because it // has no resources } catch (IOException ioex) { // ADDED throw new IOException("validation problem in " + resource.toString(), ioex); // ADDED } finally { The problem is that the resource may not have a proper toString(). I would suggest changing FileDirContext:898 (inner class=FileResource) to have a toString method, something along the lines of: public String toString() { // ADDED return file == null ? "null" : file.toString(); // ADDED } // ADDED Note: about this, in the original email thread, Konstantin Kolinko said: "Not sure about FileResource.toString(), but adding a catch for IOException looks like doable." Finally, here's the exception: 28-Oct-2011 11:03:03 AM org.apache.catalina.core.StandardContext startInternal SEVERE: Error in dependencyCheck java.io.IOException: invalid header field at java.util.jar.Attributes.read(Attributes.java:410) at java.util.jar.Manifest.read(Manifest.java:199) at java.util.jar.JarInputStream.&lt;init&gt;(JarInputStream.java:83) at java.util.jar.JarInputStream.&lt;init&gt;(JarInputStream.java:60) at org.apache.catalina.util.ExtensionValidator.getManifest(ExtensionValidator.java:394) at org.apache.catalina.util.ExtensionValidator.validateApplication(ExtensionValidator.java:195) at org.apache.catalina.core.StandardContext.startInternal(StandardContext.java:5037) at org.apache.catalina.util.LifecycleBase.start(LifecycleBase.java:148) at org.apache.catalina.core.ContainerBase.startInternal(ContainerBase.java:1033) at org.apache.catalina.core.StandardHost.startInternal(StandardHost.java:774) at org.apache.catalina.util.LifecycleBase.start(LifecycleBase.java:148) at org.apache.catalina.core.ContainerBase.startInternal(ContainerBase.java:1033) at org.apache.catalina.core.StandardEngine.startInternal(StandardEngine.java:291) at org.apache.catalina.util.LifecycleBase.start(LifecycleBase.java:148) at org.apache.catalina.core.StandardService.startInternal(StandardService.java:443) at org.apache.catalina.util.LifecycleBase.start(LifecycleBase.java:148) at org.apache.catalina.core.StandardServer.startInternal(StandardServer.java:727) at org.apache.catalina.util.LifecycleBase.start(LifecycleBase.java:148) at org.apache.catalina.startup.Catalina.start(Catalina.java:621) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:616) at org.apache.catalina.startup.Bootstrap.start(Bootstrap.java:322) at org.apache.catalina.startup.Bootstrap.main(Bootstrap.java:450) (And if only java.util.jar.Attributes.read reported WHICH attribute had the problem, we'd really be in business.)</column><column name="report_time">2012-12-06 20:44:32</column><column name="report_timestamp">1354840000</column><column name="status">resolved fixed</column><column name="commit">0ae2f34</column><column name="commit_timestamp">1357160000</column><column name="files">java/org/apache/catalina/util/ExtensionValidator.java</column><column name="result">1:java/org/apache/catalina/util/ExtensionValidator.java</column></table><table name="tomcat"><column name="id">203</column><column name="bug_id">54247</column><column name="summary">Exception in JmxRemoteLifecycleListener.destroyServer</column><column name="description">Created attachment 29697 Tomcat log (first stop with service manager, second stop with shutdown port) Tomcat 7.0.33 is installed as Windows service and is using JDK 1.7.0_09. JmxRemoteLifecycleListener is used : &lt;Listener className="org.apache.catalina.mbeans.JmxRemoteLifecycleListener" 		rmiRegistryPortPlatform="8999" rmiServerPortPlatform="9999" /&gt; When Tomcat is stopped through the Windows service manager or the Common Daemon Service Manager, the JmxRemoteLifecycleListener listener fail to stop with the following exception : 05-Dec-2012 10:44:49.306 SEVERE [Thread-36] org.apache.catalina.mbeans.JmxRemoteLifecycleListener.destroyServer The JMX connector server could not be stopped for the Platform server java.io.IOException: Cannot bind to URL: javax.naming.NoInitialContextException: Cannot instantiate class: org.apache.naming.java.javaURLContextFactory [Root exception is java.lang.ClassNotFoundException: org/apache/naming/java/javaURLContextFactory] 	at javax.management.remote.rmi.RMIConnectorServer.newIOException(RMIConnectorServer.java:826) 	at javax.management.remote.rmi.RMIConnectorServer.stop(RMIConnectorServer.java:569) 	at org.apache.catalina.mbeans.JmxRemoteLifecycleListener.destroyServer(JmxRemoteLifecycleListener.java:282) 	at org.apache.catalina.mbeans.JmxRemoteLifecycleListener.lifecycleEvent(JmxRemoteLifecycleListener.java:226) 	at org.apache.catalina.util.LifecycleSupport.fireLifecycleEvent(LifecycleSupport.java:119) 	at org.apache.catalina.util.LifecycleBase.fireLifecycleEvent(LifecycleBase.java:90) 	at org.apache.catalina.util.LifecycleBase.setStateInternal(LifecycleBase.java:402) 	at org.apache.catalina.util.LifecycleBase.setState(LifecycleBase.java:347) 	at org.apache.catalina.core.StandardServer.stopInternal(StandardServer.java:748) 	at org.apache.catalina.util.LifecycleBase.stop(LifecycleBase.java:232) 	at org.apache.catalina.startup.Catalina.stopServer(Catalina.java:486) 	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) 	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57) 	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) 	at java.lang.reflect.Method.invoke(Method.java:601) 	at org.apache.catalina.startup.Bootstrap.stopServer(Bootstrap.java:371) 	at org.apache.catalina.startup.Bootstrap.main(Bootstrap.java:453) Caused by: javax.naming.NoInitialContextException: Cannot instantiate class: org.apache.naming.java.javaURLContextFactory [Root exception is java.lang.ClassNotFoundException: org/apache/naming/java/javaURLContextFactory] 	at javax.naming.spi.NamingManager.getInitialContext(NamingManager.java:674) 	at javax.naming.InitialContext.getDefaultInitCtx(InitialContext.java:307) 	at javax.naming.InitialContext.init(InitialContext.java:242) 	at javax.naming.InitialContext.&lt;init&gt;(InitialContext.java:216) 	at javax.management.remote.rmi.RMIConnectorServer.stop(RMIConnectorServer.java:558) 	... 15 more Caused by: java.lang.ClassNotFoundException: org/apache/naming/java/javaURLContextFactory 	at java.lang.Class.forName0(Native Method) 	at java.lang.Class.forName(Class.java:264) 	at com.sun.naming.internal.VersionHelper12.loadClass(VersionHelper12.java:63) 	at javax.naming.spi.NamingManager.getInitialContext(NamingManager.java:671) 	... 19 more If Tomcat is stopped through the use of the shutdown port, the JmxRemoteLifecycleListener listener stop gently.</column><column name="report_time">2012-12-05 10:00:36</column><column name="report_timestamp">1354720000</column><column name="status">resolved fixed</column><column name="commit">29c4a0e</column><column name="commit_timestamp">1357160000</column><column name="files">java/org/apache/catalina/startup/Bootstrap.java</column><column name="result">60:java/org/apache/catalina/startup/Bootstrap.java</column></table><table name="tomcat"><column name="id">204</column><column name="bug_id">54241</column><column name="summary">NPE in BodyContentImpl</column><column name="description">Created attachment 29688 Patch for BodyContentImpl.java Similar as BUG 35410, there is a NPE when calling BodyContentImpl#write(String) if the String is NULL.</column><column name="report_time">2012-12-04 07:53:25</column><column name="report_timestamp">1354630000</column><column name="status">resolved fixed</column><column name="commit">ffc4525</column><column name="commit_timestamp">1357140000</column><column name="files">java/org/apache/jasper/runtime/JspWriterImpl.java
test/org/apache/jasper/runtime/TestJspWriterImpl.java</column><column name="result">5:java/org/apache/jasper/runtime/JspWriterImpl.java</column></table><table name="tomcat"><column name="id">205</column><column name="bug_id">54194</column><column name="summary">NPE in DataSource.registerJmx() although DataSource is created with setJmxEnabled(false)</column><column name="description">Created attachment 29626 Patch against DataSource.java (rev 1412899) from /tomcat/tc7.0.x/trunk The exception does not seem to have any impact (at least not for my application) on the connection pools functionality , it's merely a minor annoyance. The attached patch fixed the problem for me. OS: Ubuntu 12.04 64-bit JDK: java version "1.7.0_09" Java(TM) SE Runtime Environment (build 1.7.0_09-b05) Java HotSpot(TM) 64-Bit Server VM (build 23.5-b02, mixed mode) Version of tomcat-jdbc.jar: 7.0.33 I create the datasource inside a custom ObjectFactory (because I need to retrieve JDBC URL/username/password from a config file on the classpath): Resources are configured inside tomcat/conf/context.xml as follows: ------------------------------------ &lt;Resource name="jdbc/db0" database="db0" auth="Container" type="javax.sql.DataSource" factory="my.DatasourceResourceFactory" /&gt; &lt;Resource name="jdbc/db1" database="db1" auth="Container" type="javax.sql.DataSource" factory="my.DatasourceResourceFactory" /&gt; ------------------------------------ I'm creating the datasource like so: ------------------------------------ private DataSource createDataSource(String jdbcUrl,String username,String password) { final PoolProperties p = new PoolProperties(); p.setUrl( jdbcUrl ); p.setDriverClassName("org.postgresql.Driver"); p.setUsername( username ); p.setPassword( password ); p.setJmxEnabled(false); // JMX disabled p.setTestWhileIdle(false); p.setTestOnBorrow(true); p.setValidationQuery("SELECT 1"); p.setTestOnReturn(false); p.setValidationInterval(30000); p.setInitialSize(5); p.setMaxActive(25); p.setMinIdle(0); p.setMaxIdle(8); p.setTimeBetweenEvictionRunsMillis(30000); p.setMinEvictableIdleTimeMillis(30000); p.setRemoveAbandonedTimeout(60); p.setLogAbandoned(false); p.setRemoveAbandoned(false); p.setJdbcInterceptors("org.apache.tomcat.jdbc.pool.interceptor.ConnectionState;org.apache.tomcat.jdbc.pool.interceptor.StatementFinalizer"); final DataSource datasource = new DataSource(); datasource.setPoolProperties(p); return datasource; } ------------------------------------ This is the exception showing up in the log file: ------------------------------------ 2012-11-23 14:53:48,109 [pool-2-thread-1] ERROR org.apache.tomcat.jdbc.pool.DataSource - Unable to register JDBC pool with JMX java.lang.NullPointerException at org.apache.tomcat.jdbc.pool.DataSource.registerJmx(DataSource.java:135) at org.apache.tomcat.jdbc.pool.DataSource.preRegister(DataSource.java:102) at org.apache.tomcat.util.modeler.BaseModelMBean.preRegister(BaseModelMBean.java:1132) at com.sun.jmx.interceptor.DefaultMBeanServerInterceptor.preRegister(DefaultMBeanServerInterceptor.java:1007) at com.sun.jmx.interceptor.DefaultMBeanServerInterceptor.registerDynamicMBean(DefaultMBeanServerInterceptor.java:919) at com.sun.jmx.interceptor.DefaultMBeanServerInterceptor.registerObject(DefaultMBeanServerInterceptor.java:900) at com.sun.jmx.interceptor.DefaultMBeanServerInterceptor.registerMBean(DefaultMBeanServerInterceptor.java:324) at com.sun.jmx.mbeanserver.JmxMBeanServer.registerMBean(JmxMBeanServer.java:512) at org.apache.tomcat.util.modeler.Registry.registerComponent(Registry.java:742) at org.apache.catalina.core.NamingContextListener.addResource(NamingContextListener.java:1062) at org.apache.catalina.core.NamingContextListener.createNamingContext(NamingContextListener.java:671) at org.apache.catalina.core.NamingContextListener.lifecycleEvent(NamingContextListener.java:270) at org.apache.catalina.util.LifecycleSupport.fireLifecycleEvent(LifecycleSupport.java:119) at org.apache.catalina.util.LifecycleBase.fireLifecycleEvent(LifecycleBase.java:90) at org.apache.catalina.core.StandardContext.startInternal(StandardContext.java:5161) at org.apache.catalina.util.LifecycleBase.start(LifecycleBase.java:150) at org.apache.catalina.core.ContainerBase.addChildInternal(ContainerBase.java:895) at org.apache.catalina.core.ContainerBase.addChild(ContainerBase.java:871) at org.apache.catalina.core.StandardHost.addChild(StandardHost.java:615) at org.apache.catalina.startup.HostConfig.deployWAR(HostConfig.java:958) at org.apache.catalina.startup.HostConfig$DeployWar.run(HostConfig.java:1599) at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:471) at java.util.concurrent.FutureTask$Sync.innerRun(FutureTask.java:334) at java.util.concurrent.FutureTask.run(FutureTask.java:166) at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1110) at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:603) at java.lang.Thread.run(Thread.java:722)</column><column name="report_time">2012-11-23 14:35:58</column><column name="report_timestamp">1353700000</column><column name="status">resolved fixed</column><column name="commit">1c61fb1</column><column name="commit_timestamp">1354600000</column><column name="files">modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/DataSource.java</column><column name="result">1:modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/DataSource.java</column></table><table name="tomcat"><column name="id">206</column><column name="bug_id">54150</column><column name="summary">SlowQueryReportJmx mbean deregistration failure due to NPE - properties not set during pool close callback</column><column name="description">Found while debugging version 7.0.29 I found that our SlowQueryReportJmx mbean was not being deregistered during webapp shutdown. I tracked this down to a NPE. The interceptor properties are not being set (as is done in setupConnection) prior to the pool close callback. ConnectionPool.close(boolean) poolClosed callback produces NPE in SlowQueryReportJmx. {code} PoolProperties.InterceptorDefinition[] proxies = getPoolProperties().getJdbcInterceptorsAsArray(); for (int i=0; i&lt;proxies.length; i++) { try { proxies[i].getInterceptorClass().newInstance().poolClosed(this); }catch (Exception x) { log.debug("Unable to inform interceptor of pool closure.",x); } } ... {code} NPE in SlowQueryReportJmx - null.containsKey {code} public ObjectName getObjectName(Class&lt;?&gt; clazz, String poolName) throws MalformedObjectNameException { ... NPE if (getProperties().containsKey(objectNameAttribute)) { ... {code} Sounds reasonable to set properties any time you need to instantiate interceptors. As is done in ConnectionPool.init(PoolConfiguration) {code} JdbcInterceptor interceptor = proxies[i].getInterceptorClass().newInstance(); interceptor.setProperties(proxies[i].getProperties()); interceptor.poolStarted(this); {code}</column><column name="report_time">2012-11-15 18:38:29</column><column name="report_timestamp">1353020000</column><column name="status">resolved fixed</column><column name="commit">b021a22</column><column name="commit_timestamp">1354600000</column><column name="files">modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/ConnectionPool.java</column><column name="result">2:modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/ConnectionPool.java</column></table><table name="tomcat"><column name="id">207</column><column name="bug_id">54220</column><column name="summary">ErrorReportValve invoked on non-error responses too</column><column name="description">If you issue a response.setStatus(404) from a servlet, you expect as per spec that the response is left untouched. No error page written. There is sendError for that. Unfortunately, ErrorReportValve reacts on line 158 &gt; if ((statusCode &lt; 400) || (response.getContentCount() &gt; 0)) &gt; return; If you take a look at the StandardHostValve, it invokes error handling on line 316 &gt; if (!response.isError()) &gt; return; On errors only (correct behavior). The ErrorReportValve must react on response.isError() == true only. Regardless of the status code or the content count. The Javadoc does not limit this to status codes &gt;= 400 but is says that reponse.sendError() has to clears buffers. As far I understand that, regardless of the response body is disposed and the error reponse is always written.</column><column name="report_time">2012-11-28 20:19:49</column><column name="report_timestamp">1354150000</column><column name="status">resolved fixed</column><column name="commit">a2d1441</column><column name="commit_timestamp">1354540000</column><column name="files">java/org/apache/catalina/valves/ErrorReportValve.java
test/org/apache/catalina/valves/TestErrorReportValve.java</column><column name="result">1:java/org/apache/catalina/valves/ErrorReportValve.java
105:test/org/apache/catalina/valves/TestErrorReportValve.java</column></table><table name="tomcat"><column name="id">208</column><column name="bug_id">54217</column><column name="summary">JDBC connection pool runs out of connections when Context reload=true is enabled in Tomcat</column><column name="description">Created attachment 29646 Exception stack trace I am developing a Java EE web application in Eclipse Juno. I have configured Tomcat to use JDBC connection pool (org.apache.tomcat.jdbc.pool) along with PostgreSQL database. Here are the configurations in my project's META-INF/context.xml: &lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;Context&gt; &lt;!-- Configuration for the Tomcat JDBC Connection Pool --&gt; &lt;Resource name="jdbc/someDB" type="javax.sql.DataSource" auth="Container" factory="org.apache.tomcat.jdbc.pool.DataSourceFactory" driverClassName="org.postgresql.Driver" url="jdbc:postgresql://localhost:5432/somedb" username="postgres" password="12345" maxActive="100" minIdle="10" initialSize="10" validatonQuery="SELECT 1" validationInterval="30000" removeAbandoned="true" removeAbandonedTimeout="60" abandonWhenPercentageFull="50" /&gt; &lt;/Context&gt; My application is deployed to Tomcat using Eclipse, and in Tomcat's context.xml an attribute reloadable is set to "true" to automatically reload the web application if a change is detected: &lt;Context reloadable="true"&gt; I have noticed that every time the above mentioned automatic reload is happening 10 more connections to PostgreSQL db is reserved (because in webapp's context.xml initialSize="10"). So after 10 changes a PSQLException is thrown: org.postgresql.util.PSQLException: FATAL: sorry, too many clients already ... (full stack in attachment) If I manually restart Tomcat - everything is fine and just 10 connections are reserved. And I am closing all ResultSets, Statements/PrepareStatements, Connections in the finally block. Would be great if this issue could be fixed, so that it could be possible to develop with reloadable set to "true" and not cause pooling more connections every time the context is reloaded. P.S. Apache Tomcat 7.0.32 Java(TM) SE Runtime Environment (build 1.7.0_09-b05) Eclipse Juno Service Release 1 PostgreSQL version 9.1 DB driver: postgresql-9.1-902.jdbc4.jar</column><column name="report_time">2012-11-28 10:35:43</column><column name="report_timestamp">1354120000</column><column name="status">resolved fixed</column><column name="commit">a81538d</column><column name="commit_timestamp">1354540000</column><column name="files">modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/ConnectionPool.java</column><column name="result">5:modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/ConnectionPool.java</column></table><table name="tomcat"><column name="id">209</column><column name="bug_id">54207</column><column name="summary">javaURLContextFactory javadoc refers to defunct package names in initial context properties</column><column name="description">Javadoc for org.apache.naming.java.javaURLContextFactory: /** * Context factory for the "java:" namespace. * &lt;p&gt; * &lt;b&gt;Important note&lt;/b&gt; : This factory MUST be associated with the "java" URL * prefix, which can be done by either : * &lt;ul&gt; * &lt;li&gt;Adding a * java.naming.factory.url.pkgs=org.apache.catalina.util.naming property * to the JNDI properties file&lt;/li&gt; * &lt;li&gt;Setting an environment variable named Context.URL_PKG_PREFIXES with * its value including the org.apache.catalina.util.naming package name. * More detail about this can be found in the JNDI documentation : * {@link javax.naming.spi.NamingManager#getURLContext(java.lang.String, java.util.Hashtable)}.&lt;/li&gt; * &lt;/ul&gt; * * @author Remy Maucherat * @version $Id$ */ org.apache.catalina.util.naming is a very old package name. The correct name for both TC6 and TC7 is org.apache.naming .</column><column name="report_time">2012-11-26 02:10:22</column><column name="report_timestamp">1353910000</column><column name="status">resolved fixed</column><column name="commit">d6b4740</column><column name="commit_timestamp">1353930000</column><column name="files">java/org/apache/naming/java/javaURLContextFactory.java</column><column name="result">1:java/org/apache/naming/java/javaURLContextFactory.java</column></table><table name="tomcat"><column name="id">210</column><column name="bug_id">54198</column><column name="summary">Improve HttpServletResponse#sendError(int) JavaDoc description</column><column name="description">This methods calls sendError(int, null) internally. Thus generating a HTML page without a message. This is not mentioned in the docs. One could assume that the response will be empty. One could duplicate the first paragraph of the sendError(int,String) method and alter it to "The server defaults to creating the response to look like an HTML-formatted server error page with any specific message, setting the content type to "text/html",..." further "If an error-page declaration has been made for the web application corresponding to the status code passed in, it will be served back." (Might need improvement in this case, I am not a native speaker). Moreover, I would add "This method is effectively the same as calling sendError(int, null)". Plus add @see #sendError(int,String). Though the JavaDocs seems to be a verbatim copy of Oracle's Servlet API, it does not reveal this information explicitly. Should I provide a patch if that doc is available in svn.apache.org?</column><column name="report_time">2012-11-23 22:33:12</column><column name="report_timestamp">1353730000</column><column name="status">resolved fixed</column><column name="commit">3c13e90</column><column name="commit_timestamp">1353930000</column><column name="files">java/javax/servlet/http/HttpServletResponse.java</column><column name="result">1:java/javax/servlet/http/HttpServletResponse.java</column></table><table name="tomcat"><column name="id">211</column><column name="bug_id">54144</column><column name="summary">Processing of java.io.Reader in "Out" tagplugin</column><column name="description">Reviewing r1401816 I see two issues in tagplugin o.a.jasper.tagplugins.jstl.core.Out: The code that the plugin generates calls value.toString(), default.toString() and passes these String values to the static method Out.output(...). This new method was added in r1401816. I think the output() method should accept Objects instead of Strings, because the following is wrong: 1. The evaluation of default.toString() is not needed at all if the default is not used. 2. The JSTL spec (1.1, 1.2) says that there is special processing if value is java.io.Reader. There is no such processing in the current code. (It seems that this feature was added in JSTL 1.1). [quote] If the result of the evaluation is not a java.io.Reader object, then it is coerced to a String and is subsequently emitted into the current JspWriter object. If the result of the evaluation is a java.io.Reader object, data is first read from the Reader object and then written into the current JspWriter object. [/quote] These two issues are not new - they existed before the recent changes.</column><column name="report_time">2012-11-14 08:38:29</column><column name="report_timestamp">1352900000</column><column name="status">resolved fixed</column><column name="commit">7c4a841</column><column name="commit_timestamp">1353110000</column><column name="files">java/org/apache/jasper/tagplugins/jstl/Util.java
java/org/apache/jasper/tagplugins/jstl/core/Out.java
test/org/apache/jasper/tagplugins/jstl/core/TestOut.java</column><column name="result">10:java/org/apache/jasper/tagplugins/jstl/core/Out.java
933:java/org/apache/jasper/tagplugins/jstl/Util.java</column></table><table name="tomcat"><column name="id">212</column><column name="bug_id">54143</column><column name="summary">Add display of PermGen memory pool usage to the Status page of the Manager webapp</column><column name="description">It would be nice to add display of the PermGen memory pool usage to the Status page of the Manager webapp. This is because OutOfMemoryError's caused by PermGen pool exhaustion are fatal for the server and are hard to predict, as they are are not visible from the simple Free/Max/Total Heap statistics. Technically speaking, the information is provided by "MemoryPool" MBeans. It is easier to display all memory pools at once rather than to search for specific one. The beans could be obtained via a query, e.g. [1], but it is much easier to use standard API that is available in Java SE [2]. [1] http://localhost:8080/manager/jmxproxy/?qry=java.lang%3Atype%3DMemoryPool%2C* [2] http://docs.oracle.com/javase/6/docs/api/java/lang/management/MemoryPoolMXBean.html I have an implementation ready and will commit it shortly. A small question is whether it is suitable for the simple "Server Status" page or is better for the "Complete Server Status" one. I think it is OK on the simple page, as this information is important.</column><column name="report_time">2012-11-13 22:39:44</column><column name="report_timestamp">1352860000</column><column name="status">resolved fixed</column><column name="commit">9998c80</column><column name="commit_timestamp">1352850000</column><column name="files">java/org/apache/catalina/manager/StatusTransformer.java</column><column name="result">18:java/org/apache/catalina/manager/StatusTransformer.java</column></table><table name="tomcat"><column name="id">213</column><column name="bug_id">54141</column><column name="summary">Configuration does not allow Realms to be nested more than 2 levels deep</column><column name="description">The use case is to have one Realm that is configured for lock-out with another that is not: the two should be combined together. The obvious configuration attempt is this: &lt;CombinedRealm&gt; &lt;LockoutRealm&gt; &lt;DataSourceRealm/&gt; &lt;/LockoutRealm&gt; &lt;UserDatabaseRealm/&gt; &lt;/CombinedRealm&gt; Unfortunately, this configuration yields an error: No rules found matching 'Server/Service/Engine/Realm/Realm/Realm' org.apache.catalina.startup.RealmRuleSet.addRuleInstances only goes 2 levels deep when it comes to Realms (that is, only allows "Realm" and "Realm/Realm"). Adding a 3rd level would certainly work here and might be sufficient. Another option would be to configure the digester to allow arbitrary levels of Realm-nesting for even the most pathological cases. For reference, see this link to a question over on StackOverflow: http://stackoverflow.com/questions/13274696/tomcat-7-nesting-combinedrealm-lockoutrealm-and-datasourcerealm</column><column name="report_time">2012-11-13 01:55:35</column><column name="report_timestamp">1352790000</column><column name="status">resolved fixed</column><column name="commit">2ed3d7d</column><column name="commit_timestamp">1352820000</column><column name="files">java/org/apache/catalina/startup/RealmRuleSet.java</column><column name="result">32:java/org/apache/catalina/startup/RealmRuleSet.java</column></table><table name="tomcat"><column name="id">214</column><column name="bug_id">54087</column><column name="summary">HTTP Connector incorrectly throws Exception on Invalid If-Modified-Since Header</column><column name="description">Given this request: Frame 6: 988 bytes on wire (7904 bits), 988 bytes captured (7904 bits) Ethernet II, Src: Adtran_16:34:e9 (00:a0:c8:16:34:e9), Dst: Supermic_34:fe:a8 (00:30:48:34:fe:a8) Internet Protocol Version 4, Src: 198.58.103.28 (198.58.103.28), Dst: 216.17.130.68 (216.17.130.68) Transmission Control Protocol, Src Port: 37483 (37483), Dst Port: http (80), Seq: 1449, Ack: 1, Len: 922 [2 Reassembled TCP Segments (2370 bytes): #4(1448), #6(922)] Hypertext Transfer Protocol GET /rss/calendar_id/2.xml HTTP/1.1\r\n Accept: application/atom+xml,application/rdf+xml,application/rss+xml,application/xml,text/xml,*/*\r\n Connection: close\r\n Accept-Encoding: gzip,deflate\r\n User-Agent: Superfeedr bot/2.0 http://superfeedr.com - Please get in touch if we are polling too hard.\r\n X-Superfeedr-Url: http://startupia.mhsoftware.com/rss/calendar_id/2.xml\r\n If-None-Match: "1351656000000"\r\n If-Modified-Since: 2012-10-31 04:00:00 +0000\r\n host: startupia.mhsoftware.com\r\n ofu.dpn=ffffffffc3a03c0245525d5f4f58455e445a4a4236 \r\n [Full request URI: http://startupia.mhsoftware.com/rss/calendar_id/2.xml] ~ Tomcat Throws the Exception: 2012-10-31 15:47:15,381 [http-80-46] ERROR org.apache.catalina.core.ContainerBase.[Catalina].[startupia.mhsoftware.com].[/].[RSSProcessor]- Servlet.service() for servlet RSSProcessor threw exception java.lang.IllegalArgumentException: 2012-10-31 04:00:00 +0000 at org.apache.catalina.connector.Request.getDateHeader(Request.java:1924) at org.apache.catalina.connector.RequestFacade.getDateHeader(RequestFacade.java:632) at javax.servlet.http.HttpServlet.service(HttpServlet.java:619) at javax.servlet.http.HttpServlet.service(HttpServlet.java:717) at sun.reflect.GeneratedMethodAccessor72.invoke(Unknown Source) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25) at java.lang.reflect.Method.invoke(Method.java:597) This is because the date for the If-Modified-Since Header (2012-10-31 04:00:00 +0000) is not in the format specified by RFC-2616 Section 3.3.1. However, the RFC states in section 14.25a: if the passed If-Modified-Since date is invalid, the response is exactly the same as for a normal GET. A date which is later than the server's current time is invalid. Tomcat is not complying with this aspect of the specification because it throws a 500 rather than processing it as described by the specification.</column><column name="report_time">2012-11-01 16:10:42</column><column name="report_timestamp">1351800000</column><column name="status">resolved fixed</column><column name="commit">810732d</column><column name="commit_timestamp">1352720000</column><column name="files">java/javax/servlet/http/HttpServlet.java</column><column name="result">9:java/javax/servlet/http/HttpServlet.java</column></table><table name="tomcat"><column name="id">215</column><column name="bug_id">54115</column><column name="summary">Minor enhancements to HttpClient test helper class</column><column name="description">Created attachment 29566 patch to HttpClient Main reason for this change is to add two new accessor methods to the enhanced logic in https://issues.apache.org/bugzilla/show_bug.cgi?id=53960. I also took the opportunity to make the sendRequest method tolerant of null elements in its input array. Finally, I added comments (definitely not proper javadoc!) to some other methods to clarify their purpose. This change is 100% backward compatible.</column><column name="report_time">2012-11-07 17:10:11</column><column name="report_timestamp">1352330000</column><column name="status">resolved fixed</column><column name="commit">8f53c89</column><column name="commit_timestamp">1352680000</column><column name="files">test/org/apache/catalina/startup/SimpleHttpClient.java</column><column name="result">118:test/org/apache/catalina/startup/SimpleHttpClient.java</column></table><table name="tomcat"><column name="id">216</column><column name="bug_id">54124</column><column name="summary">wrong javax.servlet.async.request_uri information and javax.servlet.async.path_info is missing</column><column name="description">As it is clearly shown that org.apache.catalina.core.AsyncContextImpl.dispatch(ServletContext, String) @Override public void dispatch(ServletContext context, String path) { if (log.isDebugEnabled()) { logDebug("dispatch "); } check(); if (request.getAttribute(ASYNC_REQUEST_URI)==null) { request.setAttribute(ASYNC_REQUEST_URI, request.getRequestURI()+"?"+request.getQueryString()); request.setAttribute(ASYNC_CONTEXT_PATH, request.getContextPath()); request.setAttribute(ASYNC_SERVLET_PATH, request.getServletPath()); request.setAttribute(ASYNC_QUERY_STRING, request.getQueryString()); } .... } the value of ASYNC_REQUEST_URI is not the same as request.getRequestURI(). They must be equal to each other as defined by Servlet 3.0, 9.7.2 Dispatched Request Parameters. And ASYNC_PATH_INFO is missing.</column><column name="report_time">2012-11-09 10:42:29</column><column name="report_timestamp">1352480000</column><column name="status">resolved fixed</column><column name="commit">76f84eb</column><column name="commit_timestamp">1352680000</column><column name="files">java/org/apache/catalina/core/AsyncContextImpl.java</column><column name="result">1:java/org/apache/catalina/core/AsyncContextImpl.java</column></table><table name="tomcat"><column name="id">217</column><column name="bug_id">54123</column><column name="summary">servlet 3.0 spec violation in async timeout processing</column><column name="description">Created attachment 29575 test war file within java source Servlet 3.0 Spec. says that 2.3.3.3 Asynchronous processing ... In the event that an asynchronous operation times out, the container must run through the following steps:  Invoke the AsyncListener.onTimeout method on all the AsyncListener instances registered with the ServletRequest on which the asynchronous operation was initiated.  If none of the listeners called AsyncContext.complete() or any of the AsyncContext.dispatch methods, perform an error dispatch with a status code equal to HttpServletResponse.SC_INTERNAL_SERVER_ERROR.  If no matching error page was found, or the error page did not call AsyncContext.complete() or any of the AsyncContext.dispatch methods, the container MUST call AsyncContext.complete(). (servlet-3_0-mrel-spec.pdf / pdf page 40, Spec page 18) In other words, if there are no AsyncListeners which calls AsyncContext.complete() or any of the AsyncContext.dispatch, the container must perform an error dispatch with 500 error code. But tomcat 7 does not send 500 error response. It sends 200 OK. In org.apache.catalina.core.AsyncContextImpl.timeout(), if (listenerInvoked) { request.getCoyoteRequest().action( ActionCode.ASYNC_IS_TIMINGOUT, result); return !result.get(); } else { // No listeners, container calls complete complete(); } it just calls complete(). So I think it must be spec violation. I've attached the test war file within a test source. Test URL is http://localhost:8080/asyncTimeoutTest/AsyncTimeoutTestServlet .</column><column name="report_time">2012-11-09 10:30:48</column><column name="report_timestamp">1352480000</column><column name="status">resolved fixed</column><column name="commit">14637ef</column><column name="commit_timestamp">1352680000</column><column name="files">java/org/apache/catalina/core/AsyncContextImpl.java
java/org/apache/catalina/core/StandardHostValve.java
java/org/apache/coyote/AsyncStateMachine.java
test/org/apache/catalina/core/TestAsyncContextImpl.java</column><column name="result">2:java/org/apache/coyote/AsyncStateMachine.java
4:java/org/apache/catalina/core/AsyncContextImpl.java
12:test/org/apache/catalina/core/TestAsyncContextImpl.java
120:java/org/apache/catalina/core/StandardHostValve.java</column></table><table name="tomcat"><column name="id">218</column><column name="bug_id">54127</column><column name="summary">WsOutbound is missing a ping method</column><column name="description">Created attachment 29577 patch which adds ping functionality to WsOutbound WsOutbound currently lacks the ability to send a ping request to the client. Attached patch creates a new method pong which takes in a ByteBuffer and passes the ping byte (0x09) to sendControlMessage which sets the opcode byte on the frame. Refactored pong method to all call sendControlMessage as opposed to duplicate code. Added websocket.Constants import for OPCODE_PING/PONG.</column><column name="report_time">2012-11-09 20:23:13</column><column name="report_timestamp">1352510000</column><column name="status">resolved fixed</column><column name="commit">8fea85c</column><column name="commit_timestamp">1352490000</column><column name="files">java/org/apache/catalina/websocket/WsOutbound.java</column><column name="result">1:java/org/apache/catalina/websocket/WsOutbound.java</column></table><table name="tomcat"><column name="id">219</column><column name="bug_id">54096</column><column name="summary">env-entry rejects legal types</column><column name="description">In servlet 3.0 the type in an env-entry can be any type which has a public constructor taking a single String (or character) as an argument. Tomcat only accepts a fixed list of types (see NamingContextListener from line 813). This is legal in web.xml but not accepted by tomcat: &lt;env-entry&gt; &lt;env-entry-name&gt;location&lt;/env-entry-name&gt; &lt;env-entry-type&gt;java.io.File&lt;/env-entry-type&gt; &lt;env-entry-value&gt;/var/lib/tomcat&lt;/env-entry-value&gt; &lt;/env-entry&gt;</column><column name="report_time">2012-11-04 18:43:14</column><column name="report_timestamp">1352070000</column><column name="status">resolved fixed</column><column name="commit">48314f9</column><column name="commit_timestamp">1352490000</column><column name="files">java/org/apache/catalina/core/NamingContextListener.java
test/org/apache/catalina/core/TestNamingContextListener.java</column><column name="result">2:java/org/apache/catalina/core/NamingContextListener.java
78:test/org/apache/catalina/core/TestNamingContextListener.java</column></table><table name="tomcat"><column name="id">220</column><column name="bug_id">54076</column><column name="summary">SPNEGO authenticator's stateless-ness incompatible with stateful clients</column><column name="description">At the moment, Tomcat is not able to store connection-level information to support stateful authentication mechanisms. This has been confirmed on the mailinglist: http://www.mail-archive.com/users@tomcat.apache.org/msg102169.html Unfortunately, a client which observes that, like Apache HTTPComponents or libserf (used in Apache Subversion) with authenticate only the first the request and expect the server to cache that for the connection. Subsequent comm will end in an endless loop. See here http://serf.googlecode.com/issues/attachment?aid=770006001&amp;name=tomcat-serf-spnego-response.png&amp;token=GDWvY5f7eMDzDGwtg1tD5N_MUXY%3A1351604707042&amp;inline=1 and here http://serf.googlecode.com/issues/attachment?aid=770006002&amp;name=serf-endless-loop.png&amp;token=cHvvfubJuAHDuTMjG_OHOaps5hQ%3A1351604707042&amp;inline=1 A simple hint can tell the client that the server does not support stateful auth on a connection-level. Add here http://svn.apache.org/viewvc/tomcat/tc7.0.x/trunk/java/org/apache/catalina/authenticator/SpnegoAuthenticator.java?view=markup#l272 before line 272 "response.addHeader("Connection", "close");" and the client will open a new connection and reauth further requests. Not doing so makes the Tomcat server vulnerable to DoS as you can see in the second screenshot.</column><column name="report_time">2012-10-30 13:49:27</column><column name="report_timestamp">1351620000</column><column name="status">resolved fixed</column><column name="commit">9f65875</column><column name="commit_timestamp">1351980000</column><column name="files">java/org/apache/catalina/authenticator/SpnegoAuthenticator.java</column><column name="result">1:java/org/apache/catalina/authenticator/SpnegoAuthenticator.java</column></table><table name="tomcat"><column name="id">221</column><column name="bug_id">54068</column><column name="summary">Web fragment sorting incorrectly detects circular reference</column><column name="description">Created attachment 29522 Test case implementation The implementation of web fragment sorting with relative ordering constraints may detect circular references, even though there is no such circle. This occurrence of this bug depends on the iteration order of the input map. Consider the attached test case, defining a simple chain of three web fragments: * web fragments a, b, c, with relative constraints "b after a", "c after b". * expected result: a, b, c * actual result: Testcase: testOrderWebFragmentsRelative4 took 0,002 sec Caused an ERROR Fragment relative ordering contains circular references. Thsi can be resolved by using absolute ordering in web.xml. java.lang.IllegalArgumentException: Fragment relative ordering contains circular references. Thsi can be resolved by using absolute ordering in web.xml. at org.apache.catalina.deploy.WebXml.orderWebFragments(WebXml.java:2190) at org.apache.catalina.deploy.TestWebXmlOrdering.testOrderWebFragmentsRelative4(TestWebXmlOrdering.java:268) Workaround: use absolute ordering. Details: * Java 1.7.0_07</column><column name="report_time">2012-10-30 05:30:27</column><column name="report_timestamp">1351590000</column><column name="status">resolved fixed</column><column name="commit">07d343a</column><column name="commit_timestamp">1351720000</column><column name="files">java/org/apache/catalina/deploy/WebXml.java
test/org/apache/catalina/deploy/TestWebXmlOrdering.java</column><column name="result">4:test/org/apache/catalina/deploy/TestWebXmlOrdering.java
5:java/org/apache/catalina/deploy/WebXml.java</column></table><table name="tomcat"><column name="id">222</column><column name="bug_id">54067</column><column name="summary">Upgrade Response with Transfer-Encoding: chunked invalid</column><column name="description">WebSocket upgrade response from Tomcat 7.0.32 contains an invalid response header "Transfer-Encoding: chunked" Full Request/Response is as follows (against example URI ws://localhost:8080/examples/websocket/echoMessage from distribution) ... GET /examples/websocket/echoMessage HTTP/1.1 Host: localhost:8080 Upgrade: websocket Connection: Upgrade Sec-WebSocket-Key: ZDTIRU5vU9xOfkg8JAgN3A== Sec-WebSocket-Version: 13 HTTP/1.1 101 Switching Protocols Server: Apache-Coyote/1.1 Upgrade: websocket Connection: upgrade Sec-WebSocket-Accept: Kgo85/8KVE8YPONSeyhgL3GwqhI= Transfer-Encoding: chunked Date: Mon, 29 Oct 2012 16:32:53 GMT The Jetty project is working this issue from the Jetty WebSocket client point of view. https://bugs.eclipse.org/bugs/show_bug.cgi?id=393075</column><column name="report_time">2012-10-29 17:23:09</column><column name="report_timestamp">1351550000</column><column name="status">resolved fixed</column><column name="commit">9308b3f</column><column name="commit_timestamp">1351540000</column><column name="files">java/org/apache/coyote/http11/AbstractHttp11Processor.java</column><column name="result">4:java/org/apache/coyote/http11/AbstractHttp11Processor.java</column></table><table name="tomcat"><column name="id">223</column><column name="bug_id">53867</column><column name="summary">Performance tuning solution for PageContextImpl.XmlEscape</column><column name="description">Created attachment 29369 Patch for PageContextImpl.java XmlEscape is used to do escape special characters for EL result. Currently it gets characters from String one by one and check whether the char is special character or not, than put the char into a StringBuilder. Most cases the string has no such special characters, However, it always creates a new StringBuilder than do such iteration. It's better to check whether there is any special characters first. If there is special character, then do create a StringBuilder and put those characters in front of te special character into the StringBuilder. Again, check the string by character one by one similar as the original logic. Here is the result of comparison testing between the two methods. Old escape:1610 New escape:1050 Old escape:1566 New escape:873 Old escape:1437 New escape:905 Old escape:1590 New escape:890 Old escape:1452 New escape:889 Old escape:1547 New escape:889 Old escape:1467 New escape:889 Old escape:1575 New escape:930 Old escape:1479 New escape:874 Old escape:1517 New escape:970</column><column name="report_time">2012-09-13 13:33:48</column><column name="report_timestamp">1347560000</column><column name="status">resolved fixed</column><column name="commit">c40ca99</column><column name="commit_timestamp">1351460000</column><column name="files">java/org/apache/jasper/runtime/PageContextImpl.java
test/org/apache/jasper/runtime/TesterPageContextImpl.java</column><column name="result">1:java/org/apache/jasper/runtime/PageContextImpl.java</column></table><table name="tomcat"><column name="id">224</column><column name="bug_id">54054</column><column name="summary">2 CGIServlet's with different Parameter passShellEnvironment</column><column name="description">Created attachment 29511 2 webapps test1/test2. I'm running Tomcat 6.0.36 with Java 1.6.0_32 on Ubuntu 12.04 (64 Bit). I have 2 webapps test1 and test2 which use CGI with CGIServlet. The difference between test1 and test2 is the Parameter passShellEnvironment. test1 sets it to true, test2 to false. When I call .../cgi-bin/getenv.pl, both apps show the complete environment. I searched the source of CGIServlet and found, that there is a static Hashtable: static Hashtable&lt;String,String&gt; shellEnv = new Hashtable&lt;String,String&gt;(); So test1 sets this Hashtable and test2 has it too. I suggest to remove the static. Then only test1 has the environment. In Tomcat 7.0.32 the problem is the same.</column><column name="report_time">2012-10-26 07:24:33</column><column name="report_timestamp">1351250000</column><column name="status">resolved fixed</column><column name="commit">05fe671</column><column name="commit_timestamp">1351280000</column><column name="files">java/org/apache/catalina/servlets/CGIServlet.java</column><column name="result">1:java/org/apache/catalina/servlets/CGIServlet.java</column></table><table name="tomcat"><column name="id">225</column><column name="bug_id">54022</column><column name="summary">CometEvent.END event is not sent on a suspended socket disconnect when running with Tomcat Native (tcnative-1.dll) on Windows Vista / Windows Server 2008 or newer.</column><column name="description">Created attachment 29492 Tomcat 7.0.32 source file with the bugfix Our Web application uses an asynchronous 3.0 servlet (via Atmosphere 1.0, actually) to send notification messages to clients connected via long-running sockets (e.g., HTTP streaming, long polling, etc.) I found a bug where Tomcat was not sending the CometEvent.END event on x64 platforms that used Tomcat Native when a socket would disconnect (e.g., by pressing CTRL-C from an HTTP GET curl command). After narrowing it down and debugging the Tomcat 7.0.32 source, I tracked the problem down to org.apache.coyote.AbstractProtocol.java. Due to the way that APR handles socket polling in Tomcat Native, the bug only occurs on Windows platforms that 1) use tcnative-1.dll, and 2) are Vista/Server 2008 or newer. Here is what is happening: 1) On startup, APR in tcnative-1.dll looks for a method named "WSAPoll" method in Ws2_32.dll. If it finds it, it assigns that function as the function to use to poll sockets. Otherwise, it falls back to the legacy method of polling sockets. WSAPoll is only present on Windows Vista/Server 2008 or newer. 2) In org.apache.tomcat.util.net.AprEndpoint, the doPoll(long pollset) method invokes Poll.poll(pollset, pollTime, desc, true), which delegates the call to tcnative-1.dll if present. 3) If doPoll returns &gt; 0, it means that at least one socket requires processing, so it falls through to this block in the doPoll method AprEndpoint.java (comments added below marked with "{DB}"): for (int n = 0; n &lt; rv; n++) { // Check for failed sockets and hand this socket off to a worker if (((desc[n*2] &amp; Poll.APR_POLLHUP) == Poll.APR_POLLHUP) // {DB} only the WSAPoll method sets the APR_POLLHUP flag when a socket disconnects; neither the legacy tcnative polling method nor the pure Java Coyote polling method sets this flag (which is fine) || ((desc[n*2] &amp; Poll.APR_POLLERR) == Poll.APR_POLLERR) || (comet &amp;&amp; (!processSocket(desc[n*2+1], SocketStatus.OPEN))) // {DB} this line is executed for comet sockets if WSAPoll is not available on this platform (e.g., pre-Vista/Server 2008) or if tcnative-1.dll is not present. (This is also fine.) || (!comet &amp;&amp; (!processSocket(desc[n*2+1])))) { // Close socket and clear pool if (comet) { processSocket(desc[n*2+1], SocketStatus.DISCONNECT); // {DB} this is only reached if tcnative-1.dll is present and we are running on Vista/Server 2008 or newer. This is OK, but there is a bug with SocketStatus.DISCONNECT handling for comet sockets in processSocket (described in the next step) } else { destroySocket(desc[n*2+1]); } } } 4) The processSocket(long socket, SocketStatus status) method fires up a SocketEventProcessor and runs it, which excutes this: Handler.SocketState state = handler.process(socket, status); // {DB} this does not send CometEvent.END for comet if status == SocketStatus.DISCONNECT (details in next steps) if (state == Handler.SocketState.CLOSED) { // Close socket and pool destroySocket(socket.getSocket().longValue()); // {DB} this closes the socket and frees it for reuse, but since the Comet application was not notified that the socket went away, the next time it tries to send data down the socket it either crashes the JVM or writes the data to the response which is now owned by somebody else. Chaos ensues. socket = null; } 5) When running Tomcat Native, the handler.process(socket, status) method is implemented by org.apache.coyote.http11.Http11AprProtocol$Http11ConnectionHandler, which extends AbstractConnectionHandler defined as an inner class in org.apache.coyote.AbstractProtocol. The method and the fix that I made on my test instance are shown below [the fix was to add '&amp;&amp; (!processor.isComet())' to the beginning condition of the 'if' block]: ====== public SocketState process(SocketWrapper&lt;S&gt; socket, SocketStatus status) { ...&lt;snip&gt;... do { // {DB} NOTE: status only == SocketStatus.DISCONNECT here if we are running tcnative on Windows Vista / Server 2008 or newer // {DB} For all other cases status == SocketStatus.OPEN here even if a disconnect has occurred, so it falls through to the '} else if (processor.isComet()) {' line all is well. // {DB} Original line: if (status == SocketStatus.DISCONNECT) { if ( (status == SocketStatus.DISCONNECT) &amp;&amp; (!processor.isComet()) ) { // &lt;&lt;&lt;&lt;&lt;&lt; {DB} BUGFIX: if comet, must allow processor.event(SocketStatus.DISCONNECT) later in the 'if' block to send the Comet.END event and return SocketState.CLOSED //do nothing here, just wait for it to get recycled } else if (processor.isAsync() || state == SocketState.ASYNC_END) { state = processor.asyncDispatch(status); } else if (processor.isComet()) { state = processor.event(status); // {DB} this sends CometEvent.END and returns SocketState.CLOSED if status == SocketStatus.DISCONNECT, which is what we want } else if (processor.isUpgrade()) { state = processor.upgradeDispatch(); } else { state = processor.process(socket); } ...&lt;snip&gt;... ====== After I made the fix above and deployed the updated tomcat-coyote.jar I am now getting the CometEvent.END events as expected when using Tomcat Native on Windows 7. We are using Atmosphere (which uses Comet) for our next release, but we will need this Tomcat bugfix before we can deploy. We could ship a custom patched tomcat-coyote.jar but obviously we would prefer to have an official fix in the next Tomcat patch release so we could just deploy that. The fix I made above works for me, but if you need to reproduce the problem, all you need to do is: 1) Install Tomcat 7.0.32 along with Tomcat Native on a Windows 7 or Windows Server 2008 PC (I was using a 64-bit Windows 7 PC). 2) Run a servlet that: a) implements org.apache.catalina.comet.CometProcessor, and b) logs the CometEvents received, and c) suspends the HttpRequest when it receives one. 3) Connect to that servlet by doing an HTTP GET via Curl. 4) Press CTRL-C to abort the socket connection. The CometEvent.END event is never fired. I attached the source file containing the bugfix (AbstractProtocol.java). The fix is marked with "{DB}" comments. Thanks.</column><column name="report_time">2012-10-17 18:18:23</column><column name="report_timestamp">1350510000</column><column name="status">resolved fixed</column><column name="commit">874c332</column><column name="commit_timestamp">1351200000</column><column name="files">java/org/apache/coyote/AbstractProtocol.java</column><column name="result">71:java/org/apache/coyote/AbstractProtocol.java</column></table><table name="tomcat"><column name="id">226</column><column name="bug_id">54017</column><column name="summary">new String instance is generated for constant string in Generator.convertString</column><column name="description">If the target class is "Object.class", the generator generates "new String(" + quoted + ")"; as attribute value for Tag Handler. How about using quoted directly same as when the target class is "Object.class"? Creating a String instance will cause some overhead from memory allocation and hash code recaluation when it is used as a key on HashMap. Here is the detail code, /* * @param c The target class to which to coerce the given string @param * s The string value @param attrName The name of the attribute whose * value is being supplied @param propEditorClass The property editor * for the given attribute @param isNamedAttribute true if the given * attribute is a named attribute (that is, specified using the * jsp:attribute standard action), and false otherwise */ private String convertString(Class&lt;?&gt; c, String s, String attrName, Class&lt;?&gt; propEditorClass, boolean isNamedAttribute) { String quoted = s; if (!isNamedAttribute) { quoted = quote(s); } if (propEditorClass != null) { String className = c.getCanonicalName(); return "(" + className + ")org.apache.jasper.runtime.JspRuntimeLibrary.getValueFromBeanInfoPropertyEditor(" + className + ".class, \"" + attrName + "\", " + quoted + ", " + propEditorClass.getCanonicalName() + ".class)"; } else if (c == String.class) { return quoted; } else if (c == boolean.class) { return JspUtil.coerceToPrimitiveBoolean(s, isNamedAttribute); } else if (c == Boolean.class) { return JspUtil.coerceToBoolean(s, isNamedAttribute); } else if (c == byte.class) { return JspUtil.coerceToPrimitiveByte(s, isNamedAttribute); } else if (c == Byte.class) { return JspUtil.coerceToByte(s, isNamedAttribute); } else if (c == char.class) { return JspUtil.coerceToChar(s, isNamedAttribute); } else if (c == Character.class) { return JspUtil.coerceToCharacter(s, isNamedAttribute); } else if (c == double.class) { return JspUtil.coerceToPrimitiveDouble(s, isNamedAttribute); } else if (c == Double.class) { return JspUtil.coerceToDouble(s, isNamedAttribute); } else if (c == float.class) { return JspUtil.coerceToPrimitiveFloat(s, isNamedAttribute); } else if (c == Float.class) { return JspUtil.coerceToFloat(s, isNamedAttribute); } else if (c == int.class) { return JspUtil.coerceToInt(s, isNamedAttribute); } else if (c == Integer.class) { return JspUtil.coerceToInteger(s, isNamedAttribute); } else if (c == short.class) { return JspUtil.coerceToPrimitiveShort(s, isNamedAttribute); } else if (c == Short.class) { return JspUtil.coerceToShort(s, isNamedAttribute); } else if (c == long.class) { return JspUtil.coerceToPrimitiveLong(s, isNamedAttribute); } else if (c == Long.class) { return JspUtil.coerceToLong(s, isNamedAttribute); } else if (c == Object.class) { return "new String(" + quoted + ")"; } else { String className = c.getCanonicalName(); return "(" + className + ")org.apache.jasper.runtime.JspRuntimeLibrary.getValueFromPropertyEditorManager(" + className + ".class, \"" + attrName + "\", " + quoted + ")"; } }</column><column name="report_time">2012-10-17 08:47:42</column><column name="report_timestamp">1350480000</column><column name="status">resolved fixed</column><column name="commit">095a403</column><column name="commit_timestamp">1351170000</column><column name="files">java/org/apache/jasper/compiler/Generator.java</column><column name="result">3:java/org/apache/jasper/compiler/Generator.java</column></table><table name="tomcat"><column name="id">227</column><column name="bug_id">54012</column><column name="summary">No "pageContext" in tag files' generated java code when using code generation by JSTL tagplugin "Set"</column><column name="description">Created attachment 29485 Patch for org.apache.jasper.tagplugins.jstl.core.Set.java The code generated by the following code from " org.apache.jasper.tagplugins.jstl.core.Set" can't work in Tag Files. There is no "PageContext" in tag file. So this should check "isTagFile". String strVar = ctxt.getConstantAttribute("var"); ctxt.generateJavaSource("if(null != " + resultName + "){"); ctxt.generateJavaSource(" pageContext.setAttribute(\"" + strVar + "\"," + resultName + "," + iScope + ");"); ctxt.generateJavaSource("} else {"); if(hasScope){ ctxt.generateJavaSource(" pageContext.removeAttribute(\"" + strVar + "\"," + iScope + ");"); }else{ ctxt.generateJavaSource(" pageContext.removeAttribute(\"" + strVar + "\");"); } ctxt.generateJavaSource("}");</column><column name="report_time">2012-10-16 09:01:56</column><column name="report_timestamp">1350390000</column><column name="status">resolved fixed</column><column name="commit">a0ff3f97</column><column name="commit_timestamp">1351170000</column><column name="files">java/org/apache/jasper/compiler/Compiler.java
java/org/apache/jasper/compiler/PageInfo.java
java/org/apache/jasper/compiler/TagPluginManager.java
java/org/apache/jasper/compiler/tagplugin/TagPluginContext.java
java/org/apache/jasper/tagplugins/jstl/core/Set.java</column><column name="result">2:java/org/apache/jasper/compiler/TagPluginManager.java
8:java/org/apache/jasper/compiler/tagplugin/TagPluginContext.java
15:java/org/apache/jasper/tagplugins/jstl/core/Set.java
26:java/org/apache/jasper/compiler/Compiler.java
58:java/org/apache/jasper/compiler/PageInfo.java</column></table><table name="tomcat"><column name="id">228</column><column name="bug_id">54045</column><column name="summary">ReplicatedMap don't like TcpFailureDetector in static configuration</column><column name="description">Tribes stack using: * TcpPingInterceptor * TcpFailureDetector * MessageDispatchInterceptor * StaticMembershipInterceptor Do not work well in static cluster. First side (ie one thread): * call to TcpFailureDetector.heartbeat() * call to checkMembers(false) * call to performBasicCheck() in synchronized(membership) * in performBasicCheck, for a missing static node: * add "missing" member to membership with membership.memberAlive(m) * HERE THE SECOND THREAD HAVE SOME TIME TO WORK * check it with memberAlive(m) * remove it since if it doesn't exist Second side (ie another thread): * some call to channel.getMembers() like what the done by AbstractReplicatedMap * this call will call the TcpFailureDetector.getMembers() * this one could return a wrong value since it can contains unavailable nodes Note: * synchronize on membership isn't use by TcpFailureDetector in getMember(), getMembers(), hasMembers(), neither in Membership equivalent method (maybe because it's too heavy to lock every thread while the TcpFailureDetector check if node are alive). It must not be an issue for AbstractReplicatedMap since with or without TcpFailureDetector a node could disapear while replicated map try to use it. But ReplicatedMap use always Channel.SEND_OPTIONS_DEFAULT where the value is Channel.SEND_OPTIONS_USE_ACK. So a message sent to a missing node will fail with an exception. Personnaly I override TcpFailureDetector.heartbeat() to avoid performBasicCheck() if I use a static configuration (TcpPingInterceptor call performForcedCheck()). But this doesn't fix ReplicatedMap issue. Better fix could avoid adding missing member to membership list: * Add a method like memberAlive(MemberImpl) to Membership without side effect (add the member) * in TcpFailureDetector.performBasicCheck(): check this new method before adding the node This doesn't fix the AbstractReplicatedMap issue which work always with acknoledge from other nodes. Same code for Tomcat 6. best regards F.Arnoud</column><column name="report_time">2012-10-23 16:03:53</column><column name="report_timestamp">1351020000</column><column name="status">resolved fixed</column><column name="commit">d2b41b5</column><column name="commit_timestamp">1351170000</column><column name="files">java/org/apache/catalina/tribes/group/interceptors/TcpFailureDetector.java</column><column name="result">2:java/org/apache/catalina/tribes/group/interceptors/TcpFailureDetector.java</column></table><table name="tomcat"><column name="id">229</column><column name="bug_id">54010</column><column name="summary">Suggestion for code improvement (avoiding potential bug)</column><column name="description">In connectors/jk/java/org/apache/jk/common/HandlerRequest.java coyote.Request's schemeMB is assigned in 2 places. 1st place: 400 boolean isSSL = msg.getByte() != 0; 401 if( isSSL ) { 402 // XXX req.setSecure( true ); 403 req.scheme().setString("https"); 404 } 2nd place: 518 case AjpConstants.SC_A_SSL_CERT : 519 req.scheme().setString( "https" ); and similar assignments for SC_A_SSL_CIPHER and SC_A_SSL_SESSION cases below. It seems they do not make sense because the packet's 8-bit field is designated for telling whether it's SSL or not. So the 1st place is enough. Adding the 2nd place may pose potential bug in that a packet with the 8-bit SSL field being 0 and suffixes of SC_A_SSL_* key-value pairs can later incorrect trigger a wrong redirection message pointing to a https location. A simple correction is to honor the 8-bit SSL-field in packet and delete the 3 lines of 2nd place assigning "https". Even though the chances of such spurious packet is low, but it's best we can have threat-free, semantic-correct tomcat code. The same lines of code remain in 6.0 and 7.0. But maybe I misunderstand the code, in which case please kindly point out. Thanks.</column><column name="report_time">2012-10-16 02:20:47</column><column name="report_timestamp">1350370000</column><column name="status">resolved fixed</column><column name="commit">9f04094</column><column name="commit_timestamp">1350950000</column><column name="files">java/org/apache/coyote/ajp/AbstractAjpProcessor.java</column><column name="result">2:java/org/apache/coyote/ajp/AbstractAjpProcessor.java</column></table><table name="tomcat"><column name="id">230</column><column name="bug_id">53993</column><column name="summary">NPE in AccessLogValve</column><column name="description">During a load test of tomcat 7.0.30, we occasionally see NPEs from the AccessLogValve. Some of the requests that are being executed as part of the load test call HttpSession.invalidate. I mention this because the code in question appears to be susceptible to multithreaded manipulation of the session. I think the fix should be as simple as a check for null on the return value of request.getSessionInternal. Of course, our access log pattern includes logging the session id. java.lang.NullPointerException org.apache.catalina.valves.AccessLogValve$SessionIdElement.addElement(AccessLogValve.java:1733) org.apache.catalina.valves.AccessLogValve.log(AccessLogValve.java:955) org.apache.catalina.core.AccessLogAdapter.log(AccessLogAdapter.java:51) org.apache.catalina.core.StandardEngine.logAccess(StandardEngine.java:332) org.apache.catalina.core.ContainerBase.logAccess(ContainerBase.java:1270) org.apache.catalina.core.ContainerBase.logAccess(ContainerBase.java:1270) org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:441) org.apache.coyote.http11.AbstractHttp11Processor.process(AbstractHttp11Processor.java:1002) org.apache.coyote.AbstractProtocol$AbstractConnectionHandler.process(AbstractProtocol.java:585) org.apache.tomcat.util.net.JIoEndpoint$SocketProcessor.run(JIoEndpoint.java:312) java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1110) java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:603) java.lang.Thread.run(Thread.java:722) existing code for convenience: protected static class SessionIdElement implements AccessLogElement { @Override public void addElement(StringBuilder buf, Date date, Request request, Response response, long time) { if (request != null) { if (request.getSession(false) != null) { buf.append(request.getSessionInternal(false) // LINE 1733 .getIdInternal()); } else { buf.append('-'); } } else { buf.append('-'); } } } possible fix: ... if (request.getSession(false) != null) { Session internalSession = request.getSessionInternal(false); if (internalSession != null) { buf.append(internalSession.getIdInternal()); } else { buf.append('-'); } } else { buf.append('-'); }</column><column name="report_time">2012-10-11 19:56:38</column><column name="report_timestamp">1350000000</column><column name="status">resolved fixed</column><column name="commit">39c4270</column><column name="commit_timestamp">1350140000</column><column name="files">java/org/apache/catalina/valves/AccessLogValve.java</column><column name="result">1:java/org/apache/catalina/valves/AccessLogValve.java</column></table><table name="tomcat"><column name="id">231</column><column name="bug_id">53986</column><column name="summary">Comment end tag preceded directly by a dash causes JSP fail compilation</column><column name="description">Created attachment 29466 JSP file to reproduce compilation error I have a JSP file that contained a comment line as follows: &lt;%--- comment ---%&gt; Such a JSP compiles in Tomcat 7.0.30, but it does not compile in 7.0.32. Ive attached a copy of a test file, which compiles in 7.0.30, but not in 7.0.32. The only related change I see in the release notes is https://issues.apache.org/bugzilla/show_bug.cgi?id=53713. From reading the JSP 2.2 spec, it appears that absent a specific comment about whitespace, the rules of XML shall apply, which effectively means whitespace is ignored. This would seem to indicate this could be a regression introduced in 7.0.32, but since the spec is somewhat vague in the section about comments, ERROR 09 Oct 2012 11:15:25,190 [http-bio-8080-exec-8] [com.liferay.portal.log.Co mmonsLogImpl.error(52)] org.apache.jasper.JasperException: /html/portal/layout/v iew/portlet.jsp (line: 48, column: 6) Unterminated &amp;lt;%-- tag at org.apache.jasper.compiler.DefaultErrorHandler.jspError(DefaultErrorH andler.java:42) at org.apache.jasper.compiler.ErrorDispatcher.dispatch(ErrorDispatcher.j ava:408) at org.apache.jasper.compiler.ErrorDispatcher.jspError(ErrorDispatcher.j ava:133) at org.apache.jasper.compiler.Parser.parseComment(Parser.java:615) at org.apache.jasper.compiler.Parser.parseElements(Parser.java:1425) at org.apache.jasper.compiler.Parser.parse(Parser.java:138) at org.apache.jasper.compiler.ParserController.doParse(ParserController. java:242) at org.apache.jasper.compiler.ParserController.parse(ParserController.ja va:102) at org.apache.jasper.compiler.Compiler.generateJava(Compiler.java:198) at org.apache.jasper.compiler.Compiler.compile(Compiler.java:373) at org.apache.jasper.compiler.Compiler.compile(Compiler.java:353) at org.apache.jasper.compiler.Compiler.compile(Compiler.java:340) at org.apache.jasper.JspCompilationContext.compile(JspCompilationContext .java:646) at org.apache.jasper.servlet.JspServletWrapper.service(JspServletWrapper .java:357) at org.apache.jasper.servlet.JspServlet.serviceJspFile(JspServlet.java:3 90) at org.apache.jasper.servlet.JspServlet.service(JspServlet.java:334) at javax.servlet.http.HttpServlet.service(HttpServlet.java:722) at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(Appl icationFilterChain.java:305) at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationF ilterChain.java:210) at com.liferay.filters.strip.StripFilter.doFilter(StripFilter.java:260)</column><column name="report_time">2012-10-09 18:40:08</column><column name="report_timestamp">1349820000</column><column name="status">resolved fixed</column><column name="commit">88d8dd5</column><column name="commit_timestamp">1349880000</column><column name="files">java/org/apache/jasper/compiler/JspReader.java
test/org/apache/jasper/compiler/TestJspReader.java</column><column name="result">8:java/org/apache/jasper/compiler/JspReader.java</column></table><table name="tomcat"><column name="id">232</column><column name="bug_id">53854</column><column name="summary">DefaultServlet directory listings for aliased directories do not seem to work</column><column name="description">The following situation does not seem to work. 1.) In a Context, add an alias to a directory. 2.) Enable directory listings on the DefaultServlet. 3.) Try to view the directory listing of the alias directory. Example: conf/context.xml: &lt;Context aliases="/files=/my/downloads"&gt; ... &lt;/Context&gt; conf/web.xml: ... &lt;servlet&gt; &lt;servlet-name&gt;default&lt;/servlet-name&gt; &lt;servlet-class&gt;org.apache.catalina.servlets.DefaultServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;debug&lt;/param-name&gt; &lt;param-value&gt;0&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;listings&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; ... contents of the directory "/my/downloads": -rw-r--r--@ 1 daniel staff 8156824 Sep 10 09:15 apache-tomcat-7.0.30.zip URL works: http://localhost:8080/files/apache-tomcat-7.0.30.zip URL does not work: http://localhost:8080/files/ The URL that does not work fails with the error: SEVERE: Servlet.service() for servlet [default] in context with path [/] threw exception [Error accessing resource] with root cause javax.naming.NameNotFoundException: Resource /files/ not found 	at org.apache.naming.resources.FileDirContext.list(FileDirContext.java:303) 	at org.apache.naming.resources.ProxyDirContext.list(ProxyDirContext.java:512) 	at org.apache.catalina.servlets.DefaultServlet.renderHtml(DefaultServlet.java:1458) 	at org.apache.catalina.servlets.DefaultServlet.render(DefaultServlet.java:1254) 	at org.apache.catalina.servlets.DefaultServlet.serveResource(DefaultServlet.java:951) 	at org.apache.catalina.servlets.DefaultServlet.doGet(DefaultServlet.java:412) 	at javax.servlet.http.HttpServlet.service(HttpServlet.java:621) 	at javax.servlet.http.HttpServlet.service(HttpServlet.java:722) 	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:305) 	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:210) 	at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:222) 	at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:123) 	at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:472) 	at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:168) 	at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:99) 	at org.apache.catalina.valves.AccessLogValve.invoke(AccessLogValve.java:929) 	at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:118) 	at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:407) 	at org.apache.coyote.http11.AbstractHttp11Processor.process(AbstractHttp11Processor.java:1002) 	at org.apache.coyote.AbstractProtocol$AbstractConnectionHandler.process(AbstractProtocol.java:585) 	at org.apache.tomcat.util.net.JIoEndpoint$SocketProcessor.run(JIoEndpoint.java:310) 	at java.util.concurrent.ThreadPoolExecutor$Worker.runTask(ThreadPoolExecutor.java:886) 	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:908) 	at java.lang.Thread.run(Thread.java:680)</column><column name="report_time">2012-09-11 20:28:09</column><column name="report_timestamp">1347410000</column><column name="status">resolved fixed</column><column name="commit">a3e0f09</column><column name="commit_timestamp">1349030000</column><column name="files">java/org/apache/naming/resources/BaseDirContext.java
java/org/apache/naming/resources/FileDirContext.java
java/org/apache/naming/resources/WARDirContext.java</column><column name="result">28:java/org/apache/naming/resources/FileDirContext.java
56:java/org/apache/naming/resources/BaseDirContext.java
109:java/org/apache/naming/resources/WARDirContext.java</column></table><table name="tomcat"><column name="id">233</column><column name="bug_id">53863</column><column name="summary">Unable to override default servlet when using Tomcat in embedded mode</column><column name="description">An implementation of ServletContainerInitializer can't add a mapping to "/" because the default servlet is loaded first, as first reported in 51278: public final class SampleServletContainerInitializer implements ServletContainerInitializer { public void onStartup(final Set&lt;Class&lt;?&gt;&gt; c, final ServletContext ctx) throws ServletException { final XmlWebApplicationContext appCtx = new XmlWebApplicationContext(); appCtx.setConfigLocation("/WEB-INF/DispatcherServlet-servlet.xml"); final ServletRegistration.Dynamic dispatcher = ctx.addServlet("DispatcherServlet", new DispatcherServlet(appCtx)); dispatcher.setLoadOnStartup(1); final Set&lt;String&gt; conflictSet = dispatcher.addMapping("/"); for (final String conflict : conflictSet) out.println(conflict); // prints "/" } } A test case follows attached.</column><column name="report_time">2012-09-13 03:44:28</column><column name="report_timestamp">1347520000</column><column name="status">resolved fixed</column><column name="commit">7f6f99e</column><column name="commit_timestamp">1347820000</column><column name="files">java/org/apache/catalina/startup/Tomcat.java</column><column name="result">6:java/org/apache/catalina/startup/Tomcat.java</column></table><table name="tomcat"><column name="id">234</column><column name="bug_id">52777</column><column name="summary">Automatically shut down old versions in parallel deployment</column><column name="description">Under parallel deployment, when an older version in an application has zero sessions, shut it down automatically to release tomcat and JVM resources. Christopher Schultz suggested these approaches might be possible (on the Tomcat user list): 1. Modify the parallel deployment code to register an MBean NotificationListener that filters for useful events (such as expiring session notifications on the outgoing webapp). 2. When the listener receives a notification, check the current state (e.g. session count=0; or, I suppose you could make this a part of your filter in step #1). If session count = 0, start a new thread that stops the outgoing webapp and de-registers the listener. Or. 1. Install a SessionEventListener that counts-down the sessions (you'll have to get the count from JMX, I suppose) until they equal 0, then starts a new thread that ... etc. Or. 1. Install a Timer thread that polls at intervals (1 minute?) to see if all the sessions are dead and then starts a thread ... etc. The first idea seems the cleanest, though Tomcat might not actually fire MBean events for things like session count changing.</column><column name="report_time">2012-02-27 03:30:27</column><column name="report_timestamp">1330330000</column><column name="status">resolved fixed</column><column name="commit">97cefcc</column><column name="commit_timestamp">1347140000</column><column name="files">java/org/apache/catalina/Host.java
java/org/apache/catalina/core/StandardHost.java
java/org/apache/catalina/startup/HostConfig.java</column><column name="result">25:java/org/apache/catalina/startup/HostConfig.java
46:java/org/apache/catalina/core/StandardHost.java
245:java/org/apache/catalina/Host.java</column></table><table name="tomcat"><column name="id">235</column><column name="bug_id">53713</column><column name="summary">Performance tuning solution for JspReader</column><column name="description">Created attachment 29223 patch for JspReader.java mark() is called so many times when doing JSP or tag files compilation. This can be reduced by a little bit code changes. Attached files contain this solution.</column><column name="report_time">2012-08-14 06:28:58</column><column name="report_timestamp">1344940000</column><column name="status">resolved fixed</column><column name="commit">5fccf68</column><column name="commit_timestamp">1346880000</column><column name="files">java/org/apache/jasper/compiler/JspReader.java
java/org/apache/jasper/compiler/Mark.java</column><column name="result">1:java/org/apache/jasper/compiler/JspReader.java
5:java/org/apache/jasper/compiler/Mark.java</column></table><table name="tomcat"><column name="id">236</column><column name="bug_id">53828</column><column name="summary">StreamInbound.closeOutboundConnection(WsFrame) closes with an opcode instead of status</column><column name="description">201	private void closeOutboundConnection(WsFrame frame) throws IOException { 202	 try { 203	 getWsOutbound().close(frame); 204	 } finally { 205	 doOnClose(Constants.OPCODE_CLOSE); 206	 } 207	} Line 205 uses the close opcode instead of a valid status (Constants.STATUS_*). Not sure of the exact context of this called but it seems to only be called when the last frame from the client was a close frame, thus a Constants.STATUS_NORMAL may be in order. If not, the frame's opcode could be inspected and mapped to an appropriate status (normal, shutdown, etc...). Thanks, Michael</column><column name="report_time">2012-09-04 16:55:42</column><column name="report_timestamp">1346790000</column><column name="status">resolved fixed</column><column name="commit">a81d941</column><column name="commit_timestamp">1346790000</column><column name="files">java/org/apache/catalina/websocket/StreamInbound.java</column><column name="result">1:java/org/apache/catalina/websocket/StreamInbound.java</column></table><table name="tomcat"><column name="id">237</column><column name="bug_id">53801</column><column name="summary">Nondeterministic behaviour of security constraints</column><column name="description">Created attachment 29303 test web application that reproduces the issue I'm experiencing a weird behaviour with certain combinations of security constraints having the following pattern: (i) one security constraint applies to (at least) two overlapping URL patterns ending in /*, where one is more specific than the other (e.g., /a/* and /a/b/*) (ii) a second security constraint applies only to the less specific URL pattern (e.g. /a/*), and (iii) the two security constraints apply to different (possibly overlapping) sets of methods. One such example is as follows: &lt;servlet-mapping&gt; &lt;servlet-name&gt;test&lt;/servlet-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;login-config&gt; &lt;auth-method&gt;BASIC&lt;/auth-method&gt; &lt;realm-name&gt;test&lt;/realm-name&gt; &lt;/login-config&gt; &lt;security-constraint&gt; &lt;web-resource-collection&gt; &lt;web-resource-name/&gt; &lt;url-pattern&gt;/a/*&lt;/url-pattern&gt; &lt;url-pattern&gt;/a/b/*&lt;/url-pattern&gt; &lt;http-method&gt;POST&lt;/http-method&gt; &lt;/web-resource-collection&gt; &lt;/security-constraint&gt; &lt;security-constraint&gt; &lt;web-resource-collection&gt; &lt;web-resource-name/&gt; &lt;url-pattern&gt;/a/*&lt;/url-pattern&gt; &lt;http-method&gt;GET&lt;/http-method&gt; &lt;/web-resource-collection&gt; &lt;auth-constraint/&gt; &lt;/security-constraint&gt; The problem occurs for HTTP requests matching to the most specific URL pattern (in the above example, /a/b, /a/b/c, etc.), but on methods other than the ones mentioned in the first security constraint (in the above example, GET). For instance, each time I deploy a web application with the above-mentioned deployment descriptor in Tomcat, or each time I redeploy it or restart the server in case it is already deployed, I get randomly either of the two following behaviours: 1) "GET /a/b" requests are allowed, i.e. no authentication is required 2) "GET /a/b" requests are denied, i.e. the response requires authentication (HTTP 401) Notice that the behaviour remains then constant until I restart the server or re-deploy the application. Also, adding arbitrary roles in either of the two auth-constraints, does not seem to change the result. According to the Java Servlet Specification, 1) is the correct behaviour. In fact, such requests shall be allowed to any (possibly unauthenticated) users, because the constraint with the most specific pattern (the first one) matches to the request, but it does not mention the method of the request (GET). I tested several different combinations of security constraints, but this issue seems to occur only with those of this kind. Please find attached a WAR that produces the above behaviour. Here are some HTTP requests I tested together with the expected and actual results: HTTP Request Expected HTTP Response Observed Behaviour GET /test/a 403 Always correct GET /test/b 200 Always correct GET /test/a/b 200 Sometimes incorrect (401 is given) GET /test/a/b/ 200 Sometimes incorrect (401 is given) GET /test/a/b/c 200 Sometimes incorrect (401 is given)</column><column name="report_time">2012-08-30 09:14:42</column><column name="report_timestamp">1346330000</column><column name="status">resolved fixed</column><column name="commit">95d7a0f</column><column name="commit_timestamp">1346370000</column><column name="files">java/org/apache/catalina/realm/RealmBase.java</column><column name="result">9:java/org/apache/catalina/realm/RealmBase.java</column></table><table name="tomcat"><column name="id">238</column><column name="bug_id">53800</column><column name="summary">Infinte loop cause by FileDirContext in a CDI/Weld project when using Eclipse's "Server modules without publishing"</column><column name="description">Created attachment 29302 Patch for FileDirContext.java Weld's TomcatListener is using the recurse method recited below. In the case I am encountering the DirContext that Tomcat provides is a FileDirContext. The discovery code used by Weld encounters what appears to be a bug in FileDirContext where FileDirContexts for child directories are created with the current FileDirContext's path. This causes an infinite loop while it searches the root directory over and over. Assuming the class discovery code Weld is using is correct, I tracked down the problem to a specific line in FileDirContext.java. Fixing this line to set the path of the new child FileDirContext to the matching child directory fixes the issue I am encountering. With this change the project appears to still pass all the unit tests ran with "ant test". I have attached the patch to this issue. Here is Weld's recurse function which I am assuming is correct... protected static void recurse(DirContext context, Set&lt;String&gt; classes, Set&lt;URL&gt; urls, String prefix) throws Exception { if (prefix.length() &gt; 0) prefix += "."; NamingEnumeration ne = context.listBindings(""); while (ne.hasMoreElements()) { Binding next = (Binding) ne.nextElement(); String name = prefix + next.getName(); if (name.endsWith(".class")) { classes.add(name.substring(0, name.length() - 6)); continue; } Object nextObject = next.getObject(); if (nextObject instanceof DirContext) { recurse((DirContext) nextObject, classes, urls, name); } } }</column><column name="report_time">2012-08-30 06:19:19</column><column name="report_timestamp">1346320000</column><column name="status">resolved fixed</column><column name="commit">44eabba</column><column name="commit_timestamp">1346310000</column><column name="files">java/org/apache/naming/resources/FileDirContext.java</column><column name="result">1:java/org/apache/naming/resources/FileDirContext.java</column></table><table name="tomcat"><column name="id">239</column><column name="bug_id">53793</column><column name="summary">Change webapp links in Manager to point to /appname/ instead of /appname</column><column name="description">The first column of the table that lists Web Applications in Tomcat Manager webapp contains links to those applications, e.g. &lt;a href="/examples"&gt;/examples&lt;/a&gt; When the link is clicked and browser navigates to "/examples", it results in 302 redirect to "/examples/". It would be better to change that link to point directly to "/examples/". &lt;a href="/examples/"&gt;/examples&lt;/a&gt; I am changing the link address only, but not the text on it. That is because the "Path" of the web application displayed in that column (and used in Manager commands elsewhere) does not have the additional '/'.</column><column name="report_time">2012-08-28 21:50:21</column><column name="report_timestamp">1346210000</column><column name="status">resolved fixed</column><column name="commit">fcc3d65</column><column name="commit_timestamp">1346190000</column><column name="files">java/org/apache/catalina/manager/HTMLManagerServlet.java</column><column name="result">8:java/org/apache/catalina/manager/HTMLManagerServlet.java</column></table><table name="tomcat"><column name="id">240</column><column name="bug_id">42181</column><column name="summary">ArrayIndexOutOfBoundsException in parseChunkHeader</column><column name="description">Apr 22, 2007 11:53:32 AM org.apache.coyote.http11.Http11Processor process SEVERE: Error finishing request java.lang.ArrayIndexOutOfBoundsException: -28 at org.apache.coyote.http11.filters.ChunkedInputFilter.parseChunkHeader(ChunkedInputFilter.java:256) at org.apache.coyote.http11.filters.ChunkedInputFilter.doRead(ChunkedInputFilter.java:129) at org.apache.coyote.http11.filters.ChunkedInputFilter.end(ChunkedInputFilter.java:179) at org.apache.coyote.http11.InternalInputBuffer.endRequest(InternalInputBuffer.java:368) at org.apache.coyote.http11.Http11Processor.process(Http11Processor.java:894) at org.apache.coyote.http11.Http11BaseProtocol$Http11ConnectionHandler.processConnection(Http11BaseProtocol.java:664) at org.apache.tomcat.util.net.PoolTcpEndpoint.processSocket(PoolTcpEndpoint.java:527) at org.apache.tomcat.util.net.LeaderFollowerWorkerThread.runIt(LeaderFollowerWorkerThread.java:80) at org.apache.tomcat.util.threads.ThreadPool$ControlRunnable.run(ThreadPool.java:684) at java.lang.Thread.run(Thread.java:595)</column><column name="report_time">2007-04-21 22:48:21</column><column name="report_timestamp">1177210000</column><column name="status">resolved fixed</column><column name="commit">cd05aa1</column><column name="commit_timestamp">1346110000</column><column name="files">java/org/apache/coyote/http11/filters/ChunkedInputFilter.java
java/org/apache/tomcat/util/buf/HexUtils.java
test/org/apache/tomcat/util/buf/TestHexUtils.java</column><column name="result">3:java/org/apache/coyote/http11/filters/ChunkedInputFilter.java
642:java/org/apache/tomcat/util/buf/HexUtils.java</column></table><table name="tomcat"><column name="id">241</column><column name="bug_id">53783</column><column name="summary">Static resources and jsp files under WEB-INF/lib/*.jar!/META-INF/resources are not found</column><column name="description">Created attachment 29283 Example Hi, According to Servlet Specification, Servlet container should serve static resources and jsp files, located in META-INF/resources in any jar file under WEB-INF/lib. " 10.5 Directory Structure A Web application exists as a structured hierarchy of directories. The root of this hierarchy serves as the document root for files that are part of the application. For example, for a Web application with the context path /catalog in a Web container, the index.html file at the base of the Web application hierarchy or in a JAR file inside WEB-INF/lib that includes the index.html under META-INF/resources directory can be served to satisfy a request from /catalog/index.html. If an index.html is present both in the root context and in the META-INF/resources directory of a JAR file in the WEB-INF/lib directory of the application, then the file that is available in the root context MUST be used. " When requesting such static resource/jsp file, Tomcat returns 404 Not Found. Example is attached. Request: http://localhost:8080/test-meta-inf-resources/test.jsp http://localhost:8080/test-meta-inf-resources/meta_inf_resource.jsp After investigating the issue I think that the problem is in the following code: org.apache.catalina.startup.ContextConfig protected void processResourceJARs(Set&lt;WebXml&gt; fragments) { ... if (jar.entryExists("META-INF/resources/")) { context.addResourceJarUrl(url); ... } When I list the entries in jar, I receive: INFO: Deploying web application archive C:\apache-tomcat-7.0.29\webapps\test-met a-inf-resources.war META-INF/MANIFEST.MF META-INF/resources/meta_inf_resource.jsp There is no entry "META-INF/resources/" I would like to propose a patch (attached) with which the request URLs above are working as expected. Best Regards Violeta Georgieva</column><column name="report_time">2012-08-27 13:32:16</column><column name="report_timestamp">1346090000</column><column name="status">resolved fixed</column><column name="commit">6b934d8</column><column name="commit_timestamp">1346090000</column><column name="files">java/org/apache/catalina/startup/ContextConfig.java</column><column name="result">1:java/org/apache/catalina/startup/ContextConfig.java</column></table><table name="tomcat"><column name="id">242</column><column name="bug_id">53758</column><column name="summary">Dynamic Filter Registration mapping logic inverted</column><column name="description">In the class org.apache.catalina.core.ApplicationFilterRegistration, the methods addMappingForServletNames and addMappingForUrlPatterns have inverted logic on how to register the filter to the context. If the parameter isMatchAfter is passed as true, the filter is placed in the context using the addFilterMapBefore method. if (isMatchAfter) { context.addFilterMapBefore(filterMap); } else { context.addFilterMap(filterMap); } The logic should ultimate be (in both methods): if (!isMatchAfter) { context.addFilterMapBefore(filterMap); } else { context.addFilterMap(filterMap); } or if (isMatchAfter) { context.addFilterMap(filterMap); } else { context.addFilterMapBefore(filterMap); } svn rev on trunk is 1375614</column><column name="report_time">2012-08-21 19:59:03</column><column name="report_timestamp">1345590000</column><column name="status">resolved fixed</column><column name="commit">8f169e4</column><column name="commit_timestamp">1346020000</column><column name="files">java/org/apache/catalina/core/ApplicationFilterRegistration.java</column><column name="result">2:java/org/apache/catalina/core/ApplicationFilterRegistration.java</column></table><table name="tomcat"><column name="id">243</column><column name="bug_id">53725</column><column name="summary">Some GZipped responses result in java.io.IOException: Corrupt GZIP trailer during gunzip.</column><column name="description">Created attachment 29238 Please see description for purpose of attachment. FlushableGZIPOutputStream gives corrupt output in rare circumstances. Tomcat 7 encounters this bug when compression is turned on. Please see the attachment: Compile and run ErrorCase.java which uses FlushableGZIPOutputStream to GZIP the contents of data.bin (included in the attachment) and then uses GZIPInputStream to gunzip the output of FlushableGZIPOutputStream, resulting in java.io.IOException: Corrupt GZIP trailer.</column><column name="report_time">2012-08-15 18:28:36</column><column name="report_timestamp">1345070000</column><column name="status">resolved fixed</column><column name="commit">3dff241</column><column name="commit_timestamp">1345930000</column><column name="files">java/org/apache/coyote/http11/filters/FlushableGZIPOutputStream.java</column><column name="result">17:java/org/apache/coyote/http11/filters/FlushableGZIPOutputStream.java</column></table><table name="tomcat"><column name="id">244</column><column name="bug_id">53714</column><column name="summary">misleading log output when jarsToSkip cointains web-fragments</column><column name="description">I have a jar which contains a web-fragment and no TLDs. When starting the server I get the Message: org.apache.jasper.compiler.TldLocationsCache tldScanJar INFO: At least one JAR was scanned for TLDs yet contained no TLDs. Enable debug logging for this logger for a complete list of JARs that were scanned but no TLDs were found in them. Skipping unneeded JARs during scanning can improve startup time and JSP compilation time. so far so good. When adding it to the tomcat.util.scan.DefaultJarScanner.jarsToSkip property the web-fragment won't be scanned either. The log message should only be printed when no TLDs and web-fragments could be found in the jar.</column><column name="report_time">2012-08-14 09:13:38</column><column name="report_timestamp">1344950000</column><column name="status">resolved fixed</column><column name="commit">15e8d8e</column><column name="commit_timestamp">1345840000</column><column name="files">java/org/apache/catalina/startup/Constants.java
java/org/apache/catalina/startup/ContextConfig.java
java/org/apache/catalina/startup/TldConfig.java
java/org/apache/jasper/Constants.java
java/org/apache/jasper/compiler/TldLocationsCache.java</column><column name="result">1:java/org/apache/catalina/startup/ContextConfig.java
3:java/org/apache/jasper/compiler/TldLocationsCache.java
4:java/org/apache/catalina/startup/TldConfig.java
218:java/org/apache/jasper/Constants.java
293:java/org/apache/catalina/startup/Constants.java</column></table><table name="tomcat"><column name="id">245</column><column name="bug_id">53697</column><column name="summary">java.lang.NullPointerException at org.apache.coyote.http11.Http11AprProcessor.actionInternal(Http11AprProcessor.java:277)</column><column name="description">I hit tomcat with ~20 different urls in ~2 seconds, test some functionality, wait ~3 minutes, then do it again and I always get this exception and then I get (intermitent) connection interrupted messages in the browser. Here's the full trace: Aug 10, 2012 6:33:14 PM org.apache.catalina.connector.CoyoteAdapter event SEVERE: null Aug 10, 2012 6:33:14 PM org.apache.catalina.connector.CoyoteAdapter event java.lang.NullPointerException 	at org.apache.coyote.http11.Http11AprProcessor.actionInternal(Http11AprProcessor.java:277) 	at org.apache.coyote.http11.AbstractHttp11Processor.action(AbstractHttp11Processor.java:846) 	at org.apache.coyote.Response.action(Response.java:172) 	at org.apache.catalina.connector.CoyoteAdapter.event(CoyoteAdapter.java:229) 	at org.apache.coyote.http11.Http11AprProcessor.event(Http11AprProcessor.java:133) 	at org.apache.coyote.AbstractProtocol$AbstractConnectionHandler.process(AbstractProtocol.java:581) 	at org.apache.tomcat.util.net.AprEndpoint$SocketProcessor.run(AprEndpoint.java:1770) 	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1110) 	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:603) 	at java.lang.Thread.run(Thread.java:722) Aug 10, 2012 6:33:14 PM org.apache.coyote.http11.Http11AprProcessor event SEVERE: Error processing request java.lang.NullPointerException 	at org.apache.coyote.http11.Http11AprProcessor.actionInternal(Http11AprProcessor.java:277) 	at org.apache.coyote.http11.AbstractHttp11Processor.action(AbstractHttp11Processor.java:846) 	at org.apache.coyote.Request.action(Request.java:346) 	at org.apache.catalina.connector.Request.getRemoteAddr(Request.java:1281) 	at org.apache.catalina.connector.Request.getRemoteHost(Request.java:1296) 	at org.apache.catalina.valves.AccessLogValve$HostElement.addElement(AccessLogValve.java:1327) 	at org.apache.catalina.valves.AccessLogValve.log(AccessLogValve.java:953) 	at org.apache.catalina.core.AccessLogAdapter.log(AccessLogAdapter.java:51) 	at org.apache.catalina.core.ContainerBase.logAccess(ContainerBase.java:1263) 	at org.apache.catalina.core.ContainerBase.logAccess(ContainerBase.java:1270) 	at org.apache.catalina.connector.CoyoteAdapter.event(CoyoteAdapter.java:250) 	at org.apache.coyote.http11.Http11AprProcessor.event(Http11AprProcessor.java:133) 	at org.apache.coyote.AbstractProtocol$AbstractConnectionHandler.process(AbstractProtocol.java:581) 	at org.apache.tomcat.util.net.AprEndpoint$SocketProcessor.run(AprEndpoint.java:1770) 	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1110) 	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:603) 	at java.lang.Thread.run(Thread.java:722) Additional information: - hp Proliant DL360 with two 3ghz processors - CentOS 6.3 - One app runs websockets under bleading edge Atmosphere and Grails - the 20 urls come from chrome and firefox, simulatneously</column><column name="report_time">2012-08-11 08:33:54</column><column name="report_timestamp">1344690000</column><column name="status">resolved fixed</column><column name="commit">6c13431</column><column name="commit_timestamp">1345070000</column><column name="files">java/org/apache/coyote/http11/AbstractHttp11Processor.java
java/org/apache/coyote/http11/Http11NioProcessor.java</column><column name="result">3:java/org/apache/coyote/http11/AbstractHttp11Processor.java
14:java/org/apache/coyote/http11/Http11NioProcessor.java</column></table><table name="tomcat"><column name="id">246</column><column name="bug_id">53702</column><column name="summary">Only the last url-pattern from jsp-property-group is processed</column><column name="description">Created attachment 29215 Modified files from the ROOT webapp According to XSDs (jsp_2_0.xsd, jsp_2_1.xsd, jsp_2_2.xsd), the "url-pattern" can occur more than once in the same "jsp-property-group". [[[ &lt;xsd:complexType name="jsp-property-groupType"&gt; ... &lt;xsd:element name="url-pattern" type="javaee:url-patternType" maxOccurs="unbounded"/&gt; ]]] There are three places where the "jsp-property-group" element is represented by an object in Tomcat: a) in Jasper, o.a.jasper.compiler.JspConfig$JspPropertyGroup b) in Catalina, o.a.catalina.deploy.JspPropertyGroup c) in Servlet 3.0 API, javax.servlet.descriptor.JspPropertyGroupDescriptor (implemented by o.a.c.core.ApplicationJspPropertyGroupDescriptor) The implementations in a) and c) are correct ones, but in b) the collection of url patterns is mistakenly represented by a single value and setUrlPattern() method. As the "setUrlPattern" method is called by digester (configured in o.a.c.startup.WebRuleSet), only the last url-pattern value survives. The observable consequences of this issue: =========================================== 1. Merged web.xml is reproduced and passed to Jasper incorrectly. (Currently it is passed only when metadata-complete="false" or absent, as I noted in Re:r1371995 on dev@, which is a different issue but it hides the effect of this one). 2. A known feature is that the paths mentioned in jsp-property-group are implicitly mapped to the JspServlet. Due to this issue this mapping occurs only for the last url-pattern. (in WebXml#configureContext()) To reproduce in current 7.0.x (7.0.29 is affected): ==================================================== 1. Unpack attached archive and put the files into the ROOT webapp. The files are context.xml with &lt;Context logEffectiveWebXml="true"/&gt; and web.xml without metadata-compete attribute and adding the following: [[[ &lt;jsp-config&gt; &lt;jsp-property-group&gt; &lt;url-pattern&gt;*.foo&lt;/url-pattern&gt; &lt;url-pattern&gt;*.bar&lt;/url-pattern&gt; &lt;is-xml&gt;true&lt;/is-xml&gt; &lt;/jsp-property-group&gt; &lt;/jsp-config&gt; ]]] 2. Start Tomcat and look into the "catalina.`date`.log" file. The merged web.xml should have been dumped there. Look for the "jsp-property-group" element. Actual result: [[[ &lt;jsp-config&gt; &lt;jsp-property-group&gt; &lt;url-pattern&gt;*.bar&lt;/url-pattern&gt; &lt;is-xml&gt;true&lt;/is-xml&gt; &lt;/jsp-property-group&gt; &lt;/jsp-config&gt; ]]] Expected result: both *.foo and *.bar should be mentioned. Tomcat 6 does not have this issue, because there is no such object in Catalina there. The digester configured in WebRuleSet calls StandardContext.addJspMapping(..), which is additive.</column><column name="report_time">2012-08-12 14:54:17</column><column name="report_timestamp">1344800000</column><column name="status">resolved fixed</column><column name="commit">e38a097</column><column name="commit_timestamp">1345060000</column><column name="files">java/org/apache/catalina/core/ApplicationJspPropertyGroupDescriptor.java
java/org/apache/catalina/deploy/JspPropertyGroup.java
java/org/apache/catalina/deploy/WebXml.java
java/org/apache/catalina/startup/WebRuleSet.java</column><column name="result">1:java/org/apache/catalina/deploy/JspPropertyGroup.java
2:java/org/apache/catalina/core/ApplicationJspPropertyGroupDescriptor.java
3:java/org/apache/catalina/deploy/WebXml.java
53:java/org/apache/catalina/startup/WebRuleSet.java</column></table><table name="tomcat"><column name="id">247</column><column name="bug_id">53654</column><column name="summary">JSP file is always recompiled for using file based TLD URL</column><column name="description">Now, in Jasper codes, it only supports jar URL and relative URL, that may be enough for common web applications. While, it is possible that the third-party uses other protocol URL, like file: protocol based URL. So, the JSP files will be always recompiled for each access for the target page. The codes are located in Compiler.isOutDated() method. Is it possible to provide more generic handlering for the URL ?</column><column name="report_time">2012-08-05 14:47:43</column><column name="report_timestamp">1344190000</column><column name="status">resolved fixed</column><column name="commit">1efc23d</column><column name="commit_timestamp">1345050000</column><column name="files">java/org/apache/jasper/compiler/Compiler.java</column><column name="result">1:java/org/apache/jasper/compiler/Compiler.java</column></table><table name="tomcat"><column name="id">248</column><column name="bug_id">53624</column><column name="summary">sendRedirect doesn't work after a dispatch through the AsyncContext</column><column name="description">A call to sendRedirect after AsyncContext.dispatch doesn't redirect and returns with a 200 status code instead. A project demonstrating the issue: https://github.com/rstoyanchev/dispatch-test Build and deploy the source in the 'tomcat-issue-repro'. From the home page of the deployed application, select the "Redirect" scenario. The scenario involves Servlet "RedirectA" that creates a thread and dispatches to Servlet "RedirectB", which in turn redirects to Servlet "RedirectC" and that forwards to a simple JSP page. Instead of the JSP page rendering, you should see a blank page and the log output will show that processing ended at ServletC. For details on the setup see WebAppInitializer.setupRedirectScenario(ServletContext). --- FWIW if a forward is used instead of a dispatch from the async thread, the scenario works. To do that, modify the line that creates servlet "RedirectA" to be ForwardingAsyncServlet instead of DispatchingAsyncServlet. --- This issue is very similar to 51197, which was marked resolved in 7.0.25. The current issue was tested against 7.0.29.</column><column name="report_time">2012-07-30 19:07:39</column><column name="report_timestamp">1343690000</column><column name="status">resolved fixed</column><column name="commit">e37b01e</column><column name="commit_timestamp">1344980000</column><column name="files">java/org/apache/catalina/core/ApplicationDispatcher.java</column><column name="result">75:java/org/apache/catalina/core/ApplicationDispatcher.java</column></table><table name="tomcat"><column name="id">249</column><column name="bug_id">53701</column><column name="summary">Javadoc fixes</column><column name="description">Created attachment 29214 Javadoc fixes The attached patch fixes various Javadoc issues</column><column name="report_time">2012-08-12 12:25:04</column><column name="report_timestamp">1344790000</column><column name="status">resolved fixed</column><column name="commit">2a3b42d</column><column name="commit_timestamp">1344970000</column><column name="files">java/javax/servlet/ServletInputStream.java
java/javax/servlet/ServletOutputStream.java
java/javax/servlet/jsp/JspException.java
java/org/apache/catalina/Executor.java
java/org/apache/catalina/Manager.java
java/org/apache/catalina/tribes/ErrorHandler.java
java/org/apache/naming/SelectorContext.java
java/org/apache/tomcat/util/http/fileupload/FileItem.java
webapps/examples/WEB-INF/classes/compressionFilters/CompressionResponseStream.java</column><column name="result">226:webapps/examples/WEB-INF/classes/compressionFilters/CompressionResponseStream.java
406:java/javax/servlet/jsp/JspException.java
631:java/org/apache/tomcat/util/http/fileupload/FileItem.java
644:java/org/apache/naming/SelectorContext.java
656:java/org/apache/catalina/Manager.java</column></table><table name="tomcat"><column name="id">250</column><column name="bug_id">53700</column><column name="summary">InternalNioOutputBuffer unused (debug?) code</column><column name="description">The class InternalNioOutputBuffer includes the field: int total = 0; This is currently defined at line 227, which is between the Javadoc and method body to which the Javadoc applies, i.e. private synchronized int writeToSocket. This invalidates the method Javadoc. The field is used to keep a running total of bytes written by the method; however the field is not actually referenced - the System.out.println statement is commented out. The field and associated code shcould probably be deleted. If the field is to be kept, it should be private, and it should probably be changed to long, and of course should be moved so it does not invalidate the method Javadoc.</column><column name="report_time">2012-08-12 11:17:07</column><column name="report_timestamp">1344780000</column><column name="status">resolved fixed</column><column name="commit">a2ca744</column><column name="commit_timestamp">1344970000</column><column name="files">java/org/apache/coyote/http11/InternalNioOutputBuffer.java</column><column name="result">1:java/org/apache/coyote/http11/InternalNioOutputBuffer.java</column></table><table name="tomcat"><column name="id">251</column><column name="bug_id">53574</column><column name="summary">metadata-complete="true" and servlet defined as jsp not working</column><column name="description">We have a servlet defined as &lt;servlet&gt; &lt;servlet-name&gt;VersionInfoServlet&lt;/servlet-name&gt; &lt;jsp-file&gt;/WEB-INF/svnrevision.jsp&lt;/jsp-file&gt; &lt;/servlet&gt; and mapped as &lt;servlet-mapping&gt; &lt;servlet-name&gt;VersionInfoServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/svnrevision&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; It worked fine. Then we changed metadata-complete to "true", and from now on we receive INFO: Marking servlet VersionInfoServlet as unavailable lip 20, 2012 11:05:36 AM org.apache.catalina.core.StandardWrapperValve invoke SEVERE: Allocate exception for servlet VersionInfoServlet javax.servlet.ServletException: No servlet class has been specified for servlet VersionInfoServlet at org.apache.catalina.core.StandardWrapper.loadServlet(StandardWrapper.java:1130) at org.apache.catalina.core.StandardWrapper.allocate(StandardWrapper.java:857) at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:136) at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:123) at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:168) at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:98) at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:118) at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:407) at org.apache.coyote.ajp.AjpNioProcessor.process(AjpNioProcessor.java:184) at org.apache.coyote.AbstractProtocol$AbstractConnectionHandler.process(AbstractProtocol.java:585) at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.run(NioEndpoint.java:1653) at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1110) at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:603) at java.lang.Thread.run(Thread.java:722)</column><column name="report_time">2012-07-20 09:35:23</column><column name="report_timestamp">1342790000</column><column name="status">resolved fixed</column><column name="commit">f9b0182</column><column name="commit_timestamp">1344710000</column><column name="files">java/org/apache/catalina/startup/ContextConfig.java
test/org/apache/catalina/startup/TestContextConfig.java</column><column name="result">2:java/org/apache/catalina/startup/ContextConfig.java
134:test/org/apache/catalina/startup/TestContextConfig.java</column></table><table name="tomcat"><column name="id">252</column><column name="bug_id">53545</column><column name="summary">jsp:forward action to static resources causes IllegalStateException when inside classic custom tag</column><column name="description">If we have a JSP like the one below we get java.lang.IllegalStateException: getOutputStream() has already been called for this response: Notes: 1. the jsp:forward is inside classic custom tag ( extends BodyTagSupport). 2. if I put a dynamic resource everything is fine (ex. redirect.jsp) 3. I think that the response gets flushed if jsp:forward redirects to a static resource and that's why the exception is trown. test.jsp &lt;%@ page language="java" contentType="text/html; charset=ISO-8859-1" pageEncoding="ISO-8859-1"%&gt; &lt;%@ taglib prefix="t" uri="test" %&gt; &lt;t:do&gt; &lt;jsp:forward page="redirect.html"/&gt; &lt;!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"&gt; &lt;html&gt; &lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"&gt; &lt;title&gt;Insert title here&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt; &lt;/html&gt; &lt;/t:do&gt;</column><column name="report_time">2012-07-13 07:53:20</column><column name="report_timestamp">1342180000</column><column name="status">resolved fixed</column><column name="commit">5a6b27b</column><column name="commit_timestamp">1344680000</column><column name="files">java/org/apache/jasper/runtime/PageContextImpl.java
test/org/apache/jasper/runtime/TestPageContextImpl.java
test/org/apache/tomcat/unittest/tags/Bug53545.java</column><column name="result">22:java/org/apache/jasper/runtime/PageContextImpl.java</column></table><table name="tomcat"><column name="id">253</column><column name="bug_id">53541</column><column name="summary">Bug in virtual webapp feature. Custom tags badly supported. Error is "org.apache.jasper.JasperException: The absolute uri: http://java.sun.com/jsp/jstl/core cannot be resolved in either web.xml or the jar files deployed with this application"</column><column name="description">Defect report - briefly: Tomcat implements virtual webapp feature. For details, see http://tomcat.apache.org/tomcat-7.0-doc/config/context.html#Virtual_webapp Tomcat 7.0.28 implementation of virtual webapp has a defect  it does not allow developer to use tag library from WEB-INF/lib/*.jar. For example, developer cant put well known jstl-1.2.jar into WEB-INF/lib/ and use it. Defect report  detailed: Proof of concept web application - lite-filter-mdot-1.0.0-BUILD-SNAPSHOT-sources.jar. Really, its a sample web app downloaded from Spring Source. You can download it from https://github.com/SpringSource/spring-mobile-samples. I just changed POM a little bit to remove redundant samples. Error screenshot  error.png Zipped tomcat CONF directory  defect-conf.zip ======From Spring.xml======== &lt;Context path="/spring" docBase="C:/Users/Filipp_Zuev/workspace/lite-filter-mdot/src/main/webapp" &gt; &lt;Resources className="org.apache.naming.resources.VirtualDirContext" extraResourcePaths= "/WEB-INF/classes=C:/Users/Filipp_Zuev/workspace/lite-filter-mdot/target/classes,/WEB-INF/lib=C:/Users/Filipp_Zuev/workspace/lite-filter-mdot/target/lite-filter-mdot-1.0.0-BUILD-SNAPSHOT/WEB-INF/lib" /&gt; &lt;Loader className="org.apache.catalina.loader.VirtualWebappLoader" virtualClasspath="C:/Users/Filipp_Zuev/workspace/lite-filter-mdot/target/classes; C:/Users/Filipp_Zuev/workspace/lite-filter-mdot/target/lite-filter-mdot-1.0.0-BUILD-SNAPSHOT/WEB-INF/lib/*.jar" /&gt; &lt;JarScanner scanAllDirectories="true" /&gt; &lt;/Context&gt; ============= Tomcat log file - catalina.2012-07-12.log Defectfix suggested: Add this method to org.apache.naming.resources.VirtualDirContext @Override 	protected String doGetRealPath(String path) { File file = file(path); if(null!=file){ 	return file.getAbsolutePath(); }else{ 	return null; } } Defectfix suggested-proof of concept: 1.	Deploy attached tomcat-extension-0.0.1-SNAPSHOT.jar with me.tomcat.bugfix.workaround.VirtualDirContext.class into Tomcats common lib directory. 2.	In the Context configuration for the proof of concept application replace org.apache.naming.resources.VirtualDirContext for me.tomcat.bugfix.workaround.VirtualDirContext 3.	Restart tomcat. Defect fixed!</column><column name="report_time">2012-07-12 18:16:08</column><column name="report_timestamp">1342130000</column><column name="status">resolved fixed</column><column name="commit">432bd0f</column><column name="commit_timestamp">1344630000</column><column name="files">java/org/apache/naming/resources/VirtualDirContext.java</column><column name="result">368:java/org/apache/naming/resources/VirtualDirContext.java</column></table><table name="tomcat"><column name="id">254</column><column name="bug_id">53481</column><column name="summary">Support SSL_OP_CIPHER_SERVER_PREFERENCE / SSLHonorCipherOrder</column><column name="description">Currently, Tomcat Native does not have an equivalent of the mod_ssl SSLHonorCipherOrder directive and is thus vulnerable to the SSL BEAST attack. See http://httpd.apache.org/docs/current/mod/mod_ssl.html#sslhonorcipherorder for the docs on this directive, and https://community.qualys.com/blogs/securitylabs/2011/10/17/mitigating-the-beast-attack-on-tls on why and how it mitigates the BEAST attack. Please incorporate an option named SSLHonorCipherOrder that sets the OpenSSL option SSL_OP_CIPHER_SERVER_PREFERENCE P.S., not sure whether to qualify this as bug or enhancement, but since it concerns a security issue I filed it as a bug. P.S.2, I'm willing to create a patch myself, but since I don't have an Tomcat Native build env that will probably take some time... It's a really small change.</column><column name="report_time">2012-06-28 14:27:30</column><column name="report_timestamp">1340910000</column><column name="status">resolved fixed</column><column name="commit">82e5dce</column><column name="commit_timestamp">1344530000</column><column name="files">java/org/apache/coyote/http11/Http11AprProtocol.java
java/org/apache/tomcat/util/net/AprEndpoint.java</column><column name="result">1:java/org/apache/tomcat/util/net/AprEndpoint.java
9:java/org/apache/coyote/http11/Http11AprProtocol.java</column></table><table name="tomcat"><column name="id">255</column><column name="bug_id">53641</column><column name="summary">Wrong websocket's subprotocol implementation</column><column name="description">According to RFC6455 Section 4.3. the handling of subprotocol requests is not correct. It must be checked for "Sec-WebSocket-Protocol" instead of "Sec-WebSocket-Protocol-Client" in WebSocketServlet class.</column><column name="report_time">2012-08-02 12:52:08</column><column name="report_timestamp">1343930000</column><column name="status">resolved fixed</column><column name="commit">af45441</column><column name="commit_timestamp">1344380000</column><column name="files">java/org/apache/catalina/websocket/WebSocketServlet.java</column><column name="result">1:java/org/apache/catalina/websocket/WebSocketServlet.java</column></table><table name="tomcat"><column name="id">256</column><column name="bug_id">53607</column><column name="summary">No message set for PING: TcpPingInterceptor fail with NullPointerException in ChannelData.getDataPackageLength()</column><column name="description">I added data.setMessage(new XByteBuffer(TCP_PING_DATA, false)); to TcpPingInterceptor send ping message function by: protected void sendPingMessage(Member[] members) { if ( members == null || members.length == 0 ) return; ChannelData data = new ChannelData(true);//generates a unique Id data.setAddress(getLocalMember(false)); data.setTimestamp(System.currentTimeMillis()); data.setOptions(getOptionFlag()); data.setMessage(new XByteBuffer(TCP_PING_DATA, false)); try { super.sendMessage(members, data, null); }catch (ChannelException x) { log.warn("Unable to send TCP ping.",x); } } error also for Tomcat 6 regards fred</column><column name="report_time">2012-07-26 18:33:54</column><column name="report_timestamp">1343340000</column><column name="status">resolved fixed</column><column name="commit">57b56f2</column><column name="commit_timestamp">1343720000</column><column name="files">java/org/apache/catalina/tribes/group/interceptors/TcpPingInterceptor.java</column><column name="result">1:java/org/apache/catalina/tribes/group/interceptors/TcpPingInterceptor.java</column></table><table name="tomcat"><column name="id">257</column><column name="bug_id">53606</column><column name="summary">NullPointerException in TcpPingInterceptor</column><column name="description">start(int) method initializes failureDetector (resp. staticMembers) only if TcpFailureDetector (resp. StaticMembershipInterceptor) was found in channel interceptors stack. Without TcpFailureDetector (resp. StaticMembershipInterceptor), futur calls to sendPing() will fail because failureDetector (resp. staticMembers) wasn't initialized at least to new WeakReference&lt;StaticMembershipInterceptor&gt;(null). Fix: v1) initializes weak references containers: Replace: WeakReference&lt;TcpFailureDetector&gt; failureDetector = null; WeakReference&lt;StaticMembershipInterceptor&gt; staticMembers = null; for: WeakReference&lt;TcpFailureDetector&gt; failureDetector = new WeakReference&lt;TcpFailureDetector&gt;(); WeakReference&lt;StaticMembershipInterceptor&gt; staticMembers = new WeakReference&lt;StaticMembershipInterceptor&gt;(); v2) checks field before dereferencing it: sendPing becomes: protected void sendPing() { if (failureDetector!=null &amp;&amp; failureDetector.get()!=null) { //we have a reference to the failure detector //piggy back on that dude failureDetector.get().checkMembers(true); }else { if (staticOnly &amp;&amp; staticMembers!=null &amp;&amp; staticMembers.get()!=null) { sendPingMessage(staticMembers.get().getMembers()); } else { sendPingMessage(getMembers()); } } } affect also tomcat 6 regards fred arnoud</column><column name="report_time">2012-07-26 16:15:05</column><column name="report_timestamp">1343330000</column><column name="status">resolved fixed</column><column name="commit">eb9f94e</column><column name="commit_timestamp">1343600000</column><column name="files">java/org/apache/catalina/tribes/group/interceptors/TcpPingInterceptor.java</column><column name="result">1:java/org/apache/catalina/tribes/group/interceptors/TcpPingInterceptor.java</column></table><table name="tomcat"><column name="id">258</column><column name="bug_id">53535</column><column name="summary">Out of memory while performing ContextConfig.webConfig</column><column name="description">Created attachment 29047 Suggested solution to improve ContextConfig JavaClassCacheEntry objects are using too much memory causing eventually (all kinds of) out of memory errors during container startup. There is no need to save whole JavaClass in cache since only superclass name and interface names are needed in later processing. Suggested solution is attached.</column><column name="report_time">2012-07-11 10:29:10</column><column name="report_timestamp">1342020000</column><column name="status">resolved fixed</column><column name="commit">7db08d3</column><column name="commit_timestamp">1343600000</column><column name="files">java/org/apache/catalina/startup/ContextConfig.java</column><column name="result">1:java/org/apache/catalina/startup/ContextConfig.java</column></table><table name="tomcat"><column name="id">259</column><column name="bug_id">53469</column><column name="summary">possible bug in Response.normalize(CharChunk cc)</column><column name="description">The Response.normalize(CharChunk cc) introduced in 7.0.28 introduced a bug. See Bug ID 53062 The URL that is being encoded is: ../../resources/org.apache.wicket.markup.html.WicketEventReference/wicket-event.js?w:lm=1340711670 which causes a IllegalArgumentException in this method java.lang.IllegalArgumentException 	at org.apache.catalina.connector.Response.normalize(Response.java:1799) 	at org.apache.catalina.connector.Response.toAbsolute(Response.java:1732) 	at org.apache.catalina.connector.Response.encodeURL(Response.java:1242) 	at org.apache.catalina.connector.ResponseFacade.encodeURL(ResponseFacade.java:406) 	at org.apache.wicket.protocol.http.WebResponse.encodeURL(WebResponse.java:149) 	at org.apache.wicket.protocol.http.request.WebRequestCodingStrategy.encode(WebRequestCodingStrategy.java:387) Running the same application in tomcat 7.0.27 and 6.0.18 works without issue</column><column name="report_time">2012-06-26 12:45:09</column><column name="report_timestamp">1340730000</column><column name="status">resolved fixed</column><column name="commit">9a80d06</column><column name="commit_timestamp">1343590000</column><column name="files">java/org/apache/catalina/connector/Response.java
test/org/apache/catalina/connector/TestResponse.java</column><column name="result">2:java/org/apache/catalina/connector/Response.java
28:test/org/apache/catalina/connector/TestResponse.java</column></table><table name="tomcat"><column name="id">260</column><column name="bug_id">53529</column><column name="summary">Call interrupt() after InterruptedException instead interrupted()</column><column name="description">In class: org\apache\catalina\tribes\group\GroupChannel.java line 692 org\apache\catalina\tribes\group\interceptors\NonBlockingCoordinator.java line 228 org\apache\catalina\tribes\group\interceptors\TcpPingInterceptor.java line 173 org\apache\catalina\tribes\membership\McastServiceImpl.java line 542 org\apache\juli\AsyncFileHandler.java line 124 line 146 org\apache\tomcat\util\net\AprEndpoint.java line 640 org\apache\tomcat\util\net\NioBlockingSelector.java line 112 line 177 org\apache\tomcat\util\threads\ThreadPoolExecutor.java line 187 Affect 7.0.29 (and previous release) but affect also Tomcat 6.</column><column name="report_time">2012-07-10 11:27:42</column><column name="report_timestamp">1341930000</column><column name="status">resolved fixed</column><column name="commit">3ea8285</column><column name="commit_timestamp">1343430000</column><column name="files">java/org/apache/catalina/tribes/group/GroupChannel.java
java/org/apache/catalina/tribes/group/interceptors/NonBlockingCoordinator.java
java/org/apache/catalina/tribes/group/interceptors/TcpPingInterceptor.java
java/org/apache/catalina/tribes/membership/McastServiceImpl.java
java/org/apache/juli/AsyncFileHandler.java
java/org/apache/tomcat/util/net/AprEndpoint.java
java/org/apache/tomcat/util/net/NioBlockingSelector.java
java/org/apache/tomcat/util/threads/ThreadPoolExecutor.java</column><column name="result">1:java/org/apache/catalina/tribes/membership/McastServiceImpl.java
2:java/org/apache/catalina/tribes/group/interceptors/TcpPingInterceptor.java
3:java/org/apache/catalina/tribes/group/GroupChannel.java
4:java/org/apache/tomcat/util/net/NioBlockingSelector.java
5:java/org/apache/tomcat/util/net/AprEndpoint.java
7:java/org/apache/catalina/tribes/group/interceptors/NonBlockingCoordinator.java
15:java/org/apache/juli/AsyncFileHandler.java
82:java/org/apache/tomcat/util/threads/ThreadPoolExecutor.java</column></table><table name="tomcat"><column name="id">261</column><column name="bug_id">53526</column><column name="summary">.ConnectionPool.terminateTransaction unsafe == check of Boolean</column><column name="description">The method ConnectionPool.terminateTransaction(PooledConnection con) uses == to check the value of a Boolean, viz: if (con.getPoolProperties().getDefaultAutoCommit()==Boolean.FALSE) { This is not 100% safe - if the user sets the property as follows: String value; // e.g. derived from property file ... setDefaultAutoCommit(new Boolean(value)); then the condition will never be true, even if value="false". Although it is better to use Boolean.valueOf(value), which would not have the same problem, the code ought to work regardless.</column><column name="report_time">2012-07-09 20:08:39</column><column name="report_timestamp">1341880000</column><column name="status">resolved fixed</column><column name="commit">eac6366</column><column name="commit_timestamp">1341930000</column><column name="files">modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/ConnectionPool.java</column><column name="result">1:modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/ConnectionPool.java</column></table><table name="tomcat"><column name="id">262</column><column name="bug_id">53523</column><column name="summary">rollbackOnReturn/commitOnReturn does not work without defaultAutoCommit=false</column><column name="description">Hi, The properties rollbackOnReturn and commitOnReturn, which are critical for cleaning up connections after they are used and returned to the pool, does not work when the defaultAutoCommit property is not set or when it is set to true. The code segment at ConnectionPool class has this, protected boolean terminateTransaction(PooledConnection con) { try { if (con.getPoolProperties().getDefaultAutoCommit()==Boolean.FALSE) { .... The full logic is wrapped in that first if statement, and as I see, that is not correct. Because, the actual default auto commit value when we don't set this property can either be autoCommit true or false, which depends on the database driver. And also, even when we have a default setting provided, the user has the freedom to change the autoCommit flag to either true or false at the beginning when they get the connection from the pool. So we should not be reading the pool properties in this place, but just check the current live connection's autoCommit value and act accordingly. So I suppose the fix should be to simply remove the outer if statement. Cheers, Anjana.</column><column name="report_time">2012-07-09 11:21:38</column><column name="report_timestamp">1341850000</column><column name="status">resolved wontfix</column><column name="commit">f54bb45</column><column name="commit_timestamp">1341860000</column><column name="files">modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/PoolConfiguration.java</column><column name="result">3:modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/PoolConfiguration.java</column></table><table name="tomcat"><column name="id">263</column><column name="bug_id">53513</column><column name="summary">Race condition / out of order operation in session replication at node startup</column><column name="description">My configuration: 2 nodes running Tomcat 7.0.26 Using a custom session manager, which extends the DeltaManager My startInternal() method first calls super.startInternal(), then performs a few additional initializations. I reviewed the code of DeltaManager.startInternal(), and it calls getAllClusterSessions() which in turn calls waitForSendAllSessions(), which requires either getStateTransfered() to return true, or a timeout. So by this, I should be able to trust that as the second node starts, the initial sync up of all session data from the first node has completed prior to the startInternal() method exiting (and thus prior to my initializations). This is, however, not the case! I can confirm this by repeatedly logging the value of findSessions().length during my inializations, and see that number going up! There appears to be a race condition between the processing of the message containing the actual session data &amp; the "transfer complete" message. After tracing this through a little further, I see the stateTransfered is set to true in the handleALL_SESSION_TRANSFERCOMPLETE() callback method. And that callback is being called PRIOR to the session data itself even being received! Here is the debug logging output (slightly scrubbed) which shows this out of order messaging: Jul 5, 2012 4:20:41 PM org.apache.catalina.ha.session.DeltaManager getAllClusterSessions INFO: Manager [wwwtest#], requesting session state from org.apache.catalina.tribes.membership.MemberImpl[...]. This operation will timeout if no session state has been received within 60 seconds. Jul 5, 2012 4:20:41 PM org.apache.catalina.ha.session.DeltaManager messageReceived FINE: Manager [wwwtest#]: Received SessionMessage of type=(SESSION-STATE-TRANSFERED) from [org.apache.catalina.tribes.membership.MemberImpl[...] Jul 5, 2012 4:20:41 PM org.apache.catalina.ha.session.DeltaManager handleALL_SESSION_TRANSFERCOMPLETE FINE: Manager [wwwtest#] received from node [[B@6789b939:4,000] session state transfered. Jul 5, 2012 4:20:41 PM org.apache.catalina.ha.session.DeltaManager messageReceived FINE: Manager [wwwtest#]: Received SessionMessage of type=(ALL-SESSION-DATA) from [org.apache.catalina.tribes.membership.MemberImpl[...] Jul 5, 2012 4:20:41 PM org.apache.catalina.ha.session.DeltaManager handleALL_SESSION_DATA FINE: Manager [wwwtest#]: received session state data</column><column name="report_time">2012-07-05 21:56:22</column><column name="report_timestamp">1341540000</column><column name="status">resolved fixed</column><column name="commit">4c03dff</column><column name="commit_timestamp">1341830000</column><column name="files">java/org/apache/catalina/ha/tcp/SimpleTcpCluster.java</column><column name="result">7:java/org/apache/catalina/ha/tcp/SimpleTcpCluster.java</column></table><table name="tomcat"><column name="id">264</column><column name="bug_id">53498</column><column name="summary">Atomicity violation bugs because of misusing concurrent collections</column><column name="description">Created attachment 29021 The patch that may fix the atomicity violation bugs. My name is Yu Lin. I'm a Ph.D. student in the CS department at UIUC. I'm currently doing research on mining Java concurrent library misusages. I found some misusages of ConcurrentHashMap in Tomcat 7.0.28, which may result in potential atomicity violation bugs or harm the performance. The code below is a snapshot of the code in file java/org/apache/catalina/core/ApplicationContext.java from line 761 to 767 and line 1262 to 1266 L761 found = attributes.containsKey(name); L762 if (found) { L763 value = attributes.get(name); L764 attributes.remove(name); L765 } else { L766 return; L767 } ... L1262 if (parameters.containsKey(name)) { L1263 return false; L1264 } L1265 L1266 parameters.put(name, value); In the code above, an atomicity violation may occur between lines 762 and 763. Suppose thread T1 executes line 761 and finds that the concurrent hashmap "attributes" contains the key "name". Before thread T1 executes line 763, another thread T2 removes the "name" key from "attributes". Now thread T1 resumes execution at line 763 and will get a null value for "name". Then the next line will throw a NullPointerException when invoking the method on "name". Second, the snapshot above has another atomicity violation. Let's look at lines 1262 and 1266. Suppose a thread T1 executes line 1262 and finds out the concurrent hashmap dose not contain the key "name". Before it gets to execute line 1266, another thread T2 puts a pair &lt;name, v&gt; in the concurrent hashmap "parameters". Now thread T1 resumes execution and it will overwrite the value written by thread T2. Thus, the code no longer preserves the "put-if-absent" semantics. I found some similar misusages in other files: In java/org/apache/catalina/ha/context/ReplicatedContext.java, similar atomicity violation may occur when another thread T2 remove the key "name" from concurrent hashmap "tomcatAttributes" before thread T1 executes line 172. In java/org/apache/catalina/startup/HostConfig.java, suppose thread T1 executes line 1480 and finds out the concurrent hashmap dose not contain the key "contextName". Before it executes line 1509, another thread T2 puts a pair &lt;contextName, v&gt; in the concurrent hashmap "deployed". Now thread T1 resumes execution and it will overwrite the value written by thread T2. Indeed, the putIfAbsent method shoule be used rather than put method at line 1509.</column><column name="report_time">2012-07-02 21:19:45</column><column name="report_timestamp">1341280000</column><column name="status">resolved fixed</column><column name="commit">4aef8e3</column><column name="commit_timestamp">1341440000</column><column name="files">java/org/apache/catalina/core/ApplicationContext.java
java/org/apache/catalina/ha/context/ReplicatedContext.java</column><column name="result">7:java/org/apache/catalina/core/ApplicationContext.java
110:java/org/apache/catalina/ha/context/ReplicatedContext.java</column></table><table name="tomcat"><column name="id">265</column><column name="bug_id">45995</column><column name="summary">RFE - MIME type extension not case sensitive</column><column name="description">Hi, On the dev-tomcat list I described in the topic "Byte Serving and PDFs with the DefaultServlet" an issue that I had with Tomcat to serve PDFs. Analysing the answers I could find that the matter was related to the case of the file extension. Today Tomcat is case sensitive for MIME type extensions. So the solution for me was enter two MIME specifications on the web.xml file. One is for "pdf" and another one for "PDF". This way I would like to ask for and request for enhancement to make Tomcat be able to, due a setup on configuration file, consider or not case for MIME type extensions. Regards, Vitor</column><column name="report_time">2008-10-13 04:32:38</column><column name="report_timestamp">1223890000</column><column name="status">resolved fixed</column><column name="commit">f8e173b</column><column name="commit_timestamp">1341220000</column><column name="files">java/org/apache/catalina/core/StandardContext.java</column><column name="result">1:java/org/apache/catalina/core/StandardContext.java</column></table><table name="tomcat"><column name="id">266</column><column name="bug_id">52135</column><column name="summary">Global error page is not handled</column><column name="description">The new Servlet 3.0 global error page &lt;error-page&gt; &lt;location&gt;/error.jsp&lt;/location&gt; &lt;/error-page&gt; is not handled in Tomcat 7. On Glassfish 3 for example, it works fine.</column><column name="report_time">2011-11-04 14:15:58</column><column name="report_timestamp">1320430000</column><column name="status">resolved fixed</column><column name="commit">6213b38</column><column name="commit_timestamp">1341060000</column><column name="files">java/org/apache/catalina/core/StandardContext.java
java/org/apache/catalina/core/StandardHostValve.java
java/org/apache/catalina/deploy/ErrorPage.java
test/org/apache/catalina/core/TestStandardHostValve.java</column><column name="result">3:java/org/apache/catalina/core/StandardContext.java
4:java/org/apache/catalina/deploy/ErrorPage.java
6:java/org/apache/catalina/core/StandardHostValve.java</column></table><table name="tomcat"><column name="id">267</column><column name="bug_id">53467</column><column name="summary">7.0.28 will no longer accept our jsp filenames</column><column name="description">We are currently running Tomcat7 7.0.27, and attempting to upgrade to 7.0.28. Some of our jsp files have square brackets and commas in the filenames, ie: WEB-INF/templates/com.example.standard/Container.asHeaderItem[_,_,closings].jsp With 7.0.27, this works fine. With 7.0.28, an error is thrown to the 'localhost.&lt;date&gt;.log' file, IE: Jun 25, 2012 4:17:42 PM org.apache.catalina.core.ApplicationContext log SEVERE: Failed to locate resource [/WEB-INF/templates//com.example.standard/CMContainer.asHeaderItem[_,_,closings].jsp] in context [/cae] java.net.URISyntaxException: Illegal character in path at index 123: jndi:/localhost/cae/WEB-INF/templates/com.example.standard/Container.asHeaderItem[_,_,closings].jsp at java.net.URI$Parser.fail(URI.java:2810) at java.net.URI$Parser.checkChars(URI.java:2983) at java.net.URI$Parser.parseHierarchical(URI.java:3067) at java.net.URI$Parser.parse(URI.java:3015) at java.net.URI.&lt;init&gt;(URI.java:806) at org.apache.catalina.core.ApplicationContext.getResource(ApplicationContext.java:537) at org.apache.catalina.core.ApplicationContextFacade.getResource(ApplicationContextFacade.java:201) at org.springframework.web.context.support.ServletContextResource.exists(ServletContextResource.java:101) Looks like this is the change that is breaking things: http://svn.apache.org/viewvc/tomcat/trunk/java/org/apache/catalina/core/ApplicationContext.java?r1=1344890&amp;r2=1345357&amp;pathrev=1345357 Was this intentional? Or is our naming actually OK and this is a new bug?</column><column name="report_time">2012-06-25 21:56:46</column><column name="report_timestamp">1340680000</column><column name="status">resolved fixed</column><column name="commit">4de4325</column><column name="commit_timestamp">1340820000</column><column name="files">java/org/apache/catalina/core/ApplicationContext.java
test/org/apache/catalina/core/TestApplicationContext.java</column><column name="result">17:java/org/apache/catalina/core/ApplicationContext.java
297:test/org/apache/catalina/core/TestApplicationContext.java</column></table><table name="tomcat"><column name="id">268</column><column name="bug_id">53416</column><column name="summary">Two datasources with the same name in different web applications results in javax.management.InstanceAlreadyExistsException</column><column name="description">Deploy two different web applications onto Tomcat. Each web application has a resource that: * uses the Use Tomcat JDBC Connection Pool * has an identical name to the other one &lt;Resource name="jdbc/collision" factory="org.apache.tomcat.jdbc.pool.DataSourceFactory" ... /&gt; When starting the server you get a non fatal error in the logs InstanceAlreadyExistsException. Both applications appear to still work OK ERROR org.apache.tomcat.jdbc.pool.DataSource - Unable to register JDBC pool with JMX javax.management.InstanceAlreadyExistsException: tomcat.jdbc:name="jdbc/soscvuk",context=/,type=ConnectionPool,host=localhost,class=org.apache.tomcat.jdbc.pool. DataSource 	at com.sun.jmx.mbeanserver.Repository.addMBean(Repository.java:453) ~[na:1.6.0_32] 	at com.sun.jmx.interceptor.DefaultMBeanServerInterceptor.internal_addObject(DefaultMBeanServerInterceptor.java:1484) [na:1.6.0_32] 	at com.sun.jmx.interceptor.DefaultMBeanServerInterceptor.registerDynamicMBean(DefaultMBeanServerInterceptor.java:963) [na:1.6.0_32] 	at com.sun.jmx.interceptor.DefaultMBeanServerInterceptor.registerObject(DefaultMBeanServerInterceptor.java:917) [na:1.6.0_32] 	at com.sun.jmx.interceptor.DefaultMBeanServerInterceptor.registerMBean(DefaultMBeanServerInterceptor.java:312) [na:1.6.0_32] 	at com.sun.jmx.mbeanserver.JmxMBeanServer.registerMBean(JmxMBeanServer.java:482) [na:1.6.0_32] 	at org.apache.tomcat.jdbc.pool.DataSource.registerJmx(DataSource.java:135) [tomcat-jdbc.jar:na] 	at org.apache.tomcat.jdbc.pool.DataSource.preRegister(DataSource.java:102) [tomcat-jdbc.jar:na] 	at org.apache.tomcat.util.modeler.BaseModelMBean.preRegister(BaseModelMBean.java:1132) [tomcat-coyote.jar:7.0.27] 	at com.sun.jmx.interceptor.DefaultMBeanServerInterceptor.preRegisterInvoke(DefaultMBeanServerInterceptor.java:1010) [na:1.6.0_32] 	at com.sun.jmx.interceptor.DefaultMBeanServerInterceptor.registerDynamicMBean(DefaultMBeanServerInterceptor.java:938) [na:1.6.0_32] 	at com.sun.jmx.interceptor.DefaultMBeanServerInterceptor.registerObject(DefaultMBeanServerInterceptor.java:917) [na:1.6.0_32] 	at com.sun.jmx.interceptor.DefaultMBeanServerInterceptor.registerMBean(DefaultMBeanServerInterceptor.java:312) [na:1.6.0_32] 	at com.sun.jmx.mbeanserver.JmxMBeanServer.registerMBean(JmxMBeanServer.java:482) [na:1.6.0_32] 	at org.apache.tomcat.util.modeler.Registry.registerComponent(Registry.java:742) [tomcat-coyote.jar:7.0.27] 	at org.apache.catalina.core.NamingContextListener.addResource(NamingContextListener.java:1062) [catalina.jar:7.0.27] 	at org.apache.catalina.core.NamingContextListener.createNamingContext(NamingContextListener.java:671) [catalina.jar:7.0.27] 	at org.apache.catalina.core.NamingContextListener.lifecycleEvent(NamingContextListener.java:270) [catalina.jar:7.0.27] 	at org.apache.catalina.util.LifecycleSupport.fireLifecycleEvent(LifecycleSupport.java:119) [catalina.jar:7.0.27] 	at org.apache.catalina.util.LifecycleBase.fireLifecycleEvent(LifecycleBase.java:90) [catalina.jar:7.0.27] 	at org.apache.catalina.core.StandardContext.startInternal(StandardContext.java:5161) [catalina.jar:7.0.27] 	at org.apache.catalina.util.LifecycleBase.start(LifecycleBase.java:150) [catalina.jar:7.0.27] 	at org.apache.catalina.core.ContainerBase.addChildInternal(ContainerBase.java:895) [catalina.jar:7.0.27] 	at org.apache.catalina.core.ContainerBase.addChild(ContainerBase.java:871) [catalina.jar:7.0.27] 	at org.apache.catalina.core.StandardHost.addChild(StandardHost.java:615) [catalina.jar:7.0.27] 	at org.apache.catalina.startup.HostConfig.deployDescriptor(HostConfig.java:649) [catalina.jar:7.0.27] 	at org.apache.catalina.startup.HostConfig$DeployDescriptor.run(HostConfig.java:1585) [catalina.jar:7.0.27] 	at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:441) [na:1.6.0_32] 	at java.util.concurrent.FutureTask$Sync.innerRun(FutureTask.java:303) [na:1.6.0_32] 	at java.util.concurrent.FutureTask.run(FutureTask.java:138) [na:1.6.0_32] 	at java.util.concurrent.ThreadPoolExecutor$Worker.runTask(ThreadPoolExecutor.java:886) [na:1.6.0_32] 	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:908) [na:1.6.0_32] 	at java.lang.Thread.run(Thread.java:662) [na:1.6.0_32]</column><column name="report_time">2012-06-14 13:37:06</column><column name="report_timestamp">1339700000</column><column name="status">resolved fixed</column><column name="commit">ff9a272</column><column name="commit_timestamp">1340820000</column><column name="files">modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/DataSource.java</column><column name="result">1:modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/DataSource.java</column></table><table name="tomcat"><column name="id">269</column><column name="bug_id">53465</column><column name="summary">mapped-name is read when in @Resource, but not when in web.xml</column><column name="description">Created attachment 28995 Patch proposal Hi, When I have the code below in a servlet 	@Resource(mappedName="test") 	private DataSource ds; 'mapped name' is read when @Resource is processed (org.apache.catalina.startup.WebAnnotationSet.addResource(WebAnnotationSet.java:377)) so later on it is available through Reference object as StringRefAddr But when I have the declaration below in web.xml &lt;resource-ref&gt; 	&lt;res-ref-name&gt;datasource&lt;/res-ref-name&gt; 	&lt;res-type&gt;javax.sql.DataSource&lt;/res-type&gt; 	&lt;mapped-name&gt;test&lt;/mapped-name&gt; &lt;/resource-ref&gt; 'mapped name' is not read at all. I would like to propose a patch that adds additional Rule to WebRuleSet so that 'mapped name' is process and set as property. I'm looking forward to your comments. Regards Violeta Georgieva</column><column name="report_time">2012-06-25 20:31:48</column><column name="report_timestamp">1340670000</column><column name="status">resolved fixed</column><column name="commit">7ecd402</column><column name="commit_timestamp">1340750000</column><column name="files">java/org/apache/catalina/startup/WebRuleSet.java
test/org/apache/naming/resources/TestNamingContext.java</column><column name="result">23:test/org/apache/naming/resources/TestNamingContext.java
24:java/org/apache/catalina/startup/WebRuleSet.java</column></table><table name="tomcat"><column name="id">270</column><column name="bug_id">53460</column><column name="summary">Use error handling when TooManyActiveSessionsException happens in JSP</column><column name="description">I noticed this while testing the fix for bug 53230 in Tomcat 6. To reproduce: 1. Limit the count of active sessions supported by session manager, by adding the following line to conf/server.xml: &lt;Manager maxActiveSessions="0" /&gt; 2. Start Tomcat and access the NumGuess example: http://localhost:8080/examples/jsp/num/numguess.jsp Actual result: - Blank page. - An error (SEVERE) is logged by JspFactoryImpl.internalGetPageContext(), where this exception is swallowed. Expected result: - Error page. - This expected issue does not deserve severe logging. Note, that simply rethrowing it in JspFactoryImpl.internalGetPageContext() will not help, as will be further swallowed by Java code of JSP page and proper error handling there does not happen without a PageContext instance - see r1347100 for related fix. Maybe create PageContext instance and initialize session in two separate calls? So that if session initialization fails, it could be handled by that PageContext instance. Stack trace: (trunk, running with SecurityManager enabled) [[[ 23-Jun-2012 17:28:20.937 SEVERE [http-apr-8080-exec-2] org.apache.jasper.runtime.JspFactoryImpl.internalGetPageContext Exception initializing page context org.apache.catalina.session.TooManyActiveSessionsException: createSession: Too many active sessions 	at org.apache.catalina.session.ManagerBase.createSession(ManagerBase.java:616) 	at org.apache.catalina.connector.Request.doGetSession(Request.java:2687) 	at org.apache.catalina.connector.Request.getSession(Request.java:2119) 	at org.apache.catalina.connector.RequestFacade$GetSessionPrivilegedAction.run(RequestFacade.java:217) 	at org.apache.catalina.connector.RequestFacade$GetSessionPrivilegedAction.run(RequestFacade.java:206) 	at java.security.AccessController.doPrivileged(Native Method) 	at org.apache.catalina.connector.RequestFacade.getSession(RequestFacade.java:895) 	at org.apache.catalina.connector.RequestFacade.getSession(RequestFacade.java:910) 	at org.apache.jasper.runtime.PageContextImpl._initialize(PageContextImpl.java:146) 	at org.apache.jasper.runtime.PageContextImpl.initialize(PageContextImpl.java:125) 	at org.apache.jasper.runtime.JspFactoryImpl.internalGetPageContext(JspFactoryImpl.java:112) 	at org.apache.jasper.runtime.JspFactoryImpl.access$000(JspFactoryImpl.java:41) 	at org.apache.jasper.runtime.JspFactoryImpl$PrivilegedGetPageContext.run(JspFactoryImpl.java:156) 	at org.apache.jasper.runtime.JspFactoryImpl$PrivilegedGetPageContext.run(JspFactoryImpl.java:129) 	at java.security.AccessController.doPrivileged(Native Method) 	at org.apache.jasper.runtime.JspFactoryImpl.getPageContext(JspFactoryImpl.java:63) 	at org.apache.jsp.jsp.num.numguess_jsp._jspService(numguess_jsp.java:54) ]]]</column><column name="report_time">2012-06-23 14:02:41</column><column name="report_timestamp">1340470000</column><column name="status">resolved fixed</column><column name="commit">294c52b</column><column name="commit_timestamp">1340740000</column><column name="files">java/org/apache/jasper/compiler/Generator.java
java/org/apache/jasper/runtime/JspFactoryImpl.java</column><column name="result">70:java/org/apache/jasper/compiler/Generator.java
179:java/org/apache/jasper/runtime/JspFactoryImpl.java</column></table><table name="tomcat"><column name="id">271</column><column name="bug_id">53445</column><column name="summary">Support consistent Jmx object naming strategy across managed resources</column><column name="description">Tomcat JDBC Pool Versions tested: 7.0.27 &amp; 7.0.28 More of an inquiry. Let me preface by saying we have recently adopted this pool and are very pleased so far. Currently, Jmx managed resources like ConnectionPool and SlowQueryReportJmx are registered under the same domain (i.e. tomcat.jdbc). Some users may want to employ an alternate object naming strategy. With DataSource#createObjectName it is relatively easy to change the ConnectionPool ObjectName (i.e. subclass). However, with SlowQueryReportJmx, due to a static getObjectName method, it requires overriding additional methods which is less desirable. It appears that ConnectionPool has a constant POOL_JMX_TYPE_PREFIX. SlowQueryReportJmx appears to use this but DataSource does not? Is there any reason that the SlowQueryReportJmx#getObjectName method is static? What about registering an object naming strategy with the pool that the various components would use, facilitating consistency? This would mitigate the need to override just to alter the ObjectName. Reference: Spring MBean exporters and their ObjectNamingStrategy interface. Thanks.</column><column name="report_time">2012-06-20 19:20:53</column><column name="report_timestamp">1340230000</column><column name="status">resolved fixed</column><column name="commit">4e010fc</column><column name="commit_timestamp">1340740000</column><column name="files">modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/ConnectionPool.java
modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/DataSource.java
modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/interceptor/SlowQueryReportJmx.java
modules/jdbc-pool/src/test/java/org/apache/tomcat/jdbc/test/TestSlowQueryReport.java</column><column name="result">1:modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/ConnectionPool.java
3:modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/interceptor/SlowQueryReportJmx.java
8:modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/DataSource.java
16:modules/jdbc-pool/src/test/java/org/apache/tomcat/jdbc/test/TestSlowQueryReport.java</column></table><table name="tomcat"><column name="id">272</column><column name="bug_id">53430</column><column name="summary">JVM crash at startup if TC-Native version is too old</column><column name="description">For each Tomcat release there exists minimum version of Tomcat-Native library with which it can work. Tomcat 7.0.28 requires Tomcat-Native 1.1.24 or later. If you try to start it with an older version of the library + it is explicitly configured it to use the "Apr" variant of a connector, then it crashes the JVM at startup. Actual result: Tomcat will not start and will crash the JVM. A crash report file is created by JVM (hs_err_pidNNNN.log) Stack trace from the crash report file: [[[ Stack: [0x008c0000,0x00910000], sp=0x0090f634, free space=317k Native frames: (J=compiled Java code, j=interpreted, Vv=VM code, C=native code) C [tcnative-1.dll+0xf762] C [tcnative-1.dll+0x6ddd] Java_org_apache_tomcat_jni_Pool_create+0x1d j org.apache.tomcat.jni.Pool.create(J)J+0 j org.apache.tomcat.util.net.AprEndpoint.bind()V+2 j org.apache.tomcat.util.net.AbstractEndpoint.init()V+8 j org.apache.coyote.AbstractProtocol.init()V+274 j org.apache.catalina.connector.Connector.initInternal()V+49 j org.apache.catalina.util.LifecycleBase.init()V+29 j org.apache.catalina.core.StandardService.initInternal()V+105 j org.apache.catalina.util.LifecycleBase.init()V+29 j org.apache.catalina.core.StandardServer.initInternal()V+212 j org.apache.catalina.util.LifecycleBase.init()V+29 j org.apache.catalina.startup.Catalina.load()V+573 j org.apache.catalina.startup.Catalina.load([Ljava/lang/String;)V+9 ]]] Expected result: 1. Log an error and do not initialize the connector. Do not initialize the endpoint. If org.apache.catalina.startup.EXIT_ON_INIT_FAILURE=true system property is configured [1], then exit Tomcat. If the property is not defined or is false (its current default value), then continue with startup sequence, without that connector. [1] http://tomcat.apache.org/tomcat-7.0-doc/config/systemprops.html --------------------- Steps to reproduce: (on Windows) 1. Place an older version of tcnative-1.dll (e.g. the one from Tomcat 7.0.27) into the bin directory. 2. Configure connector with one of these: protocol="org.apache.coyote.http11.Http11AprProtocol" protocol="org.apache.coyote.ajp.AjpAprProtocol" 3. Start Tomcat Actual result: JVM crashes, as described above. --------------------- Notes on the code: 1. The issue is that AprLifecycleListener.isAprAvailable() flag is only tested by Connector#setProtocol(String) and influences autoselection of protocols. If an Apr protocol implementation is configured explicitly, it does not prevent it from starting. 2. The code is essentially the same in 6.0 and 5.5. So it is an old issue. This issue happens when running the testsuite because the testsuite explicitly selects the Apr connector. 3. If tc-native version is below required one, AprLifecycleListener shuts down the library by calling terminateAPR(). That is why an old library crashes early. 4. AprEndpoint is not supposed to call AprLifecycleListener.isAprAvailable() directly, because they belong to different subsystems (coyote, tomcat.util.net vs. catalina.core). Do we care? We can do the isAprAvailable() check in Connector class, but it would mean that Connector class should know which ProtocolHandler implementations require the library. It could guess it from ProtocolHandler class name (contains("Apr")), but it is not pretty. --------------------- Thread on dev@: "tcnative version check broken for test suite of TC 7" (2012-06-16) http://tomcat.markmail.org/thread/izbqzmfgs7jdgnnq</column><column name="report_time">2012-06-17 10:16:07</column><column name="report_timestamp">1339940000</column><column name="status">resolved fixed</column><column name="commit">553259c</column><column name="commit_timestamp">1340630000</column><column name="files">java/org/apache/catalina/connector/Connector.java
java/org/apache/coyote/AbstractProtocol.java
java/org/apache/coyote/ProtocolHandler.java
java/org/apache/coyote/ajp/AjpAprProtocol.java
java/org/apache/coyote/http11/Http11AprProtocol.java</column><column name="result">98:java/org/apache/coyote/ajp/AjpAprProtocol.java
102:java/org/apache/catalina/connector/Connector.java
103:java/org/apache/coyote/http11/Http11AprProtocol.java
581:java/org/apache/coyote/AbstractProtocol.java
678:java/org/apache/coyote/ProtocolHandler.java</column></table><table name="tomcat"><column name="id">273</column><column name="bug_id">53421</column><column name="summary">BeanELResolver's inner class BeanProperty throws incorrect message while PropertyNotFound</column><column name="description">BeanELResolver's inner class BeanProperty(line: 264) has two methods (write, read) that will throw PropertyNotFoundException. And there current implementation are wrong: throw new PropertyNotFoundException(message(ctx, "propertyNotWritable", new Object[] { type.getName(), descriptor.getName() })); it should use owner.getName() instead of type.getName() because the assembled message will be: Property '[descriptor.getName()]' not readable on type [type.getName()] Here the descriptor.getName() means the property name, type.getName() means the property type's name and the owner.getName() means the property owner - bean's type name. Of course we developer would prefer to receive a message that tells us which bean type doesn't contain such property because this is a PropertyNotFoundException.</column><column name="report_time">2012-06-15 13:54:17</column><column name="report_timestamp">1339780000</column><column name="status">resolved fixed</column><column name="commit">8a13b39</column><column name="commit_timestamp">1340460000</column><column name="files">java/javax/el/BeanELResolver.java
test/javax/el/TestBeanELResolver.java</column><column name="result">1:java/javax/el/BeanELResolver.java</column></table><table name="tomcat"><column name="id">274</column><column name="bug_id">53450</column><column name="summary">Deployment of an application with 'ROOT' context hangs forever</column><column name="description">Hi, The scenario is the following: - I have running Tomcat 7.0.28 - I deploy an application with 'ROOT' context - The deployment hangs forever. When taking a tread dump, the following is suspicious: "localhost-startStop-2" daemon prio=6 tid=0x0000000006607800 nid=0x2560 waiting on condition [0x0000000009ebf000] java.lang.Thread.State: WAITING (parking) at sun.misc.Unsafe.park(Native Method) - parking to wait for &lt;0x00000007d80f0108&gt; (a java.util.concurrent.locks.ReentrantReadWriteLock$NonfairSync) at java.util.concurrent.locks.LockSupport.park(LockSupport.java:158) at java.util.concurrent.locks.AbstractQueuedSynchronizer.parkAndCheckInterrupt(AbstractQueuedSynchronizer.java:811) at java.util.concurrent.locks.AbstractQueuedSynchronizer.acquireQueued(AbstractQueuedSynchronizer.java:842) at java.util.concurrent.locks.AbstractQueuedSynchronizer.acquire(AbstractQueuedSynchronizer.java:1178) at java.util.concurrent.locks.ReentrantReadWriteLock$WriteLock.lock(ReentrantReadWriteLock.java:807) at org.apache.catalina.core.ContainerBase.removeContainerListener(ContainerBase.java:1071) at org.apache.catalina.core.StandardEngine$AccessLogListener.uninstall(StandardEngine.java:463) at org.apache.catalina.core.StandardEngine$AccessLogListener.containerEvent(StandardEngine.java:505) at org.apache.catalina.core.ContainerBase.fireContainerEvent(ContainerBase.java:1431) at org.apache.catalina.core.ContainerBase.addChildInternal(ContainerBase.java:907) at org.apache.catalina.core.ContainerBase.addChild(ContainerBase.java:875) at org.apache.catalina.core.StandardHost.addChild(StandardHost.java:618) at org.apache.catalina.startup.HostConfig.deployDirectory(HostConfig.java:1100) at org.apache.catalina.startup.HostConfig$DeployDirectory.run(HostConfig.java:1618) at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:441) at java.util.concurrent.FutureTask$Sync.innerRun(FutureTask.java:303) at java.util.concurrent.FutureTask.run(FutureTask.java:138) at java.util.concurrent.ThreadPoolExecutor$Worker.runTask(ThreadPoolExecutor.java:886) at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:908) at java.lang.Thread.run(Thread.java:662) As you can see - A read lock is acquired at org.apache.catalina.core.ContainerBase.fireContainerEvent(ContainerBase.java:1425) - Then every listener is invoked to process the container event - Then AccessLogListener is invoked org.apache.catalina.core.StandardEngine$AccessLogListener.uninstall(StandardEngine.java:463) - The latter causes a call for a write lock org.apache.catalina.core.ContainerBase.removeContainerListener(ContainerBase.java:1071) - Unfortunately in the ReentrantReadWriteLock it is stated that upgrade from read to write lock is not possible "Reentrancy also allows downgrading from the write lock to a read lock, by acquiring the write lock, then the read lock and then releasing the write lock. However, upgrading from a read lock to the write lock is not possible." Regards Violeta Georgieva</column><column name="report_time">2012-06-21 18:22:10</column><column name="report_timestamp">1340320000</column><column name="status">resolved fixed</column><column name="commit">91a13d2</column><column name="commit_timestamp">1340310000</column><column name="files">java/org/apache/catalina/core/ContainerBase.java</column><column name="result">1:java/org/apache/catalina/core/ContainerBase.java</column></table><table name="tomcat"><column name="id">275</column><column name="bug_id">53406</column><column name="summary">Stack overflow in connector</column><column name="description">found against trunk on Jun 18, 2012 SEVERE: java.lang.StackOverflowError at org.apache.catalina.core.StandardContextValve.event(StandardContextValve.java:128) at org.apache.catalina.valves.ValveBase.event(ValveBase.java:204) at org.apache.catalina.core.StandardHostValve.event(StandardHostValve.java:223) at org.apache.catalina.valves.ValveBase.event(ValveBase.java:204) at org.apache.catalina.valves.ValveBase.event(ValveBase.java:204) at org.apache.catalina.core.StandardEngineValve.event(StandardEngineValve.java:110) at org.apache.catalina.connector.CoyoteAdapter.event(CoyoteAdapter.java:209) at org.apache.coyote.http11.Http11NioProcessor.event(Http11NioProcessor.java:124) at org.apache.coyote.AbstractProtocol$AbstractConnectionHandler.process(AbstractProtocol.java:569) at org.apache.coyote.http11.Http11NioProtocol$Http11ConnectionHandler.process(Http11NioProtocol.java:223) at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.run(NioEndpoint.java:1653) at org.apache.tomcat.util.net.NioEndpoint.processSocket(NioEndpoint.java:730) at org.apache.tomcat.util.net.NioEndpoint$Poller.add(NioEndpoint.java:1008) at org.apache.tomcat.util.net.NioEndpoint$Poller.add(NioEndpoint.java:999) at org.apache.coyote.http11.Http11NioProtocol$Http11ConnectionHandler.longPoll(Http11NioProtocol.java:277) at org.apache.coyote.AbstractProtocol$AbstractConnectionHandler.process(AbstractProtocol.java:596) at org.apache.coyote.http11.Http11NioProtocol$Http11ConnectionHandler.process(Http11NioProtocol.java:223) at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.run(NioEndpoint.java:1653) at org.apache.tomcat.util.net.NioEndpoint.processSocket(NioEndpoint.java:730) at org.apache.tomcat.util.net.NioEndpoint$Poller.add(NioEndpoint.java:1008) at org.apache.tomcat.util.net.NioEndpoint$Poller.add(NioEndpoint.java:999) at org.apache.coyote.http11.Http11NioProtocol$Http11ConnectionHandler.longPoll(Http11NioProtocol.java:277) at org.apache.coyote.AbstractProtocol$AbstractConnectionHandler.process(AbstractProtocol.java:596) at org.apache.coyote.http11.Http11NioProtocol$Http11ConnectionHandler.process(Http11NioProtocol.java:223) at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.run(NioEndpoint.java:1653) at org.apache.tomcat.util.net.NioEndpoint.processSocket(NioEndpoint.java:730) at org.apache.tomcat.util.net.NioEndpoint$Poller.add(NioEndpoint.java:1008) at org.apache.tomcat.util.net.NioEndpoint$Poller.add(NioEndpoint.java:999) at org.apache.coyote.http11.Http11NioProtocol$Http11ConnectionHandler.longPoll(Http11NioProtocol.java:277) at org.apache.coyote.AbstractProtocol$AbstractConnectionHandler.process(AbstractProtocol.java:596) at org.apache.coyote.http11.Http11NioProtocol$Http11ConnectionHandler.process(Http11NioProtocol.java:223) at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.run(NioEndpoint.java:1653) at org.apache.tomcat.util.net.NioEndpoint.processSocket(NioEndpoint.java:730) at org.apache.tomcat.util.net.NioEndpoint$Poller.add(NioEndpoint.java:1008) at org.apache.tomcat.util.net.NioEndpoint$Poller.add(NioEndpoint.java:999) at org.apache.coyote.http11.Http11NioProtocol$Http11ConnectionHandler.longPoll(Http11NioProtocol.java:277) at org.apache.coyote.AbstractProtocol$AbstractConnectionHandler.process(AbstractProtocol.java:596) at org.apache.coyote.http11.Http11NioProtocol$Http11ConnectionHandler.process(Http11NioProtocol.java:223) at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.run(NioEndpoint.java:1653) at org.apache.tomcat.util.net.NioEndpoint.processSocket(NioEndpoint.java:730) at org.apache.tomcat.util.net.NioEndpoint$Poller.add(NioEndpoint.java:1008) at org.apache.tomcat.util.net.NioEndpoint$Poller.add(NioEndpoint.java:999) at org.apache.coyote.http11.Http11NioProtocol$Http11ConnectionHandler.longPoll(Http11NioProtocol.java:277) at org.apache.coyote.AbstractProtocol$AbstractConnectionHandler.process(AbstractProtocol.java:596) at org.apache.coyote.http11.Http11NioProtocol$Http11ConnectionHandler.process(Http11NioProtocol.java:223) at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.run(NioEndpoint.java:1653) at org.apache.tomcat.util.net.NioEndpoint.processSocket(NioEndpoint.java:730) at org.apache.tomcat.util.net.NioEndpoint$Poller.add(NioEndpoint.java:1008) at org.apache.tomcat.util.net.NioEndpoint$Poller.add(NioEndpoint.java:999) at org.apache.coyote.http11.Http11NioProtocol$Http11ConnectionHandler.longPoll(Http11NioProtocol.java:277) at org.apache.coyote.AbstractProtocol$AbstractConnectionHandler.process(AbstractProtocol.java:596) at org.apache.coyote.http11.Http11NioProtocol$Http11ConnectionHandler.process(Http11NioProtocol.java:223) at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.run(NioEndpoint.java:1653) at org.apache.tomcat.util.net.NioEndpoint.processSocket(NioEndpoint.java:730) at org.apache.tomcat.util.net.NioEndpoint$Poller.add(NioEndpoint.java:1008) at org.apache.tomcat.util.net.NioEndpoint$Poller.add(NioEndpoint.java:999) at org.apache.coyote.http11.Http11NioProtocol$Http11ConnectionHandler.longPoll(Http11NioProtocol.java:277) at org.apache.coyote.AbstractProtocol$AbstractConnectionHandler.process(AbstractProtocol.java:596) at org.apache.coyote.http11.Http11NioProtocol$Http11ConnectionHandler.process(Http11NioProtocol.java:223) at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.run(NioEndpoint.java:1653) at org.apache.tomcat.util.net.NioEndpoint.processSocket(NioEndpoint.java:730) at org.apache.tomcat.util.net.NioEndpoint$Poller.add(NioEndpoint.java:1008) at org.apache.tomcat.util.net.NioEndpoint$Poller.add(NioEndpoint.java:999) at org.apache.coyote.http11.Http11NioProtocol$Http11ConnectionHandler.longPoll(Http11NioProtocol.java:277) at org.apache.coyote.AbstractProtocol$AbstractConnectionHandler.process(AbstractProtocol.java:596) at org.apache.coyote.http11.Http11NioProtocol$Http11ConnectionHandler.process(Http11NioProtocol.java:223) at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.run(NioEndpoint.java:1653) at org.apache.tomcat.util.net.NioEndpoint.processSocket(NioEndpoint.java:730) at org.apache.tomcat.util.net.NioEndpoint$Poller.add(NioEndpoint.java:1008) at org.apache.tomcat.util.net.NioEndpoint$Poller.add(NioEndpoint.java:999) at org.apache.coyote.http11.Http11NioProtocol$Http11ConnectionHandler.longPoll(Http11NioProtocol.java:277) at org.apache.coyote.AbstractProtocol$AbstractConnectionHandler.process(AbstractProtocol.java:596) at org.apache.coyote.http11.Http11NioProtocol$Http11ConnectionHandler.process(Http11NioProtocol.java:223) at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.run(NioEndpoint.java:1653) at org.apache.tomcat.util.net.NioEndpoint.processSocket(NioEndpoint.java:730) at org.apache.tomcat.util.net.NioEndpoint$Poller.add(NioEndpoint.java:1008) at org.apache.tomcat.util.net.NioEndpoint$Poller.add(NioEndpoint.java:999) at org.apache.coyote.http11.Http11NioProtocol$Http11ConnectionHandler.longPoll(Http11NioProtocol.java:277) at org.apache.coyote.AbstractProtocol$AbstractConnectionHandler.process(AbstractProtocol.java:596) at org.apache.coyote.http11.Http11NioProtocol$Http11ConnectionHandler.process(Http11NioProtocol.java:223) at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.run(NioEndpoint.java:1653) at org.apache.tomcat.util.net.NioEndpoint.processSocket(NioEndpoint.java:730) at org.apache.tomcat.util.net.NioEndpoint$Poller.add(NioEndpoint.java:1008) at org.apache.tomcat.util.net.NioEndpoint$Poller.add(NioEndpoint.java:999) at org.apache.coyote.http11.Http11NioProtocol$Http11ConnectionHandler.longPoll(Http11NioProtocol.java:277) at org.apache.coyote.AbstractProtocol$AbstractConnectionHandler.process(AbstractProtocol.java:596) at org.apache.coyote.http11.Http11NioProtocol$Http11ConnectionHandler.process(Http11NioProtocol.java:223) at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.run(NioEndpoint.java:1653) at org.apache.tomcat.util.net.NioEndpoint.processSocket(NioEndpoint.java:730) at org.apache.tomcat.util.net.NioEndpoint$Poller.add(NioEndpoint.java:1008) at org.apache.tomcat.util.net.NioEndpoint$Poller.add(NioEndpoint.java:999) at org.apache.coyote.http11.Http11NioProtocol$Http11ConnectionHandler.longPoll(Http11NioProtocol.java:277) at org.apache.coyote.AbstractProtocol$AbstractConnectionHandler.process(AbstractProtocol.java:596) at org.apache.coyote.http11.Http11NioProtocol$Http11ConnectionHandler.process(Http11NioProtocol.java:223)</column><column name="report_time">2012-06-13 03:51:40</column><column name="report_timestamp">1339570000</column><column name="status">resolved fixed</column><column name="commit">ce24a10</column><column name="commit_timestamp">1339600000</column><column name="files">java/org/apache/coyote/http11/Http11AprProcessor.java
java/org/apache/coyote/http11/Http11NioProcessor.java</column><column name="result">3:java/org/apache/coyote/http11/Http11NioProcessor.java
17:java/org/apache/coyote/http11/Http11AprProcessor.java</column></table><table name="tomcat"><column name="id">276</column><column name="bug_id">52954</column><column name="summary">Allowing for broken android HTTP DIGEST support</column><column name="description">Android's browser has a slightly broken implementation of DIGEST support, causing it to fail authentication against Tomcat. There are 2 issues here which if bypassed in DigestAuthenticator, allow Android devices to authenticate successfully. 1. nc (nonce-count) is 6 digits instead of 8 nonce-count = "nc" "=" nc-value nc-value = 8LHEX Fail as per RFC, however: "The nc-value is the hexadecimal count of the number of requests (including the current request) that the client has sent with the nonce value in this request." So Android is sending a 24 bit number instead of a 32 bit number. Tomcat is failing auth based on (nc.length() != 8) which means the request must match the RFC, but I can't see anything saying that it's necessary to fail based on a shorter nc-value. Additionally, if this value wrapped due to being too short (the client would have to send the same nonce 16777216 times in a single request), we'd fail it anyway because of the nc check (count &lt;= info.getCount()). 2. uri is specified as an absolute URI, whereas browsers and examples show it as a relative URI. However, the RFC specifies this as: digest-uri = "uri" "=" digest-uri-value digest-uri-value = request-uri ; As specified by HTTP/1.1 But in RFC 2616 (HTTP/1.1): Request-URI = "*" | absoluteURI | abs_path | authority ... "To allow for transition to absoluteURIs in all requests in future versions of HTTP, all HTTP/1.1 servers MUST accept the absoluteURI form in requests, even though HTTP/1.1 clients will only generate them in requests to proxies." So this one is a bit vague as to whether an absolute uri should cause a validation fail. There is an issue listed here showing similar problems against Apache. http://code.google.com/p/android/issues/detail?id=21239 --------- I've only listed this as an enhancement, as Tomcat isn't broken here, but I'm interested in opinions: We could: 1. patch Tomcat to allow the two above situations 2. make the above allowable via a setting in the Realm 3. just continue to block digest auth for all Android devices until they fix the problem. Best Regards, Neale Rudd</column><column name="report_time">2012-03-21 06:53:16</column><column name="report_timestamp">1332330000</column><column name="status">resolved fixed</column><column name="commit">bf41254</column><column name="commit_timestamp">1339510000</column><column name="files">java/org/apache/catalina/authenticator/DigestAuthenticator.java</column><column name="result">14:java/org/apache/catalina/authenticator/DigestAuthenticator.java</column></table><table name="tomcat"><column name="id">277</column><column name="bug_id">53266</column><column name="summary">ServletContainerInitializer will crash catalina if dependcy is not present.</column><column name="description">When using a ServletContainerInitializer with a HandlesTypes annotation if any of the classes specified in the HandlesTypes annotation are not available due to a missing jar file catalina will crash with a "java.lang.ArrayStoreException: sun.reflect.annotation.TypeNotPresentExceptionProxy". Caused by: java.lang.ArrayStoreException: sun.reflect.annotation.TypeNotPresentExceptionProxy 	at sun.reflect.annotation.AnnotationParser.parseClassArray(AnnotationParser.java:653) 	at sun.reflect.annotation.AnnotationParser.parseArray(AnnotationParser.java:460) 	at sun.reflect.annotation.AnnotationParser.parseMemberValue(AnnotationParser.java:286) 	at sun.reflect.annotation.AnnotationParser.parseAnnotation(AnnotationParser.java:222) 	at sun.reflect.annotation.AnnotationParser.parseAnnotations2(AnnotationParser.java:69) 	at sun.reflect.annotation.AnnotationParser.parseAnnotations(AnnotationParser.java:52) 	at java.lang.Class.initAnnotationsIfNecessary(Class.java:3070) 	at java.lang.Class.getAnnotation(Class.java:3029) 	at org.apache.catalina.startup.ContextConfig.processServletContainerInitializers(ContextConfig.java:1546) 	at org.apache.catalina.startup.ContextConfig.webConfig(ContextConfig.java:1222) 	at org.apache.catalina.startup.ContextConfig.configureStart(ContextConfig.java:855) 	at org.apache.catalina.startup.ContextConfig.lifecycleEvent(ContextConfig.java:345) 	at org.apache.catalina.util.LifecycleSupport.fireLifecycleEvent(LifecycleSupport.java:119) 	at org.apache.catalina.util.LifecycleBase.fireLifecycleEvent(LifecycleBase.java:90) 	at org.apache.catalina.core.StandardContext.startInternal(StandardContext.java:5161) 	at org.apache.catalina.util.LifecycleBase.start(LifecycleBase.java:150) 	... 7 more Line where exception is thrown: "HandlesTypes ht = sci.getClass().getAnnotation(HandlesTypes.class);"</column><column name="report_time">2012-05-20 14:32:34</column><column name="report_timestamp">1337540000</column><column name="status">resolved fixed</column><column name="commit">37e8c59</column><column name="commit_timestamp">1339450000</column><column name="files">java/org/apache/catalina/startup/ContextConfig.java</column><column name="result">1:java/org/apache/catalina/startup/ContextConfig.java</column></table><table name="tomcat"><column name="id">278</column><column name="bug_id">53398</column><column name="summary">Incorrect tag on XML response when calling 'manager/status?XML=true'</column><column name="description">Created attachment 28909 Manager Status XML Response When calling 'manager/status?XML=true' on Tomcat Server the XML response includes incorrect 'requestBytesRecieved' attributes on some '&lt;worker&gt;' nodes. Attribute should read 'requestBytesReceived'. Seems like a typo when generating the 'requestBytesReceived' attribute for some nodes (Recieved != Received). Error can be generated using the CURL command to get the Tomcat status response: curl "http://&lt;tomcat-server-address&gt;/manager/status?XML=true" --basic -u &lt;user&gt; (This assumes a user has already been defined with the proper privileges to access the status API command).</column><column name="report_time">2012-06-11 16:39:14</column><column name="report_timestamp">1339450000</column><column name="status">resolved fixed</column><column name="commit">2bf1556</column><column name="commit_timestamp">1339450000</column><column name="files">java/org/apache/catalina/manager/StatusTransformer.java</column><column name="result">28:java/org/apache/catalina/manager/StatusTransformer.java</column></table><table name="tomcat"><column name="id">279</column><column name="bug_id">52955</column><column name="summary">Add a ThreadFactory implementation to the ExecutorService used to deploy applications</column><column name="description">Created attachment 28488 ThreadFactory implementation for ContainerBase ExecutorService The current implementation of the ExecutorService (in ContainerBase) uses the default thread factory, producing Threads named "pool-1-thread-1". Thread properties can be customised using a thread factory, modifying the naming scheme will help users identify container threads. Patch attached.</column><column name="report_time">2012-03-21 07:55:31</column><column name="report_timestamp">1332330000</column><column name="status">resolved fixed</column><column name="commit">d73c07a</column><column name="commit_timestamp">1339250000</column><column name="files">java/org/apache/catalina/core/ContainerBase.java</column><column name="result">14:java/org/apache/catalina/core/ContainerBase.java</column></table><table name="tomcat"><column name="id">280</column><column name="bug_id">53374</column><column name="summary">DataSourceFactory does not support commitOnReturn property</column><column name="description">DataSourceFactory does not support commitOnReturn property. DataSourceFactory.ALL_PROPERTIES and DataSourceFactory.parsePoolProperties() omit commitOnReturn property.</column><column name="report_time">2012-06-06 20:56:47</column><column name="report_timestamp">1339030000</column><column name="status">resolved fixed</column><column name="commit">0290e57</column><column name="commit_timestamp">1339160000</column><column name="files">modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/DataSourceFactory.java</column><column name="result">3:modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/DataSourceFactory.java</column></table><table name="tomcat"><column name="id">281</column><column name="bug_id">53373</column><column name="summary">Allow whitespace around delimiters in &lt;Context&gt; aliases for readability</column><column name="description">See bug 53359: Request for &lt;Aliases&gt; or &lt;Alias&gt; as element inside &lt;Context&gt; &lt;Context&gt; aliases attribute should allow whitespace to surround both the "," and "=" delimiters. For example: &lt;Context aliases="/EDSILabCatalog= c:/xampp/htdocs/cLabs/EDSILabCatalog, /EDSILabs = c:/xampp/htdocs/cLabs/EDSILabs, /Global = c:/xampp/htdocs/cLabs/Global, /Skyline = c:/xampp/htdocs/cLabs/Skyline, /Sun = c:/xampp/htdocs/cLabs/Sun, /Sunset = c:/xampp/htdocs/cLabs/Sunset, /Tech2000 = c:/xampp/htdocs/cLabs/Tech2000" 	/&gt;</column><column name="report_time">2012-06-06 20:01:27</column><column name="report_timestamp">1339030000</column><column name="status">resolved fixed</column><column name="commit">cf703d2</column><column name="commit_timestamp">1339010000</column><column name="files">java/org/apache/naming/resources/BaseDirContext.java
test/org/apache/naming/resources/TestNamingContext.java</column><column name="result">11:java/org/apache/naming/resources/BaseDirContext.java
659:test/org/apache/naming/resources/TestNamingContext.java</column></table><table name="tomcat"><column name="id">282</column><column name="bug_id">53367</column><column name="summary">Database failure may cause pool to hang</column><column name="description">during the con.connect(); call in the method protected PooledConnection borrowConnection(long now, PooledConnection con, String username, String password) in ConnectionPool.java There is no counting down the size of the pool. This means, if a connection failure happens here, the pool size remains the same. This means that 'size' will show the pool as full, but in reality the pool is empty</column><column name="report_time">2012-06-06 01:01:10</column><column name="report_timestamp">1338960000</column><column name="status">resolved fixed</column><column name="commit">1412935</column><column name="commit_timestamp">1338940000</column><column name="files">modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/ConnectionPool.java
modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/PooledConnection.java</column><column name="result">1:modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/ConnectionPool.java
2:modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/PooledConnection.java</column></table><table name="tomcat"><column name="id">283</column><column name="bug_id">53032</column><column name="summary">Ant Jasper task fails to run when using XML namespaces; no output; no errors</column><column name="description">One way to use bulk task definitions in Ant is to use XML namespaces: &lt;project name="teamcity" xmlns:tomcat6="http://tomcat.apache.org/ant/tomcat/6"&gt; ... &lt;path id="tomcat.6.ant.classpath"&gt; &lt;fileset dir="${my.path.library.build}/tomcat-6.0.35"&gt; &lt;include name="*.jar" /&gt; &lt;/fileset&gt; &lt;path refid="my.path.compile.jsp" /&gt; &lt;/path&gt; &lt;typedef resource="org/apache/catalina/ant/antlib.xml" uri="http://tomcat.apache.org/ant/tomcat/6" classpathref="tomcat.6.ant.classpath" /&gt; ... &lt;target&gt; &lt;tomcat6:list ... /&gt; &lt;tomcat6:deploy ... /&gt; &lt;/target&gt; ... &lt;/project&gt; This works great for list, deploy, etc. In fact, it works great for every other Ant task as far as I can tell. But it doesn't work for the jasper/jasper2 tasks (which both point to the same class). &lt;tomcat6:jasper ... /&gt; This does nothing. And by nothing I mean that I use `ant -verbose` when running Ant, verbose=1 within the Jasper task, and theres no output from the Jasper task, not a single line of output/logging, and the build completes in 0 seconds with no compiled JSPs output. However, if I define the Jasper task explicitly, using the exact same paths (as you can clearly see): &lt;taskdef classname="org.apache.jasper.JspC" name="tomcat6-jsp-compile"&gt; &lt;classpath&gt; &lt;path refid="tomcat.6.ant.classpath" /&gt; &lt;/classpath&gt; &lt;/taskdef&gt; And call the Jasper task using the exact same options: &lt;tomcat6-jsp-compile ... /&gt; Everything works. It compiles 2,487 JSPs in 275s, and outputs exactly what I expect, including 2,487 compiled JSPs and two logging messages. From what I understand about Ant, there should be absolutely no difference, and yet there apparently is, because they behave differently. The jasper task should support namespaces like the other Tomcat Ant tasks, and like other Ant tasks in general. (Note: I have confirmed at http://ant.apache.org/faq.html that a separate classloader IS used for the taskdef, and that Jspc will not have access to conflicting classes loaded by other namespaces.)</column><column name="report_time">2012-04-03 21:41:35</column><column name="report_timestamp">1333500000</column><column name="status">resolved fixed</column><column name="commit">957d33b</column><column name="commit_timestamp">1338940000</column><column name="files">java/org/apache/jasper/JspC.java</column><column name="result">14:java/org/apache/jasper/JspC.java</column></table><table name="tomcat"><column name="id">284</column><column name="bug_id">53230</column><column name="summary">Allow custom error mapping when Manager's maxActiveSessions is exceeded</column><column name="description">Tomcat 7.0.27 In ManagerBase an IllegalStateException is thrown when the configured maxActiveSessions attribute is exceeded. This allows no customized error handling via configuration in web.xml. See discussion: http://markmail.org/thread/xqjgdhf32gjrzjz2 Can be reproduced with the sample application: http://localhost:8080/examples/jsp/security/protected/index.jsp Just set maxActiveSession="0" in ${catalina.base}/conf/context.xml A configuration like this would be very useful: &lt;error-page&gt; &lt;exception-type&gt;org.apache.catalina.session.MaxActiveSessionsExceededException&lt;/exception-type&gt; &lt;location&gt;/maxSessions.html&lt;/location&gt; &lt;/error-page&gt;</column><column name="report_time">2012-05-14 17:09:13</column><column name="report_timestamp">1337030000</column><column name="status">resolved fixed</column><column name="commit">ea77dfb</column><column name="commit_timestamp">1338930000</column><column name="files">java/org/apache/catalina/session/ManagerBase.java
java/org/apache/catalina/session/TooManyActiveSessionsException.java</column><column name="result">1:java/org/apache/catalina/session/ManagerBase.java</column></table><table name="tomcat"><column name="id">285</column><column name="bug_id">53354</column><column name="summary">&lt;filter-mapping&gt; doesn't find the @WebFilter(filterName)</column><column name="description">As it's not possible to specify the invocation order in a @WebFilter, users are forced to explicitly specify &lt;filter-mapping&gt; in web.xml. This works in combination with a @WebFilter(filterName) in Glassfish and JBoss AS as follows: @WebFilter(filterName="filter1") public class Filter1 implements Filter {} @WebFilter(filterName="filter2") public class Filter2 implements Filter {} with &lt;filter-mapping&gt; &lt;filter-name&gt;filter1&lt;/filter-name&gt; &lt;url-pattern&gt;/url1/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;filter2&lt;/filter-name&gt; &lt;url-pattern&gt;/url2/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; However it fails in Tomcat 7.0.27 with the following confusing exception (the &lt;url-pattern&gt; *is* been set) Caused by: java.lang.IllegalArgumentException: Filter mapping must specify either a &lt;url-pattern&gt; or a &lt;servlet-name&gt; 	at org.apache.catalina.core.StandardContext.validateFilterMap(StandardContext.java:3009) 	at org.apache.catalina.core.StandardContext.addFilterMap(StandardContext.java:2968) 	at org.apache.catalina.deploy.WebXml.configureContext(WebXml.java:1207) 	at org.apache.catalina.startup.ContextConfig.webConfig(ContextConfig.java:1294) 	at org.apache.catalina.startup.ContextConfig.configureStart(ContextConfig.java:855) 	at org.apache.catalina.startup.ContextConfig.lifecycleEvent(ContextConfig.java:345) 	at org.apache.catalina.util.LifecycleSupport.fireLifecycleEvent(LifecycleSupport.java:119) 	at org.apache.catalina.util.LifecycleBase.fireLifecycleEvent(LifecycleBase.java:90) 	at org.apache.catalina.core.StandardContext.startInternal(StandardContext.java:5161) 	at org.apache.catalina.util.LifecycleBase.start(LifecycleBase.java:150) 	... 7 more</column><column name="report_time">2012-06-03 19:16:25</column><column name="report_timestamp">1338770000</column><column name="status">resolved fixed</column><column name="commit">b82c47e</column><column name="commit_timestamp">1338760000</column><column name="files">java/org/apache/catalina/startup/ContextConfig.java</column><column name="result">2:java/org/apache/catalina/startup/ContextConfig.java</column></table><table name="tomcat"><column name="id">286</column><column name="bug_id">53339</column><column name="summary">ClassNotFoundException when using WebSocketServlet</column><column name="description">I'm trying to do a JNDI lookup inside the "onOpen" method of my StreamInbound class, but it gives me the exception below. The code works if I move my JNP JARs to the server lib instead of the webapp lib. The code also works fine from anywhere else, like in the "doGet" method. ERROR http-bio-8080-exec-3 Test javax.naming.NoInitialContextException: Cannot instantiate class: org.jnp.interfaces.NamingContextFactory [Root exception is java.lang.ClassNotFoundException: org.jnp.interfaces.NamingContextFactory] 	at javax.naming.spi.NamingManager.getInitialContext(NamingManager.java:657) 	at javax.naming.InitialContext.getDefaultInitCtx(InitialContext.java:288) 	at javax.naming.InitialContext.init(InitialContext.java:223) 	at javax.naming.InitialContext.&lt;init&gt;(InitialContext.java:197) 	at Test$TestStreamInbound.onOpen(Test.java:103) 	at org.apache.catalina.websocket.StreamInbound.onUpgradeComplete(StreamInbound.java:180) 	at org.apache.coyote.AbstractProtocol$AbstractConnectionHandler.process(AbstractProtocol.java:579) 	at org.apache.tomcat.util.net.JIoEndpoint$SocketProcessor.run(JIoEndpoint.java:307) 	at java.util.concurrent.ThreadPoolExecutor$Worker.runTask(ThreadPoolExecutor.java:886) 	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:908) 	at java.lang.Thread.run(Thread.java:662)</column><column name="report_time">2012-05-31 18:20:53</column><column name="report_timestamp">1338500000</column><column name="status">resolved fixed</column><column name="commit">d713894</column><column name="commit_timestamp">1338750000</column><column name="files">java/org/apache/catalina/websocket/StreamInbound.java
test/org/apache/catalina/websocket/TestWebSocket.java</column><column name="result">2:java/org/apache/catalina/websocket/StreamInbound.java
96:test/org/apache/catalina/websocket/TestWebSocket.java</column></table><table name="tomcat"><column name="id">287</column><column name="bug_id">53008</column><column name="summary">New test case for Basic Authenticator</column><column name="description">Created attachment 28519 patch file for test org.apache.catalina.authenticator.TestNonLoginAndBasicAuthenticator RFC2617 states the authentication scheme is case-insensitive. A new test case has been added which confirms that tomcat already complies with the requirement. The attached patch file passes checkstyle and all tests run successfully against the trunk.</column><column name="report_time">2012-03-30 12:21:42</column><column name="report_timestamp">1333120000</column><column name="status">resolved fixed</column><column name="commit">a1c6165</column><column name="commit_timestamp">1338740000</column><column name="files">test/org/apache/catalina/authenticator/TestNonLoginAndBasicAuthenticator.java</column><column name="result">10:test/org/apache/catalina/authenticator/TestNonLoginAndBasicAuthenticator.java</column></table><table name="tomcat"><column name="id">288</column><column name="bug_id">53337</column><column name="summary">IllegalStateException when trying to render a JSP after startAsync</column><column name="description">The scenario involves: 1. ServletA forwards to Servlet B 2. ServletB calls request.startAsync and starts thread 3. New thread attempts to render a JSP I've tried JSP rendering via asyncContext.dispatch("") and via request.getRequestDispatcher("") plus forward or include. When using a RequestDispatcher, calling ServletA fails while calling ServletB directly succeeds. When using AsyncContext.dispatch, both ServletA and ServletB fail. The exception is always the same (while attempting to render the JSP): java.lang.IllegalStateException: Cannot create a session after the response has been committed I've created a project at: https://github.com/rstoyanchev/dispatch-test The project page contains instructions and attached is a .war although you might want to check the source out in order to try a couple of variations. Beyond the specifics of the bug, the more general question is whether it is ok to use request.getRequestDispatcher from an async thread? That seems to be the case in Tomcat, aside from this bug, but in other containers (Jetty in particular) it's clearly not recommended. Servlet Spec discussion on this question: http://java.net/projects/servlet-spec/lists/users/archive/2012-05/message/10.</column><column name="report_time">2012-05-31 17:06:36</column><column name="report_timestamp">1338500000</column><column name="status">resolved fixed</column><column name="commit">c6b691d</column><column name="commit_timestamp">1338740000</column><column name="files">java/org/apache/catalina/core/ApplicationDispatcher.java
test/org/apache/catalina/core/TestAsyncContextImpl.java</column><column name="result">30:test/org/apache/catalina/core/TestAsyncContextImpl.java
141:java/org/apache/catalina/core/ApplicationDispatcher.java</column></table><table name="tomcat"><column name="id">289</column><column name="bug_id">53301</column><column name="summary">Servlet init method called twice with embedded Tomcat</column><column name="description">When using embedded Tomcat, the servlet init method is called twice by the container. This has been seen with an Apache DirectMemory unit test. I have checked with a normal Tomcat launched by the Tomcat Maven plugin (mvn tomcat7:run) and in this case, the init method is correctly called once.</column><column name="report_time">2012-05-26 21:36:56</column><column name="report_timestamp">1338080000</column><column name="status">resolved fixed</column><column name="commit">6ce3128</column><column name="commit_timestamp">1338550000</column><column name="files">java/org/apache/catalina/startup/Tomcat.java
test/org/apache/catalina/startup/TestTomcat.java</column><column name="result">2:test/org/apache/catalina/startup/TestTomcat.java
3:java/org/apache/catalina/startup/Tomcat.java</column></table><table name="tomcat"><column name="id">290</column><column name="bug_id">53285</column><column name="summary">Web app configuration fails when security-role-ref does not contain role-link</column><column name="description">Created attachment 28829 Sample WAR The &lt;role-link&gt; element is optional content within &lt;security-role-ref&gt;. However, an application will fail to deploy if the optional element is missing. I've attached a sample WAR that highlights the problem. Note, the attached WAR will deploy ok in 6.0.35. Console output from running 7.0.27 embedded in Eclipse: INFO: Starting Servlet Engine: Apache Tomcat/7.0.27 24/05/2012 2:32:34 PM org.apache.tomcat.util.digester.Digester endElement SEVERE: End event threw exception Throwable occurred: java.lang.IllegalArgumentException: Can't convert argument: null 	at org.apache.tomcat.util.IntrospectionUtils.convert(IntrospectionUtils.java:966) 	at org.apache.tomcat.util.digester.CallMethodRule.end(CallMethodRule.java:476) 	at org.apache.tomcat.util.digester.Digester.endElement(Digester.java:1051) 	at org.apache.xerces.parsers.AbstractSAXParser.endElement(Unknown Source) 	at org.apache.xerces.impl.XMLDocumentFragmentScannerImpl.scanEndElement(Unknown Source) 	at org.apache.xerces.impl.XMLDocumentFragmentScannerImpl$FragmentContentDispatcher.dispatch(Unknown Source) 	at org.apache.xerces.impl.XMLDocumentFragmentScannerImpl.scanDocument(Unknown Source) 	at org.apache.xerces.parsers.XML11Configuration.parse(Unknown Source) 	at org.apache.xerces.parsers.XML11Configuration.parse(Unknown Source) 	at org.apache.xerces.parsers.XMLParser.parse(Unknown Source) 	at org.apache.xerces.parsers.AbstractSAXParser.parse(Unknown Source) 	at org.apache.xerces.jaxp.SAXParserImpl$JAXPSAXParser.parse(Unknown Source) 	at org.apache.tomcat.util.digester.Digester.parse(Digester.java:1537) 	at org.apache.catalina.startup.ContextConfig.parseWebXml(ContextConfig.java:1825) 	at org.apache.catalina.startup.ContextConfig.webConfig(ContextConfig.java:1201) 	at org.apache.catalina.startup.ContextConfig.configureStart(ContextConfig.java:855) 	at org.apache.catalina.startup.ContextConfig.lifecycleEvent(ContextConfig.java:345) 	at org.apache.catalina.util.LifecycleSupport.fireLifecycleEvent(LifecycleSupport.java:119) 	at org.apache.catalina.util.LifecycleBase.fireLifecycleEvent(LifecycleBase.java:90) 	at org.apache.catalina.core.StandardContext.startInternal(StandardContext.java:5161) 	at org.apache.catalina.util.LifecycleBase.start(LifecycleBase.java:150) 	at org.apache.catalina.core.ContainerBase$StartChild.call(ContainerBase.java:1566) 	at org.apache.catalina.core.ContainerBase$StartChild.call(ContainerBase.java:1556) 	at java.util.concurrent.FutureTask$Sync.innerRun(FutureTask.java:314) 	at java.util.concurrent.FutureTask.run(FutureTask.java:149) 	at java.util.concurrent.ThreadPoolExecutor$Worker.runTask(ThreadPoolExecutor.java:897) 	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:919) 	at java.lang.Thread.run(Thread.java:736) 24/05/2012 2:32:34 PM org.apache.catalina.startup.ContextConfig parseWebXml SEVERE: Parse error in application web.xml file at jndi:/localhost/testApp/WEB-INF/web.xml Throwable occurred: java.lang.IllegalArgumentException: Can't convert argument: null 	at org.apache.tomcat.util.digester.Digester.createSAXException(Digester.java:2687) 	at org.apache.tomcat.util.digester.Digester.createSAXException(Digester.java:2719) 	at org.apache.tomcat.util.digester.Digester.endElement(Digester.java:1054) 	at org.apache.xerces.parsers.AbstractSAXParser.endElement(Unknown Source) 	at org.apache.xerces.impl.XMLDocumentFragmentScannerImpl.scanEndElement(Unknown Source) 	at org.apache.xerces.impl.XMLDocumentFragmentScannerImpl$FragmentContentDispatcher.dispatch(Unknown Source) 	at org.apache.xerces.impl.XMLDocumentFragmentScannerImpl.scanDocument(Unknown Source) 	at org.apache.xerces.parsers.XML11Configuration.parse(Unknown Source) 	at org.apache.xerces.parsers.XML11Configuration.parse(Unknown Source) 	at org.apache.xerces.parsers.XMLParser.parse(Unknown Source) 	at org.apache.xerces.parsers.AbstractSAXParser.parse(Unknown Source) 	at org.apache.xerces.jaxp.SAXParserImpl$JAXPSAXParser.parse(Unknown Source) 	at org.apache.tomcat.util.digester.Digester.parse(Digester.java:1537) 	at org.apache.catalina.startup.ContextConfig.parseWebXml(ContextConfig.java:1825) 	at org.apache.catalina.startup.ContextConfig.webConfig(ContextConfig.java:1201) 	at org.apache.catalina.startup.ContextConfig.configureStart(ContextConfig.java:855) 	at org.apache.catalina.startup.ContextConfig.lifecycleEvent(ContextConfig.java:345) 	at org.apache.catalina.util.LifecycleSupport.fireLifecycleEvent(LifecycleSupport.java:119) 	at org.apache.catalina.util.LifecycleBase.fireLifecycleEvent(LifecycleBase.java:90) 	at org.apache.catalina.core.StandardContext.startInternal(StandardContext.java:5161) 	at org.apache.catalina.util.LifecycleBase.start(LifecycleBase.java:150) 	at org.apache.catalina.core.ContainerBase$StartChild.call(ContainerBase.java:1566) 	at org.apache.catalina.core.ContainerBase$StartChild.call(ContainerBase.java:1556) 	at java.util.concurrent.FutureTask$Sync.innerRun(FutureTask.java:314) 	at java.util.concurrent.FutureTask.run(FutureTask.java:149) 	at java.util.concurrent.ThreadPoolExecutor$Worker.runTask(ThreadPoolExecutor.java:897) 	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:919) 	at java.lang.Thread.run(Thread.java:736) 24/05/2012 2:32:34 PM org.apache.catalina.startup.ContextConfig parseWebXml SEVERE: Occurred at line 18 column 23</column><column name="report_time">2012-05-24 04:52:55</column><column name="report_timestamp">1337850000</column><column name="status">resolved fixed</column><column name="commit">ad3b503</column><column name="commit_timestamp">1338540000</column><column name="files">java/org/apache/catalina/deploy/ServletDef.java
java/org/apache/catalina/startup/WebRuleSet.java</column><column name="result">2:java/org/apache/catalina/deploy/ServletDef.java
35:java/org/apache/catalina/startup/WebRuleSet.java</column></table><table name="tomcat"><column name="id">291</column><column name="bug_id">53342</column><column name="summary">If starting immediately after Tomcat stop fail, BindException will throw.</column><column name="description">e.g. When Context#stop throw LifecycleException, the main thread stops, but startStopThreads of Host/Engine will remain for a while. Because, startStopThreads is not a demon thread. As a result, even if a main thread stops, Acceptor Threads of 8080/8009 is not stopped. keepAliveTime for 10 seconds is set up now. === startStopExecutor = new ThreadPoolExecutor( getStartStopThreadsInternal(), getStartStopThreadsInternal(), 10, TimeUnit.SECONDS, startStopQueue); === Therefore, in order to avoid BindException, the waiting for 10 seconds is required. I think that I need to make startStopThreads into a demon thread. Best Regards.</column><column name="report_time">2012-06-01 09:34:18</column><column name="report_timestamp">1338560000</column><column name="status">resolved fixed</column><column name="commit">84342f5</column><column name="commit_timestamp">1338540000</column><column name="files">java/org/apache/catalina/core/ContainerBase.java</column><column name="result">1:java/org/apache/catalina/core/ContainerBase.java</column></table><table name="tomcat"><column name="id">292</column><column name="bug_id">53225</column><column name="summary">IllegalStateException "zip file closed" with resource from webfragment jar if JreMemoryLeakPreventionListener is removed</column><column name="description">Created attachment 28764 icontest.war The issue was reported in the following thread on users@: http://markmail.org/thread/m6fimchl2jk2vyl4 http://marc.info/?t=133665328700005&amp;r=1&amp;w=2 I am able to reproduce the issue on current trunk with the following steps: 1. Remove JreMemoryLeakPreventionListener from server.xml 2. Deploy the attached war file, icontest.war It contains WEB-INF/lib/icon.jar with several copies of Tomcat icon 3. Start Tomcat and access the following URL: http://localhost:8080/icontest/favicon.ico Expected behaviour: The icon is displayed Actual behaviour: [[[ 13-May-2012 00:23:05.906 SEVERE [http-bio-8080-exec-1] org.apache.coyote.http11.AbstractHttp11Processor.process Error processing request java.lang.IllegalStateException: zip file closed 	at java.util.jar.JarFile.getMetaInfEntryNames(Native Method) 	at java.util.jar.JarFile.maybeInstantiateVerifier(JarFile.java:279) 	at java.util.jar.JarFile.getInputStream(JarFile.java:383) 	at org.apache.naming.resources.WARDirContext$WARResource.streamContent(WARDirContext.java:990) 	at org.apache.naming.resources.ProxyDirContext.cacheLoad(ProxyDirContext.java:1621) 	at org.apache.naming.resources.ProxyDirContext.cacheLookup(ProxyDirContext.java:1501) 	at org.apache.naming.resources.ProxyDirContext.lookup(ProxyDirContext.java:262) 	at org.apache.tomcat.util.http.mapper.Mapper.internalMapWrapper(Mapper.java:996) 	at org.apache.tomcat.util.http.mapper.Mapper.internalMap(Mapper.java:808) 	at org.apache.tomcat.util.http.mapper.Mapper.map(Mapper.java:671) 	at org.apache.catalina.connector.CoyoteAdapter.postParseRequest(CoyoteAdapter.java:646) 	at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:402) 	at org.apache.coyote.http11.AbstractHttp11Processor.process(AbstractHttp11Processor.java:995) 	at org.apache.coyote.AbstractProtocol$AbstractConnectionHandler.process(AbstractProtocol.java:573) 	at org.apache.coyote.http11.Http11Protocol$Http11ConnectionHandler.process(Http11Protocol.java:145) 	at org.apache.tomcat.util.net.JIoEndpoint$SocketProcessor.run(JIoEndpoint.java:311) 	at java.util.concurrent.ThreadPoolExecutor$Worker.runTask(ThreadPoolExecutor.java:886) 	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:908) 	at java.lang.Thread.run(Thread.java:662) ]]]</column><column name="report_time">2012-05-12 20:32:50</column><column name="report_timestamp">1336870000</column><column name="status">resolved fixed</column><column name="commit">e90cd4b</column><column name="commit_timestamp">1338460000</column><column name="files">java/org/apache/tomcat/util/scan/FileUrlJar.java</column><column name="result">15:java/org/apache/tomcat/util/scan/FileUrlJar.java</column></table><table name="tomcat"><column name="id">293</column><column name="bug_id">53169</column><column name="summary">[patch] don't do chunking with Connection: close</column><column name="description">Created attachment 28702 patch against trunk The attached patch disables chunking on if there is a Connection: close header, we're on HTTP 1.1 and there's no Content-Length header. This helps to implement Server-Sent Events [1]. Server-Sent Event are conceptually similar to the forever streaming iframe in the sense that there's an "infinite" response from the server that always gets updated. But they're easier to use and with less issues. They are also easier to use than WebSockets if you don't need a back channel. The specification reccoments to disable chunking. Jetty implements the same behavior, when there's a Connection: close header it doesn't do chunking. The following discussion [2] leads me to believe that patches would be welcome. The patch comes with unit tests that verify that there is still chunking happending when there is no Connection: close header. [1] http://dev.w3.org/html5/eventsource/#notes [2] http://tomcat.10.n6.nabble.com/How-to-disable-chunked-encoding-for-the-Http11NioProtocol-connector-td2038448.html</column><column name="report_time">2012-05-01 09:35:06</column><column name="report_timestamp">1335880000</column><column name="status">resolved fixed</column><column name="commit">280beac</column><column name="commit_timestamp">1338390000</column><column name="files">java/org/apache/coyote/http11/AbstractHttp11Processor.java
test/org/apache/coyote/http11/TestAbstractHttp11Processor.java</column><column name="result">70:java/org/apache/coyote/http11/AbstractHttp11Processor.java
353:test/org/apache/coyote/http11/TestAbstractHttp11Processor.java</column></table><table name="tomcat"><column name="id">294</column><column name="bug_id">53322</column><column name="summary">Odd decapitalization when inferring JavaBean property from setter name for an injection target</column><column name="description">There is code in DefaultInstanceManager class that converts a setter method name into JavaBean property name. The code is wrong: it removes "set" prefix and then converts the first character into lowercase. That is a wrong way to get JavaBeans property name. The correct way would be to follow JavaBeans specification 1.01 ch.8.8 [1] and use java.beans.Introspector#decapitalize(String) method. E.g. for method setURL(..) the correct property name would be "URL", not "uRL". [1] http://www.oracle.com/technetwork/java/javase/documentation/spec-136004.html</column><column name="report_time">2012-05-30 01:22:25</column><column name="report_timestamp">1338360000</column><column name="status">resolved fixed</column><column name="commit">13100e9</column><column name="commit_timestamp">1338340000</column><column name="files">java/org/apache/catalina/core/DefaultInstanceManager.java</column><column name="result">1:java/org/apache/catalina/core/DefaultInstanceManager.java</column></table><table name="tomcat"><column name="id">295</column><column name="bug_id">53180</column><column name="summary">DefaultInstanceManager#populateAnnotationsCache - incomplete check is used when validating for a setter method</column><column name="description">Created attachment 28711 Patch proposal Hi, In org.apache.catalina.core.DefaultInstanceManager#populateAnnotationsCache, when iterating over methods in a given class, in one of the cases (when injection-target is specified) you validate whether the method is a valid setter method. In my opinion the check that is used for that validation is not complete. I would like to propose a patch (attached) that introduces additional checks in order to guarantee that the corresponding method is really suitable to be an injection target. I'm looking forward to your commends. Best Regards Violeta Georgieva</column><column name="report_time">2012-05-02 20:27:25</column><column name="report_timestamp">1336000000</column><column name="status">resolved fixed</column><column name="commit">39c8e18</column><column name="commit_timestamp">1338300000</column><column name="files">java/org/apache/catalina/core/DefaultInstanceManager.java</column><column name="result">1:java/org/apache/catalina/core/DefaultInstanceManager.java</column></table><table name="tomcat"><column name="id">296</column><column name="bug_id">53081</column><column name="summary">WebappClassLoader causes java.lang.OutOfMemoryError in findResourceInternal()</column><column name="description">When examining the code of WebappClassLoader#findResourceInternal() (http://grepcode.com/file/repo1.maven.org/maven2/org.apache.tomcat/tomcat-catalina/7.0.26/org/apache/catalina/loader/WebappClassLoader.java#3098) I came to the conclusion that findResourceInternal() always loads the binary content of the resource, however binary content is only used in e.g. findClassInternal() and obviously not needed in findResource(). In certain cases this can cause OutOfMemoryError, for example when a big media file is packaged with application. The example of stack trace is given here: http://stackoverflow.com/questions/10100480 Solution: the binary content should be loaded for certain types of resources (.classpath or .properties [only if fileNeedConvert is true]).</column><column name="report_time">2012-04-13 21:46:53</column><column name="report_timestamp">1334370000</column><column name="status">resolved fixed</column><column name="commit">5d12129</column><column name="commit_timestamp">1338300000</column><column name="files">java/org/apache/catalina/loader/WebappClassLoader.java</column><column name="result">1:java/org/apache/catalina/loader/WebappClassLoader.java</column></table><table name="tomcat"><column name="id">297</column><column name="bug_id">53090</column><column name="summary">Servlet superclass injection targets are ignored</column><column name="description">Created attachment 28623 patch that shows the processing of the servlet's superclass injections Hi folks, I've been running Tomcat 7.0.26 in a JEE container against the EE6 Web Profile CTS. In many of the tests there is the following scenario: A servlet 'X' extends a regular class 'Y'. An env-entry element for a field in 'Y' with injection-target-class equal to 'Y' is defined in the app's web.xml. The injection-target-name points to a field that is not annotated. When the app boots and Tomcat handles the injections for the servlet it processes only those that are defined explicitly for the 'X' servlet's class name, ignoring its superclasses. I'm attaching a patch I made on top of 7.0.x/trunk that fixed the issue. It's quite small. I believe Tomcat should respect the injections for the servlet's superclasses. What do you think is the right behavior? Thank you, Bobby</column><column name="report_time">2012-04-17 08:07:14</column><column name="report_timestamp">1334660000</column><column name="status">resolved fixed</column><column name="commit">de1f763</column><column name="commit_timestamp">1338240000</column><column name="files">java/org/apache/catalina/core/DefaultInstanceManager.java</column><column name="result">5:java/org/apache/catalina/core/DefaultInstanceManager.java</column></table><table name="tomcat"><column name="id">298</column><column name="bug_id">53074</column><column name="summary">[websocket] java.net.SocketTimeoutException: Read timed caused by server.xml' connectTimeout</column><column name="description">The default connectTimeout value is set to 20000 and cause issue with WebSocket connection java.net.SocketTimeoutException: Read timed out at java.net.SocketInputStream.socketRead0(Native Method) at java.net.SocketInputStream.read(SocketInputStream.java:129) at org.apache.coyote.http11.upgrade.UpgradeBioProcessor.read(UpgradeBioProcessor.java:75) at org.apache.catalina.websocket.WsFrame.nextFrame(WsFrame.java:213) at org.apache.catalina.websocket.WsInputStream.nextFrame(WsInputStream.java:68) at org.apache.catalina.websocket.StreamInbound.onData(StreamInbound.java:143) at org.apache.coyote.http11.upgrade.UpgradeProcessor.upgradeDispatch(UpgradeProcessor.java:83) at org.apache.coyote.AbstractProtocol$AbstractConnectionHandler.process(AbstractProtocol.java:563) at org.apache.tomcat.util.net.JIoEndpoint$SocketProcessor.run(JIoEndpoint.java:307) at java.util.concurrent.ThreadPoolExecutor$Worker.runTask(ThreadPoolExecutor.java:886) at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:908) at java.lang.Thread.run(Thread.java:680) Increasing the value delay the issue (but the timeout should not occurs)</column><column name="report_time">2012-04-13 13:45:11</column><column name="report_timestamp">1334340000</column><column name="status">resolved fixed</column><column name="commit">098a647</column><column name="commit_timestamp">1337960000</column><column name="files">java/org/apache/catalina/websocket/StreamInbound.java
java/org/apache/coyote/ajp/AjpAprProtocol.java
java/org/apache/coyote/http11/Http11AprProtocol.java
java/org/apache/coyote/http11/upgrade/UpgradeAprProcessor.java
java/org/apache/coyote/http11/upgrade/UpgradeBioProcessor.java
java/org/apache/coyote/http11/upgrade/UpgradeInbound.java
java/org/apache/coyote/http11/upgrade/UpgradeNioProcessor.java
java/org/apache/tomcat/util/net/AprEndpoint.java</column><column name="result">5:java/org/apache/tomcat/util/net/AprEndpoint.java
7:java/org/apache/coyote/http11/upgrade/UpgradeBioProcessor.java
15:java/org/apache/catalina/websocket/StreamInbound.java
16:java/org/apache/coyote/http11/Http11AprProtocol.java
21:java/org/apache/coyote/ajp/AjpAprProtocol.java
31:java/org/apache/coyote/http11/upgrade/UpgradeInbound.java
46:java/org/apache/coyote/http11/upgrade/UpgradeAprProcessor.java
102:java/org/apache/coyote/http11/upgrade/UpgradeNioProcessor.java</column></table><table name="tomcat"><column name="id">299</column><column name="bug_id">53254</column><column name="summary">Support for purging connection pool</column><column name="description">It is a common function of a connection pool to support "purging" the pool of all current connections and getting all fresh connections. Oracle UCP and Websphere pools are two such examples. It would be great if this pool supported such an operation as well. It would be useful if the operation were exposed through JMX too.</column><column name="report_time">2012-05-17 17:59:28</column><column name="report_timestamp">1337290000</column><column name="status">resolved fixed</column><column name="commit">f170929</column><column name="commit_timestamp">1337360000</column><column name="files">modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/ConnectionPool.java
modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/DataSourceProxy.java
modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/PooledConnection.java
modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/jmx/ConnectionPool.java
modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/jmx/ConnectionPoolMBean.java
modules/jdbc-pool/src/test/java/org/apache/tomcat/jdbc/test/PoolPurgeTest.java</column><column name="result">1:modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/ConnectionPool.java
2:modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/jmx/ConnectionPool.java
3:modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/PooledConnection.java
4:modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/DataSourceProxy.java
128:modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/jmx/ConnectionPoolMBean.java</column></table><table name="tomcat"><column name="id">300</column><column name="bug_id">53067</column><column name="summary">WebSocket implementation issue with wrapped requests</column><column name="description">Originally reported in Atmosphere https://github.com/Atmosphere/atmosphere/issues/280 Mainly the WebSocketServlet must make sure the request hasn't been wrapped when looking at the RequestFacade and if wrapped, cycle until it find the original request.</column><column name="report_time">2012-04-12 17:56:58</column><column name="report_timestamp">1334270000</column><column name="status">resolved fixed</column><column name="commit">111dc8e</column><column name="commit_timestamp">1336860000</column><column name="files">java/org/apache/catalina/websocket/WebSocketServlet.java</column><column name="result">2:java/org/apache/catalina/websocket/WebSocketServlet.java</column></table><table name="tomcat"><column name="id">301</column><column name="bug_id">53063</column><column name="summary">Inconsistency in documentation regarding Connector's maxConnections property</column><column name="description">According to the documentation, the "maxConnections" property of a BIO HTTP Connector defaults to the value of "maxThreads". Additionally, the documentation states that if the "executor" property is specified, any thread related properties on the Connector will be ignored. This includes "maxThreads". However, when a BIO HTTP Connector is defined with an executor, the default value for "maxConnections" does not take the "maxThreads" value from the Executor. In fact, it appears to take the "maxThreads" value from the Connector object, which is supposed to be ignored. https://tomcat.apache.org/tomcat-7.0-doc/config/http.html#Standard_Implementation This can be confirmed with the following test. 1.) Download Tomcat 7.0.27. 2.) Edit "conf/server.xml", uncomment the "tomcatThreadPool" executor, comment out the default HTTP connector and uncomment the HTTP connector below it that uses the executor. 3.) Start Tomcat and connect with jconsole 4.) Look at the Catalina -&gt; ProtocolHandler -&gt; 8080 -&gt; maxConnections. It will be set to 200 and not 150 (maxThreads on the executor). 5.) Now, stop Tomcat, edit "conf/server.xml", add a "maxThreads" attribute to the connector, set the value to 300 and start tomcat. 6.) Examine the Catalina -&gt; ProtocolHandler -&gt; 8080 -&gt; maxConnections property again and it'll be set to 300. Suggestions: 1.) Update the documentation to indicate that "maxConnections" for a BIO HTTP Connector defaults to "maxThreads" on the Connector, regardless of the presence of an executor. 2.) Fix the "maxConnections" default so that it takes its value from "maxThreads" on the executor, when an executor is specified. My preferences would be for #2.</column><column name="report_time">2012-04-11 13:14:14</column><column name="report_timestamp">1334160000</column><column name="status">resolved fixed</column><column name="commit">be365e5</column><column name="commit_timestamp">1336680000</column><column name="files">java/org/apache/tomcat/util/net/AbstractEndpoint.java
java/org/apache/tomcat/util/net/JIoEndpoint.java</column><column name="result">1:java/org/apache/tomcat/util/net/AbstractEndpoint.java
3:java/org/apache/tomcat/util/net/JIoEndpoint.java</column></table><table name="tomcat"><column name="id">302</column><column name="bug_id">53087</column><column name="summary">BackupManager does not replicate session access time.</column><column name="description">Created attachment 28619 BackupManager does not replicate session access time. BackupManager does not replicate session access time. If a primary session does not change an attribute but it is only access , non-primary session(backup node) expire session. I made a patch to replicate session access time. Best Regards.</column><column name="report_time">2012-04-17 05:44:46</column><column name="report_timestamp">1334660000</column><column name="status">resolved fixed</column><column name="commit">48b9153</column><column name="commit_timestamp">1334640000</column><column name="files">java/org/apache/catalina/ha/session/DeltaSession.java
java/org/apache/catalina/tribes/tipis/AbstractReplicatedMap.java
java/org/apache/catalina/tribes/tipis/ReplicatedMapEntry.java</column><column name="result">2:java/org/apache/catalina/ha/session/DeltaSession.java
3:java/org/apache/catalina/tribes/tipis/AbstractReplicatedMap.java
37:java/org/apache/catalina/tribes/tipis/ReplicatedMapEntry.java</column></table><table name="tomcat"><column name="id">303</column><column name="bug_id">53056</column><column name="summary">Add APR version number to tcnative version INFO log message</column><column name="description">When tcnative starts, it emits information like this to catalina.out: pr 10, 2012 4:54:55 PM org.apache.catalina.core.AprLifecycleListener init INFO: Loaded APR based Apache Tomcat Native library 1.1.23. Apr 10, 2012 4:54:55 PM org.apache.catalina.core.AprLifecycleListener init INFO: APR capabilities: IPv6 [true], sendfile [true], accept filters [false], random [true]. It would be nice if the APR version in use could also be displayed as well as the tcnative version. Maybe the OpenSSL version, too.</column><column name="report_time">2012-04-10 20:58:50</column><column name="report_timestamp">1334110000</column><column name="status">resolved fixed</column><column name="commit">df88ecb</column><column name="commit_timestamp">1334090000</column><column name="files">java/org/apache/catalina/core/AprLifecycleListener.java</column><column name="result">1:java/org/apache/catalina/core/AprLifecycleListener.java</column></table><table name="tomcat"><column name="id">304</column><column name="bug_id">50864</column><column name="summary">Reconfigure pool on the fly using JMX</column><column name="description">Provide a way to reconfigure the jdbc-pool using JMX and have it take effect when changes are submitted. http://markmail.org/message/x6wem3zkxl4ps7ki</column><column name="report_time">2011-03-03 11:15:31</column><column name="report_timestamp">1299170000</column><column name="status">resolved fixed</column><column name="commit">518662f</column><column name="commit_timestamp">1334080000</column><column name="files">modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/ConnectionPool.java
modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/PoolProperties.java
modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/jmx/ConnectionPool.java</column><column name="result">1:modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/ConnectionPool.java
2:modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/jmx/ConnectionPool.java
6:modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/PoolProperties.java</column></table><table name="tomcat"><column name="id">305</column><column name="bug_id">52998</column><column name="summary">Performance issue with ExpressionFactory.newInstance()</column><column name="description">javax.el.ExpressionFactory.newInstance() implementation in Tomcat 7 does not cache created instance and performs class name discovery on every invocation. The discovery process involves looking for the file named "META-INF/services/javax.el.ExpressionFactory". So every invocation of the method involves looking for and maybe reading the file. This issue was reported on the dev list, see thread: [1] "Two performance problems (found during myfaces testing)", starting on 2012-03-08, - http://tomcat.markmail.org/thread/7bbvzmkvyvryvn44 - http://marc.info/?t=133124021200002&amp;r=1&amp;w=2 The above thread [1] also references this one of myfaces: [2] "EL method invocation performance", 2010-08-25: - http://www.mail-archive.com/dev@myfaces.apache.org/msg48482.html ------------------ My evaluation is that 1. This problem is specific for Tomcat 7. - The ExpressionFactory.newInstance() method was added in EL 2.2 and Tomcat 6 does not have it. 2. It hits javax.el.BeanELResolver#invoke() the most, as ExpressionFactory.newInstance() is called on each invocation. 3. There are 2 places where the factory instance is stored in a static field. This is good for performance, but breaks the discovery process and may cause consequences if implementation is bundled in a web application. It is a bug. The places: org.apache.jasper.runtime.JspApplicationContextImpl.expressionFactory org.apache.jasper.compiler.Validator$ValidateVisitor.EXPRESSION_FACTORY</column><column name="report_time">2012-03-28 21:16:03</column><column name="report_timestamp">1332980000</column><column name="status">resolved fixed</column><column name="commit">7da5fa9</column><column name="commit_timestamp">1333140000</column><column name="files">java/javax/el/ExpressionFactory.java</column><column name="result">1:java/javax/el/ExpressionFactory.java</column></table><table name="tomcat"><column name="id">306</column><column name="bug_id">53001</column><column name="summary">Behaviour of ResourceBundleELResolver</column><column name="description">I have discovered the the ResourceBundleELResolver from the tomcat el-api.jar behaves differently then the one from standard el-api. The difference lays in the handling of missing properties. The tomcat version will not set the resolved property to true such that evaluation continues and finally an exception is thrown. This causes pages to crash if a property can not be found (which I think is kind of unacceptable for production sites). The bahaviour was changed due to https://issues.apache.org/bugzilla/show_bug.cgi?id=46915. I think that changing the standard behaviour of "resolving" an unbound property by just returning its key is to throwing an exception was a strong decision. I would strongly recommend of reintroducing the old bahviour and fixing the issue 46915 in a different way. If someone can point my to the requirements and corner cases related to 46915, I will gladly provide an implementation. Until then, a workaround for everybody using jsf: Subclass the ResourceBundleELResolver and override its getValue(...) method. Change it such that it sets the PropertyResolved attribute to true before any exception might occur. Register this custom resolver in the faces-config.xml with &lt;el-resolver&gt;</column><column name="report_time">2012-03-29 09:41:39</column><column name="report_timestamp">1333030000</column><column name="status">resolved fixed</column><column name="commit">1aced29</column><column name="commit_timestamp">1333130000</column><column name="files">test/javax/el/TestResourceBundleELResolver.java</column><column name="result" /></table><table name="tomcat"><column name="id">307</column><column name="bug_id">52974</column><column name="summary">NameNotFoundException is thrown when field/method is annotated with @Resource annotation</column><column name="description">Created attachment 28500 Patch proposal Hi, I have a web application (attached) that has a Servlet with an annotated (@Resource) field and an annotated (@Resource) method. When I request the Servlet I'm receiving: javax.naming.NameNotFoundException: Name test.TestServlet is not bound in this Context org.apache.naming.NamingContext.lookup(NamingContext.java:820) org.apache.naming.NamingContext.lookup(NamingContext.java:168) org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:472) org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:98) I searched the sources and found that org.apache.catalina.startup.WebAnnotationSet processes and prepares for binding only @Resource annotation on a class level. However org.apache.catalina.core.DefaultInstanceManager tries to process @Resource annotation on field/method level and to inject the necessary Object. Unfortunately as the information is not processed and bound in the naming previously, NameNotFoundException is thrown. I would like to propose a patch (attached). I'm looking forward to your comments. Thanks in advance. Regards Violeta Georgieva Steps to reproduce the issue: 1. Deploy the attached web application 2. Request http://localhost:8080/test/TestServlet 3. NameNotFoundException is thrown 4. Apply the patch and restart Tomcat 5. Request http://localhost:8080/test/TestServlet 6. You should see in the browser "Annotated field: test Annotated method: test1"</column><column name="report_time">2012-03-22 20:43:20</column><column name="report_timestamp">1332460000</column><column name="status">resolved fixed</column><column name="commit">67a926c</column><column name="commit_timestamp">1332880000</column><column name="files">java/org/apache/catalina/startup/WebAnnotationSet.java</column><column name="result">31:java/org/apache/catalina/startup/WebAnnotationSet.java</column></table><table name="tomcat"><column name="id">308</column><column name="bug_id">52833</column><column name="summary">NPE with 7.0.26</column><column name="description">Upgrading the maven plugin 7.0.26, the goal which runs tomcat with a conf dir (not the embed version) generate the following NPE Log: 	at org.apache.catalina.util.LifecycleBase.stop(LifecycleBase.java:236) 	at org.apache.catalina.util.LifecycleBase.start(LifecycleBase.java:141) 	at org.apache.catalina.startup.Catalina.start(Catalina.java:645) 	at org.apache.tomcat.maven.plugin.tomcat7.run.AbstractRunMojo.startContainer(AbstractRunMojo.java:679) 	at org.apache.tomcat.maven.plugin.tomcat7.run.AbstractRunMojo.execute(AbstractRunMojo.java:365) 	at org.apache.maven.plugin.DefaultBuildPluginManager.executeMojo(DefaultBuildPluginManager.java:101) 	at org.apache.maven.lifecycle.internal.MojoExecutor.execute(MojoExecutor.java:209) 	at org.apache.maven.lifecycle.internal.MojoExecutor.execute(MojoExecutor.java:153) 	at org.apache.maven.lifecycle.internal.MojoExecutor.execute(MojoExecutor.java:145) 	at org.apache.maven.lifecycle.internal.LifecycleModuleBuilder.buildProject(LifecycleModuleBuilder.java:84) 	at org.apache.maven.lifecycle.internal.LifecycleModuleBuilder.buildProject(LifecycleModuleBuilder.java:59) 	at org.apache.maven.lifecycle.internal.LifecycleStarter.singleThreadedBuild(LifecycleStarter.java:183) 	at org.apache.maven.lifecycle.internal.LifecycleStarter.execute(LifecycleStarter.java:161) 	at org.apache.maven.DefaultMaven.doExecute(DefaultMaven.java:320) 	at org.apache.maven.DefaultMaven.execute(DefaultMaven.java:156) 	at org.apache.maven.cli.MavenCli.execute(MavenCli.java:544) 	at org.apache.maven.cli.MavenCli.doMain(MavenCli.java:197) 	at org.apache.maven.cli.MavenCli.main(MavenCli.java:141) 	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) 	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) 	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25) 	at java.lang.reflect.Method.invoke(Method.java:597) 	at org.codehaus.plexus.classworlds.launcher.Launcher.launchEnhanced(Launcher.java:290) 	at org.codehaus.plexus.classworlds.launcher.Launcher.launch(Launcher.java:230) 	at org.codehaus.plexus.classworlds.launcher.Launcher.mainWithExitCode(Launcher.java:409) 	at org.codehaus.plexus.classworlds.launcher.Launcher.main(Launcher.java:352)</column><column name="report_time">2012-03-05 23:28:06</column><column name="report_timestamp">1331010000</column><column name="status">resolved fixed</column><column name="commit">6a8e480</column><column name="commit_timestamp">1332870000</column><column name="files">java/org/apache/catalina/core/StandardServer.java</column><column name="result">19:java/org/apache/catalina/core/StandardServer.java</column></table><table name="tomcat"><column name="id">309</column><column name="bug_id">52066</column><column name="summary">ConnectionPool.borrowConnection swallows interrupt state.</column><column name="description">In this code snippet starting on line 6.15 of ConnectionPool.java version 7.0.22 try { //retrieve an existing connection con = idle.poll(timetowait, TimeUnit.MILLISECONDS); } catch (InterruptedException ex) { Thread.interrupted();//clear the flag, and bail out SQLException sx = new SQLException("Pool wait interrupted."); sx.initCause(ex); throw sx; } finally { waitcount.decrementAndGet(); } The line marked '//clear the flag, and bail out' is wrong, because after that there is no way for calling code to find out that the thread has been interrupted. The correct behavior should be Thread.currentThread( ).interrupt( ); Here is the excerpt from the Biran Goetz's "Java Concurrency in Practice" chapter 5.4. &lt;!START QUOTATION&gt; For library code there are basically two choices: -- Propagate the InterruptedException. This is often the most sensible policy if you can get away with it -- just propagate the InterruptedException to your caller. This could involve not catching InterruptedException, or catching it and throwing it again after performing some brief activity-specific cleanup. -- Restore the interrupt. Sometimes you cannot throw InterruptedException, for instance when your code is part of a Runnable. In these situations, you must catch InterruptedException and restore the interrupted status by calling interrupt on the current thread, so that code higher up the call stack can see that an interrupt was issued. &lt;!END QUOTATION&gt; In the case of borrowConnection, #1 is not really a choice, as it is running in the confines of JDBC interface. But it can definitely restore the interrupt status of the thread.</column><column name="report_time">2011-10-20 19:28:24</column><column name="report_timestamp">1319150000</column><column name="status">resolved fixed</column><column name="commit">fe16ac2</column><column name="commit_timestamp">1332870000</column><column name="files">modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/ConnectionPool.java
modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/DataSourceProxy.java
modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/PoolConfiguration.java
modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/PoolProperties.java
modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/jmx/ConnectionPool.java</column><column name="result">1:modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/ConnectionPool.java
2:modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/jmx/ConnectionPool.java
5:modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/DataSourceProxy.java
15:modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/PoolConfiguration.java
24:modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/PoolProperties.java</column></table><table name="tomcat"><column name="id">310</column><column name="bug_id">52957</column><column name="summary">ClassCastException while removing Valve</column><column name="description">Created attachment 28490 Patch proposal Hello, The exception below is thrown when StandardPipeline.removeValve() is invoked: Caused by: java.lang.ClassCastException: test.MyValve cannot be cast to org.apache.catalina.Lifecycle 	at org.apache.catalina.core.StandardPipeline.removeValve(StandardPipeline.java:461) 	at org.apache.catalina.core.StandardPipeline.destroyInternal(StandardPipeline.java:222) 	at org.apache.catalina.util.LifecycleBase.destroy(LifecycleBase.java:304) test.MyValve implements only Valve I'm attaching a patch made against 7.0.x. Please review it and comment it. Thanks in advance. Regards Violeta Georgieva</column><column name="report_time">2012-03-21 12:47:49</column><column name="report_timestamp">1332350000</column><column name="status">resolved fixed</column><column name="commit">d5cee34</column><column name="commit_timestamp">1332430000</column><column name="files">java/org/apache/catalina/core/StandardPipeline.java</column><column name="result">5:java/org/apache/catalina/core/StandardPipeline.java</column></table><table name="tomcat"><column name="id">311</column><column name="bug_id">52839</column><column name="summary">New unit test for DigestAuthenticator and SingleSignOn</column><column name="description">Created attachment 28425 complete new class file New test class for SingleSignOn and the Digest Authenticator. Code passes validation and executes successfully against trunk svn commit: r1297158.</column><column name="report_time">2012-03-06 16:12:53</column><column name="report_timestamp">1331070000</column><column name="status">resolved fixed</column><column name="commit">c0f1bb9</column><column name="commit_timestamp">1332280000</column><column name="files">test/org/apache/catalina/authenticator/TestSSOnonLoginAndDigestAuthenticator.java</column><column name="result" /></table><table name="tomcat"><column name="id">312</column><column name="bug_id">50860</column><column name="summary">In case of invalid or empty slqQuery connection are always invalidated without usefull information</column><column name="description">The code is (in PooledConnection.java#validate(int validateAction,String sql) ) Statement stmt = null; try { stmt = connection.createStatement(); stmt.execute(query); stmt.close(); this.lastValidated = now; return true; } catch (Exception ignore) { if (log.isDebugEnabled()) log.debug("Unable to validate object:",ignore); if (stmt!=null) try { stmt.close();} catch (Exception ignore2){/*NOOP*/} } return false; So in the case of null or invalid query (connection is always invalidated : seems normal :-) ). But without any usefull message (except if you use debug : but seems complicated in a production env). So IMHO adding a log.warning in case of null query could be usefull.</column><column name="report_time">2011-03-03 06:51:14</column><column name="report_timestamp">1299150000</column><column name="status">resolved fixed</column><column name="commit">e092870</column><column name="commit_timestamp">1332260000</column><column name="files">modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/DataSourceProxy.java
modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/PoolConfiguration.java
modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/PoolProperties.java
modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/PooledConnection.java
modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/jmx/ConnectionPool.java</column><column name="result">1:modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/PooledConnection.java
18:modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/DataSourceProxy.java
20:modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/PoolProperties.java
30:modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/PoolConfiguration.java
46:modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/jmx/ConnectionPool.java</column></table><table name="tomcat"><column name="id">313</column><column name="bug_id">51893</column><column name="summary">JMX notification/Exception for empty/exhausted connection pool</column><column name="description">Currently, if there is an error getting a connection from the pool, a generic SQLException is thrown. The only way to determine if the problem is a result of the connection pool being exhausted is to catch the SQLException and parse the message (i.e. look for "Pool empty" in ex.getMessage()). Would like to see the following: 1) A subclass of SQLException thrown in the case of an empty pool 2) A JMX notification sent in the case of an empty pool (e.g. [POOL EXHAUSTED])</column><column name="report_time">2011-09-26 14:49:49</column><column name="report_timestamp">1317060000</column><column name="status">resolved fixed</column><column name="commit">9d687eb</column><column name="commit_timestamp">1332260000</column><column name="files">modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/ConnectionPool.java
modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/PoolExhaustedException.java
modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/jmx/ConnectionPool.java</column><column name="result">5:modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/ConnectionPool.java
15:modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/jmx/ConnectionPool.java</column></table><table name="tomcat"><column name="id">314</column><column name="bug_id">51237</column><column name="summary">SlowQueryReport interceptor does not log anything</column><column name="description">The documentation I've seen for the SlowQueryInterceptor (http://people.apache.org/~fhanik/jdbc-pool/jdbc-pool.html#org.apache.tomcat.jdbc.pool.interceptor.SlowQueryReport) indicate that it is supposed to log a message with level WARN when a slow query is detected or there is a failure. However, it appears that no logging is ever done. reportSlowQuery and reportFailedQuery simply record the event with the QueryStats object. No call to the logging framework is ever made.</column><column name="report_time">2011-05-20 22:01:35</column><column name="report_timestamp">1305940000</column><column name="status">resolved fixed</column><column name="commit">0eb38b8</column><column name="commit_timestamp">1332250000</column><column name="files">modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/interceptor/SlowQueryReport.java</column><column name="result">1:modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/interceptor/SlowQueryReport.java</column></table><table name="tomcat"><column name="id">315</column><column name="bug_id">52926</column><column name="summary">NPE in processSocket</column><column name="description">We have sporadic issues triggering 502 proxy errors using the NIO connector behind Nginx, caused by dropped connections/end of streams in Tomcat. The Tomcat log shows: SEVERE: Error allocating socket processor java.lang.NullPointerException at org.apache.tomcat.util.net.NioEndpoint.processSocket(NioEndpoint.java:721) at org.apache.tomcat.util.net.NioEndpoint$Poller.cancelledKey(NioEndpoint.java:1048) at org.apache.tomcat.util.net.NioEndpoint$Poller.timeout(NioEndpoint.java:1392) at org.apache.tomcat.util.net.NioEndpoint$Poller.run(NioEndpoint.java:1174) at java.lang.Thread.run(Thread.java:662) Looking at the code in processSocket I see the line in NioEndpoint(721): attachment.setCometNotify(false); //will get reset upon next reg Attachment is fetched in line 720: KeyAttachment attachment = (KeyAttachment)socket.getAttachment(false); Looking at socket.getAttachement() method I see that this method is indeed capable of returning null, but no null-check for this is done (although it is in multiple other locations, so it seems inconsistent).</column><column name="report_time">2012-03-16 08:19:25</column><column name="report_timestamp">1331900000</column><column name="status">resolved fixed</column><column name="commit">dcb8808</column><column name="commit_timestamp">1332240000</column><column name="files">java/org/apache/tomcat/util/net/NioEndpoint.java</column><column name="result">1:java/org/apache/tomcat/util/net/NioEndpoint.java</column></table><table name="tomcat"><column name="id">316</column><column name="bug_id">52723</column><column name="summary">An incomplete fix for the resource leak bugs in StandardManager.java</column><column name="description">The fix revision 907502 was aimed to remove an resource leak bug on the FileOutputStream object "fos" and the ObjectOutputStream "oos" in the method "doUnload" of the file "/tomcat/tc6.0.x/trunk/java/org/apache/catalina/session/StandardManager.java" , but it is incomplete. When the ObjectOutputStream object is created unsuccessfully but the temp BufferedOutputStream object is created successfully, the temp object will be leaked. Besides that, the "oos" is not closed in all the pathes. The best way to close such resource object is putting such close operations in the finaly block of a try-catch-finally structure.</column><column name="report_time">2012-02-21 10:22:02</column><column name="report_timestamp">1329840000</column><column name="status">resolved wontfix</column><column name="commit">9f8c8d6</column><column name="commit_timestamp">1331330000</column><column name="files">java/org/apache/catalina/session/StandardManager.java</column><column name="result">1:java/org/apache/catalina/session/StandardManager.java</column></table><table name="tomcat"><column name="id">317</column><column name="bug_id">52850</column><column name="summary">Various miscellaneous fixes to Tomcat Memory Leak Detection code</column><column name="description">Problem Description - ---------------------- Tomcat memory leak detection has the following issues - Most of the detection and fixing code has been tested ONLY on Sun JVMs. A lot of the reflection based code does not work with the IBM JDK. - Tests in tomcat7.source\test\org\apache\catalina\loader do not seem to run successfully and are incomplete for all the protection that Tomcat provides for classloader memory leaks. - For some categories of threadlocal memory leaks the key and value are not displayed correctly in the warning messages; particularly ones dealing with indirect references to threadlocals - org.apache.catalina.loader.WebappClassLoader.loadedByThisOrChild(Object) incorrectly traverses the object classloader hierarchy instead of the current (this) classloader hierarchy Problem Conclusion - -------------------- - After extensive testing with the IBM JDKs, I have cleaned up and sanitized some of the reflection code to stop executors, timers, threads etc on the IBM JDK - Added new tests for detecting threadlocal leaks and thread leaks - Better ThreadLocal leak reporting with corrected loadedByThisOrChild method and addition of expungeStaleEntries method - Make code more resilient in certain leak detection scenarios.</column><column name="report_time">2012-03-07 14:57:15</column><column name="report_timestamp">1331150000</column><column name="status">resolved fixed</column><column name="commit">adbf442</column><column name="commit_timestamp">1331320000</column><column name="files">java/org/apache/catalina/loader/WebappClassLoader.java
test/org/apache/catalina/loader/TestWebappClassLoaderExecutorMemoryLeak.java
test/org/apache/catalina/loader/TestWebappClassLoaderThreadLocalMemoryLeak.java</column><column name="result">1:java/org/apache/catalina/loader/WebappClassLoader.java</column></table><table name="tomcat"><column name="id">318</column><column name="bug_id">52776</column><column name="summary">Generator's JspFragment.invoke implementation does not reset ELContext[JspContext.class]</column><column name="description">If a developer captures a JspFragment themselves and calls invoke on it, the JspContext.class attribute in the enclosing pageContext's ELContext is set by the generated JspFragment subclass, but not reset to its original value afterwards. Therefore after invoking a JspContext any EL expressions will be searching the wrong jspContext for attribute values. org.apache.jasper.compiler.Generator is responsible for creating the JspFragment subclass to represent the compiled fragment. The generatePostamble() method emits generated code to set the JspContext attribute in the ELContext: out.printil("this.jspContext.getELContext().putContext(javax.servlet.jsp.JspContext.class,this.jspContext);"); However it doesn't later put back the original value. If you are using the &lt;jsp:invoke&gt; tag to invoke the fragment (which is undoubtedly what most people are doing) then the code generated by visit(Node.InvokeAction n) in Generator explicitly restores the EL context: out.printil("jspContext.getELContext().putContext(javax.servlet.jsp.JspContext.class,getJspContext());"); However if you call invoke(Writer) on the JspFragment yourself you don't get that tidy up code. I suggest the resolution is to have the JspFragment.invoke method tidy up after itself. It "puts" the change to the JspContext.class attribute so it should also re"put" it. Then there shouldn't be any need to restore the EL context in the generated &lt;jsp:invoke&gt; code. I have tested this solution successfully.</column><column name="report_time">2012-02-27 00:46:22</column><column name="report_timestamp">1330320000</column><column name="status">resolved fixed</column><column name="commit">faf26da</column><column name="commit_timestamp">1331290000</column><column name="files">java/org/apache/jasper/compiler/Generator.java</column><column name="result">1:java/org/apache/jasper/compiler/Generator.java</column></table><table name="tomcat"><column name="id">319</column><column name="bug_id">52500</column><column name="summary">Improve client certificate authentication</column><column name="description" /><column name="report_time">2012-01-23 13:02:04</column><column name="report_timestamp">1327340000</column><column name="status">resolved fixed</column><column name="commit">401c703</column><column name="commit_timestamp">1331230000</column><column name="files">java/org/apache/catalina/realm/RealmBase.java
java/org/apache/catalina/realm/X509SubjectDnRetriever.java
java/org/apache/catalina/realm/X509UsernameRetriever.java</column><column name="result">4:java/org/apache/catalina/realm/RealmBase.java</column></table><table name="tomcat"><column name="id">320</column><column name="bug_id">52719</column><column name="summary">An incomplete fix for the resource leak bug in WebappClassLoader.java</column><column name="description">The fix revision 423920 was aimed to remove an resource leak bug on the JarFile "jarFile " in the method "validateJarFile" of the file "/tomcat/tc6.0.x/trunk/java/org/apache/catalina/loader/WebappClassLoader.java" , but it is incomplete. When the statements at lines 3226-3245 throw any eception, the object "jarFile " can not be closed as expected. The best way to close such resource object is putting such close operations in the finaly block of a try-catch-finally structure. The buggy code is copies as bellows: 3220 protected boolean validateJarFile(File jarfile) throws IOException { if (triggers == null) return (true); 3225 JarFile jarFile = new JarFile(jarfile); 3226 for (int i = 0; i &lt; triggers.length; i++) { Class clazz = null; try { if (parent != null) { clazz = parent.loadClass(triggers[i]); } else { clazz = Class.forName(triggers[i]); } } catch (Throwable t) { clazz = null; } if (clazz == null) continue; String name = triggers[i].replace('.', '/') + ".class"; if (log.isDebugEnabled()) log.debug(" Checking for " + name); JarEntry jarEntry = jarFile.getJarEntry(name); if (jarEntry != null) { log.info("validateJarFile(" + jarfile + ") - jar not loaded. See Servlet Spec 2.3, " + "section 9.7.2. Offending class: " + name); 3246 jarFile.close(); return (false); } } jarFile.close(); return (true); }</column><column name="report_time">2012-02-21 09:37:53</column><column name="report_timestamp">1329840000</column><column name="status">resolved fixed</column><column name="commit">78c02a7</column><column name="commit_timestamp">1331160000</column><column name="files">java/org/apache/catalina/loader/WebappClassLoader.java</column><column name="result">1:java/org/apache/catalina/loader/WebappClassLoader.java</column></table><table name="tomcat"><column name="id">321</column><column name="bug_id">52792</column><column name="summary">Incomplete error message when lookup a resource that is not bound in the naming</column><column name="description">Created attachment 28401 Patch proposal Hi, I have a servlet that specifies @Resource on a field level. (see attached sample application) When a request comes for this servlet, Tomcat tries to inject this resource and to instantiate the servlet. If the resource is not found, 500 ISE is returned as a response code. In the error message returned in the error page, it is not specified the full composite name that Tomcat tries to lookup, but only the first part (the context) (see incorrect.png). Thus the end user cannot understand which is the resource that causes the problem, but only the context that cannot be found. I would like to propose a patch (attached). A screenshot (correct.png) with corrected error message is also attached. Thanks in advance. Regards, Violeta Georgieva</column><column name="report_time">2012-02-28 20:30:12</column><column name="report_timestamp">1330480000</column><column name="status">resolved fixed</column><column name="commit">7cec4ff</column><column name="commit_timestamp">1331150000</column><column name="files">java/org/apache/naming/NamingContext.java</column><column name="result">7:java/org/apache/naming/NamingContext.java</column></table><table name="tomcat"><column name="id">322</column><column name="bug_id">52772</column><column name="summary">JspC : checking uriRoot option validness</column><column name="description">In org.apache.jasper.JspC#execute() method, if uriRoot is not null, it scans all jsp files under uriRoot, and then checks if uriRoot is a directory. It should be more desirable to check if uriRoot is a directory or not first and then scanning it. Here are my suggestion. if (uriRoot == null) { throw new JasperException( Localizer.getMessage("jsp.error.jspc.no_uriroot")); } File uriRootF = new File(uriRoot); if (!uriRootF.exists() || !uriRootF.isDirectory()) { throw new JasperException( Localizer.getMessage("jsp.error.jspc.uriroot_not_dir")); } if( context==null ) { initServletContext(); } // No explicit pages, we'll process all .jsp in the webapp if (pages.size() == 0) { scanFiles(uriRootF); }</column><column name="report_time">2012-02-26 07:41:43</column><column name="report_timestamp">1330260000</column><column name="status">resolved fixed</column><column name="commit">35958df</column><column name="commit_timestamp">1331130000</column><column name="files">java/org/apache/jasper/JspC.java</column><column name="result">1:java/org/apache/jasper/JspC.java</column></table><table name="tomcat"><column name="id">323</column><column name="bug_id">52770</column><column name="summary">Potential Bug or Inconsistency in NioBlockingSelector.java</column><column name="description">This is Ken Cheung, a Computer Science M.Phil. student. I observed some code clones in Tomcat and found inconsistent code: /tomcat/trunk/java/org/apache/tomcat/util/net/NioBlockingSelector.java 103	 try { 104	 if ( att.getWriteLatch()==null || att.getWriteLatch().getCount()==0) att.startWriteLatch(1); 105	 poller.add(att,SelectionKey.OP_WRITE,reference); 106	 att.awaitWriteLatch(writeTimeout,TimeUnit.MILLISECONDS); 107	 }catch (InterruptedException ignore) { 108	 Thread.interrupted(); 109	 } 110	 if ( att.getWriteLatch()!=null &amp;&amp; att.getWriteLatch().getCount()&gt; 0) { 111	 //we got interrupted, but we haven't received notification from the poller. 112	 keycount = 0; 113	 }else { 114	 //latch countdown has happened 115	 keycount = 1; 116	 att.resetWriteLatch(); 117	 } 118	 119	 if (writeTimeout &gt; 0 &amp;&amp; (keycount == 0)) 120	 timedout = (System.currentTimeMillis() - time) &gt;= writeTimeout; /tomcat/trunk/java/org/apache/tomcat/util/net/NioBlockingSelector.java 164	 try { 165	 if ( att.getReadLatch()==null || att.getReadLatch().getCount()==0) att.startReadLatch(1); 166	 poller.add(att,SelectionKey.OP_READ, reference); 167	 if (readTimeout &lt; 0) { 168	 att.awaitReadLatch(Long.MAX_VALUE, TimeUnit.MILLISECONDS); 169	 } else { 170	 att.awaitReadLatch(readTimeout, TimeUnit.MILLISECONDS); 171	 } 172	 }catch (InterruptedException ignore) { 173	 Thread.interrupted(); 174	 } 175	 if ( att.getReadLatch()!=null &amp;&amp; att.getReadLatch().getCount()&gt; 0) { 176	 //we got interrupted, but we haven't received notification from the poller. 177	 keycount = 0; 178	 }else { 179	 //latch countdown has happened 180	 keycount = 1; 181	 att.resetReadLatch(); 182	 } 183	 if (readTimeout &gt;= 0 &amp;&amp; (keycount == 0)) 184	 timedout = (System.currentTimeMillis() - time) &gt;= readTimeout; Quick description of the inconsistency Two code snippets are very similar code, but as you see, the first code does not check "if (readTimeout &lt; 0)" while the second code has the checker. We thought it could be a potential bug or inconsistency. Hope this helps.</column><column name="report_time">2012-02-25 15:04:31</column><column name="report_timestamp">1330200000</column><column name="status">resolved fixed</column><column name="commit">4f75b2d</column><column name="commit_timestamp">1331130000</column><column name="files">java/org/apache/tomcat/util/net/NioBlockingSelector.java</column><column name="result">1:java/org/apache/tomcat/util/net/NioBlockingSelector.java</column></table><table name="tomcat"><column name="id">324</column><column name="bug_id">52767</column><column name="summary">Potential Bug or Inconsistency in JDBCRealm.java and JDBCAccessLogValve.java</column><column name="description">This is Ken Cheung, a Computer Science M.Phil. student. I observed some code clones in Tomcat and found inconsistent code: /tomcat/trunk/java/org/apache/catalina/realm/JDBCRealm.java 676	 if (driver == null) { 677	 try { 678	 Class&lt;?&gt; clazz = Class.forName(driverName); 679	 driver = (Driver) clazz.newInstance(); 680	 } catch (Throwable e) { 681	 ExceptionUtils.handleThrowable(e); 682	 throw new SQLException(e.getMessage(), e); 683	 } 684	 } 685	 686	 // Open a new connection 687	 Properties props = new Properties(); 688	 if (connectionName != null) 689	 props.put("user", connectionName); 690	 if (connectionPassword != null) 691	 props.put("password", connectionPassword); 692	 dbConnection = driver.connect(connectionURL, props); /tomcat/trunk/java/org/apache/catalina/valves/JDBCAccessLogValve.java 566	 if (driver == null) { 567	 try { 568	 Class&lt;?&gt; clazz = Class.forName(driverName); 569	 driver = (Driver) clazz.newInstance(); 570	 } catch (Throwable e) { 571	 ExceptionUtils.handleThrowable(e); 572	 throw new SQLException(e.getMessage(), e); 573	 } 574	 } 575	 576	 // Open a new connection 577	 Properties props = new Properties(); 578	 props.put("autoReconnect", "true"); 579	 if (connectionName != null) { 580	 props.put("user", connectionName); 581	 } 582	 if (connectionPassword != null) { 583	 props.put("password", connectionPassword); 584	 } 585	 conn = driver.connect(connectionURL, props); Quick description of the inconsistency Two code snippets are very similar code, but as you see, in JDBCRealm.java does not use "props.put("autoReconnect", "true")" while JDBCAccessLogValve.java has. We thought it could be a potential bug or inconsistency. Hope this helps.</column><column name="report_time">2012-02-25 14:32:33</column><column name="report_timestamp">1330200000</column><column name="status">resolved fixed</column><column name="commit">1f4663d</column><column name="commit_timestamp">1331130000</column><column name="files">java/org/apache/catalina/valves/JDBCAccessLogValve.java</column><column name="result">2:java/org/apache/catalina/valves/JDBCAccessLogValve.java</column></table><table name="tomcat"><column name="id">325</column><column name="bug_id">52846</column><column name="summary">Programmatic login using UserDatabaseRealm returns 403 error.</column><column name="description">IMHO,HttpServletRequest#login does not need to define a &lt;login-config&gt;. NonLoginAuthenticator is used when &lt;login-config&gt; is not specified in HttpServletRequest#login. When UserDatabaseRealm is used, not GenericPrincipal but Memory User is set to a session. In AuthenticatorBase#invoke, principal registered into a session is set to a request. Because MemoryUser is set to a request as principal, RealmBase#hasRole always returns false. As a result, 403 error is returned.</column><column name="report_time">2012-03-07 08:40:46</column><column name="report_timestamp">1331130000</column><column name="status">resolved fixed</column><column name="commit">a01418d</column><column name="commit_timestamp">1331110000</column><column name="files">java/org/apache/catalina/authenticator/NonLoginAuthenticator.java</column><column name="result">7:java/org/apache/catalina/authenticator/NonLoginAuthenticator.java</column></table><table name="tomcat"><column name="id">326</column><column name="bug_id">52732</column><column name="summary">An incomplete fix for the resource leak bug in ExpressionFactory.java</column><column name="description">The fix revision 1043157 was aimed to remove an resource leak bug on the BufferedReader object "br " (created in line 231), the InputStream object "is" (created in line 222 or 224) in the method "getClassNameServices()" of the file "/tomcat/trunk/java/javax/el/ExpressionFactory.java" , but it is incomplete. There are some problems: 1. when "br" is not created successfully but the temp InputStreamReader is created successfully at line 231, the temp InputStreamReader will be leaked. The best way to close such resource objects is putting such close operations for each resource object in the finaly block of a try-catch-finally structure.</column><column name="report_time">2012-02-21 12:22:44</column><column name="report_timestamp">1329840000</column><column name="status">resolved fixed</column><column name="commit">6399c83</column><column name="commit_timestamp">1331070000</column><column name="files">java/javax/el/ExpressionFactory.java</column><column name="result">1:java/javax/el/ExpressionFactory.java</column></table><table name="tomcat"><column name="id">327</column><column name="bug_id">52731</column><column name="summary">An incomplete fix for the resource leak bug in JDTCompiler.java</column><column name="description">The fix revision 1043157 was aimed to remove an resource leak bug on the BufferedReader object "reader " (created in line 115), the FileInputStream object "is" (created in line 112) in the method "getContents()" of the file "/tomcat/trunk/java/org/apache/jasper/compiler/JDTCompiler.java" , but it is incomplete. There are some problems: 1. when "reader" is not created successfully but the temp InputStreamReader is created successfully at line 114, the temp InputStreamReader will be leaked. The best way to close such resource objects is putting such close operations in the finaly block of a try-catch-finally structure.</column><column name="report_time">2012-02-21 12:16:28</column><column name="report_timestamp">1329840000</column><column name="status">resolved fixed</column><column name="commit">2b1d195</column><column name="commit_timestamp">1331070000</column><column name="files">java/org/apache/jasper/compiler/JDTCompiler.java</column><column name="result">1:java/org/apache/jasper/compiler/JDTCompiler.java</column></table><table name="tomcat"><column name="id">328</column><column name="bug_id">52729</column><column name="summary">An incomplete fix for the resource leak bug in CometConnectionManagerValve.java</column><column name="description">The fix revision 640273 was aimed to remove an resource leak bug on the CometEventImpl object "cometEvent " (created line 130) in the method "lifecycleEvent()" of the file "/tomcat/trunk/java/org/apache/catalina/valves/CometConnectionManagerValve.java" , but it is incomplete. There are some problems: 1. when the statements at lines 131-134 throw some exception, the "cometEvent" can not be closed as expected. The best way to close such resource objects is putting such close operations in the finaly block of a try-catch-finally structure.</column><column name="report_time">2012-02-21 12:01:25</column><column name="report_timestamp">1329840000</column><column name="status">resolved fixed</column><column name="commit">683d5c1</column><column name="commit_timestamp">1331070000</column><column name="files">java/org/apache/catalina/valves/CometConnectionManagerValve.java</column><column name="result">1:java/org/apache/catalina/valves/CometConnectionManagerValve.java</column></table><table name="tomcat"><column name="id">329</column><column name="bug_id">52727</column><column name="summary">An incomplete fix for the resource leak bug in HostConfig.java</column><column name="description">The fix revision 423920 was aimed to remove an resource leak bug on the BufferedOutputStream object "ostream " (created line 804) in the method "deployWAR" of the file "/tomcat/trunk/java/org/apache/catalina/startup/HostConfig.java" , but it is incomplete. There are some problems: 1. when "ostream" is not created successfully but the temp FileOutputStream object is created successfully , the temp FileOutputStream object will be leaked. The best way to close such resource objects is putting such close operations for each object in the finaly block of a try-catch-finally structure.</column><column name="report_time">2012-02-21 11:58:35</column><column name="report_timestamp">1329840000</column><column name="status">resolved fixed</column><column name="commit">8293a6e</column><column name="commit_timestamp">1331070000</column><column name="files">java/org/apache/catalina/startup/HostConfig.java</column><column name="result">1:java/org/apache/catalina/startup/HostConfig.java</column></table><table name="tomcat"><column name="id">330</column><column name="bug_id">52726</column><column name="summary">An incomplete fix for the resource leak bug in MemoryUserDatabase.java</column><column name="description">The fix revision 423920 was aimed to remove an resource leak bug on the FileInputStream object "fis" (created line 418) in the method "open()" of the file "/tomcat/trunk/java/org/apache/catalina/users/MemoryUserDatabase.java" , but it is incomplete. There are some problems: 1. when the statements at lines 420-439 throw some exception, the "fis" can not be closed as expected. The best way to close such resource objects is putting such close operations in the finaly block of a try-catch-finally structure.</column><column name="report_time">2012-02-21 11:50:36</column><column name="report_timestamp">1329840000</column><column name="status">resolved fixed</column><column name="commit">a30ce07</column><column name="commit_timestamp">1331070000</column><column name="files">java/org/apache/catalina/users/MemoryUserDatabase.java</column><column name="result">1:java/org/apache/catalina/users/MemoryUserDatabase.java</column></table><table name="tomcat"><column name="id">331</column><column name="bug_id">52725</column><column name="summary">org.apache.jasper.compiler.JspUtil#getTagHandlerClassName() does not use org.apache.jasper.Constants.TAG_FILE_PACKAGE_NAME</column><column name="description">In the class org.apache.jasper.compiler.JspUtil, its method public static String getTagHandlerClassName(String path, String urn, ErrorDispatcher err) throws JasperException { ... } uses the string constants directly like "org.apache.jsp.tag.web.", "org.apache.jsp.tag.meta.". But you know there is TAG_FILE_PACKAGE_NAME field in the class org.apache.jasper.Constants. The code should be adjusted like below : Constants.TAG_FILE_PACKAGE_NAME + ".web" Constants.TAG_FILE_PACKAGE_NAME + ".meta"</column><column name="report_time">2012-02-21 11:28:46</column><column name="report_timestamp">1329840000</column><column name="status">resolved fixed</column><column name="commit">bf0287e</column><column name="commit_timestamp">1330980000</column><column name="files">java/org/apache/jasper/compiler/JspUtil.java</column><column name="result">1:java/org/apache/jasper/compiler/JspUtil.java</column></table><table name="tomcat"><column name="id">332</column><column name="bug_id">52724</column><column name="summary">An incomplete fix for the resource leak bugs in Catalina.java</column><column name="description">The fix revision 730178 was aimed to remove an resource leak bug on the FileInputStream object "fis" (created line 458), the Socket "socket" (created at line 477), the OutputStream object "stream", and the FileInputStream object "inputStream" in the file "/tomcat/tc7.0.x/trunk/java/org/apache/catalina/startup/Catalina.java" , but it is incomplete. There are some problems: 1. the InputSource object "is" created at line 452 is not closed. 2. when the statements at lines 455-457 throw some exception, the "fis" can not be closed as expected. 3. when the statements at lines 480-483 throw some exception, the "socket" and the "stream" can not be closed as expected. 4. when the statements at lines 574-576 throw some exception, the "inputStream" can not be closed as expected. The best way to close such resource objects is putting such close operations in the finaly block of a try-catch-finally structure.</column><column name="report_time">2012-02-21 10:35:32</column><column name="report_timestamp">1329840000</column><column name="status">resolved fixed</column><column name="commit">7c51f61</column><column name="commit_timestamp">1330980000</column><column name="files">java/org/apache/catalina/startup/Catalina.java</column><column name="result">20:java/org/apache/catalina/startup/Catalina.java</column></table><table name="tomcat"><column name="id">333</column><column name="bug_id">52804</column><column name="summary">Make PoolProperties implement Cloneable.</column><column name="description">It would be very useful to have the PoolProperties class implement the java.lang.Cloneable interface. We have many databases that share the same schema, username, password, configuration etc but differ only in their URL. Implementing a routing datasource based on something like org.springframework.jdbc.datasource.AbstractDataSource can then just clone a PoolProperties object and set the one or two properties that differ in the clone. In a spring project the properties that are common across all the datasources are only supplied once.</column><column name="report_time">2012-03-01 17:18:03</column><column name="report_timestamp">1330640000</column><column name="status">resolved fixed</column><column name="commit">55baca6</column><column name="commit_timestamp">1330630000</column><column name="files">modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/PoolProperties.java</column><column name="result">1:modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/PoolProperties.java</column></table><table name="tomcat"><column name="id">334</column><column name="bug_id">52760</column><column name="summary">Mime type for javascript incorrect  in documentation</column><column name="description">The mime type for javascript for the expires by type filter is documented as text/javascript. Tomcat actually serves javascript with the mime-type application/javascript. http://tomcat.apache.org/tomcat-7.0-doc/config/filter.html Says &lt;init-param&gt; &lt;param-name&gt;ExpiresByType text/javascript&lt;/param-name&gt; &lt;param-value&gt;access plus 1 month&lt;/param-value&gt; &lt;/init-param&gt; Should say &lt;init-param&gt; &lt;param-name&gt;ExpiresByType application/javascript&lt;/param-name&gt; &lt;param-value&gt;access plus 1 month&lt;/param-value&gt; &lt;/init-param&gt;</column><column name="report_time">2012-02-24 13:35:39</column><column name="report_timestamp">1330110000</column><column name="status">resolved fixed</column><column name="commit">833e6b1</column><column name="commit_timestamp">1330260000</column><column name="files">java/org/apache/catalina/filters/ExpiresFilter.java</column><column name="result">118:java/org/apache/catalina/filters/ExpiresFilter.java</column></table><table name="tomcat"><column name="id">335</column><column name="bug_id">52758</column><column name="summary">Jasper illegally implements org.eclipse.jdt.internal.compiler.env.ICompilationUnit from Eclipse</column><column name="description">The illegal implementation described in the Eclipse bug (https://bugs.eclipse.org/bugs/show_bug.cgi?id=372351) is causing severe problems for the Eclipse SDK which uses Jasper for our help system. The interface in question is org.eclipse.jdt.internal.compiler.env.ICompilationUnit which resides in an internal package and should not be implemented by clients. The ideal resolution to this problem would be for Jasper to discontinue implementing it, but we would also be fine with Jasper just updating their code to resolve the compilation problems.</column><column name="report_time">2012-02-24 04:21:56</column><column name="report_timestamp">1330080000</column><column name="status">resolved fixed</column><column name="commit">2e7f5ab</column><column name="commit_timestamp">1330080000</column><column name="files">java/org/apache/jasper/compiler/JDTCompiler.java</column><column name="result">6:java/org/apache/jasper/compiler/JDTCompiler.java</column></table><table name="tomcat"><column name="id">336</column><column name="bug_id">52671</column><column name="summary">NIO Connector: Exception invoking method readBufSize / writeBufSize in the JMX Proxy Servlet</column><column name="description">JDK versions tested with: 1.7.0_02 (x64) and 1.7.0_03 (x64) I am using the new NIO connector, configured like this: &lt;Connector protocol="org.apache.coyote.ajp.AjpNioProtocol" port="8009" redirectPort="8443" URIEncoding="UTF-8" maxThreads="50" minSpareThreads="10" connectionTimeout="600000" acceptorThreadCount="2" /&gt; I query the JMX proxy for the thread pool status like this: http://www.mydomain.com/manager/jmxproxy/?qry=Catalina:type=ThreadPool,name=%22ajp-nio-8009%22 The JMX proxy servlet returns a valid response, and the server's general operation is not affected in any way. But at the same time, Tomcat logs the following two exceptions to catalina.out: Feb 15, 2012 12:26:49 PM org.apache.catalina.mbeans.MBeanDumper dumpBeans Schwerwiegend: Error getting attribute Catalina:type=ThreadPool,name="ajp-nio-8009" readBufSize javax.management.RuntimeOperationsException: Exception invoking method readBufSize at org.apache.tomcat.util.modeler.BaseModelMBean.getAttribute(BaseModelMBean.java:197) at com.sun.jmx.interceptor.DefaultMBeanServerInterceptor.getAttribute(DefaultMBeanServerInterceptor.java:647) at com.sun.jmx.mbeanserver.JmxMBeanServer.getAttribute(JmxMBeanServer.java:668) at org.apache.catalina.mbeans.MBeanDumper.dumpBeans(MBeanDumper.java:81) at org.apache.catalina.manager.JMXProxyServlet.listBeans(JMXProxyServlet.java:166) at org.apache.catalina.manager.JMXProxyServlet.doGet(JMXProxyServlet.java:121) at javax.servlet.http.HttpServlet.service(HttpServlet.java:621) at javax.servlet.http.HttpServlet.service(HttpServlet.java:722) at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:305) at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:210) at org.apache.catalina.filters.SetCharacterEncodingFilter.doFilter(SetCharacterEncodingFilter.java:108) at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:243) at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:210) at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:224) at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:169) at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:581) at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:168) at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:98) at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:118) at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:407) at org.apache.coyote.ajp.AjpNioProcessor.process(AjpNioProcessor.java:184) at org.apache.coyote.AbstractProtocol$AbstractConnectionHandler.process(AbstractProtocol.java:579) at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.run(NioEndpoint.java:1600) at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1110) at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:603) at java.lang.Thread.run(Thread.java:722) Caused by: java.lang.NullPointerException at org.apache.tomcat.util.net.SocketProperties.getRxBufSize(SocketProperties.java:251) at org.apache.tomcat.util.net.NioEndpoint.getReadBufSize(NioEndpoint.java:613) at sun.reflect.GeneratedMethodAccessor1196.invoke(Unknown Source) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:601) at org.apache.tomcat.util.modeler.BaseModelMBean.getAttribute(BaseModelMBean.java:190) ... 25 more Feb 15, 2012 12:26:49 PM org.apache.catalina.mbeans.MBeanDumper dumpBeans Schwerwiegend: Error getting attribute Catalina:type=ThreadPool,name="ajp-nio-8009" writeBufSize javax.management.RuntimeOperationsException: Exception invoking method writeBufSize at org.apache.tomcat.util.modeler.BaseModelMBean.getAttribute(BaseModelMBean.java:197) at com.sun.jmx.interceptor.DefaultMBeanServerInterceptor.getAttribute(DefaultMBeanServerInterceptor.java:647) at com.sun.jmx.mbeanserver.JmxMBeanServer.getAttribute(JmxMBeanServer.java:668) at org.apache.catalina.mbeans.MBeanDumper.dumpBeans(MBeanDumper.java:81) at org.apache.catalina.manager.JMXProxyServlet.listBeans(JMXProxyServlet.java:166) at org.apache.catalina.manager.JMXProxyServlet.doGet(JMXProxyServlet.java:121) at javax.servlet.http.HttpServlet.service(HttpServlet.java:621) at javax.servlet.http.HttpServlet.service(HttpServlet.java:722) at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:305) at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:210) at org.apache.catalina.filters.SetCharacterEncodingFilter.doFilter(SetCharacterEncodingFilter.java:108) at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:243) at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:210) at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:224) at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:169) at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:581) at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:168) at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:98) at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:118) at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:407) at org.apache.coyote.ajp.AjpNioProcessor.process(AjpNioProcessor.java:184) at org.apache.coyote.AbstractProtocol$AbstractConnectionHandler.process(AbstractProtocol.java:579) at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.run(NioEndpoint.java:1600) at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1110) at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:603) at java.lang.Thread.run(Thread.java:722) Caused by: java.lang.NullPointerException at org.apache.tomcat.util.net.SocketProperties.getTxBufSize(SocketProperties.java:283) at org.apache.tomcat.util.net.NioEndpoint.getWriteBufSize(NioEndpoint.java:609) at sun.reflect.GeneratedMethodAccessor1151.invoke(Unknown Source) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:601) at org.apache.tomcat.util.modeler.BaseModelMBean.getAttribute(BaseModelMBean.java:190) ... 25 more</column><column name="report_time">2012-02-15 11:47:03</column><column name="report_timestamp">1329320000</column><column name="status">resolved fixed</column><column name="commit">3fe64a5</column><column name="commit_timestamp">1329340000</column><column name="files">java/org/apache/catalina/mbeans/MBeanDumper.java</column><column name="result">170:java/org/apache/catalina/mbeans/MBeanDumper.java</column></table><table name="tomcat"><column name="id">337</column><column name="bug_id">52669</column><column name="summary">Annotation processing, in WEB-INF/classes, for Servlets/Listeners/Filters is skipped when the web app is not extracted, classes do not have packages and for some embedded scenarios</column><column name="description">Hi, Annotation processing for Servlets/Listeners/Filters is skipped when: - the web app is not extracted (screenshot1), - classes do not have packages (screenshot2), - for some embedded scenarios (running Tomcat in OSGI environment - screenshot3) A test web application is attached - test-web-app.war. I followed the history and the change that introduces that behaviour is made with revision 1210012. org.apache.catalina.startup.ContextConfig The annotations are processed correctly in all use cases when we have: 1199 URL webinfClasses; 1200 try { 1201 webinfClasses = context.getServletContext().getResource( 1202 "/WEB-INF/classes"); 1203 processAnnotationsUrl(webinfClasses, webXml); 1204 } catch (MalformedURLException e) { 1205 log.error(sm.getString( 1206 "contextConfig.webinfClassesUrl"), e); 1207 } The way how they are processed now is assuming that we will have FirDirContext always. 1196 try { 1197 NamingEnumeration&lt;Binding&gt; listBindings = 1198 context.getResources().listBindings("/WEB-INF/classes"); 1199 while (listBindings.hasMoreElements()) { 1200 Binding binding = listBindings.nextElement(); 1201 if (binding.getObject() instanceof FileDirContext) { 1202 File webInfCLassDir = 1203 new File( 1204 ((FileDirContext) binding.getObject()).getDocBase()); 1205 processAnnotationsFile(webInfCLassDir, webXml); 1206 } 1207 } 1208 } catch (NamingException e) { 1209 log.error(sm.getString( 1210 "contextConfig.webinfClassesUrl"), e); 1211 } Regards Violeta Georgieva</column><column name="report_time">2012-02-14 21:39:46</column><column name="report_timestamp">1329270000</column><column name="status">resolved fixed</column><column name="commit">34b1a7e</column><column name="commit_timestamp">1329340000</column><column name="files">java/org/apache/catalina/startup/ContextConfig.java</column><column name="result">2:java/org/apache/catalina/startup/ContextConfig.java</column></table><table name="tomcat"><column name="id">338</column><column name="bug_id">52666</column><column name="summary">EL should coerce String to Integer in equals operation</column><column name="description">This issue was reported on the users@ list, thread: "EL String -&gt; int coercion stopped working after TC 5.5 -&gt; 7.0 upgrade?" http://tomcat.markmail.org/thread/a7l45meiakblxcvz http://marc.info/?t=132918931400002&amp;r=1&amp;w=2 Original reporter used &lt;c:out&gt; tag, but it is not necessary to reproduce the issue. The issue is reproducible in current 7.0 and 6.0. It works correctly in 5.5.35. To reproduce, 1. save the following JSP page as ROOT/test.jsp [[[ ${param['foo'] == 1}&lt;br&gt; ${1 == param['foo']}&lt;br&gt; ${1 == (0+param['foo'])}&lt;br&gt; ]]] 2. go to http://localhost:8080/test.jsp?foo=01 Expected result: true true true Actual result: false false true This happens for foo=01, 001 etc. The equals result happens only when foo=1 According to EL 2.2 specification chapter 1.8.2 the ==,!= operators have the following step: "If A or B is Byte, Short, Character, Integer, or Long coerce both A and B to Long, apply operator". This step should happen earlier than coercion to String.</column><column name="report_time">2012-02-14 12:55:34</column><column name="report_timestamp">1329240000</column><column name="status">resolved fixed</column><column name="commit">bf9bf39</column><column name="commit_timestamp">1329320000</column><column name="files">java/org/apache/el/lang/ELSupport.java
test/org/apache/el/lang/TestELSupport.java</column><column name="result">2:test/org/apache/el/lang/TestELSupport.java
7:java/org/apache/el/lang/ELSupport.java</column></table><table name="tomcat"><column name="id">339</column><column name="bug_id">52607</column><column name="summary">It is not well defined how "Dependencies on extensions" mechanism can be used in Tomcat</column><column name="description">Hi, As a result of the mail thread [1] I'm opening a bug. In short it is not clear how exactly "Dependencies on extensions" mechanism can be used. I have two proposals: 1. Tomcat can continue to use in its implementation a separate property ("catalina.ext.dirs") that provides extensions' location. But its value should be added by default to the Tomcat's classpath directories (e.g. "shared.loader"). - Pros: Tomcat users will know that this property specifies the directory for their extensions and only the files located there will be scanned during ExtensionValidator.validateApplication invocation. - Cons: Additional configuration that has to be maintained. 2. Tomcat can remove this separate property ("catalina.ext.dirs") and start searching for such extensions in the Tomcat's classpath directories (e.g. shared.loader). - Pros: No additional configuration is needed. One can specify the shared libraries and the extensions with one and the same property. - Cons: During ExtensionValidator.validateApplication, it may appear that a lot of files are scanned which might be not necessary. I'm willing to provide a patch once we agree on the solution. My favourite is the first proposal. I'm looking forward to your comments. Thanks in advance. Regards, Violeta Georgieva [1] http://marc.info/?t=132827584600009&amp;r=1&amp;w=2</column><column name="report_time">2012-02-05 22:19:35</column><column name="report_timestamp">1328500000</column><column name="status">resolved fixed</column><column name="commit">4b6d583</column><column name="commit_timestamp">1328740000</column><column name="files">java/org/apache/catalina/core/StandardServer.java
java/org/apache/catalina/util/ExtensionValidator.java</column><column name="result">32:java/org/apache/catalina/util/ExtensionValidator.java
33:java/org/apache/catalina/core/StandardServer.java</column></table><table name="tomcat"><column name="id">340</column><column name="bug_id">52606</column><column name="summary">FORM authentication POST replay broken for AJP</column><column name="description">Reported and discussed in the following thread on users@: "Form Authentication POST data not preserved?" http://markmail.org/message/pldgbe4jbnb46ha4 http://marc.info/?t=132830976900001&amp;r=1&amp;w=2 This supposedly has the same trigger as the issue reported in Comment 9 in bug 51940 [3], that is consuming the body of the original request before replacing it. [3] https://issues.apache.org/bugzilla/show_bug.cgi?id=51940#c9 In AbstractAjpProcessor$SocketInputBuffer#doRead() there is a check for "endOfStream" flag. If the flag is set the method returns immediately and does not use the bodyBytes field that was initialized to replay the body. The fix is to add the following line to "REQ_SET_BODY_REPLAY" case in AbstractAjpProcessor#action(), as confirmed on the users@ thread: endOfStream = false; In 6.0.x implementation of AjpProcessor$SocketInputBuffer and of replay action is the same, but I have not tested whether this bug can be triggered there or not.</column><column name="report_time">2012-02-05 18:10:19</column><column name="report_timestamp">1328480000</column><column name="status">resolved fixed</column><column name="commit">6f766be</column><column name="commit_timestamp">1328720000</column><column name="files">java/org/apache/coyote/ajp/AbstractAjpProcessor.java</column><column name="result">6:java/org/apache/coyote/ajp/AbstractAjpProcessor.java</column></table><table name="tomcat"><column name="id">341</column><column name="bug_id">52591</column><column name="summary">UnsupportedOperationException logged when fetching BasicDataSource 'loginTimeout'</column><column name="description">With a BasicDataSource configured (using a &lt;Resource&gt;), simply list the available MBeans and this exception will be emitted to stdout: SEVERE: Error getting attribute Catalina:type=DataSource,context=/context,host=localhost,class=javax.sql.DataSource,name="jdbc/myDataSource" loginTimeout javax.management.RuntimeOperationsException: Exception invoking method loginTimeout at org.apache.tomcat.util.modeler.BaseModelMBean.getAttribute(BaseModelMBean.java:197) at com.sun.jmx.interceptor.DefaultMBeanServerInterceptor.getAttribute(DefaultMBeanServerInterceptor.java:666) at com.sun.jmx.mbeanserver.JmxMBeanServer.getAttribute(JmxMBeanServer.java:638) at org.apache.catalina.mbeans.MBeanDumper.dumpBeans(MBeanDumper.java:81) at org.apache.catalina.manager.JMXProxyServlet.listBeans(JMXProxyServlet.java:166) at org.apache.catalina.manager.JMXProxyServlet.doGet(JMXProxyServlet.java:121) at javax.servlet.http.HttpServlet.service(HttpServlet.java:621) [...] Caused by: java.lang.UnsupportedOperationException: Not supported by BasicDataSource at org.apache.tomcat.dbcp.dbcp.BasicDataSource.getLoginTimeout(BasicDataSource.java:1083) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) This exception does not cause the request to fail, but definitely puts an ugly stack trace in catalina.out. It might be better to catch UnsupportedOperationException and emit a one-line error message -- one that isn't SEVERE.</column><column name="report_time">2012-02-03 14:43:28</column><column name="report_timestamp">1328300000</column><column name="status">resolved fixed</column><column name="commit">fbf9166</column><column name="commit_timestamp">1328710000</column><column name="files">java/org/apache/catalina/mbeans/MBeanDumper.java</column><column name="result">5:java/org/apache/catalina/mbeans/MBeanDumper.java</column></table><table name="tomcat"><column name="id">342</column><column name="bug_id">52586</column><column name="summary">When requests are forwarded, the request attribute javax.servlet.forward.path_info is assigned an incorrect value.</column><column name="description">As per the servlet spec, the values for: javax.servlet.forward.request_uri javax.servlet.forward.context javax.servlet.forward.servlet_path javax.servlet.forward.path_info javax.servlet.forward.query_string MUST be set to the values from the very first servlet that serviced the current request. However, it seems that Tomcat is populating path_info with the value of the LAST path_info serviced in the request (i.e. the final servlet that serviced the request). It's possible the other value assignments are afflicted by similar defects, I've not explicitly tested for this. Because of this issue, it's impossible to correctly reconstruct the original request's URI piecemeal by concatenating context+servlet_path+path_info+?+query_string, since path_info will contain the path to another servlet and thus this concatenation will produce a probably invalid URI target. Therefore, creating "click here to retry" links is impossible without workaround code. The critical issue here is the deviation from the servlet spec, which spells out the behavior of those attributes.</column><column name="report_time">2012-02-02 18:49:59</column><column name="report_timestamp">1328230000</column><column name="status">resolved fixed</column><column name="commit">660513c</column><column name="commit_timestamp">1328480000</column><column name="files">java/org/apache/catalina/core/StandardHostValve.java</column><column name="result">63:java/org/apache/catalina/core/StandardHostValve.java</column></table><table name="tomcat"><column name="id">343</column><column name="bug_id">52577</column><column name="summary">Response output written in filter can be truncated</column><column name="description">Due to changes 1229726, 1229727 and 1229728 output written to response in the filter can be truncated up to 8192 bytes. Consider the following scenario: - you have a filter that invoke getWriter() before chain.doFilter(request, responseWrapper) - responseWrapper overrides getWriter() method and returns some buffered writer, not the real one - during execution of chain.doFilter there is a forward Before the forward ApplicationDispather calls resetBuffer on response, which in turn calls reset() on OutputBuffer, which sets gotEnc field to false. This field is initialized in the setConverter() method which is called from response.getWriter(), but since our wrapperResponse overrides getWriter(), OutputBuffer.setConverter() never called and OutputBuffer still has gotEnc = false. Response's close() and flushBuffer() methods call OutputBuffer's flush(), but since gotEnc == false, conv.flushBuffer() is not called: if (gotEnc &amp;&amp; conv != null) { conv.flushBuffer(); } A workaround for us is to implement getWriter() method in responseWrapper like this: public Writer getWriter() { Writer originalWriter = originalResponse.getWriter();//save for future processing return ourWriter; } Maybe you should change flushing to something like that: if (conv != null) { conv.flushBuffer(); } because you invoke conv.convert() without any checks in the write*() methods and it seems like conv is never null.</column><column name="report_time">2012-02-02 07:45:44</column><column name="report_timestamp">1328190000</column><column name="status">resolved fixed</column><column name="commit">2fd117b</column><column name="commit_timestamp">1328480000</column><column name="files">java/org/apache/catalina/connector/OutputBuffer.java
java/org/apache/catalina/connector/Response.java
test/org/apache/catalina/connector/TestOutputBuffer.java</column><column name="result">1:java/org/apache/catalina/connector/OutputBuffer.java
2:java/org/apache/catalina/connector/Response.java
294:test/org/apache/catalina/connector/TestOutputBuffer.java</column></table><table name="tomcat"><column name="id">344</column><column name="bug_id">52587</column><column name="summary">NPE in authenticator when no realm/resource is defined</column><column name="description">When no Realm is available to authenticate against, an NPE is thrown. STR: 1. Start with a stock 7.0.25 and modify server.xml: 2. Comment-out &lt;Resource&gt; in &lt;GlobalNamingResources&gt; 3. Comment-out &lt;Realm&gt; in &lt;Engine&gt; 4. Deploy manager app and try to log in java.lang.NullPointerException 	org.apache.catalina.realm.RealmBase.authenticate(RealmBase.java:340) 	org.apache.catalina.authenticator.BasicAuthenticator.authenticate(BasicAuthenticator.java:158) 	org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:544) 	org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:98) 	org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:407) 	org.apache.coyote.http11.AbstractHttp11Processor.process(AbstractHttp11Processor.java:987) 	org.apache.coyote.AbstractProtocol$AbstractConnectionHandler.process(AbstractProtocol.java:579) 	org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.run(NioEndpoint.java:1600) 	java.util.concurrent.ThreadPoolExecutor$Worker.runTask(ThreadPoolExecutor.java:886) 	java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:908) 	java.lang.Thread.run(Thread.java:680) Clearly, this is a pathological setup, but it might be nice to get a decent error message instead of an NPE.</column><column name="report_time">2012-02-02 20:00:01</column><column name="report_timestamp">1328230000</column><column name="status">resolved fixed</column><column name="commit">49a52cb</column><column name="commit_timestamp">1328470000</column><column name="files">java/org/apache/catalina/core/StandardEngine.java</column><column name="result">148:java/org/apache/catalina/core/StandardEngine.java</column></table><table name="tomcat"><column name="id">345</column><column name="bug_id">52444</column><column name="summary">Classloading-based ServletContainerInitializer @HandlesTypes processing can result in long startup times</column><column name="description">See 52326 for background, noting particularly the following: "As long as SCI processing involves expensive classloading, larger applications will suffer from long startup times and thus be encouraged to "shut off" this functionality via metadata-complete='true'." This issue, then, is intended to address classloading-based approach to @HandlesTypes processing by replacing it with something faster and generally less problematic. ASM would be one way to get it done.</column><column name="report_time">2012-01-09 17:11:12</column><column name="report_timestamp">1326150000</column><column name="status">resolved fixed</column><column name="commit">f4896de</column><column name="commit_timestamp">1327920000</column><column name="files">java/org/apache/catalina/startup/ContextConfig.java
java/org/apache/tomcat/util/bcel/classfile/JavaClass.java
test/org/apache/catalina/startup/TestContextConfigAnnotation.java</column><column name="result">1:java/org/apache/catalina/startup/ContextConfig.java
6:test/org/apache/catalina/startup/TestContextConfigAnnotation.java
325:java/org/apache/tomcat/util/bcel/classfile/JavaClass.java</column></table><table name="tomcat"><column name="id">346</column><column name="bug_id">52547</column><column name="summary">incorrect byeswritten log after completed async request under http1.0</column><column name="description">AbstractHttp11Processor does not call nextRequest() if the socket will be closed because keepAlive=false (i.e. http/1.0). See line 1539 in http://svn.apache.org/repos/asf/tomcat/tc7.0.x/tags/TOMCAT_7_0_25/java/org/apache/coyote/http11/AbstractHttp11Processor.java Presumably the recycle() caused by the socket close is expected to subsume the behaviour of nextRequest() But in AbstractOutputBuffer recycle() does not have byteCount = 0, whereas nextRequest() does. See lines 260, 280 in http://svn.apache.org/repos/asf/tomcat/tc7.0.x/tags/TOMCAT_7_0_25/java/org/apache/coyote/http11/AbstractOutputBuffer.java The result is that the bytesWritten log of the following request will be incorrectly increased by the size of the async http/1.0 request</column><column name="report_time">2012-01-27 19:43:42</column><column name="report_timestamp">1327710000</column><column name="status">resolved fixed</column><column name="commit">f2edc92</column><column name="commit_timestamp">1327780000</column><column name="files">java/org/apache/coyote/http11/AbstractOutputBuffer.java</column><column name="result">21:java/org/apache/coyote/http11/AbstractOutputBuffer.java</column></table><table name="tomcat"><column name="id">347</column><column name="bug_id">52543</column><column name="summary">Exception</column><column name="description">SEVERE: Error finishing response java.lang.ArrayIndexOutOfBoundsException 	at java.lang.System.arraycopy(Native Method) 	at org.apache.coyote.http11.AbstractOutputBuffer.write(AbstractOutputBuffer.java:495) 	at org.apache.coyote.http11.AbstractOutputBuffer.sendStatus(AbstractOutputBuffer.java:337) 	at org.apache.coyote.http11.AbstractHttp11Processor.prepareResponse(AbstractHttp11Processor.java:1418) 	at org.apache.coyote.http11.AbstractHttp11Processor.action(AbstractHttp11Processor.java:756) 	at org.apache.coyote.Response.action(Response.java:168) 	at org.apache.coyote.http11.AbstractOutputBuffer.endRequest(AbstractOutputBuffer.java:310) 	at org.apache.coyote.http11.InternalOutputBuffer.endRequest(InternalOutputBuffer.java:158) 	at org.apache.coyote.http11.AbstractHttp11Processor.endRequest(AbstractHttp11Processor.java:1586) 	at org.apache.coyote.http11.AbstractHttp11Processor.process(AbstractHttp11Processor.java:1022) 	at org.apache.coyote.AbstractProtocol$AbstractConnectionHandler.process(AbstractProtocol.java:579) 	at org.apache.tomcat.util.net.JIoEndpoint$SocketProcessor.run(JIoEndpoint.java:307) 	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1110) 	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:603) 	at java.lang.Thread.run(Thread.java:722) big application i dont know why its happens may be due to the fact that twice as add some cookie</column><column name="report_time">2012-01-27 11:18:09</column><column name="report_timestamp">1327680000</column><column name="status">resolved fixed</column><column name="commit">ee0562d</column><column name="commit_timestamp">1327780000</column><column name="files">java/org/apache/coyote/http11/AbstractOutputBuffer.java</column><column name="result">4:java/org/apache/coyote/http11/AbstractOutputBuffer.java</column></table><table name="tomcat"><column name="id">348</column><column name="bug_id">52511</column><column name="summary">Exception logged in annotation scanning for web apps without /WEB-INF/classes</column><column name="description">Created attachment 28196 error and exception trace Any web app not containing a /WEB-INF/classes directory appears to cause an error and exception trace to be logged during web app startup. This is new Tomcat 7.0.25 (or 7.0.24) and did not occur in 7.0.23.</column><column name="report_time">2012-01-23 21:02:08</column><column name="report_timestamp">1327370000</column><column name="status">resolved fixed</column><column name="commit">3277494</column><column name="commit_timestamp">1327700000</column><column name="files">java/org/apache/catalina/startup/ContextConfig.java</column><column name="result">4:java/org/apache/catalina/startup/ContextConfig.java</column></table><table name="tomcat"><column name="id">349</column><column name="bug_id">52474</column><column name="summary">Do not load listeners declared with blank spaces on tld file.</column><column name="description">Created attachment 28163 debugging tomcat source Do not load listeners declared with blank spaces on tld file. Removing blank spaces the application run.</column><column name="report_time">2012-01-17 05:41:49</column><column name="report_timestamp">1326800000</column><column name="status">resolved fixed</column><column name="commit">2dd8a40</column><column name="commit_timestamp">1327090000</column><column name="files">java/org/apache/catalina/startup/TldRuleSet.java</column><column name="result">18:java/org/apache/catalina/startup/TldRuleSet.java</column></table><table name="tomcat"><column name="id">350</column><column name="bug_id">51408</column><column name="summary">String.getBytes() and new String(byte[]) use default charset - may cause problems in some Locales</column><column name="description">There seem to be rather a lot of instances where Strings and bytes are cconverted using the default charset. Since the default charset is unknown, its behaviour cannot be relied on.</column><column name="report_time">2011-06-21 15:47:16</column><column name="report_timestamp">1308690000</column><column name="status">resolved fixed</column><column name="commit">9722128</column><column name="commit_timestamp">1326990000</column><column name="files">java/org/apache/catalina/ant/AbstractCatalinaTask.java
java/org/apache/catalina/authenticator/DigestAuthenticator.java
java/org/apache/catalina/realm/JNDIRealm.java
java/org/apache/catalina/realm/RealmBase.java
java/org/apache/catalina/servlets/WebdavServlet.java
java/org/apache/catalina/util/RequestUtil.java
java/org/apache/catalina/valves/AccessLogValve.java
java/org/apache/catalina/valves/SSLValve.java
java/org/apache/coyote/http11/filters/BufferedInputFilter.java
java/org/apache/coyote/http11/filters/ChunkedInputFilter.java
java/org/apache/coyote/http11/filters/IdentityInputFilter.java
java/org/apache/coyote/http11/filters/VoidInputFilter.java
java/org/apache/jasper/Constants.java
java/org/apache/jasper/compiler/SmapUtil.java
java/org/apache/naming/resources/Constants.java
java/org/apache/naming/resources/ProxyDirContext.java
java/org/apache/tomcat/util/buf/MessageBytes.java</column><column name="result">5:java/org/apache/catalina/realm/RealmBase.java
7:java/org/apache/catalina/ant/AbstractCatalinaTask.java
10:java/org/apache/tomcat/util/buf/MessageBytes.java
12:java/org/apache/catalina/util/RequestUtil.java
36:java/org/apache/catalina/valves/AccessLogValve.java
51:java/org/apache/catalina/realm/JNDIRealm.java
52:java/org/apache/naming/resources/ProxyDirContext.java
59:java/org/apache/jasper/compiler/SmapUtil.java
76:java/org/apache/coyote/http11/filters/VoidInputFilter.java
92:java/org/apache/catalina/authenticator/DigestAuthenticator.java
126:java/org/apache/coyote/http11/filters/BufferedInputFilter.java
130:java/org/apache/coyote/http11/filters/IdentityInputFilter.java
216:java/org/apache/catalina/servlets/WebdavServlet.java
244:java/org/apache/coyote/http11/filters/ChunkedInputFilter.java
285:java/org/apache/catalina/valves/SSLValve.java
627:java/org/apache/jasper/Constants.java
1183:java/org/apache/naming/resources/Constants.java</column></table><table name="tomcat"><column name="id">351</column><column name="bug_id">52480</column><column name="summary">TC7 + AntCompiler problems with whitespace in pathname</column><column name="description">### Overview Bug opened for Linux but it also happens on Windows - see below for detailed environments. TC fails to compile JSP when: 1) the compiler is AntCompiler and 2) there is a whitespace somewhere in the absolute pathname to TC home dir. It may also fail when the absolute pathname to TC home dir contains non URI-compatible characters but I have tested only with whitespace. Configuring logging.properties to have AntCompiler set to level FINEST, logs show that: - whitespace is translated to "%20"; - javac task fails with many errors, the first being "package javax.servlet does not exist". Our tests show that: - When AntCompiler is used AND tomcat is installed in a directory whose absolute pathname does NOT contain any whitespace, compilation is ok. - When AntCompiler is used AND tomcat is installed in a directory whose absolute pathname DOES contain at least one whitespace, compilation fails. - When JDTCompiler is used, compilation is ok (whitespace or not). This has been tested with the two environments described below (+ steps to reproduce). ### History Some discussion has hapened on Tomcat mailing list on January 2011 and "markt at apache.org" wrote I should fill a bug (my initial mail subject is "TC7 + AntCompiler problems with whitespace in pathname", posted January 17th 2011 around midnight, French time zone). Following "aw at ice-sa.com"'s advice on the mailing list, I googled with "deployment" and found this: - TC6: In CGI Mode, "executable" full path with spaces does not work https://issues.apache.org/bugzilla/show_bug.cgi?id=49657 - TC5: Tomcat fails to start on linux if CATALINA_HOME contains a space https://issues.apache.org/bugzilla/show_bug.cgi?id=43578 - TC5: java.endorsed.dirs is not used when JSP compilation is forked (see comment #2) https://issues.apache.org/bugzilla/show_bug.cgi?id=31257#c2 It looks like having spaces ought to be ok. Note: on Windows, the installation wizard deploys TC into "C:\Program Files\Apache Software Foundation" which contains many spaces. ### Background Q: Why not use JDTCompiler? A: We have at least one "huge" JSP that fails to compile with JDTCompiler ("unresolved compilation error"). When we delete code from this JSP, it compiles. We could resolve the problem for this specific JSP but we have not found what makes the boundary between "it compiles" and "it does not compile" (tried suppressSmap=false, development=false). We can not afford to deploy our application on a production server with a compiler that might "randomly" fail on some other JSP. Previous version of our application has always been compiled with Sun / Oracle JDK: we prefer not to change the compiler brand. ### Build &amp; Platform Test environment #1: - OS is Linux 32 bits (Ubuntu 10.04 LTS) - TC is tomcat-7.0.23 - Files ant.jar + ant-launcher.jar from ant-1.8.2 copied to tomcat lib dir - File tools.jar copied from JDK to tomcat lib dir - "javac -version" returns javac 1.6.0_26 - "java -version" returns java version "1.6.0_26" Java(TM) SE Runtime Environment (build 1.6.0_26-b03) Java HotSpot(TM) Client VM (build 20.1-b02, mixed mode, sharing) Test environment #2: - OS is Windows 7 64 bits - TC is tomcat-7.0.23 - Files ant.jar + ant-launcher.jar from ant-1.8.2 copied to tomcat lib dir - File tools.jar copied from JDK to tomcat lib dir - "javac.exe -version" returns javac 1.7.0 - "java.exe -version" returns java version "1.7.0" Java(TM) SE Runtime Environment (build 1.7.0-b147) Java HotSpot(TM) 64-Bit Server VM (build 21.0-b17, mixed mode) Note: same results with Windows 2008 R2 ### Steps to reproduce Each test begins this way: - Extract apache-tomcat-7.0.23.tar.gz to &lt;SOME_DIR&gt; - Depending on test &lt;SOME_DIR&gt; absolute pathname contains a space or not - Download apache-ant-1.8.2-bin.tar.gz - Extract to any temp directory - Copy apache-ant-1.8.2/lib/ant.jar + apache-ant-1.8.2/lib/ant-launcher.jar to &lt;SOME_DIR&gt;/lib - Forget ant (extracted directory can be deleted) - Copy JDK lib/tools.jar to &lt;SOME_DIR&gt;/lib (mandatory when fork=false, see below) - Update original web.xml this way (starting at line 230): &lt;servlet&gt; &lt;servlet-name&gt;jsp&lt;/servlet-name&gt; &lt;servlet-class&gt;org.apache.jasper.servlet.JspServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;fork&lt;/param-name&gt; &lt;param-value&gt;false&lt;/param-value&gt; &lt;!-- true: same failure --&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;xpoweredBy&lt;/param-name&gt; &lt;param-value&gt;false&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;compiler&lt;/param-name&gt; &lt;param-value&gt;javac1.6&lt;/param-value&gt; &lt;!-- 1.7 if JDK 1.7 is used --&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;suppressSmap&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;3&lt;/load-on-startup&gt; &lt;/servlet&gt; - Delete &lt;SOME_DIR&gt;/work to be sure not to run with any previous compilation results - Run tomcat with startup.sh (or startup.bat if running on Windows) - Go to http://localhost:8080 - When &lt;SOME_DIR&gt; absolute pathname contains a space, it fails, else it works. ### Actual Results Our tests: - Env#1, SOME_DIR="/mnt/DSK2/tmp/tc/tc 7.0.23" =&gt; FAILS - Env#1, SOME_DIR="/mnt/DSK2/tmp/tc/apache-tomcat-7.0.23" =&gt; WORKS - Env#2, SOME_DIR="C:\Users\ekp\Desktop\Work tc7\apache-tomcat-7.0.23" =&gt; FAILS - Env#2, SOME_DIR="C:\tc7\apache-tomcat-7.0.23" =&gt; WORKS ### Expected Results TC should compile JSP even if the absolute pathname to TC home dir contains a space (or, I suppose, any other non URI-compatible character). This is especially disturbing on Windows because the TC installer deploys into "C:\Program Files\Apache Software Foundation" which contains many spaces. ### Excerpts from log file, FAIL case on environment #1 [ translation : "FIN" = fine ; "PLUS FIN" = finer / finest ; "GRAVE" = failure ] 16 janv. 2012 23:19:12 org.apache.jasper.compiler.JspRuntimeContext initClassPath FIN: Compilation classpath initialized: /mnt/DSK2/tmp/tc/tc 7.0.23/work/Catalina/localhost/manager:/mnt/DSK2/tmp/tc/tc%207.0.23/lib/:/mnt/DSK2/tmp/tc/tc%207.0.23/lib/tools.jar:/mnt/DSK2/tmp/tc/tc%207.0.23/lib/tomcat-dbcp.jar:/mnt/DSK2/tmp/tc/tc%207.0.23/lib/tomcat-jdbc.jar:/mnt/DSK2/tmp/tc/tc%207.0.23/lib/jasper-el.jar:/mnt/DSK2/tmp/tc/tc%207.0.23/lib/ant.jar:/mnt/DSK2/tmp/tc/tc%207.0.23/lib/tomcat-i18n-es.jar:/mnt/DSK2/tmp/tc/tc%207.0.23/lib/ant-launcher.jar:/mnt/DSK2/tmp/tc/tc%207.0.23/lib/annotations-api.jar:/mnt/DSK2/tmp/tc/tc%207.0.23/lib/tomcat-util.jar:/mnt/DSK2/tmp/tc/tc%207.0.23/lib/el-api.jar:/mnt/DSK2/tmp/tc/tc%207.0.23/lib/tomcat-coyote.jar:/mnt/DSK2/tmp/tc/tc%207.0.23/lib/jasper.jar:/mnt/DSK2/tmp/tc/tc%207.0.23/lib/jsp-api.jar:/mnt/DSK2/tmp/tc/tc%207.0.23/lib/servlet-api.jar:/mnt/DSK2/tmp/tc/tc%207.0.23/lib/tomcat-i18n-ja.jar:/mnt/DSK2/tmp/tc/tc%207.0.23/lib/tomcat-api.jar:/mnt/DSK2/tmp/tc/tc%207.0.23/lib/catalina.jar:/mnt/DSK2/tmp/tc/tc%207.0.23/lib/catalina-tribes.jar:/mnt/DSK2/tmp/tc/tc%207.0.23/lib/tomcat-i18n-fr.jar:/mnt/DSK2/tmp/tc/tc%207.0.23/lib/catalina-ant.jar:/mnt/DSK2/tmp/tc/tc%207.0.23/lib/ecj-3.7.jar:/mnt/DSK2/tmp/tc/tc%207.0.23/lib/catalina-ha.jar:/mnt/DSK2/tmp/tc/tc%207.0.23/bin/bootstrap.jar:/mnt/DSK2/tmp/tc/tc%207.0.23/bin/tomcat-juli.jar:/usr/lib/jvm/java-6-sun-1.6.0.26/jre/lib/ext/sunpkcs11.jar:/usr/lib/jvm/java-6-sun-1.6.0.26/jre/lib/ext/localedata.jar:/usr/lib/jvm/java-6-sun-1.6.0.26/jre/lib/ext/sunjce_provider.jar:/usr/lib/jvm/java-6-sun-1.6.0.26/jre/lib/ext/dnsns.jar [...] 16 janv. 2012 23:19:18 org.apache.jasper.compiler.AntCompiler generateClass FIN: Using classpath: /mnt/DSK2/tmp/tc/tc 7.0.23/bin/bootstrap.jar:/mnt/DSK2/tmp/tc/tc 7.0.23/bin/tomcat-juli.jar:/mnt/DSK2/tmp/tc/tc 7.0.23/work/Catalina/localhost/_:/mnt/DSK2/tmp/tc/tc%207.0.23/lib/:/mnt/DSK2/tmp/tc/tc%207.0.23/lib/tools.jar:/mnt/DSK2/tmp/tc/tc%207.0.23/lib/tomcat-dbcp.jar:/mnt/DSK2/tmp/tc/tc%207.0.23/lib/tomcat-jdbc.jar:/mnt/DSK2/tmp/tc/tc%207.0.23/lib/jasper-el.jar:/mnt/DSK2/tmp/tc/tc%207.0.23/lib/ant.jar:/mnt/DSK2/tmp/tc/tc%207.0.23/lib/tomcat-i18n-es.jar:/mnt/DSK2/tmp/tc/tc%207.0.23/lib/ant-launcher.jar:/mnt/DSK2/tmp/tc/tc%207.0.23/lib/annotations-api.jar:/mnt/DSK2/tmp/tc/tc%207.0.23/lib/tomcat-util.jar:/mnt/DSK2/tmp/tc/tc%207.0.23/lib/el-api.jar:/mnt/DSK2/tmp/tc/tc%207.0.23/lib/tomcat-coyote.jar:/mnt/DSK2/tmp/tc/tc%207.0.23/lib/jasper.jar:/mnt/DSK2/tmp/tc/tc%207.0.23/lib/jsp-api.jar:/mnt/DSK2/tmp/tc/tc%207.0.23/lib/servlet-api.jar:/mnt/DSK2/tmp/tc/tc%207.0.23/lib/tomcat-i18n-ja.jar:/mnt/DSK2/tmp/tc/tc%207.0.23/lib/tomcat-api.jar:/mnt/DSK2/tmp/tc/tc%207.0.23/lib/catalina.jar:/mnt/DSK2/tmp/tc/tc%207.0.23/lib/catalina-tribes.jar:/mnt/DSK2/tmp/tc/tc%207.0.23/lib/tomcat-i18n-fr.jar:/mnt/DSK2/tmp/tc/tc%207.0.23/lib/catalina-ant.jar:/mnt/DSK2/tmp/tc/tc%207.0.23/lib/ecj-3.7.jar:/mnt/DSK2/tmp/tc/tc%207.0.23/lib/catalina-ha.jar:/mnt/DSK2/tmp/tc/tc%207.0.23/bin/bootstrap.jar:/mnt/DSK2/tmp/tc/tc%207.0.23/bin/tomcat-juli.jar:/usr/lib/jvm/java-6-sun-1.6.0.26/jre/lib/ext/sunpkcs11.jar:/usr/lib/jvm/java-6-sun-1.6.0.26/jre/lib/ext/localedata.jar:/usr/lib/jvm/java-6-sun-1.6.0.26/jre/lib/ext/sunjce_provider.jar:/usr/lib/jvm/java-6-sun-1.6.0.26/jre/lib/ext/dnsns.jar 16 janv. 2012 23:19:18 org.apache.jasper.compiler.AntCompiler generateClass GRAVE: Javac exception Compile failed; see the compiler error output for details. at org.apache.tools.ant.taskdefs.Javac.compile(Javac.java:1150) at org.apache.tools.ant.taskdefs.Javac.execute(Javac.java:912) at org.apache.jasper.compiler.AntCompiler.generateClass(AntCompiler.java:234) [...] 16 janv. 2012 23:19:18 org.apache.jasper.compiler.AntCompiler generateClass GRAVE: Environment: Compile: javaFileName=/mnt/DSK2/tmp/tc/tc 7.0.23/work/Catalina/localhost/_/org/apache/jsp/index_jsp.java classpath=/mnt/DSK2/tmp/tc/tc 7.0.23/work/Catalina/localhost/_:/mnt/DSK2/tmp/tc/tc%207.0.23/lib/:/mnt/DSK2/tmp/tc/tc%207.0.23/lib/tools.jar:/mnt/DSK2/tmp/tc/tc%207.0.23/lib/tomcat-dbcp.jar:/mnt/DSK2/tmp/tc/tc%207.0.23/lib/tomcat-jdbc.jar:/mnt/DSK2/tmp/tc/tc%207.0.23/lib/jasper-el.jar:/mnt/DSK2/tmp/tc/tc%207.0.23/lib/ant.jar:/mnt/DSK2/tmp/tc/tc%207.0.23/lib/tomcat-i18n-es.jar:/mnt/DSK2/tmp/tc/tc%207.0.23/lib/ant-launcher.jar:/mnt/DSK2/tmp/tc/tc%207.0.23/lib/annotations-api.jar:/mnt/DSK2/tmp/tc/tc%207.0.23/lib/tomcat-util.jar:/mnt/DSK2/tmp/tc/tc%207.0.23/lib/el-api.jar:/mnt/DSK2/tmp/tc/tc%207.0.23/lib/tomcat-coyote.jar:/mnt/DSK2/tmp/tc/tc%207.0.23/lib/jasper.jar:/mnt/DSK2/tmp/tc/tc%207.0.23/lib/jsp-api.jar:/mnt/DSK2/tmp/tc/tc%207.0.23/lib/servlet-api.jar:/mnt/DSK2/tmp/tc/tc%207.0.23/lib/tomcat-i18n-ja.jar:/mnt/DSK2/tmp/tc/tc%207.0.23/lib/tomcat-api.jar:/mnt/DSK2/tmp/tc/tc%207.0.23/lib/catalina.jar:/mnt/DSK2/tmp/tc/tc%207.0.23/lib/catalina-tribes.jar:/mnt/DSK2/tmp/tc/tc%207.0.23/lib/tomcat-i18n-fr.jar:/mnt/DSK2/tmp/tc/tc%207.0.23/lib/catalina-ant.jar:/mnt/DSK2/tmp/tc/tc%207.0.23/lib/ecj-3.7.jar:/mnt/DSK2/tmp/tc/tc%207.0.23/lib/catalina-ha.jar:/mnt/DSK2/tmp/tc/tc%207.0.23/bin/bootstrap.jar:/mnt/DSK2/tmp/tc/tc%207.0.23/bin/tomcat-juli.jar:/usr/lib/jvm/java-6-sun-1.6.0.26/jre/lib/ext/sunpkcs11.jar:/usr/lib/jvm/java-6-sun-1.6.0.26/jre/lib/ext/localedata.jar:/usr/lib/jvm/java-6-sun-1.6.0.26/jre/lib/ext/sunjce_provider.jar:/usr/lib/jvm/java-6-sun-1.6.0.26/jre/lib/ext/dnsns.jar cp=/mnt/DSK2/tmp/tc/tc 7.0.23/bin/bootstrap.jar:/mnt/DSK2/tmp/tc/tc 7.0.23/bin/tomcat-juli.jar cp=/mnt/DSK2/tmp/tc/tc 7.0.23/work/Catalina/localhost/_ cp=/mnt/DSK2/tmp/tc/tc%207.0.23/lib cp=/mnt/DSK2/tmp/tc/tc%207.0.23/lib/tools.jar cp=/mnt/DSK2/tmp/tc/tc%207.0.23/lib/tomcat-dbcp.jar cp=/mnt/DSK2/tmp/tc/tc%207.0.23/lib/tomcat-jdbc.jar cp=/mnt/DSK2/tmp/tc/tc%207.0.23/lib/jasper-el.jar [...] ### Excerpts from log file, WORK case on environment #1 17 janv. 2012 00:05:49 org.apache.jasper.compiler.JspRuntimeContext initClassPath FIN: Compilation classpath initialized: /mnt/DSK2/tmp/tc/apache-tomcat-7.0.23/work/Catalina/localhost/manager:/mnt/DSK2/tmp/tc/apache-tomcat-7.0.23/lib/:/mnt/DSK2/tmp/tc/apache-tomcat-7.0.23/lib/tools.jar:/mnt/DSK2/tmp/tc/apache-tomcat-7.0.23/lib/tomcat-dbcp.jar:/mnt/DSK2/tmp/tc/apache-tomcat-7.0.23/lib/tomcat-jdbc.jar:/mnt/DSK2/tmp/tc/apache-tomcat-7.0.23/lib/jasper-el.jar:/mnt/DSK2/tmp/tc/apache-tomcat-7.0.23/lib/ant.jar:/mnt/DSK2/tmp/tc/apache-tomcat-7.0.23/lib/tomcat-i18n-es.jar:/mnt/DSK2/tmp/tc/apache-tomcat-7.0.23/lib/ant-launcher.jar:/mnt/DSK2/tmp/tc/apache-tomcat-7.0.23/lib/annotations-api.jar:/mnt/DSK2/tmp/tc/apache-tomcat-7.0.23/lib/tomcat-util.jar:/mnt/DSK2/tmp/tc/apache-tomcat-7.0.23/lib/el-api.jar:/mnt/DSK2/tmp/tc/apache-tomcat-7.0.23/lib/tomcat-coyote.jar:/mnt/DSK2/tmp/tc/apache-tomcat-7.0.23/lib/jasper.jar:/mnt/DSK2/tmp/tc/apache-tomcat-7.0.23/lib/jsp-api.jar:/mnt/DSK2/tmp/tc/apache-tomcat-7.0.23/lib/servlet-api.jar:/mnt/DSK2/tmp/tc/apache-tomcat-7.0.23/lib/tomcat-i18n-ja.jar:/mnt/DSK2/tmp/tc/apache-tomcat-7.0.23/lib/tomcat-api.jar:/mnt/DSK2/tmp/tc/apache-tomcat-7.0.23/lib/catalina.jar:/mnt/DSK2/tmp/tc/apache-tomcat-7.0.23/lib/catalina-tribes.jar:/mnt/DSK2/tmp/tc/apache-tomcat-7.0.23/lib/tomcat-i18n-fr.jar:/mnt/DSK2/tmp/tc/apache-tomcat-7.0.23/lib/catalina-ant.jar:/mnt/DSK2/tmp/tc/apache-tomcat-7.0.23/lib/ecj-3.7.jar:/mnt/DSK2/tmp/tc/apache-tomcat-7.0.23/lib/catalina-ha.jar:/mnt/DSK2/tmp/tc/apache-tomcat-7.0.23/bin/bootstrap.jar:/mnt/DSK2/tmp/tc/apache-tomcat-7.0.23/bin/tomcat-juli.jar:/usr/lib/jvm/java-6-sun-1.6.0.26/jre/lib/ext/sunpkcs11.jar:/usr/lib/jvm/java-6-sun-1.6.0.26/jre/lib/ext/localedata.jar:/usr/lib/jvm/java-6-sun-1.6.0.26/jre/lib/ext/sunjce_provider.jar:/usr/lib/jvm/java-6-sun-1.6.0.26/jre/lib/ext/dnsns.jar [...] 17 janv. 2012 00:05:59 org.apache.jasper.compiler.AntCompiler generateClass FIN: Using classpath: /mnt/DSK2/tmp/tc/apache-tomcat-7.0.23/bin/bootstrap.jar:/mnt/DSK2/tmp/tc/apache-tomcat-7.0.23/bin/tomcat-juli.jar:/mnt/DSK2/tmp/tc/apache-tomcat-7.0.23/work/Catalina/localhost/_:/mnt/DSK2/tmp/tc/apache-tomcat-7.0.23/lib/:/mnt/DSK2/tmp/tc/apache-tomcat-7.0.23/lib/tools.jar:/mnt/DSK2/tmp/tc/apache-tomcat-7.0.23/lib/tomcat-dbcp.jar:/mnt/DSK2/tmp/tc/apache-tomcat-7.0.23/lib/tomcat-jdbc.jar:/mnt/DSK2/tmp/tc/apache-tomcat-7.0.23/lib/jasper-el.jar:/mnt/DSK2/tmp/tc/apache-tomcat-7.0.23/lib/ant.jar:/mnt/DSK2/tmp/tc/apache-tomcat-7.0.23/lib/tomcat-i18n-es.jar:/mnt/DSK2/tmp/tc/apache-tomcat-7.0.23/lib/ant-launcher.jar:/mnt/DSK2/tmp/tc/apache-tomcat-7.0.23/lib/annotations-api.jar:/mnt/DSK2/tmp/tc/apache-tomcat-7.0.23/lib/tomcat-util.jar:/mnt/DSK2/tmp/tc/apache-tomcat-7.0.23/lib/el-api.jar:/mnt/DSK2/tmp/tc/apache-tomcat-7.0.23/lib/tomcat-coyote.jar:/mnt/DSK2/tmp/tc/apache-tomcat-7.0.23/lib/jasper.jar:/mnt/DSK2/tmp/tc/apache-tomcat-7.0.23/lib/jsp-api.jar:/mnt/DSK2/tmp/tc/apache-tomcat-7.0.23/lib/servlet-api.jar:/mnt/DSK2/tmp/tc/apache-tomcat-7.0.23/lib/tomcat-i18n-ja.jar:/mnt/DSK2/tmp/tc/apache-tomcat-7.0.23/lib/tomcat-api.jar:/mnt/DSK2/tmp/tc/apache-tomcat-7.0.23/lib/catalina.jar:/mnt/DSK2/tmp/tc/apache-tomcat-7.0.23/lib/catalina-tribes.jar:/mnt/DSK2/tmp/tc/apache-tomcat-7.0.23/lib/tomcat-i18n-fr.jar:/mnt/DSK2/tmp/tc/apache-tomcat-7.0.23/lib/catalina-ant.jar:/mnt/DSK2/tmp/tc/apache-tomcat-7.0.23/lib/ecj-3.7.jar:/mnt/DSK2/tmp/tc/apache-tomcat-7.0.23/lib/catalina-ha.jar:/mnt/DSK2/tmp/tc/apache-tomcat-7.0.23/bin/bootstrap.jar:/mnt/DSK2/tmp/tc/apache-tomcat-7.0.23/bin/tomcat-juli.jar:/usr/lib/jvm/java-6-sun-1.6.0.26/jre/lib/ext/sunpkcs11.jar:/usr/lib/jvm/java-6-sun-1.6.0.26/jre/lib/ext/localedata.jar:/usr/lib/jvm/java-6-sun-1.6.0.26/jre/lib/ext/sunjce_provider.jar:/usr/lib/jvm/java-6-sun-1.6.0.26/jre/lib/ext/dnsns.jar 17 janv. 2012 00:06:00 org.apache.jasper.compiler.AntCompiler generateClass FIN: Compiled /mnt/DSK2/tmp/tc/apache-tomcat-7.0.23/work/Catalina/localhost/_/org/apache/jsp/index_jsp.java 1580ms =*= THE END =*=</column><column name="report_time">2012-01-18 00:28:00</column><column name="report_timestamp">1326860000</column><column name="status">resolved fixed</column><column name="commit">b553519</column><column name="commit_timestamp">1326890000</column><column name="files">java/org/apache/catalina/loader/WebappLoader.java</column><column name="result">187:java/org/apache/catalina/loader/WebappLoader.java</column></table><table name="tomcat"><column name="id">352</column><column name="bug_id">38216</column><column name="summary">Extend Jmxproxy to allow call of MBean Operations</column><column name="description">Currently one can only query Beans or set/get Attributes of them. It would be good if a certain operation of a MBean could be called by the Jmxproxy Servlet.</column><column name="report_time">2006-01-10 18:01:22</column><column name="report_timestamp">1136930000</column><column name="status">resolved fixed</column><column name="commit">bd478e5</column><column name="commit_timestamp">1326660000</column><column name="files">java/org/apache/catalina/manager/JMXProxyServlet.java</column><column name="result">27:java/org/apache/catalina/manager/JMXProxyServlet.java</column></table><table name="tomcat"><column name="id">353</column><column name="bug_id">52461</column><column name="summary">java.lang.IllegalArgumentException: URI scheme is not "file" is thrown in ContextConfig.getDefaultWebXmlFragment</column><column name="description">Hello, I have a project that embeds Apache Tomcat in OSGi. I provide the default web.xml from my bundles (jar files) directly; I do not provide it in a separate folder on the file system. I am using Apache Tomcat 7.0.21, but now I want to migrate to Apache Tomcat 7.0.23. Unfortunately there is a change between these two versions and with Apache Tomcat 7.0.23 the following exception is thrown: Caused by: java.lang.IllegalArgumentException: URI scheme is not "file" 	at java.io.File.&lt;init&gt;(File.java:366) 	at org.apache.catalina.startup.ContextConfig.getDefaultWebXmlFragment(ContextConfig.java:1317) 	at org.apache.catalina.startup.ContextConfig.webConfig(ContextConfig.java:1168) 	at org.apache.catalina.startup.ContextConfig.configureStart(ContextConfig.java:828) 	at org.apache.catalina.startup.ContextConfig.lifecycleEvent(ContextConfig.java:302) 	at org.apache.catalina.util.LifecycleSupport.fireLifecycleEvent(LifecycleSupport.java:119) 	at org.apache.catalina.util.LifecycleBase.fireLifecycleEvent(LifecycleBase.java:90) 	at org.apache.catalina.core.StandardContext.startInternal(StandardContext.java:5148) 	at org.apache.catalina.util.LifecycleBase.start(LifecycleBase.java:150) 	... 71 more| In OSGi environment URI scheme is not "file", but "bundleresource". The call "globalWebXml.getSystemId()" in OSGi environment returns "bundleresource://94.fwk2102834054/conf/web.xml" I would like to propose a change (below) in ContextConfig.getDefaultWebXmlFragment() method because there is no guarantee that the URI scheme will always be "file". The patch is made against 7.0.x trunc. Im looking forward to your comments. Best Regards Violeta Georgieva Patch proposal: Index: ContextConfig.java =================================================================== --- ContextConfig.java	(revision 1230565) +++ ContextConfig.java	(working copy) @@ -29,7 +29,6 @@ import java.io.UnsupportedEncodingException; import java.net.JarURLConnection; import java.net.MalformedURLException; -import java.net.URI; import java.net.URISyntaxException; import java.net.URL; import java.net.URLConnection; @@ -1324,20 +1323,24 @@ if (globalWebXml != null) { try { - File f = new File(new URI(globalWebXml.getSystemId())); - globalTimeStamp = f.lastModified(); - } catch (URISyntaxException e) { + URL f = new URL(globalWebXml.getSystemId()); + globalTimeStamp = f.openConnection().getLastModified(); + } catch (MalformedURLException e) { globalTimeStamp = -1; - } + } catch (IOException e) { + 	globalTimeStamp = -1; +			} } if (hostWebXml != null) { try { - File f = new File(new URI(hostWebXml.getSystemId())); - hostTimeStamp = f.lastModified(); - } catch (URISyntaxException e) { + URL f = new URL(hostWebXml.getSystemId()); + hostTimeStamp = f.openConnection().getLastModified(); + } catch (MalformedURLException e) { hostTimeStamp = -1; - } + } catch (IOException e) { + 	globalTimeStamp = -1; +			} } if (entry != null &amp;&amp; entry.getGlobalTimeStamp() == globalTimeStamp &amp;&amp;</column><column name="report_time">2012-01-12 20:34:28</column><column name="report_timestamp">1326420000</column><column name="status">resolved fixed</column><column name="commit">53615e5</column><column name="commit_timestamp">1326490000</column><column name="files">java/org/apache/catalina/startup/ContextConfig.java</column><column name="result">1:java/org/apache/catalina/startup/ContextConfig.java</column></table><table name="tomcat"><column name="id">354</column><column name="bug_id">52445</column><column name="summary">Methodexpression with arguments fails on nested properties</column><column name="description">This is basically an improvement of issue 50449 https://issues.apache.org/bugzilla/show_bug.cgi?id=50449 Invoking a method expression with arguments fails on nested properties. I.e. #{bean.submit('foo')} works, but #{bean.nested.submit('foo')} does not work. com.example.Bean: ------------------------------------------------------------------------------- package com.example; import javax.faces.bean.ManagedBean; import javax.faces.bean.RequestScoped; @ManagedBean @RequestScoped public class Bean { public void submit1() { System.out.println("Submit1 without argument"); } public void submit1(String argument) { System.out.println("Submit1 with argument " + argument); } public void submit2(String argument) { System.out.println("Submit2 with argument " + argument); } public Bean getNested() { return new Bean(); } } ------------------------------------------------------------------------------- test.xhtml ------------------------------------------------------------------------------- &lt;!DOCTYPE html&gt; &lt;html lang="en" xmlns="http://www.w3.org/1999/xhtml" xmlns:h="http://java.sun.com/jsf/html"&gt; &lt;h:head&gt; &lt;title&gt;Tomcat nested methodexpression test&lt;/title&gt; &lt;/h:head&gt; &lt;h:body&gt; &lt;h:form&gt; &lt;h:commandButton value="bean.submit1 without argument" action="#{bean.submit1()}" /&gt;&lt;br/&gt; &lt;h:commandButton value="bean.submit1 with argument" action="#{bean.submit1('foo')}" /&gt;&lt;br/&gt; &lt;h:commandButton value="bean.submit2 with argument" action="#{bean.submit2('bar')}" /&gt;&lt;br/&gt; &lt;h:commandButton value="bean.nested.submit1 without argument" action="#{bean.nested.submit1()}" /&gt;&lt;br/&gt; &lt;h:commandButton value="bean.nested.submit1 with argument" action="#{bean.nested.submit1('foo')}" /&gt;&lt;br/&gt; &lt;h:commandButton value="bean.nested.submit2 nested bean with argument" action="#{bean.nested.submit2('bar')}" /&gt;&lt;br/&gt; &lt;/h:form&gt; &lt;/h:body&gt; &lt;/html&gt; ------------------------------------------------------------------------------- Open the page and invoke the 6 buttons in sequence from top to bottom. The result is: ------------------------------------------------------------------------------- Submit1 without argument Submit1 with argument foo Submit2 with argument bar Submit1 without argument Submit1 without argument Jan 09, 2012 11:21:45 PM com.sun.faces.lifecycle.InvokeApplicationPhase execute WARNING: #{bean.nested.submit2('bar')}: javax.el.MethodNotFoundException: /test.xhtml @27,50 action="#{bean.nested.submit2('bar')}": Method not found: com.example.Bean@4f88bc88.submit2() javax.faces.FacesException: #{bean.nested.submit2('bar')}: javax.el.MethodNotFoundException: /test.xhtml @27,50 action="#{bean.nested.submit2('bar')}": Method not found: com.example.Bean@4f88bc88.submit2() 	at com.sun.faces.application.ActionListenerImpl.processAction(ActionListenerImpl.java:110) 	at javax.faces.component.UICommand.broadcast(UICommand.java:315) 	at javax.faces.component.UIViewRoot.broadcastEvents(UIViewRoot.java:794) 	at javax.faces.component.UIViewRoot.processApplication(UIViewRoot.java:1259) 	at com.sun.faces.lifecycle.InvokeApplicationPhase.execute(InvokeApplicationPhase.java:81) 	at com.sun.faces.lifecycle.Phase.doPhase(Phase.java:101) 	at com.sun.faces.lifecycle.LifecycleImpl.execute(LifecycleImpl.java:118) 	at javax.faces.webapp.FacesServlet.service(FacesServlet.java:593) 	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:305) 	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:210) 	at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:224) 	at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:169) 	at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:472) 	at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:168) 	at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:98) 	at org.apache.catalina.valves.AccessLogValve.invoke(AccessLogValve.java:928) 	at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:118) 	at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:407) 	at org.apache.coyote.http11.AbstractHttp11Processor.process(AbstractHttp11Processor.java:987) 	at org.apache.coyote.AbstractProtocol$AbstractConnectionHandler.process(AbstractProtocol.java:539) 	at org.apache.tomcat.util.net.JIoEndpoint$SocketProcessor.run(JIoEndpoint.java:300) 	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1110) 	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:603) 	at java.lang.Thread.run(Thread.java:722) Caused by: javax.faces.el.MethodNotFoundException: javax.el.MethodNotFoundException: /test.xhtml @27,50 action="#{bean.nested.submit2('bar')}": Method not found: com.example.Bean@4f88bc88.submit2() 	at javax.faces.component.MethodBindingMethodExpressionAdapter.invoke(MethodBindingMethodExpressionAdapter.java:92) 	at com.sun.faces.application.ActionListenerImpl.processAction(ActionListenerImpl.java:102) 	... 23 more Caused by: javax.el.MethodNotFoundException: /test.xhtml @27,50 action="#{bean.nested.submit2('bar')}": Method not found: com.example.Bean@4f88bc88.submit2() 	at com.sun.faces.facelets.el.TagMethodExpression.invoke(TagMethodExpression.java:109) 	at javax.faces.component.MethodBindingMethodExpressionAdapter.invoke(MethodBindingMethodExpressionAdapter.java:88) 	... 24 more ------------------------------------------------------------------------------- Note that the 5th button invokes the wrong method (the one without arguments) and that the 6th button throws an exception that the method cannot be found. It's basically looking for a method without arguments. This exception occurs regardless of if Mojarra or MyFaces is used. I tested with Mojarra 2.1.4 and MyFaces 2.1.3 on Tomcat 7.0.23.</column><column name="report_time">2012-01-10 03:25:21</column><column name="report_timestamp">1326180000</column><column name="status">resolved fixed</column><column name="commit">3c8f40f</column><column name="commit_timestamp">1326490000</column><column name="files">java/org/apache/el/parser/AstValue.java
test/org/apache/el/TestMethodExpressionImpl.java</column><column name="result">7:test/org/apache/el/TestMethodExpressionImpl.java
67:java/org/apache/el/parser/AstValue.java</column></table><table name="tomcat"><column name="id">355</column><column name="bug_id">52443</column><column name="summary">Tomcat#defaultRealm shares Realm instance between web applications, resulting in INFO log message from lifecycle</column><column name="description">Created attachment 28129 2012-01-09_trunk_TestTomcat_twoapps.patch Inspired by this thread on dev@: http://tomcat.markmail.org/thread/5qxa7gjsaav4ytcd "problem using default Realm in new unit tests" The problem is the following: 1. Tomcat.getDefaultRealm() is effectively a factory method for some Realm instance. It creates this Realm once and caches it as Tomcat#defaultRealm 2. Tomcat.addWebapp() method calls ctx.setRealm(defaultRealm); for every Context that it creates. Thus the Realm instance is shared between web applications. 3. When Context starts it calls start() method on the realm. When the above method was used to create several web applications then during the start of the second and later ones the following message is logged: 09.01.2012 19:19:29 org.apache.catalina.util.LifecycleBase start INFO: The start() method was called on component [Realm[Simple]] after start() had already been called. The second call will be ignored. To reproduce: 1) Apply attached patch to org.apache.catalina.startup.TestTomcat of trunk. 2) Run the test. 3) See the above "The start() method was called" message in the logs. I think there are several ways to resolve this: a) Do not call start() on the Realm if it is already started, as indicated by Lifecycle.getState() b) Change Tomcat class to do not share the Realm instance between Contexts. b.1) assign it to the Engine, or b.2) create a new instance every time. The a) way may lead to problems when the Context is stopped. It is not clear whether the Realm shall be stopped or not. It it is stopped it will affect another webapp. It may also cause problems with asynchronous start of contexts implemented in 7.0.23+. The b) way is consistent with what happens when server.xml is parsed.</column><column name="report_time">2012-01-09 16:43:35</column><column name="report_timestamp">1326150000</column><column name="status">resolved fixed</column><column name="commit">c38ed95</column><column name="commit_timestamp">1326400000</column><column name="files">java/org/apache/catalina/startup/Tomcat.java
test/org/apache/catalina/mbeans/TestRegistration.java</column><column name="result">1:java/org/apache/catalina/startup/Tomcat.java
235:test/org/apache/catalina/mbeans/TestRegistration.java</column></table><table name="tomcat"><column name="id">356</column><column name="bug_id">52245</column><column name="summary">Add detection of EL Jar to WebappClassLoader</column><column name="description">The EL API is not currently detected by the code in WebappClassLoader. Applications containing el-api.jar will not start. (patch to follow).</column><column name="report_time">2011-11-25 15:13:41</column><column name="report_timestamp">1322250000</column><column name="status">resolved fixed</column><column name="commit">ee2a461</column><column name="commit_timestamp">1326400000</column><column name="files">java/org/apache/catalina/loader/WebappClassLoader.java</column><column name="result">1:java/org/apache/catalina/loader/WebappClassLoader.java</column></table><table name="tomcat"><column name="id">357</column><column name="bug_id">52440</column><column name="summary">Wrong getValueReference behaviour with Facelets parameter expressions</column><column name="description">ValueExpression method getValueReference should return base object and property. But it returns null if ValueExpression is Facelets parameter. Example: someVar = #{concreteObject.property} ValueExpression for #{someVar} return null from method getValueReference (guess because it is simple expression #{someVar}), but logicaly it should return parent expressions ValueReference (need hierachical ValueReference lookup). I made workaround with Java Reflect API in my code and it illustrates problem: ELContext elContext = FacesContext.getCurrentInstance().getELContext(); ValueReference reference = exp.getValueReference(elContext); if (reference == null &amp;&amp; exp instanceof TagValueExpressionUEL) { 	ValueExpressionImpl origExp = (ValueExpressionImpl) ((TagValueExpressionUEL) exp).getWrapped(); 	// TODO: JR: find better way to get base and property. ! Code is not portable because uses Tomcat EL implementation details. ! 	Field field = ReflectionUtils.findField(origExp.getClass(), EL_IMPL_VAR_PROPERTY); 	field.setAccessible(true); 	VariableMapper varMapper = (VariableMapper) ReflectionUtils.getField(field, origExp); field = ReflectionUtils.findField(origExp.getClass(), EL_IMPL_NODE_PROPERTY); field.setAccessible(true); SimpleNode node = (SimpleNode) ReflectionUtils.getField(field, origExp); if (varMapper != null &amp;&amp; node != null) { 		ValueExpression parentExp = varMapper.resolveVariable(node.getImage()); if (parentExp != null) { 			try { 				reference = parentExp.getValueReference(elContext); if (reference == null) { 					reference = getValueReference(parentExp); } } catch (PropertyNotFoundException e) { 				LOG.warn("Property not found: " + e.getMessage()); } } } }</column><column name="report_time">2012-01-09 09:11:20</column><column name="report_timestamp">1326120000</column><column name="status">resolved fixed</column><column name="commit">f277b14</column><column name="commit_timestamp">1326400000</column><column name="files">java/org/apache/el/parser/AstIdentifier.java
test/org/apache/el/TestValueExpressionImpl.java</column><column name="result">4:java/org/apache/el/parser/AstIdentifier.java
29:test/org/apache/el/TestValueExpressionImpl.java</column></table><table name="tomcat"><column name="id">358</column><column name="bug_id">52328</column><column name="summary">Massive garbage production observed when using the response writer</column><column name="description">In our application we used to use Tomcat 5, by writing our content directly to the response writer in our servlet: Writer w = response.getWriter(); w.append(...) We have regularly measured performance of our application under stress with multiple simultaneous requests per second. We recently upgraded to Tomcat 7, and immediately observed a performance degradation of 10% on the request roundtrip on the same machine and the same tests, compared to our application deployed on Tomcat 5. Profiling with JProfiler showed that we got massive amount of transient objects {{java.nio.HeapCharBuffer}} produced - 400Mb+ within a few minutes. The way we are writing the response is by multiple statements of {{append}} of small strings or single chars, which used to work properly. For experiment, we wrapped the response writer with a {{BufferedWriter}} with a buffer of 64k. This brought our application's performance back to normal. We see this as either a: - anti-pattern usage since Tomcat 6/7, in which case please provide some documentation about that. - bug in the C2BConverter that is applied per every call to the CoyoteWriter write methods, which generates the garbage buffers per every call. We know that the response stream has a 8k buffer by default. Nevertheless, this buffer comes after the encoding step and as such it is too late to help with the garbage. Perhaps Tomcat can buffer before it encodes? Still, so much transient objects for just a pattern of eligible use of the servlet API seems a bug to me.</column><column name="report_time">2011-12-14 11:03:38</column><column name="report_timestamp">1323880000</column><column name="status">resolved fixed</column><column name="commit">9c7ec4c</column><column name="commit_timestamp">1326230000</column><column name="files">java/org/apache/catalina/connector/OutputBuffer.java</column><column name="result">6:java/org/apache/catalina/connector/OutputBuffer.java</column></table><table name="tomcat"><column name="id">359</column><column name="bug_id">52387</column><column name="summary">org.catalina.tomcat.startup.Tomcat#silence method doesn't use the host where we add the applications</column><column name="description">Created attachment 28100 This patch solves the issue This method calls "getHost" but it should get the host from the methods that call it because the host can be different.</column><column name="report_time">2011-12-27 01:48:16</column><column name="report_timestamp">1324970000</column><column name="status">resolved fixed</column><column name="commit">3787242</column><column name="commit_timestamp">1325330000</column><column name="files">java/org/apache/catalina/startup/Tomcat.java</column><column name="result">1:java/org/apache/catalina/startup/Tomcat.java</column></table><table name="tomcat"><column name="id">360</column><column name="bug_id">52326</column><column name="summary">Lower log level for failed class loading</column><column name="description">Reference: https://jira.springsource.org/browse/SPR-8894 Tomcat attempts to load classes when it searches for annotations. These class loading attempts when failed, should be silently ignored. If the application attempts to load the classes later, it will receive the actual error. However, when Tomcat prints out the stack trace of this class loading error, it gives the wrong signal. There is actually not anything wrong in the application itself, so a WARN as tomcat logs with a stack trace becomes misleading. The initial fix would be: ContextConfig.java to drop log level to debug in checkHandleTypes method Class&lt;?&gt; clazz = null; try { clazz = context.getLoader().getClassLoader().loadClass(className); } catch (NoClassDefFoundError e) { log.debug(sm.getString("contextConfig.invalidSciHandlesTypes", className), e); return; } catch (ClassNotFoundException e) { log.warn(sm.getString("contextConfig.invalidSciHandlesTypes", className), e); return; } catch (ClassFormatError e) { log.warn(sm.getString("contextConfig.invalidSciHandlesTypes", className), e); return; } catch (Throwable t) { ExceptionUtils.handleThrowable(t); log.warn(sm.getString("contextConfig.invalidSciHandlesTypes", className), t); return; } The better fix would be to achieve the same without classloading at all. Other containers do ignore any type of classloading errors during this sequence.</column><column name="report_time">2011-12-13 18:47:41</column><column name="report_timestamp">1323820000</column><column name="status">resolved fixed</column><column name="commit">addd522</column><column name="commit_timestamp">1325190000</column><column name="files">java/org/apache/catalina/startup/ContextConfig.java</column><column name="result">11:java/org/apache/catalina/startup/ContextConfig.java</column></table><table name="tomcat"><column name="id">361</column><column name="bug_id">52316</column><column name="summary">AccessLog does not log size for files sent with sendfile</column><column name="description">Confirming a problem reported on the users@ list. This affects both NIO and APR protocols when file is delivered with sendfile. Note, that the file have to be &gt;48kb to trigger use of sendfile. Steps to reproduce: 1) Configure three connectors: &lt;Connector port="8081" protocol="org.apache.coyote.http11.Http11Protocol" connectionTimeout="20000" redirectPort="8443" /&gt; &lt;Connector port="8082" protocol="org.apache.coyote.http11.Http11NioProtocol" connectionTimeout="20000" redirectPort="8443" /&gt; &lt;Connector port="8083" protocol="org.apache.coyote.http11.Http11AprProtocol" connectionTimeout="20000" redirectPort="8443" /&gt; and configure AccessLogValve in a &lt;Host&gt;: &lt;Valve className="org.apache.catalina.valves.AccessLogValve" directory="logs" prefix="localhost_access_log." suffix=".txt" pattern="%h %l %u %t &amp;quot;%r&amp;quot; %s %b (%D ms)" /&gt; The difference from common pattern is that I added "(%D ms)" at the end. 2) Put some big file (&gt;48k) as webapps/ROOT/file 3) Download it 3 times: http://localhost:8081/file?8081 http://localhost:8082/file?8082 http://localhost:8083/file?8083 4) Access Log: 127.0.0.1 - - [10/Dec/2011:01:05:08 +0300] "GET /file?8081 HTTP/1.1" 200 15027784 (4766 ms) 127.0.0.1 - - [10/Dec/2011:01:05:23 +0300] "GET /file?8082 HTTP/1.1" 200 - (31 ms) 127.0.0.1 - - [10/Dec/2011:01:05:48 +0300] "GET /file?8083 HTTP/1.1" 200 - (16 ms) Note that '-' is printed instead of file size for Nio and Apr connectors. Workarounds: ------------ A). Disable sendfile with useSendfile="false" on a connector B). Add the following pattern to AccessLogValve: "%{org.apache.tomcat.sendfile.start}r %{org.apache.tomcat.sendfile.end}r" That will log the range of bytes sent by sendfile. E.g.: 127.0.0.1 - - [10/Dec/2011:01:05:08 +0300] "GET /file?8081 HTTP/1.1" 200 15027784 (4766 ms) - - 127.0.0.1 - - [10/Dec/2011:01:05:23 +0300] "GET /file?8082 HTTP/1.1" 200 - (31 ms) 0 15027784 127.0.0.1 - - [10/Dec/2011:01:05:48 +0300] "GET /file?8083 HTTP/1.1" 200 - (16 ms) 0 15027784 -------------- Overall, looking at the timing value printed by %D I would say that logging occurs before data are sent. So the value of 0 bytes is correct. It could be possible to log file size from request attributes set by sendfile, but that cannot account for aborted downloads. Though I think that would be better than the current logging of '0'. At least this limitation can be mentioned in documentation for %b and %B patterns in AccessLogValve section in valve.html and in Javadoc.</column><column name="report_time">2011-12-09 22:23:47</column><column name="report_timestamp">1323490000</column><column name="status">resolved fixed</column><column name="commit">9f52382</column><column name="commit_timestamp">1325110000</column><column name="files">java/org/apache/catalina/valves/AccessLogValve.java</column><column name="result">2:java/org/apache/catalina/valves/AccessLogValve.java</column></table><table name="tomcat"><column name="id">362</column><column name="bug_id">52303</column><column name="summary">NonLoginAuthenticator does not honour session timeout with SingleSignOn Valve</column><column name="description">Created attachment 28052 proposed diff to fix org.apache.catalina.authenticator.NonLoginAuthenticator This problem has been explored and discussed on the tomcat-users mailing list under the title "SingleSignonValve and webapp session timeout". Basically, a webapp that does not need to define a &lt;login-config&gt; is valid under the servlet 3.0 spec and therefore should be able to participate in a single signon realm. It should be able to inherit the security principal established by another webapp within the same realm. Its own &lt;session-timeout&gt; value should be honoured, even when all the other sessions in the same SingleSignOnEntry have expired. The problem is with NonLoginAuthenticator - at some time it had SSO helper logic that was too primitive. This logic was completely commented-out in tomcat 6.0.0. I have two fairly simple webapps (not quite drop-ins) that demonstrate the problem and my proposed fix. I have heavily commented my proposed fix to explain the surrounding dependent logic that it relies on. At the moment I have not found an SSO-based unit test for any of the AuthenticatorBase concrete classes, but I will try to create one (eventually).</column><column name="report_time">2011-12-08 09:35:59</column><column name="report_timestamp">1323360000</column><column name="status">resolved fixed</column><column name="commit">8b6d341</column><column name="commit_timestamp">1325020000</column><column name="files">java/org/apache/catalina/authenticator/NonLoginAuthenticator.java</column><column name="result">1:java/org/apache/catalina/authenticator/NonLoginAuthenticator.java</column></table><table name="tomcat"><column name="id">363</column><column name="bug_id">52384</column><column name="summary">URL parameter without value should be parsed successfully when logging level = DEBUG</column><column name="description">Create a simple servlet with protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { request.getParameterMap(); } Start Tomcat under Eclipse, or force logging level for class org.apache.tomcat.util.http.Parameters to be "DEBUG" Call the servlet with parameter which has no value set, e.g. http://localhost:8080/mywebapp/myservlet?parameterWithotValue (so only the "parameterWithotValue" should be in the result of request.getParameterMap()) enjoy exception: java.lang.ArrayIndexOutOfBoundsException 	at java.lang.System.arraycopy(Native Method) 	at org.apache.tomcat.util.buf.ByteChunk.append(ByteChunk.java:334) 	at org.apache.tomcat.util.http.Parameters.processParameters(Parameters.java:347) 	at org.apache.tomcat.util.http.Parameters.processParameters(Parameters.java:425) 	at org.apache.tomcat.util.http.Parameters.handleQueryParameters(Parameters.java:189) 	at org.apache.catalina.connector.Request.parseParameters(Request.java:2993) 	at org.apache.catalina.connector.Request.getParameterNames(Request.java:1185) 	at org.apache.catalina.connector.Request.getParameterMap(Request.java:1164) 	at org.apache.catalina.connector.RequestFacade.getParameterMap(RequestFacade.java:444) 	at ru.agapemoda.servlet.ImageServlet.doGet(ImageServlet.java:47) ...................................................... 	at java.lang.Thread.run(Thread.java:662) Note: when logging level is "SEVERE", the troublesome code in org.apache.tomcat.util.http.Parameters.processParameters(Parameters.java:347) if (log.isDebugEnabled()) { try { origName.append(bytes, nameStart, nameEnd - nameStart); origValue.append(bytes, valueStart, valueEnd - valueStart); } catch (IOException ioe) { // Should never happen... log.error(sm.getString("parameters.copyFail"), ioe); } } is not executed and parameter is being parsed successfully. Should be parsed successfully with log level = "DEBUG" as well.</column><column name="report_time">2011-12-24 18:16:23</column><column name="report_timestamp">1324770000</column><column name="status">resolved fixed</column><column name="commit">34b011b</column><column name="commit_timestamp">1324860000</column><column name="files">java/org/apache/tomcat/util/http/Parameters.java</column><column name="result">2:java/org/apache/tomcat/util/http/Parameters.java</column></table><table name="tomcat"><column name="id">364</column><column name="bug_id">52356</column><column name="summary">Prevent potential data races on "org.apache.catalina.tribes.transport.bio.util.FastQueue.size".</column><column name="description">Even though accesses to "org.apache.catalina.tribes.transport.bio.util.FastQueue.size" are synchronized inside "org.apache.catalina.tribes.transport.bio.util.FastQueue.add(ChannelMessage, Member[], InterceptorPayload)" and "org.apache.catalina.tribes.transport.bio.util.FastQueue.remove()", the read access in "org.apache.catalina.tribes.transport.bio.util.FastQueue.getSize()" is not properly synchronized and thus can lead to a race condition. However, "org.apache.catalina.tribes.transport.bio.util.FastQueue.getSize()" is not used, so this bug never manifests. Nevertheless, we suggest that Tomcat developers either remove "org.apache.catalina.tribes.transport.bio.util.FastQueue.getSize()" or make it access the shared field safely. Field "org.apache.catalina.tribes.transport.bio.util.FastQueue.size" is declared at &lt;http://svn.apache.org/repos/asf/!svn/bc/1220560/tomcat/trunk/java/org/apache/catalina/tribes/transport/bio/util/FastQueue.java&gt;.</column><column name="report_time">2011-12-18 23:41:25</column><column name="report_timestamp">1324270000</column><column name="status">resolved fixed</column><column name="commit">6f3cafe</column><column name="commit_timestamp">1324680000</column><column name="files">java/org/apache/catalina/tribes/transport/bio/util/FastQueue.java</column><column name="result">1:java/org/apache/catalina/tribes/transport/bio/util/FastQueue.java</column></table><table name="tomcat"><column name="id">365</column><column name="bug_id">52354</column><column name="summary">Protect concurrent accesses to field "org.apache.catalina.tribes.transport.bio.util.FastQueue.inRemove"</column><column name="description">Field "org.apache.catalina.tribes.transport.bio.util.FastQueue.inRemove" may be read and written in parallel. Thus, accesses to it should be synchronized. The following is a sequence of method calls from the "run" method of a class that implements "Runnable" to a method that accesses "FastQueue.inRemove" without proper synchronization. 1. org.apache.catalina.tribes.group.interceptors.MessageDispatchInterceptor.run() 2. org.apache.catalina.tribes.group.interceptors.MessageDispatchInterceptor.removeFromQueue() 3. org.apache.catalina.tribes.transport.bio.util.FastQueue.remove() Field "FastQueue.inRemove" is declared at &lt;http://svn.apache.org/repos/asf/!svn/bc/1220560/tomcat/trunk/java/org/apache/catalina/tribes/transport/bio/util/FastQueue.java&gt;.</column><column name="report_time">2011-12-18 23:04:53</column><column name="report_timestamp">1324270000</column><column name="status">resolved fixed</column><column name="commit">8983419</column><column name="commit_timestamp">1324670000</column><column name="files">java/org/apache/catalina/tribes/transport/bio/util/FastQueue.java</column><column name="result">1:java/org/apache/catalina/tribes/transport/bio/util/FastQueue.java</column></table><table name="tomcat"><column name="id">366</column><column name="bug_id">52213</column><column name="summary">Field "org.apache.catalina.tribes.transport.bio.util.FastQueue.enabled" should be volatile.</column><column name="description">The boolean flag "org.apache.catalina.tribes.transport.bio.util.FastQueue.enabled" may be read/written by multiple threads concurrently (See &lt;http://svn.apache.org/repos/asf/!svn/bc/1203897/tomcat/trunk/java/org/apache/catalina/tribes/group/interceptors/MessageDispatchInterceptor.java&gt;). Therefore, accesses to it should be properly synchronized. It is sufficient to make this boolean flag volatile to protect access to it. See &lt;https://www.securecoding.cert.org/confluence/display/java/VNA00-J.+Ensure+visibility+when+accessing+shared+primitive+variables&gt; for more information about this bug pattern. Keshmesh (https://keshmesh.cs.illinois.edu/) is an Eclipse plugin that analyzes the source code of Java programs for common concurrency bug patterns. We used Keshmesh to detect this concurrency bug pattern.</column><column name="report_time">2011-11-18 23:29:32</column><column name="report_timestamp">1321680000</column><column name="status">resolved fixed</column><column name="commit">d69fb8e</column><column name="commit_timestamp">1324670000</column><column name="files">java/org/apache/catalina/tribes/transport/bio/util/FastQueue.java</column><column name="result">1:java/org/apache/catalina/tribes/transport/bio/util/FastQueue.java</column></table><table name="tomcat"><column name="id">367</column><column name="bug_id">52293</column><column name="summary">antiResourceLocking and unpackWARs</column><column name="description">Created attachment 28034 ContextConfig.java It appears that Tomcat is attempting to copy the WAR from the $CATALINA_HOME/webapps directory to the $CATALINA_HOME/temp directory without the .war extension (e.g., original docBase is $CATALINA_HOME/webapps/example.war and a new docBase of $CATALINA_HOME/temp/1-example ). I think that line 973 in ContextConfig.java method antiLocking never evaluates correctly because the docBase gets set to the value of path on line 969, which removes the .war extension so the file ends up being $CATALINA_HOME/temp/1-example instead of 1-example.war. Additionally, applications with sub-context paths (e.g., foo#bar.war) never get deployed to temp correctly with antiResourceLocking="true" regardless of the unpackWARs setting because of the above scenario and because the docBase gets set to the context path in the antiLocking method which converts the # separator to /. There appears to be a fix on line 882 of fixDocBase that converts the / character to # in the path but that doesn't make it to the antiLocking method. Both 6.0.35 and 7.0.23 exhibit the same behaviour. In 7.0.23, the docBase is changed back to the context path via the ContextName now instead of the context.getPath() but the result is the same. Interestingly enough, there is a comment in the 7.0.23 source on line 750 that suggests the code to copy the .war file is never reached and that it's possibly a bug. This code is never reached because the docBase is changed to the path without the .war extension.</column><column name="report_time">2011-12-06 18:54:27</column><column name="report_timestamp">1323220000</column><column name="status">resolved fixed</column><column name="commit">33e48db</column><column name="commit_timestamp">1324500000</column><column name="files">java/org/apache/catalina/startup/ContextConfig.java</column><column name="result">5:java/org/apache/catalina/startup/ContextConfig.java</column></table><table name="tomcat"><column name="id">368</column><column name="bug_id">52321</column><column name="summary">coda/prelude order not respected</column><column name="description">WebXml (http://svn.apache.org/repos/asf/tomcat/tc7.0.x/trunk/java/org/apache/catalina/deploy/WebXml.java) and in ApplicationJspConfigDescriptor (http://svn.apache.org/repos/asf/tomcat/tc7.0.x/trunk/java/org/apache/catalina/core/ApplicationJspConfigDescriptor.java) jspPropertyGroups are HashSet but this kind of set doesn't preserve the order in which elements are added. However it should be guaranteed to be spec compliant. Using a LinkedHashSet instead of the HashSet fixes this issues.</column><column name="report_time">2011-12-13 00:13:28</column><column name="report_timestamp">1323750000</column><column name="status">resolved fixed</column><column name="commit">22e7e15</column><column name="commit_timestamp">1323810000</column><column name="files">java/org/apache/catalina/core/ApplicationJspConfigDescriptor.java
java/org/apache/catalina/deploy/WebXml.java</column><column name="result">23:java/org/apache/catalina/deploy/WebXml.java</column></table><table name="tomcat"><column name="id">369</column><column name="bug_id">52208</column><column name="summary">NullPointerException in tribes.transport.nio.NioReceiver.listen() in test run</column><column name="description">Created attachment 27968 TEST-org.apache.catalina.tribes.group.interceptors.TestOrderInterceptor.BIO.txt Running tests for 7.0.23 release candidate I noted that there was a NullPointerException in one of tribes tests: TEST-org.apache.catalina.tribes.group.interceptors.TestOrderInterceptor.BIO.txt 18.11.2011 9:27:56 org.apache.catalina.tribes.transport.nio.NioReceiver listen SEVERE: Unable to process request in NioReceiver java.lang.NullPointerException 	at org.apache.catalina.tribes.transport.nio.NioReceiver.listen(NioReceiver.java:274) 	at org.apache.catalina.tribes.transport.nio.NioReceiver.run(NioReceiver.java:414) 	at java.lang.Thread.run(Thread.java:662) ------------- ---------------- --------------- The test case did not fail, so it likely occurred during tearDown. The line in source code is 268 while (doListen() &amp;&amp; selector != null) { (..) 272 events(); 273 socketTimeouts(); 274 int n = selector.select(getSelectorTimeout()); It is likely that selector field referenced on line 274 became null because of NioReceiver#stopListening() call. This issue was not observed on reruns. I am attaching complete log file from this test.</column><column name="report_time">2011-11-18 10:37:32</column><column name="report_timestamp">1321630000</column><column name="status">resolved fixed</column><column name="commit">9403e4f</column><column name="commit_timestamp">1323380000</column><column name="files">java/org/apache/catalina/tribes/transport/nio/NioReceiver.java</column><column name="result">1:java/org/apache/catalina/tribes/transport/nio/NioReceiver.java</column></table><table name="tomcat"><column name="id">370</column><column name="bug_id">52028</column><column name="summary">Embeded Tomcat using a Connector with a random port (port 0)</column><column name="description">New feature based on discussion: http://markmail.org/message/3nczqiqm6smez255</column><column name="report_time">2011-10-14 12:27:22</column><column name="report_timestamp">1318610000</column><column name="status">resolved fixed</column><column name="commit">63f708a</column><column name="commit_timestamp">1322520000</column><column name="files">java/org/apache/catalina/connector/Connector.java
java/org/apache/coyote/AbstractProtocol.java
java/org/apache/tomcat/util/net/AbstractEndpoint.java
java/org/apache/tomcat/util/net/AprEndpoint.java
java/org/apache/tomcat/util/net/JIoEndpoint.java
java/org/apache/tomcat/util/net/NioEndpoint.java
test/org/apache/catalina/authenticator/TestFormAuthenticator.java
test/org/apache/catalina/connector/TestConnector.java
test/org/apache/catalina/connector/TestRequest.java
test/org/apache/catalina/core/TestStandardContext.java
test/org/apache/catalina/core/TestSwallowAbortedUploads.java
test/org/apache/catalina/filters/TestExpiresFilter.java
test/org/apache/catalina/filters/TestRemoteIpFilter.java
test/org/apache/catalina/mbeans/TestRegistration.java
test/org/apache/catalina/servlets/TestDefaultServlet.java
test/org/apache/catalina/startup/SimpleHttpClient.java
test/org/apache/catalina/startup/TomcatBaseTest.java
test/org/apache/coyote/http11/TestAbstractHttp11Processor.java
test/org/apache/coyote/http11/TestInternalInputBuffer.java
test/org/apache/coyote/http11/filters/TestChunkedInputFilter.java
test/org/apache/tomcat/util/http/TestCookiesAllowEquals.java
test/org/apache/tomcat/util/http/TestCookiesAllowHttpSeps.java
test/org/apache/tomcat/util/http/TestCookiesAllowNameOnly.java
test/org/apache/tomcat/util/http/TestCookiesDisallowEquals.java
test/org/apache/tomcat/util/net/TestXxxEndpoint.java</column><column name="result">2:java/org/apache/catalina/connector/Connector.java
7:test/org/apache/catalina/startup/TomcatBaseTest.java
16:java/org/apache/tomcat/util/net/AbstractEndpoint.java
25:test/org/apache/catalina/mbeans/TestRegistration.java
35:test/org/apache/catalina/connector/TestConnector.java
57:java/org/apache/coyote/AbstractProtocol.java
80:test/org/apache/catalina/filters/TestExpiresFilter.java
95:test/org/apache/catalina/startup/SimpleHttpClient.java
108:test/org/apache/tomcat/util/net/TestXxxEndpoint.java
116:test/org/apache/catalina/core/TestStandardContext.java
120:test/org/apache/catalina/servlets/TestDefaultServlet.java
124:java/org/apache/tomcat/util/net/NioEndpoint.java
126:java/org/apache/tomcat/util/net/JIoEndpoint.java
144:test/org/apache/tomcat/util/http/TestCookiesDisallowEquals.java
149:test/org/apache/tomcat/util/http/TestCookiesAllowNameOnly.java
150:java/org/apache/tomcat/util/net/AprEndpoint.java
151:test/org/apache/tomcat/util/http/TestCookiesAllowHttpSeps.java
157:test/org/apache/tomcat/util/http/TestCookiesAllowEquals.java
167:test/org/apache/catalina/connector/TestRequest.java
216:test/org/apache/coyote/http11/filters/TestChunkedInputFilter.java
246:test/org/apache/catalina/filters/TestRemoteIpFilter.java
256:test/org/apache/coyote/http11/TestAbstractHttp11Processor.java
286:test/org/apache/coyote/http11/TestInternalInputBuffer.java
312:test/org/apache/catalina/core/TestSwallowAbortedUploads.java
401:test/org/apache/catalina/authenticator/TestFormAuthenticator.java</column></table><table name="tomcat"><column name="id">371</column><column name="bug_id">52225</column><column name="summary">Adding Alias for existing host on running Tomcat causes ClassCastException</column><column name="description">There is an error in the fix for Bug 42707 ("add host alias using jmx doesn't take affect until restart") In Mapper#addHostAlias(String name, String alias) the following line: newHost.object = realHost; should be replaced with the following one: newHost.object = realHost.object; That was r712467 (3 years ago). The issue affects current 5.5.x and 6.0.x as well. The issue manifests itself only if addAlias() is called on an existing Host in embedded scenario or through JMX. The usual workflow of configuring aliases in server.xml is not affected. The issue was reported on the dev@ list, http://tomcat.markmail.org/thread/sskxor4a3xtrjmk3 "Multiple Aliases Problem" Reproduction recipe #1, as reported on dev@: &lt;quote&gt; I created a Host instance with the localhost1 domain name. Host host = new StandardHost(); host.setAppBase(CATALINA_HOSTS_HOME); host.setName("localhost1"); host.setDeployOnStartup(false); host.setBackgroundProcessorDelay(5); host.setAutoDeploy(false); host.setRealm(engine.getRealm()); engine.addChild(host); Then I added the localhost2 as a alias. host.addAlias("localhost2"); If I entered localhost1 at a browser then it works fine but if I entered localhost2 at the browser then I got an error: Nov 21, 2011 1:29:26 PM org.apache.coyote.http11.AbstractHttp11Processor process SEVERE: Error processing request java.lang.ClassCastException: org.apache.tomcat.util.http.mapper.Mapper$Host cannot be cast to org.apache.catalina.Host at org.apache.catalina.connector.Request.getHost(Request.java:631) at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:105) &lt;/quote&gt; A workaround for the embedded scenario should be to reorder the calls as following: host.addAlias("localhost2"); engine.addChild(host); That will call Mapper.addHost(String name, String[] aliases, Object host) which processes aliases correctly. Reproduction recipe #2, using JMX: 1. In standard server.xml replace &lt;Engine defaultHost="localhost" with &lt;Engine defaultHost="foohost" &lt;Host name="localhost" with &lt;Host name="foohost" 2. Start Tomcat 3. Open http://localhost:8080/ It opens correctly 4. Start JConsole and connect to Tomcat 5. In Catalina -&gt; Host -&gt; foohost -&gt; Operations call addAlias(localhost) 6. Refresh http://localhost:8080/ Expected result: It opens correctly Actual result: - Blank page - Exception in the logs, [[[ 22.11.2011 10:08:41 org.apache.coyote.http11.AbstractHttp11Processor process SEVERE: Error processing request java.lang.ClassCastException: org.apache.tomcat.util.http.mapper.Mapper$Host can not be cast to org.apache.catalina.Host at org.apache.catalina.connector.Request.getHost(Request.java:623) at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineVal ve.java:77) ]]]</column><column name="report_time">2011-11-22 07:14:09</column><column name="report_timestamp">1321960000</column><column name="status">resolved fixed</column><column name="commit">f3a7cd9</column><column name="commit_timestamp">1321950000</column><column name="files">java/org/apache/tomcat/util/http/mapper/Mapper.java
test/org/apache/tomcat/util/http/mapper/TestMapper.java</column><column name="result">4:java/org/apache/tomcat/util/http/mapper/Mapper.java
133:test/org/apache/tomcat/util/http/mapper/TestMapper.java</column></table><table name="tomcat"><column name="id">372</column><column name="bug_id">52173</column><column name="summary">Add a drop of additional clarification to doc on the delegate setting of the WebappClassLoader</column><column name="description">Created attachment 27931 javadoc tweaks to WebappClassLoader There is a full description of the 'delegate' flag on the protected boolean member, but programmers using the class are likely to look to the setDelegate function for enlightenment. Further, the IMPLEMENTATION NOTE at the top does not mention the existence of the delegate flag. This patch tries to makes it harder to misunderstand, since the term 'delegate' has, to me at least, a bit of ambiguity to it.</column><column name="report_time">2011-11-13 14:59:57</column><column name="report_timestamp">1321210000</column><column name="status">resolved fixed</column><column name="commit">574af73</column><column name="commit_timestamp">1321310000</column><column name="files">java/org/apache/catalina/loader/WebappClassLoader.java</column><column name="result">1:java/org/apache/catalina/loader/WebappClassLoader.java</column></table><table name="tomcat"><column name="id">373</column><column name="bug_id">50570</column><column name="summary">Allow explicit use of FIPS mode in APR lifecycle listener</column><column name="description">Both OpenSSL and JSSE allow themselves to be put into FIPS mode, and we should allow SSL connectors to request it (and have them fail if FIPS mode can't be set). OpenSSL: http://www.mail-archive.com/openssl-dev@openssl.org/msg20882.html</column><column name="report_time">2011-01-11 12:27:44</column><column name="report_timestamp">1294770000</column><column name="status">resolved fixed</column><column name="commit">c2001ce</column><column name="commit_timestamp">1320870000</column><column name="files">java/org/apache/catalina/core/AprLifecycleListener.java
java/org/apache/tomcat/jni/SSL.java</column><column name="result">1:java/org/apache/catalina/core/AprLifecycleListener.java
123:java/org/apache/tomcat/jni/SSL.java</column></table><table name="tomcat"><column name="id">374</column><column name="bug_id">52156</column><column name="summary">ServletContext.getResource(path) doesn't accept ".." anymore</column><column name="description">With WAR-packaged webapp, getServletContext().getResource("/mydata/../mydata/myfile.txt") should return the same URL as getServletContext().getResource("/mydata/myfile.txt") but returns NULL instead. It's ok for folder-based webapp. It was working in Tomcat 6.0.20. It looks like Bug 10629 (WARDirContext.java regression?).</column><column name="report_time">2011-11-08 18:59:53</column><column name="report_timestamp">1320800000</column><column name="status">resolved fixed</column><column name="commit">b7f5c7e</column><column name="commit_timestamp">1320790000</column><column name="files">java/org/apache/catalina/core/ApplicationContext.java</column><column name="result">2:java/org/apache/catalina/core/ApplicationContext.java</column></table><table name="tomcat"><column name="id">375</column><column name="bug_id">52113</column><column name="summary">Tomcat reports missing context xml at wrong location on JMX deployment</column><column name="description">Hello, I'm using Tomcat JMX interface to deploy apps as follows: 1) call MBeanFactory#createStandardContext, where MBeanFactory is "Catalina:type=MBeanFactory", with parameters: parent = "Catalina:type=Host,host=localhost", path = "/w1", docBase = &lt;my path to the app&gt; 2) call &lt;my app&gt;#start, where &lt;my app&gt; is "Catalina:j2eeType=WebModule,name=//localhost/w1,J2EEApplication=none,J2EEServer=none" As result, my app _is succesfully deployed (its context is available)_, but nevertheless I see the following exceptions in the server console (full stacktraces are skipped, to be attached next comment): 31 ???? 2011 14:05:53 org.apache.catalina.startup.ContextConfig processContextConfig SEVERE: Missing context.xml: file:/C:/&lt;my Tomcat base folder&gt;/conf/Catalina/localhost/w1.xml java.io.FileNotFoundException: C:\&lt;my Tomcat base folder&gt;\conf\Catalina\localhost\w1.xml 31 ???? 2011 14:05:53 org.apache.catalina.startup.ContextConfig processContextConfig SEVERE: Parse error in context.xml for /w1 java.io.FileNotFoundException: C:\&lt;my Tomcat base folder&gt;\conf\Catalina\localhost\w1.xml 31 ???? 2011 14:05:53 org.apache.catalina.startup.ContextConfig configureStart SEVERE: Marking this application unavailable due to previous error(s) 31 ???? 2011 14:05:53 org.apache.catalina.core.StandardContext startInternal SEVERE: Error getConfigured 31 ???? 2011 14:05:53 org.apache.catalina.core.StandardContext startInternal SEVERE: Context [/w1] startup failed due to previous errors The exceptions looks strange to me, since I don't understand why Tomcat searches for a context xml file during the jmx deploy. Do I do something wrong in the deployment workflow? Regards, Michael</column><column name="report_time">2011-10-31 14:09:21</column><column name="report_timestamp">1320080000</column><column name="status">resolved fixed</column><column name="commit">d7af36d</column><column name="commit_timestamp">1320180000</column><column name="files">java/org/apache/catalina/mbeans/MBeanFactory.java</column><column name="result">1:java/org/apache/catalina/mbeans/MBeanFactory.java</column></table><table name="tomcat"><column name="id">376</column><column name="bug_id">52051</column><column name="summary">NullPointerException when Jasper tries to compile a directory</column><column name="description">Created attachment 27809 Sample webapp that demonstrates the problem. STR: 1. Map JspServlet to /jsp/* 2. Create a directory /jsp/dir 3. Make a request to /jsp/dir Result: org.apache.jasper.JasperException: File "/jsp/dir" not found 	org.apache.jasper.compiler.DefaultErrorHandler.jspError(DefaultErrorHandler.java:56) 	org.apache.jasper.compiler.ErrorDispatcher.dispatch(ErrorDispatcher.java:410) 	org.apache.jasper.compiler.ErrorDispatcher.jspError(ErrorDispatcher.java:117) 	org.apache.jasper.compiler.JspUtil.getInputStream(JspUtil.java:679) 	org.apache.jasper.xmlparser.XMLEncodingDetector.getEncoding(XMLEncodingDetector.java:109) 	org.apache.jasper.compiler.ParserController.determineSyntaxAndEncoding(ParserController.java:337) 	org.apache.jasper.compiler.ParserController.doParse(ParserController.java:190) 	org.apache.jasper.compiler.ParserController.parseDirectives(ParserController.java:119) 	org.apache.jasper.compiler.Compiler.generateJava(Compiler.java:193) 	org.apache.jasper.compiler.Compiler.compile(Compiler.java:373) 	org.apache.jasper.compiler.Compiler.compile(Compiler.java:353) 	org.apache.jasper.compiler.Compiler.compile(Compiler.java:340) 	org.apache.jasper.JspCompilationContext.compile(JspCompilationContext.java:644) 	org.apache.jasper.servlet.JspServletWrapper.service(JspServletWrapper.java:358) 	org.apache.jasper.servlet.JspServlet.serviceJspFile(JspServlet.java:389) 	org.apache.jasper.servlet.JspServlet.service(JspServlet.java:333) 	javax.servlet.http.HttpServlet.service(HttpServlet.java:722) Expected: 404 Not Found response</column><column name="report_time">2011-10-18 19:33:51</column><column name="report_timestamp">1318980000</column><column name="status">resolved fixed</column><column name="commit">62ff013</column><column name="commit_timestamp">1319040000</column><column name="files">java/org/apache/jasper/JspCompilationContext.java
java/org/apache/jasper/compiler/JspUtil.java</column><column name="result">15:java/org/apache/jasper/JspCompilationContext.java
56:java/org/apache/jasper/compiler/JspUtil.java</column></table><table name="tomcat"><column name="id">377</column><column name="bug_id">52009</column><column name="summary">NPE exception in org.apache.catalina.connector.CoyoteAdapter.service</column><column name="description">1. I copied activemq-all-5.4.2.jar, commons-logging-1.1.jar to tomcat lib folder 2. Edit tomcat-user.xml, context.xml, server.xml as below: Changes in server.xml: &lt;Resource name="jms/broker" auth="Container" type="org.apache.activemq.ActiveMQConnectionFactory" description="JMS Connection Factory" factory="org.apache.activemq.jndi.JNDIReferenceFactory" brokerURL="tcp://localhost:61616" brokerName="ActiveMQBroker" useEmbeddedBroker="false" /&gt; &lt;Resource name="jms/topic/MyTopic" auth="Container" type="org.apache.activemq.command.ActiveMQTopic" factory="org.apache.activemq.jndi.JNDIReferenceFactory" physicalName="APP.JMS.TOPIC" /&gt; &lt;Resource name="jms/queue/MyQueue" auth="Container" type="org.apache.activemq.command.ActiveMQQueue" factory="org.apache.activemq.jndi.JNDIReferenceFactory" physicalName="APP.JMS.QUEUE" /&gt; &lt;Connector acceptorThreadPriority="1" allowTrace="true" asyncTimeout="10000" connectionLinger="25" connectionTimeout="60000" name="NIOConnector" pollerThreadPriority="1" port="8888" protocol="org.apache.coyote.http11.Http11NioProtocol" redirectPort="8443" tcpNoDelay="false"/&gt; Changes in context.xml &lt;ResourceLink global="jms/broker" name="jms/broker" type="javax.jms.ConnectionFactory"/&gt; &lt;ResourceLink global="jms/topic/MyTopic" name="jms/topic/MyTopic" type="javax.jms.Topic"/&gt; &lt;ResourceLink global="jms/queue/MyQueue" name="jms/queue/MyQueue" type="javax.jms.Queue"/&gt; You can also get these file from attached zip Then access http://localhost:8080/manager/text/resources, got three JMS resource i defined OK - Listed global resources of all types jms/topic/MyTopic:org.apache.activemq.command.ActiveMQTopic jms/queue/MyQueue:org.apache.activemq.command.ActiveMQQueue jms/broker:org.apache.activemq.ActiveMQConnectionFactory UserDatabase:org.apache.catalina.users.MemoryUserDatabase 3. Start apache-activemq-5.4.2, create topic APP.JMS.TOPIC, and queque: APP.JMS.QUEUE 4. Put sample files QuoteStreamerApp.war as attached in webapp folder, then it will report errors, but if don't define NIO connector, this error doesn't exist 2011-10-11 15:53:01 org.apache.catalina.startup.HostConfig checkResources INFO: Undeploying context [/QuoteStreamerApp] 2011-10-11 15:53:11 org.apache.catalina.startup.HostConfig deployWAR INFO: Deploying web application archive QuoteStreamerApp.war 2011-10-11 15:53:52 com.ibm.websphere.webmsg.quotestreamer.AppInit init INFO: DataSimulator successfully created and set and started. 2011-10-11 15:54:01 com.ibm.webmsg.example.StockServlet setProperties INFO: Configured properties for quote streamer requests. 2011-10-11 15:54:02 com.ibm.webmsg.example.StockServlet registerURL INFO: Registered the URL for comet requests. 2011-10-11 15:54:02 org.apache.coyote.http11.AbstractHttp11Processor process SEVERE: Error processing request java.lang.NullPointerException 	at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:436) 	at org.apache.coyote.http11.AbstractHttp11Processor.process(AbstractHttp11Processor.java:970) 	at org.apache.coyote.AbstractProtocol$AbstractConnectionHandler.process(AbstractProtocol.java:515) 	at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.run(NioEndpoint.java:1550) 	at java.util.concurrent.ThreadPoolExecutor$Worker.runTask(ThreadPoolExecutor.java:886) 	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:908) 	at java.lang.Thread.run(Thread.java:662) 2011-10-11 15:54:02 org.apache.coyote.http11.AbstractHttp11Processor process SEVERE: Error processing request java.lang.NullPointerException 	at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:436) 	at org.apache.coyote.http11.AbstractHttp11Processor.process(AbstractHttp11Processor.java:970) 	at org.apache.coyote.AbstractProtocol$AbstractConnectionHandler.process(AbstractProtocol.java:515) 	at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.run(NioEndpoint.java:1550) 	at java.util.concurrent.ThreadPoolExecutor$Worker.runTask(ThreadPoolExecutor.java:886) 	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:908) 	at java.lang.Thread.run(Thread.java:662) 2011-10-11 15:54:04 org.apache.coyote.http11.AbstractHttp11Processor process SEVERE: Error processing request java.lang.NullPointerException 	at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:436) 	at org.apache.coyote.http11.AbstractHttp11Processor.process(AbstractHttp11Processor.java:970) 	at org.apache.coyote.AbstractProtocol$AbstractConnectionHandler.process(AbstractProtocol.java:515) 	at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.run(NioEndpoint.java:1550) 	at java.util.concurrent.ThreadPoolExecutor$Worker.runTask(ThreadPoolExecutor.java:886) 	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:908) 	at java.lang.Thread.run(Thread.java:662) 2011-10-11 15:54:04 org.apache.coyote.http11.AbstractHttp11Processor process SEVERE: Error processing request java.lang.NullPointerException 	at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:436) 	at org.apache.coyote.http11.AbstractHttp11Processor.process(AbstractHttp11Processor.java:970) 	at org.apache.coyote.AbstractProtocol$AbstractConnectionHandler.process(AbstractProtocol.java:515) 	at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.run(NioEndpoint.java:1550) 	at java.util.concurrent.ThreadPoolExecutor$Worker.runTask(ThreadPoolExecutor.java:886) 	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:908) 	at java.lang.Thread.run(Thread.java:662)</column><column name="report_time">2011-10-11 08:06:49</column><column name="report_timestamp">1318330000</column><column name="status">resolved fixed</column><column name="commit">b90c0a1</column><column name="commit_timestamp">1318630000</column><column name="files">java/org/apache/catalina/connector/CoyoteAdapter.java
test/org/apache/catalina/comet/TestCometProcessor.java</column><column name="result">1:java/org/apache/catalina/connector/CoyoteAdapter.java
312:test/org/apache/catalina/comet/TestCometProcessor.java</column></table><table name="tomcat"><column name="id">378</column><column name="bug_id">51972</column><column name="summary">sendRedirect does not support protocol relative URLs</column><column name="description">The following URL is a protocol relative URL: "//server.com:8080/foo/bar/kala.html" where as this is server relative: "/foo/bar/kala.html" org/apache/catalina/connector/Response.java breaks on protocol relative URLs in that toAbsolute(String) expects everything that begins with a '/' to be server relative. toAbsolute adds the protocol, server and port to the URL, resulting in URLs like http://foo.com:80//server.com:8080/foo/bar/kala.html (instead of the correct http://server.com:8080/foo/bar/kala.html)</column><column name="report_time">2011-10-05 21:31:50</column><column name="report_timestamp">1317860000</column><column name="status">resolved fixed</column><column name="commit">e70797e</column><column name="commit_timestamp">1318250000</column><column name="files">java/org/apache/catalina/connector/Response.java</column><column name="result">6:java/org/apache/catalina/connector/Response.java</column></table><table name="tomcat"><column name="id">379</column><column name="bug_id">51952</column><column name="summary">IllegalStateException using CompressionFilter with Tomcat 7.0.21/22</column><column name="description">Created attachment 27685 Simple test to recreate CompressionFilter causing IllegalStateException Using Tomcat 7.0.21 or 7.0.22 with jdk1.6.0_26 on Solaris 10, mod_ajp and Apache 2.2.21, we get the following logged exception when a sendRedirect is used in a jsp and the CompressionFilter is enabled. It does not occur using 7.0.20. I've attached a gzipped tar file containing a simple test that reproduces the problem. test.jsp just contains a sendRedirect to test2.jsp and I've included the source code for the CompressionFilter and a simple web.xml file with this filter's entry. Hitting test.jsp logs the exception below. SEVERE: Servlet.service() for servlet [jsp] in context with path [] threw exception [java.lang.IllegalStateException: getWriter() has already been called for this response] with root cause java.lang.IllegalStateException: getWriter() has already been called for this response at org.apache.catalina.connector.Response.getOutputStream(Response.java:594) at org.apache.catalina.connector.ResponseFacade.getOutputStream(ResponseFacade.java:199) at com.tirerack.filters.CompressionResponseStream.&lt;init&gt;(CompressionResponseStream.java:47) at com.tirerack.filters.CompressionServletResponseWrapper.createOutputStream(CompressionServletResponseWrapper.java:172) at com.tirerack.filters.CompressionServletResponseWrapper.getWriter(CompressionServletResponseWrapper.java:250) at org.apache.jasper.runtime.JspWriterImpl.initOut(JspWriterImpl.java:125) at org.apache.jasper.runtime.JspWriterImpl.flushBuffer(JspWriterImpl.java:118) at org.apache.jasper.runtime.PageContextImpl.release(PageContextImpl.java:190) at org.apache.jasper.runtime.JspFactoryImpl.internalReleasePageContext(JspFactoryImpl.java:123) at org.apache.jasper.runtime.JspFactoryImpl.releasePageContext(JspFactoryImpl.java:80) at org.apache.jsp.test_jsp._jspService(test_jsp.java:74) at org.apache.jasper.runtime.HttpJspBase.service(HttpJspBase.java:70) at javax.servlet.http.HttpServlet.service(HttpServlet.java:722) at org.apache.jasper.servlet.JspServletWrapper.service(JspServletWrapper.java:433) at org.apache.jasper.servlet.JspServlet.serviceJspFile(JspServlet.java:389) at org.apache.jasper.servlet.JspServlet.service(JspServlet.java:333) at javax.servlet.http.HttpServlet.service(HttpServlet.java:722) at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:304) at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:210) at com.tirerack.filters.CompressionFilter.doFilter(CompressionFilter.java:194) at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:243) at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:210) at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:224) at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:169) at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:472) at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:168) at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:100) at org.apache.catalina.valves.AccessLogValve.invoke(AccessLogValve.java:929) at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:118) at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:405) at org.apache.coyote.ajp.AjpProcessor.process(AjpProcessor.java:200) at org.apache.coyote.AbstractProtocol$AbstractConnectionHandler.process(AbstractProtocol.java:515) at org.apache.tomcat.util.net.JIoEndpoint$SocketProcessor.run(JIoEndpoint.java:302) at java.util.concurrent.ThreadPoolExecutor$Worker.runTask(ThreadPoolExecutor.java:886) at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:908) at java.lang.Thread.run(Thread.java:662)</column><column name="report_time">2011-10-04 15:36:57</column><column name="report_timestamp">1317760000</column><column name="status">resolved fixed</column><column name="commit">3ab3757</column><column name="commit_timestamp">1318020000</column><column name="files">java/org/apache/catalina/Context.java
java/org/apache/catalina/connector/Response.java
java/org/apache/catalina/core/StandardContext.java</column><column name="result">12:java/org/apache/catalina/core/StandardContext.java
20:java/org/apache/catalina/Context.java
25:java/org/apache/catalina/connector/Response.java</column></table><table name="tomcat"><column name="id">380</column><column name="bug_id">51956</column><column name="summary">RemoteAddrFilter uses remote host (not address) in doFilterEvent</column><column name="description">public void doFilterEvent(CometEvent event, CometFilterChain chain) throws IOException, ServletException { processCometEvent(event.getHttpServletRequest().getRemoteHost(), event, chain); } Use of getRemoteHost should be getRemoteAddr.</column><column name="report_time">2011-10-04 21:58:18</column><column name="report_timestamp">1317780000</column><column name="status">resolved fixed</column><column name="commit">d6d1c6f</column><column name="commit_timestamp">1317770000</column><column name="files">java/org/apache/catalina/filters/RemoteAddrFilter.java</column><column name="result">1:java/org/apache/catalina/filters/RemoteAddrFilter.java</column></table><table name="tomcat"><column name="id">381</column><column name="bug_id">51630</column><column name="summary">java.lang.IllegalStateException: Calling [asyncComplete()]</column><column name="description">example: webapps\examples\WEB-INF\classes\async\Async0.java log file: logs\localhost.2011-08-07.log ============================================= java.lang.IllegalStateException: Calling [asyncComplete()] is not valid for a request with Async state [DISPATCHED] 	at org.apache.coyote.AsyncStateMachine.asyncComplete(AsyncStateMachine.java:221) 	at org.apache.coyote.http11.Http11Processor.actionInternal(Http11Processor.java:525) 	at org.apache.coyote.http11.AbstractHttp11Processor.action(AbstractHttp11Processor.java:773) 	at org.apache.coyote.Request.action(Request.java:344) 	at org.apache.catalina.core.AsyncContextImpl.complete(AsyncContextImpl.java:89) 	at async.Async0.service(Async0.java:42) 	at javax.servlet.http.HttpServlet.service(HttpServlet.java:722) 	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:304) 	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:210) 	at org.apache.catalina.core.ApplicationDispatcher.invoke(ApplicationDispatcher.java:684) 	at org.apache.catalina.core.ApplicationDispatcher.doInclude(ApplicationDispatcher.java:593) 	at org.apache.catalina.core.ApplicationDispatcher.include(ApplicationDispatcher.java:530) 	at org.apache.catalina.core.AsyncContextImpl$1.run(AsyncContextImpl.java:173) 	at org.apache.catalina.core.AsyncContextImpl.doInternalDispatch(AsyncContextImpl.java:314) 	at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:219) 	at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:175) 	at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:462) 	at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:164) 	at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:100) 	at org.apache.catalina.valves.AccessLogValve.invoke(AccessLogValve.java:851) 	at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:118) 	at org.apache.catalina.connector.CoyoteAdapter.asyncDispatch(CoyoteAdapter.java:296) 	at org.apache.coyote.http11.AbstractHttp11Processor.asyncDispatch(AbstractHttp11Processor.java:1220) 	at org.apache.coyote.AbstractProtocol$AbstractConnectionHandler.process(AbstractProtocol.java:511) 	at org.apache.tomcat.util.net.JIoEndpoint$SocketProcessor.run(JIoEndpoint.java:302) 	at java.util.concurrent.ThreadPoolExecutor$Worker.runTask(ThreadPoolExecutor.java:886) 	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:908) 	at java.lang.Thread.run(Thread.java:619)</column><column name="report_time">2011-08-07 02:34:08</column><column name="report_timestamp">1312700000</column><column name="status">resolved fixed</column><column name="commit">b080c7e</column><column name="commit_timestamp">1317670000</column><column name="files">webapps/examples/WEB-INF/classes/async/Async0.java</column><column name="result">16:webapps/examples/WEB-INF/classes/async/Async0.java</column></table><table name="tomcat"><column name="id">382</column><column name="bug_id">51910</column><column name="summary">NPE in comet processing when shutting down Tomcat</column><column name="description">I've hit it when testing 7.0.22 RC. 1. Configure Tomcat with NIO connector 2. Start Tomcat and open Comet chat example http://localhost:8080/examples/jsp/chat/index.jsp 3. Type some Nickname and press button to start chat The chat log will be in the second frame at the lower half of the page. 4. While chat log is active (Browser shows page as being loaded), shut down Tomcat. 5. Observe NPE in the logs: 28.09.2011 15:55:32 org.apache.coyote.AbstractProtocol stop INFO: Stopping ProtocolHandler ["http-nio-8080"] 28.09.2011 15:55:33 org.apache.catalina.connector.CoyoteAdapter event SEVERE: null java.lang.NullPointerException at org.apache.catalina.core.StandardWrapperValve.event(StandardWrapperValve.java:354) at org.apache.catalina.core.StandardContextValve.event(StandardContextValve.java:192) at org.apache.catalina.valves.ValveBase.event(ValveBase.java:226) at org.apache.catalina.core.StandardHostValve.event(StandardHostValve.java:245) at org.apache.catalina.valves.ValveBase.event(ValveBase.java:226) at org.apache.catalina.valves.ValveBase.event(ValveBase.java:226) at org.apache.catalina.core.StandardEngineValve.event(StandardEngineValve.java:138) at org.apache.catalina.connector.CoyoteAdapter.event(CoyoteAdapter.java:211) at org.apache.coyote.http11.Http11NioProcessor.event(Http11NioProcessor.java:131) at org.apache.coyote.AbstractProtocol$AbstractConnectionHandler.process(AbstractProtocol.&gt; at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.run(NioEndpoint.java:1554) at org.apache.tomcat.util.net.NioEndpoint.processSocket(NioEndpoint.java:717) at org.apache.tomcat.util.net.NioEndpoint$Poller.cancelledKey(NioEndpoint.java:1026) at org.apache.tomcat.util.net.NioEndpoint$Poller.processKey(NioEndpoint.java:1169) at org.apache.tomcat.util.net.NioEndpoint$Poller.timeout(NioEndpoint.java:1352) at org.apache.tomcat.util.net.NioEndpoint$Poller.run(NioEndpoint.java:1085) at java.lang.Thread.run(Thread.java:662) 28.09.2011 15:55:33 org.apache.coyote.AbstractProtocol stop INFO: Stopping ProtocolHandler ["ajp-bio-8009"]</column><column name="report_time">2011-09-28 12:05:19</column><column name="report_timestamp">1317230000</column><column name="status">resolved fixed</column><column name="commit">a450d2c</column><column name="commit_timestamp">1317480000</column><column name="files">java/org/apache/catalina/core/StandardWrapperValve.java</column><column name="result">112:java/org/apache/catalina/core/StandardWrapperValve.java</column></table><table name="tomcat"><column name="id">383</column><column name="bug_id">51905</column><column name="summary">Infinite loop when shutting down AprEndpoint</column><column name="description">If unlocking the acceptor during AprEndpoint shutdown fails, it enters an infinite loop, printing endpoint.warn.unlockAcceptorFailed message (Acceptor thread [{0}] failed to unlock. Forcing hard socket shutdown.) It was reported on users@ mailing lists, http://tomcat.markmail.org/thread/xo2jolyr44ijuu34 It might be caused by a firewall preventing Tomcat from connecting to its own HTTP port. I can reproduce it if I turn the unlockAccept() method in endpoint into an noop (e.g. by adding "if(true){ return; }"), both in 6.0 and in trunk. In 6.0 this bug was introduced in r1065945 and affects 6.0.32 and 6.0.33.</column><column name="report_time">2011-09-28 09:20:16</column><column name="report_timestamp">1317220000</column><column name="status">resolved fixed</column><column name="commit">136097e</column><column name="commit_timestamp">1317200000</column><column name="files">java/org/apache/tomcat/util/net/AprEndpoint.java</column><column name="result">1:java/org/apache/tomcat/util/net/AprEndpoint.java</column></table><table name="tomcat"><column name="id">384</column><column name="bug_id">51872</column><column name="summary">request.getRemoteAddr() sometimes returning IP address from the previous request</column><column name="description">request.getRemoteAddr() sometimes returning IP address from the previous request. We have compared the IP address returned from the getRemoteHost() and from the headers with getRemoteAddr() and getRemoteAddr is returning wrong IP address. We believe that this may come from the "pooled" request objects where it is sometimes sees the previous value of the remote IP. The problem doesn't occur all the time. We are heavily relying on the getRemoteAddr to verify the remote client for some of our authentication. Can this be fixed? 2011-09-22 16:49:55,713 DEBUG [yjava.tomcat.valves.YahooConnectionValve] THREADID:1262 YahooConnectionValve invoked 2011-09-22 16:49:55,826 DEBUG [yjava.tomcat.valves.YahooConnectionValve] THREADID:1262 YahooConnectionValve request.getInfo(): org.apache.coyote.catalina.CoyoteRequest/1.0 2011-09-22 16:49:56,013 DEBUG [yjava.tomcat.valves.YahooConnectionValve] THREADID:1262 YahooConnectionValve request.getRemoteAddr(): 98.138.85.230 2011-09-22 16:49:56,014 DEBUG [yjava.tomcat.valves.YahooConnectionValve] THREADID:1262 YahooConnectionValve request.getRemoteHost(): web120016.mail.ne1.yahoo.com [][~]$ nslookup web120016.mail.ne1.yahoo.com Server: 10.72.226.8 Address: 10.72.226.8#53 Name: web120016.mail.ne1.yahoo.com Address: 98.138.85.143 2011-09-22 16:49:56,014 DEBUG [yjava.tomcat.valves.YahooConnectionValve] THREADID:1262 YahooConnectionValve request.getRequestedSessionId(): null 2011-09-22 16:49:56,015 DEBUG [yjava.tomcat.valves.YahooConnectionValve] THREADID:1262 YahooConnectionValve request.getHeader(): accept:*/* host:ls100.mail.vip.ne1.yahoo.com:4080 content-type:application/x-ypy yahoo-app-auth:v=1;a=yahoo.mail.acl.yca.lsg-prod;h=98.138.85.143;t=1319282225; content-length:574 2011-09-22 16:49:56,015 DEBUG [yjava.filter.address.RemoteIPTranslator] THREADID:1262 Got remote address '98.138.85.230' and port '46663'</column><column name="report_time">2011-09-22 17:52:57</column><column name="report_timestamp">1316730000</column><column name="status">resolved fixed</column><column name="commit">18792f4</column><column name="commit_timestamp">1317150000</column><column name="files">java/org/apache/catalina/connector/CoyoteAdapter.java
java/org/apache/coyote/ajp/AbstractAjpProcessor.java
java/org/apache/coyote/ajp/AjpAprProcessor.java
java/org/apache/coyote/ajp/AjpNioProcessor.java
java/org/apache/coyote/ajp/AjpProcessor.java
java/org/apache/coyote/http11/AbstractHttp11Processor.java</column><column name="result">39:java/org/apache/catalina/connector/CoyoteAdapter.java
86:java/org/apache/coyote/http11/AbstractHttp11Processor.java
123:java/org/apache/coyote/ajp/AbstractAjpProcessor.java
163:java/org/apache/coyote/ajp/AjpProcessor.java
168:java/org/apache/coyote/ajp/AjpAprProcessor.java
313:java/org/apache/coyote/ajp/AjpNioProcessor.java</column></table><table name="tomcat"><column name="id">385</column><column name="bug_id">51887</column><column name="summary">Speedup sessionid generation when running testsuite</column><column name="description">Created attachment 27581 2011-09-24_tc8_DummySecureRandom.patch When I run the Tomcat tests on Windows, I see a lot of following messages in the logs: [junit] 24.09.2011 17:23:56 org.apache.catalina.util.SessionIdGenerator createSecureRandom [junit] INFO: Creation of SecureRandom instance for session ID generation using [SHA1PRNG] took [5,019] milliseconds. It is OK whan starting a single Tomcat instance, but when running tests it adds 5 seconds to each startup of Tomcat. I am attaching patch that 1) Adds new DummySecureRandom class. 2) Hardcodes SessionIdGenerator to use this class. The SessionIdGenerator part of the patch cannot be committed as is.</column><column name="report_time">2011-09-24 14:09:54</column><column name="report_timestamp">1316890000</column><column name="status">resolved fixed</column><column name="commit">73a6e56</column><column name="commit_timestamp">1316880000</column><column name="files">test/org/apache/catalina/startup/FastNonSecureRandom.java
test/org/apache/catalina/startup/TomcatBaseTest.java</column><column name="result">113:test/org/apache/catalina/startup/TomcatBaseTest.java</column></table><table name="tomcat"><column name="id">386</column><column name="bug_id">51860</column><column name="summary">HTTP/SSL with NIO won't work</column><column name="description">Error reproduction conditions: Tomcat 7.0.20 and 21. Connector="...Http11NioProtocol" SSLEnabled="true" secure="true" scheme="https" clientAuth=true or false JDK 1.6.0_27 X64. All operation systems. When user connects to https://, the SSL handshake fails with error: javax.net.ssl.SSLHandshakeException: no cipher suites in common If we have same connector settings, but if we change it to BIO: Connector="...Http11Protocol", everything works fine. The problem cause is a differences in SSL behavior between BIO and NIO handshake. I've found the workaround here: http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6448723 See the org.apache.tomcat.util.net.jsse.JSSESocketFactory. JSSEKeyManager wraps the KeyManager. In NIO mode, the KeyManager should have two extra methods: public java.lang.String chooseEngineClientAlias(java.lang.String[] keyType, java.security.Principal[] issuers, javax.net.ssl.SSLEngine engine); public java.lang.String chooseEngineServerAlias(java.lang.String keyType, java.security.Principal[] issuers, javax.net.ssl.SSLEngine engine); We use a custom hand-made SSLInmplemention with extra features: * Keypair storage on hardware device or database * ExtendedKeyUsage verification in TrustManager * CRL validation on CRL distribution point online synchronization * ActiveDirectory account lookup by certificate The complete source code of workaround: package ru.yamoney.calypso.server.security.jsse; import org.apache.tomcat.util.net.AbstractEndpoint; import org.apache.tomcat.util.net.jsse.JSSESocketFactory; import ru.yamoney.calypso.server.CommonKernel; import javax.net.ssl.*; import java.net.Socket; import java.security.KeyStore; import java.security.Principal; import java.security.PrivateKey; import java.security.cert.X509Certificate; /** * SSLImplementation for Tomcat-7-NIO * * @author Roman Tsirulnikov */ final class CalypsoSSLSocketFactory extends JSSESocketFactory { private final CalypsoKeyManager keyManager; private final X509TrustManager trustManager; public CalypsoSSLSocketFactory(AbstractEndpoint endpoint) { super(endpoint); keyManager = CommonKernel.getInstance().getBean("server_calypsoKeyManager"); trustManager = CommonKernel.getInstance().getBean("server_calypsoTrustManager"); } @Override public KeyManager[] getKeyManagers() { try { KeyStore ks = keyManager.getKeyStore(); if (!ks.isKeyEntry(keyManager.getKeyAlias())) { throw new IllegalArgumentException("Keystore entry is not a private keypair: " + keyManager.getKeyAlias()); } KeyManagerFactory kmf = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm()); kmf.init(ks, keyManager.getKeystorePass().toCharArray()); KeyManager[] kms = kmf.getKeyManagers(); for (int i = 0; i &lt; kms.length; i++) { kms[i] = new NIOKeyManagerWrapper((X509KeyManager) kms[i], keyManager.getKeyAlias()); } return kms; } catch (Exception e) { throw new IllegalArgumentException("SSLSocketFactory init: " + e.getMessage(), e); } } @Override public TrustManager[] getTrustManagers() { return new TrustManager[]{trustManager}; } /** * X509KeyManager wrapper * Workaround for the SSL-NIO engine bug http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6448723 */ private final class NIOKeyManagerWrapper extends X509ExtendedKeyManager { private X509KeyManager delegate; private String serverKeyAlias; /** * Constructor. * * @param mgr The X509KeyManager used as a delegate * @param serverKeyAlias The alias name of the server's keypair and * supporting certificate chain */ NIOKeyManagerWrapper(X509KeyManager mgr, String serverKeyAlias) { super(); this.delegate = mgr; this.serverKeyAlias = serverKeyAlias; } /** * Choose an alias to authenticate the client side of a secure socket, * given the public key type and the list of certificate issuer authorities * recognized by the peer (if any). * * @param keyType The key algorithm type name(s), ordered with the * most-preferred key type first * @param issuers The list of acceptable CA issuer subject names, or null * if it does not matter which issuers are used * @param socket The socket to be used for this connection. This parameter * can be null, in which case this method will return the most generic * alias to use * @return The alias name for the desired key, or null if there are no * matches */ @Override public String chooseClientAlias(String[] keyType, Principal[] issuers, Socket socket) { return delegate.chooseClientAlias(keyType, issuers, socket); } /** * Returns this key manager's server key alias that was provided in the * constructor. * * @param keyType The key algorithm type name (ignored) * @param issuers The list of acceptable CA issuer subject names, or null * if it does not matter which issuers are used (ignored) * @param socket The socket to be used for this connection. This parameter * can be null, in which case this method will return the most generic * alias to use (ignored) * @return Alias name for the desired key */ @Override public String chooseServerAlias(String keyType, Principal[] issuers, Socket socket) { return serverKeyAlias; } /** * Returns the certificate chain associated with the given alias. * * @param alias The alias name * @return Certificate chain (ordered with the user's certificate first * and the root certificate authority last), or null if the alias can't be * found */ @Override public X509Certificate[] getCertificateChain(String alias) { return delegate.getCertificateChain(alias); } /** * Get the matching aliases for authenticating the client side of a secure * socket, given the public key type and the list of certificate issuer * authorities recognized by the peer (if any). * * @param keyType The key algorithm type name * @param issuers The list of acceptable CA issuer subject names, or null * if it does not matter which issuers are used * @return Array of the matching alias names, or null if there were no * matches */ @Override public String[] getClientAliases(String keyType, Principal[] issuers) { return delegate.getClientAliases(keyType, issuers); } /** * Get the matching aliases for authenticating the server side of a secure * socket, given the public key type and the list of certificate issuer * authorities recognized by the peer (if any). * * @param keyType The key algorithm type name * @param issuers The list of acceptable CA issuer subject names, or null * if it does not matter which issuers are used * @return Array of the matching alias names, or null if there were no * matches */ @Override public String[] getServerAliases(String keyType, Principal[] issuers) { return delegate.getServerAliases(keyType, issuers); } /** * Returns the key associated with the given alias. * * @param alias The alias name * @return The requested key, or null if the alias can't be found */ @Override public PrivateKey getPrivateKey(String alias) { return delegate.getPrivateKey(alias); } public java.lang.String chooseEngineClientAlias(java.lang.String[] keyType, java.security.Principal[] issuers, javax.net.ssl.SSLEngine engine) { return delegate.chooseClientAlias(keyType, issuers, null); } public java.lang.String chooseEngineServerAlias(java.lang.String keyType, java.security.Principal[] issuers, javax.net.ssl.SSLEngine engine) { return serverKeyAlias; } } }</column><column name="report_time">2011-09-21 10:03:38</column><column name="report_timestamp">1316610000</column><column name="status">resolved fixed</column><column name="commit">66f2d5b</column><column name="commit_timestamp">1316610000</column><column name="files">java/org/apache/tomcat/util/net/jsse/JSSEKeyManager.java</column><column name="result">201:java/org/apache/tomcat/util/net/jsse/JSSEKeyManager.java</column></table><table name="tomcat"><column name="id">387</column><column name="bug_id">51852</column><column name="summary">BeanELResolver varargs handling is broken in multiple ways</column><column name="description">The supplied patch (against SVN Revision 1173292) addresses: - Incorrectly constructed varargs arguments (resulting in ArrayIndexOutOfBoundsExceptions) - Incorrectly detected matching varargs methods I originally encountered the first issue in my JSF application using the JUEL EL implementation in conjunction with Tomcat's EL API. However I continue to get the error even when dropping JUEL from the application, so I'm not sure why in some instances the Jasper implementation seems to handle the varargs invocations and in others the BeanELResolver is invoked. In any event, code that already resides in BeanELResolver should certainly function properly, and mixing a given ExpressionFactory implementation with any conforming API implementation should AFAICT be feasible. The second issue I encountered while debugging the first issue.</column><column name="report_time">2011-09-20 19:16:07</column><column name="report_timestamp">1316560000</column><column name="status">resolved fixed</column><column name="commit">bfabec5</column><column name="commit_timestamp">1316610000</column><column name="files">java/javax/el/BeanELResolver.java
test/javax/el/TestBeanELResolverVarargsInvocation.java</column><column name="result">1:java/javax/el/BeanELResolver.java</column></table><table name="tomcat"><column name="id">388</column><column name="bug_id">51580</column><column name="summary">Severe error deploying WAR application (ExpandWar error)</column><column name="description">Created attachment 27330 Catalina log file with the error. When trying to deploy a WAR application (50MB approx) I get: "SEVERE: Error deploying web application archive gestaoApolices.war java.lang.NullPointerException" Complete stacktrace is attached. I've seen in the sources that this might be related with the correction of "Bugzilla 33636" Let me know if the war file is needed, in case you're not able to reproduce the problem.</column><column name="report_time">2011-07-28 22:41:57</column><column name="report_timestamp">1311910000</column><column name="status">resolved fixed</column><column name="commit">feff880</column><column name="commit_timestamp">1316550000</column><column name="files">java/org/apache/catalina/startup/ExpandWar.java</column><column name="result">1:java/org/apache/catalina/startup/ExpandWar.java</column></table><table name="tomcat"><column name="id">389</column><column name="bug_id">51687</column><column name="summary">Improve JreMemoryLeakPreventionListener against leak caused by sun.java2d.Disposer</column><column name="description">The sun.java2d.Disposer class, when loaded, starts an endless daemon thread that can inherit the WebappClassLoader as its context loader. This will cause a leak when the webapp is unloaded. It would be useful if JreMemoryLeakPreventionListener could load this class to prevent the leak.</column><column name="report_time">2011-08-19 14:41:36</column><column name="report_timestamp">1313780000</column><column name="status">resolved fixed</column><column name="commit">423fd89</column><column name="commit_timestamp">1316550000</column><column name="files">java/org/apache/catalina/core/JreMemoryLeakPreventionListener.java</column><column name="result">1:java/org/apache/catalina/core/JreMemoryLeakPreventionListener.java</column></table><table name="tomcat"><column name="id">390</column><column name="bug_id">51811</column><column name="summary">SSL configuration property name illegal</column><column name="description">server.xml configuration file. Connector properties. org.apache.coyote.http11.Http11NioProtocol property set: sslImplementationName="ru.yamoney.calypso.server.security.jsse.CalypsoSSLImplementation" Causes an error during catalina startup: [2011-09-14 18:42:16.299] [main WARN commons.digester.Digester] - [SetAllPropertiesRule]{Server/Service/Connector} Setting property 'sslImplementationName' to 'ru.yamoney.calypso.server.security.jsse.CalypsoSSLImplementation' did not find a matching property. According documentation: http://tomcat.apache.org/tomcat-7.0-doc/config/http.html#SSL%20Support the property name is: sslImplementationName see the source code: org.apache.coyote.http11.AbstractHttp11JsseProtocol line 107: public String getSslImplemenationName() { return sslImplemenationName; } public void setSslImplemenationName(String s) { this.sslImplemenationName = s; } As you see, the property name is misspelled ("sslImplemenation"). When I set the connector property as: sslImplemenationName="ru.yamoney.calypso.server.security.jsse.CalypsoSSLImplementation" the catalina starts fine. Versions affected: 7.0.20 and 7.0.21</column><column name="report_time">2011-09-14 14:57:22</column><column name="report_timestamp">1316030000</column><column name="status">resolved fixed</column><column name="commit">9425437</column><column name="commit_timestamp">1316350000</column><column name="files">java/org/apache/coyote/http11/AbstractHttp11JsseProtocol.java
test/org/apache/tomcat/util/net/TestCustomSsl.java</column><column name="result">25:java/org/apache/coyote/http11/AbstractHttp11JsseProtocol.java
43:test/org/apache/tomcat/util/net/TestCustomSsl.java</column></table><table name="tomcat"><column name="id">391</column><column name="bug_id">51794</column><column name="summary">Race condition in NioEndpoint$Poller causes socket to not be read until selectorTimeout</column><column name="description">I'm seeing an occasional race condition that happens between NioEndpoint$Poller#run and Http11NioProtocol finishing an event. What happens is that there is a race condition upon waking up the Selector that can cause a SelectionKey to not be marked with InterestOps.READ as soon as it could. The race is on Poller.wakeupCounter. These steps can occur which causes my SelectionKey to not have its interest ops reset soon and the Selector to not have wakeup() called on it. 1. Poller0 - Starts processing its run loop and calls events(). 2. Poller0 - Checks the wakeupCounter.get() &gt; 0 which evaluates to false (wakeupCounter is 0). 3. Worker1 - Finishes an event and calls in to Poller#addEvent 4. Worker1 - Enqueues the PollerEvent that will reset the interest ops. 5. Worker1 - Calls wakeupCounter.incrementAndGet to increment and get wakeupCounter to 1. This fails the check to call selector.wakeup(); 6. Poller0 - Calls wakeupCounter.set(-1) 7. Poller0 - Calls selector.select(selectorTimeout) and blocks for either the full time out or until another unrelated SelectionKey is polled. 8. Poller0 - Ultimately gets around to calling events() again which now resets the interest ops for the SelectionKey that was processed by Worker1. The simple fix for this is to change this code: if (wakeupCounter.get() &gt; 0) { //if we are here, means we have other stuff to do //do a non blocking select keyCount = selector.selectNow(); } else { wakeupCounter.set(-1); keyCount = selector.select(selectorTimeout); } to this if (wakeupCounter.getAndSet(-1) &gt; 0) { //if we are here, means we have other stuff to do //do a non blocking select keyCount = selector.selectNow(); } else { keyCount = selector.select(selectorTimeout); }</column><column name="report_time">2011-09-09 18:51:35</column><column name="report_timestamp">1315610000</column><column name="status">resolved fixed</column><column name="commit">58429a8</column><column name="commit_timestamp">1316010000</column><column name="files">java/org/apache/tomcat/util/net/NioEndpoint.java</column><column name="result">1:java/org/apache/tomcat/util/net/NioEndpoint.java</column></table><table name="tomcat"><column name="id">392</column><column name="bug_id">51698</column><column name="summary">ajp CPing/Forward-Request packet forgery, is a design decision? or a security vulnerability?</column><column name="description">Created attachment 27416 ajp CPing packet forgery example because the ajp "Data" packet no "CodeType" and tomcat adopts lazy-reading strategy for reading ajp "Data" packet (i.e., if you don't invoke request.getParameter("XXX")tomcat does't read post request "Data" packet) sothe current "Data" packet keeping in the socket inputstream the connection is keep-alive, ajp bio/nio procesor reading the next packet this time, is "Data" packet if the first byte of "Data" packet'length is 0x02(Code Type of Forward Request Packet) or 0x0A(Code Type of CPing Packet) then tomcat will be in trouble. please see the attachments. firt example: ajp CPing packet forgery example second example: ajp Forward-Request packet forgery</column><column name="report_time">2011-08-20 07:54:08</column><column name="report_timestamp">1313840000</column><column name="status">resolved fixed</column><column name="commit">a2538ce</column><column name="commit_timestamp">1314650000</column><column name="files">java/org/apache/coyote/ajp/AbstractAjpProcessor.java
java/org/apache/coyote/ajp/AjpAprProcessor.java
java/org/apache/coyote/ajp/AjpNioProcessor.java
java/org/apache/coyote/ajp/AjpProcessor.java</column><column name="result">3:java/org/apache/coyote/ajp/AbstractAjpProcessor.java
7:java/org/apache/coyote/ajp/AjpProcessor.java
9:java/org/apache/coyote/ajp/AjpAprProcessor.java
32:java/org/apache/coyote/ajp/AjpNioProcessor.java</column></table><table name="tomcat"><column name="id">393</column><column name="bug_id">51739</column><column name="summary">If landingpage is a XHTML (JSF/CDI), nullpointer exception.</column><column name="description" /><column name="report_time">2011-08-29 13:47:09</column><column name="report_timestamp">1314640000</column><column name="status">resolved fixed</column><column name="commit">3513acc</column><column name="commit_timestamp">1314640000</column><column name="files">java/org/apache/catalina/authenticator/FormAuthenticator.java</column><column name="result">1:java/org/apache/catalina/authenticator/FormAuthenticator.java</column></table><table name="tomcat"><column name="id">394</column><column name="bug_id">51712</column><column name="summary">Regression in cache-control headers for requests with security-constraints</column><column name="description">Created attachment 27428 Patch to revert isSecure() check Copied from http://markmail.org/thread/rlkpd3hqihc3zbji CLN 1126273 http://svn.apache.org/viewvc?view=revision&amp;revision=1126273 sets the default value for securePagesWithPragma to false, but also (re)added a request.isSecure() check to the block for adding the cache-control headers. This results in the headers not being added for secure requests with security-constraints. This is a change in behavior from Tomcat-7.0.14 that causes IE8 to improperly cache some secure pages. The secure check was initially added in CLN 287690 http://svn.apache.org/viewvc?view=revision&amp;revision=287690 to fix a bug in IE caching https://issues.apache.org/bugzilla/show_bug.cgi?id=6641 but was commented out in CLN 302373 http://svn.apache.org/viewvc?view=revision&amp;revision=302373 patch to remove isSecure() check added.</column><column name="report_time">2011-08-23 20:55:25</column><column name="report_timestamp">1314150000</column><column name="status">resolved fixed</column><column name="commit">196a8f5</column><column name="commit_timestamp">1314630000</column><column name="files">java/org/apache/catalina/authenticator/AuthenticatorBase.java</column><column name="result">7:java/org/apache/catalina/authenticator/AuthenticatorBase.java</column></table><table name="tomcat"><column name="id">395</column><column name="bug_id">51736</column><column name="summary">Make rpcTimeout configurable in BackupManager.</column><column name="description">Default rpcTimeout that BackupManager sets to AbstractReplicatedMap is 15000 msec. This is not configurable. When receiving MapMessage.MSG_START (and after a new member is added), publishEntryInfo is called for all sessions where primary and backup node are not included. And, the backup node is set to the session. When only one Tomcat starts in cluster, publishEntryInfo will be called for all sessions. As a result, the RPC message has the possibility of the timeout. When acquiring session from restarting Tomcat, warning of "Unable to retrieve remote object for key:XXX" is logged. And the session cannot be continued. I make rpcTimeout configurable in BackupManager. Additionally, if RPC message timeouted in AbstractReplicatedMap#broadcast, add warning message. Best Regards.</column><column name="report_time">2011-08-29 10:26:09</column><column name="report_timestamp">1314630000</column><column name="status">resolved fixed</column><column name="commit">87a32d6</column><column name="commit_timestamp">1314610000</column><column name="files">java/org/apache/catalina/ha/session/BackupManager.java
java/org/apache/catalina/tribes/tipis/AbstractReplicatedMap.java</column><column name="result">1:java/org/apache/catalina/tribes/tipis/AbstractReplicatedMap.java
2:java/org/apache/catalina/ha/session/BackupManager.java</column></table><table name="tomcat"><column name="id">396</column><column name="bug_id">51704</column><column name="summary">Dubious use of mkdirs() return code in juli FileHandler</column><column name="description">File#mkdirs() only returns true if the method created the directory itself. If mkdirs() returns false, it is still possible for the directory to exist. Thus the code in FileHandler at [1], i.e. 364 // Create the directory if necessary 365 	File dir = new File(directory); 366 	if (!dir.exists() &amp;&amp; !dir.mkdirs()) { 367 	 reportError("Unable to create [" + dir + "]", null, 368 	 ErrorManager.OPEN_FAILURE); 369 	 writer = null; 370 	 return; 371 	} can generate an error even though the directory now exists. It would be safer to code the check as follows: 366 	if (!dir.mkdirs() &amp;&amp; !dir.exists()) { There is no need to call dir.exists() before mkdirs() as mkdirs() does that anyway. There is similar code at [2] and possibly elsewhere in Tomcat, I did not check. [1] http://svn.apache.org/viewvc/tomcat/trunk/java/org/apache/juli/FileHandler.java?view=markup#l364 [1] http://svn.apache.org/viewvc/tomcat/trunk/java/org/apache/juli/FileHandler.java?view=markup#l379</column><column name="report_time">2011-08-22 13:17:27</column><column name="report_timestamp">1314030000</column><column name="status">resolved fixed</column><column name="commit">4587f13</column><column name="commit_timestamp">1314380000</column><column name="files">java/org/apache/catalina/core/StandardContext.java
java/org/apache/catalina/loader/WebappClassLoader.java
java/org/apache/catalina/loader/WebappLoader.java
java/org/apache/catalina/manager/ManagerServlet.java
java/org/apache/catalina/manager/host/HostManagerServlet.java
java/org/apache/catalina/servlets/CGIServlet.java
java/org/apache/catalina/session/FileStore.java
java/org/apache/catalina/startup/ExpandWar.java
java/org/apache/catalina/startup/HostConfig.java
java/org/apache/catalina/valves/AccessLogValve.java
java/org/apache/jasper/JspCompilationContext.java
java/org/apache/juli/FileHandler.java
test/org/apache/catalina/connector/TestCoyoteAdapter.java
test/org/apache/catalina/core/TestAsyncContextImpl.java
test/org/apache/catalina/core/TestStandardContext.java
test/org/apache/catalina/servlets/TestDefaultServlet.java
test/org/apache/catalina/startup/TomcatBaseTest.java</column><column name="result">1:java/org/apache/juli/FileHandler.java
12:java/org/apache/jasper/JspCompilationContext.java
14:java/org/apache/catalina/core/StandardContext.java
17:java/org/apache/catalina/manager/ManagerServlet.java
19:java/org/apache/catalina/session/FileStore.java
24:java/org/apache/catalina/loader/WebappLoader.java
27:java/org/apache/catalina/startup/HostConfig.java
29:java/org/apache/catalina/valves/AccessLogValve.java
37:java/org/apache/catalina/manager/host/HostManagerServlet.java
39:java/org/apache/catalina/loader/WebappClassLoader.java
68:test/org/apache/catalina/startup/TomcatBaseTest.java
77:java/org/apache/catalina/startup/ExpandWar.java
103:test/org/apache/catalina/connector/TestCoyoteAdapter.java
131:test/org/apache/catalina/core/TestStandardContext.java
134:test/org/apache/catalina/core/TestAsyncContextImpl.java
143:java/org/apache/catalina/servlets/CGIServlet.java
155:test/org/apache/catalina/servlets/TestDefaultServlet.java</column></table><table name="tomcat"><column name="id">397</column><column name="bug_id">51558</column><column name="summary">Tomcat Embedded: using tomcat.addWebapp always overrides programmatic context-settings with default values for the context at start of tomcat server</column><column name="description">when i deploy an webapp with a tomcat server, i use the Function "tomcat.addWebapp". I looked into the code of this function and it makes the following call: ctx.addLifecycleListener(new DefaultWebXmlListener()); When i start tomcat, this DefaultWebXmlListener is activated automatically, and always does the following code, so the manager i set for my context gets overriden with this code: public static void initWebappDefaults(Context ctx) { ... // Sessions ctx.setManager( new StandardManager()); ctx.setSessionTimeout(30); ... } so when i set a StandardManager programatically, it gets overriden by this code. The workaround i used, is to unregister the DefaultWebXmlListener, and than add my own context.xml specific settings, like a custom manager for deactivating session persistance: Context warContext = tomcat.addWebapp(warContextPath, warLocation); LifecycleListener[] lclisteners = warContext.findLifecycleListeners(); LifecycleListener defaultWebXMLListener = null; for (int i=0; i &lt; lclisteners.length; i++){ if (lclisteners[i] instanceof DefaultWebXmlListener){ defaultWebXMLListener = lclisteners[i]; } } warContext.removeLifecycleListener(defaultWebXMLListener); ... StandardManager manager = new StandardManager(); manager.setPathname(null); // disable session persistance: //manager.setPathname("SESSIONS.ser"); warContext.setCookies(true); warContext.setCrossContext(true); warContext.setManager(manager); i think its a bug that using the "tomcat.addWebapp" method makes it impossible to set context.xml specific settings programmatically, because they always get overriden by default values at the tomcat start.</column><column name="report_time">2011-07-26 10:11:48</column><column name="report_timestamp">1311690000</column><column name="status">resolved fixed</column><column name="commit">25f02b4</column><column name="commit_timestamp">1314370000</column><column name="files">java/org/apache/catalina/startup/Tomcat.java
test/org/apache/catalina/startup/TestTomcat.java</column><column name="result">1:java/org/apache/catalina/startup/Tomcat.java
43:test/org/apache/catalina/startup/TestTomcat.java</column></table><table name="tomcat"><column name="id">398</column><column name="bug_id">51713</column><column name="summary">Bad Connector protocol causes NullPointerException when using Executor</column><column name="description">Under the following configuration, an NPE is thrown because _setExecutor() calls con.getProtocolHandler().getClass() when the protocol handler is null. It would be nice to report a bad configuration instead of suffering an NPE. server.xml: &lt;Executor name="tomcatThreadPool" namePrefix="catalina-exec-" maxThreads="150" minSpareThreads="4"/&gt; &lt;Connector port="12345" redirectPort="443" protocol="HTTP" secure="true" scheme="https" proxyPort="80" URIEncoding="UTF-8" executor="tomcatThreadPool" /&gt; catalina.out: Aug 23, 2011 5:18:30 PM org.apache.catalina.connector.Connector &lt;init&gt; SEVERE: Protocol handler instantiation failed Aug 23, 2011 5:18:30 PM org.apache.tomcat.util.digester.Digester startElement SEVERE: Begin event threw exception java.lang.NullPointerException at org.apache.catalina.startup.ConnectorCreateRule._setExecutor(ConnectorCreateRule.java:69) at org.apache.catalina.startup.ConnectorCreateRule.begin(ConnectorCreateRule.java:63) at org.apache.tomcat.util.digester.Digester.startElement(Digester.java:1276) at com.sun.org.apache.xerces.internal.parsers.AbstractSAXParser.startElement(AbstractSAXParser.java:501) at com.sun.org.apache.xerces.internal.parsers.AbstractXMLDocumentParser.emptyElement(AbstractXMLDocumentParser.java:179) at com.sun.org.apache.xerces.internal.impl.XMLDocumentFragmentScannerImpl.scanStartElement(XMLDocumentFragmentScannerImpl.java:1343) at com.sun.org.apache.xerces.internal.impl.XMLDocumentFragmentScannerImpl$FragmentContentDriver.next(XMLDocumentFragmentScannerImpl.java:2755) at com.sun.org.apache.xerces.internal.impl.XMLDocumentScannerImpl.next(XMLDocumentScannerImpl.java:648) at com.sun.org.apache.xerces.internal.impl.XMLDocumentFragmentScannerImpl.scanDocument(XMLDocumentFragmentScannerImpl.java:511) at com.sun.org.apache.xerces.internal.parsers.XML11Configuration.parse(XML11Configuration.java:808) at com.sun.org.apache.xerces.internal.parsers.XML11Configuration.parse(XML11Configuration.java:737) at com.sun.org.apache.xerces.internal.parsers.XMLParser.parse(XMLParser.java:119) at com.sun.org.apache.xerces.internal.parsers.AbstractSAXParser.parse(AbstractSAXParser.java:1205) at com.sun.org.apache.xerces.internal.jaxp.SAXParserImpl$JAXPSAXParser.parse(SAXParserImpl.java:522) at org.apache.tomcat.util.digester.Digester.parse(Digester.java:1537) at org.apache.catalina.startup.Catalina.load(Catalina.java:555) at org.apache.catalina.startup.Catalina.load(Catalina.java:596) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25) at java.lang.reflect.Method.invoke(Method.java:597) at org.apache.catalina.startup.Bootstrap.load(Bootstrap.java:281) at org.apache.catalina.startup.Bootstrap.main(Bootstrap.java:449) Aug 23, 2011 5:18:30 PM org.apache.catalina.startup.Catalina load WARNING: Catalina.start using conf/server.xml: Error at (104, 66) : null Aug 23, 2011 5:18:30 PM org.apache.catalina.connector.Connector &lt;init&gt; SEVERE: Protocol handler instantiation failed Aug 23, 2011 5:18:30 PM org.apache.tomcat.util.digester.Digester startElement SEVERE: Begin event threw exception java.lang.NullPointerException at org.apache.catalina.startup.ConnectorCreateRule._setExecutor(ConnectorCreateRule.java:69) at org.apache.catalina.startup.ConnectorCreateRule.begin(ConnectorCreateRule.java:63) at org.apache.tomcat.util.digester.Digester.startElement(Digester.java:1276) at com.sun.org.apache.xerces.internal.parsers.AbstractSAXParser.startElement(AbstractSAXParser.java:501) at com.sun.org.apache.xerces.internal.parsers.AbstractXMLDocumentParser.emptyElement(AbstractXMLDocumentParser.java:179) at com.sun.org.apache.xerces.internal.impl.XMLDocumentFragmentScannerImpl.scanStartElement(XMLDocumentFragmentScannerImpl.java:1343) at com.sun.org.apache.xerces.internal.impl.XMLDocumentFragmentScannerImpl$FragmentContentDriver.next(XMLDocumentFragmentScannerImpl.java:2755) at com.sun.org.apache.xerces.internal.impl.XMLDocumentScannerImpl.next(XMLDocumentScannerImpl.java:648) at com.sun.org.apache.xerces.internal.impl.XMLDocumentFragmentScannerImpl.scanDocument(XMLDocumentFragmentScannerImpl.java:511) at com.sun.org.apache.xerces.internal.parsers.XML11Configuration.parse(XML11Configuration.java:808) at com.sun.org.apache.xerces.internal.parsers.XML11Configuration.parse(XML11Configuration.java:737) at com.sun.org.apache.xerces.internal.parsers.XMLParser.parse(XMLParser.java:119) at com.sun.org.apache.xerces.internal.parsers.AbstractSAXParser.parse(AbstractSAXParser.java:1205) at com.sun.org.apache.xerces.internal.jaxp.SAXParserImpl$JAXPSAXParser.parse(SAXParserImpl.java:522) at org.apache.tomcat.util.digester.Digester.parse(Digester.java:1537) at org.apache.catalina.startup.Catalina.load(Catalina.java:555) at org.apache.catalina.startup.Catalina.start(Catalina.java:609) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25) at java.lang.reflect.Method.invoke(Method.java:597) at org.apache.catalina.startup.Bootstrap.start(Bootstrap.java:322) at org.apache.catalina.startup.Bootstrap.main(Bootstrap.java:450) Aug 23, 2011 5:18:31 PM org.apache.catalina.startup.Catalina load WARNING: Catalina.start using conf/server.xml: Error at (104, 66) : null Aug 23, 2011 5:18:31 PM org.apache.catalina.startup.Catalina start SEVERE: Cannot start server. Server instance is not configured.</column><column name="report_time">2011-08-23 21:44:53</column><column name="report_timestamp">1314150000</column><column name="status">resolved fixed</column><column name="commit">517fd9b</column><column name="commit_timestamp">1314230000</column><column name="files">java/org/apache/catalina/connector/Connector.java</column><column name="result">1:java/org/apache/catalina/connector/Connector.java</column></table><table name="tomcat"><column name="id">399</column><column name="bug_id">51688</column><column name="summary">JreMemoryLeakPreventionListener should protect against AWT thread creation</column><column name="description">Any webapp that calls java.awt.Toolkit.getDefaultToolkit will launch a new thread (AWT-Windows, AWT-XAWT, etc.) which will capture the ContextClassLoader, pinning the webapp in memory after an undeploy/redeploy. A simple addition to JreMemoryLeakPreventionListener can alleviate this condition.</column><column name="report_time">2011-08-19 14:49:17</column><column name="report_timestamp">1313780000</column><column name="status">resolved fixed</column><column name="commit">0cdbfa6</column><column name="commit_timestamp">1314220000</column><column name="files">java/org/apache/catalina/core/JreMemoryLeakPreventionListener.java</column><column name="result">1:java/org/apache/catalina/core/JreMemoryLeakPreventionListener.java</column></table><table name="tomcat"><column name="id">400</column><column name="bug_id">49683</column><column name="summary">Separate keep-alive and connection timeout with APR/native connector</column><column name="description">Originally observed as part of bug 48648. If a keepAliveTimeout is specified it is used for connectionTimeout as well. Fixing this may require changes to the native code too.</column><column name="report_time">2010-08-01 15:40:53</column><column name="report_timestamp">1280690000</column><column name="status">resolved fixed</column><column name="commit">bf4a544</column><column name="commit_timestamp">1313520000</column><column name="files">java/org/apache/coyote/ajp/AjpAprProtocol.java
java/org/apache/coyote/http11/Http11AprProtocol.java
java/org/apache/tomcat/util/net/AprEndpoint.java</column><column name="result">1:java/org/apache/tomcat/util/net/AprEndpoint.java
19:java/org/apache/coyote/ajp/AjpAprProtocol.java
43:java/org/apache/coyote/http11/Http11AprProtocol.java</column></table><table name="tomcat"><column name="id">401</column><column name="bug_id">51658</column><column name="summary">Potential NPE in CoyoteAdapter.log</column><column name="description">Created attachment 27384 logAccess on host instead of context In CoyoteAdapter.log:501 request.mapping.context is known to be null and request.mapping.host is checked to be not null, but inside that if branch in line 503 request.mapping.context will be used. I think it should be "((Host) request.mappingData.host).logAccess(..." instead.</column><column name="report_time">2011-08-13 11:10:19</column><column name="report_timestamp">1313250000</column><column name="status">resolved fixed</column><column name="commit">5d55842</column><column name="commit_timestamp">1313480000</column><column name="files">java/org/apache/catalina/connector/CoyoteAdapter.java</column><column name="result">1:java/org/apache/catalina/connector/CoyoteAdapter.java</column></table><table name="tomcat"><column name="id">402</column><column name="bug_id">51654</column><column name="summary">NullPointerException in startup (org.apache.catalina.startup.HostConfig.filterAppPaths) due to missing app base</column><column name="description">A hard-to-diagnose NullPointerException at startup which can be bettered with an appropriate error message: INFO: Starting Servlet Engine: Apache Tomcat/7.0.19 java.lang.NullPointerException at org.apache.catalina.startup.HostConfig.filterAppPaths(HostConfig.java:493) at org.apache.catalina.startup.HostConfig.deployApps(HostConfig.java:466) at org.apache.catalina.startup.HostConfig.start(HostConfig.java:1322) at org.apache.catalina.startup.HostConfig.lifecycleEvent(HostConfig.java:311) at org.apache.catalina.util.LifecycleSupport.fireLifecycleEvent(LifecycleSupport.java:119) at org.apache.catalina.util.LifecycleBase.fireLifecycleEvent(LifecycleBase.java:89) Ok, what's this about? In "protected String[] filterAppPaths(String[] unfilteredAppPaths)" the exception is raised at for (String appPath : unfilteredAppPaths) Which means the "unfilteredAppPaths" passed in is null. filterAppPaths does not check for that (shouldn't there be an assertion at least) The problems comes from "deployApps()": protected void deployApps() { File appBase = appBase(); File configBase = configBase(); String[] filteredAppPaths = filterAppPaths(appBase.list()); &lt;---- // Deploy XML descriptors from configBase deployDescriptors(configBase, configBase.list()); // Deploy WARs, and loop if additional descriptors are found deployWARs(appBase, filteredAppPaths); // Deploy expanded folders deployDirectories(appBase, filteredAppPaths); } Where "appBase.list()" returns null. This must be because "appBase" does not actually denote a directory (A-HA!) Indeed, the server.xml points to a nonexisting appBase. Suggesting to add a check to "deployApps": protected void deployApps() { File appBase = appBase(); File configBase = configBase(); if (!appBase.exists() || appBase.list()==null) { throw new IllegalArgumentException("The appBase " + appBase + " does not exist or cannot be listed"); } String[] filteredAppPaths = filterAppPaths(appBase.list()); &lt;---- // Deploy XML descriptors from configBase deployDescriptors(configBase, configBase.list()); // Deploy WARs, and loop if additional descriptors are found deployWARs(appBase, filteredAppPaths); // Deploy expanded folders deployDirectories(appBase, filteredAppPaths); } This probably violates some I18N requirement though.</column><column name="report_time">2011-08-12 10:36:54</column><column name="report_timestamp">1313160000</column><column name="status">resolved fixed</column><column name="commit">c4d1631</column><column name="commit_timestamp">1313430000</column><column name="files">java/org/apache/catalina/startup/HostConfig.java</column><column name="result">1:java/org/apache/catalina/startup/HostConfig.java</column></table><table name="tomcat"><column name="id">403</column><column name="bug_id">51650</column><column name="summary">possible nullpointer exception in RequestUtil.parseParameters</column><column name="description">Created attachment 27376 set default encoding, if none is given When encoding is null, RequestUtil.parseParameters will throw a NPE at B2CConverter.getCharset.</column><column name="report_time">2011-08-11 17:03:48</column><column name="report_timestamp">1313100000</column><column name="status">resolved fixed</column><column name="commit">7562fc1</column><column name="commit_timestamp">1313140000</column><column name="files">java/org/apache/catalina/util/RequestUtil.java</column><column name="result">1:java/org/apache/catalina/util/RequestUtil.java</column></table><table name="tomcat"><column name="id">404</column><column name="bug_id">41673</column><column name="summary">Jasper output the message of compiling error using LF(\n) on ANY OS.</column><column name="description">Jasper output the message of compiling error using LF(\n) on ANY OS. This cannot be correctly displayed with Windows notepad. I think the line feed code along OS would be better, though I know other text editor solves this.</column><column name="report_time">2007-02-21 17:37:02</column><column name="report_timestamp">1172100000</column><column name="status">resolved fixed</column><column name="commit">841e9fc</column><column name="commit_timestamp">1313000000</column><column name="files">java/org/apache/jasper/compiler/DefaultErrorHandler.java
java/org/apache/jasper/compiler/ErrorDispatcher.java</column><column name="result">52:java/org/apache/jasper/compiler/DefaultErrorHandler.java
60:java/org/apache/jasper/compiler/ErrorDispatcher.java</column></table><table name="tomcat"><column name="id">405</column><column name="bug_id">51644</column><column name="summary">Unable to deploy applications with the name a#b.xml</column><column name="description">When I try to deploy a context with the name "a#b.xml" I get the following exception. SEVERE: Unable to process JNDI URL [jndi:/localhost/sample/one/WEB-INF/classes] for annotations java.io.FileNotFoundException: jndi:/localhost/sample/one/WEB-INF/classes at org.apache.naming.resources.DirContextURLConnection.list(DirContextUR LConnection.java:452) at org.apache.catalina.startup.ContextConfig.processAnnotationsJndi(Cont extConfig.java:1901) at org.apache.catalina.startup.ContextConfig.processAnnotationsUrl(Conte xtConfig.java:1828) at org.apache.catalina.startup.ContextConfig.webConfig(ContextConfig.jav a:1295) at org.apache.catalina.startup.ContextConfig.configureStart(ContextConfi g.java:896) at org.apache.catalina.startup.ContextConfig.lifecycleEvent(ContextConfi g.java:322) at org.apache.catalina.util.LifecycleSupport.fireLifecycleEvent(Lifecycl eSupport.java:119) at org.apache.catalina.util.LifecycleBase.fireLifecycleEvent(LifecycleBa se.java:89) at org.apache.catalina.core.StandardContext.startInternal(StandardContex t.java:5103) at org.apache.catalina.util.LifecycleBase.start(LifecycleBase.java:145) at org.apache.catalina.core.ContainerBase.addChildInternal(ContainerBase .java:812) at org.apache.catalina.core.ContainerBase.addChild(ContainerBase.java:78 7) at org.apache.catalina.core.StandardHost.addChild(StandardHost.java:607) at org.apache.catalina.startup.HostConfig.deployDescriptor(HostConfig.ja va:633) at org.apache.catalina.startup.HostConfig.deployDescriptors(HostConfig.j ava:558) at org.apache.catalina.startup.HostConfig.deployApps(HostConfig.java:468 ) at org.apache.catalina.startup.HostConfig.check(HostConfig.java:1363) at org.apache.catalina.startup.HostConfig.lifecycleEvent(HostConfig.java :294) at org.apache.catalina.util.LifecycleSupport.fireLifecycleEvent(Lifecycl eSupport.java:119) at org.apache.catalina.util.LifecycleBase.fireLifecycleEvent(LifecycleBa se.java:89) at org.apache.catalina.core.ContainerBase.backgroundProcess(ContainerBas e.java:1233) at org.apache.catalina.core.ContainerBase$ContainerBackgroundProcessor.p rocessChildren(ContainerBase.java:1391) at org.apache.catalina.core.ContainerBase$ContainerBackgroundProcessor.p rocessChildren(ContainerBase.java:1401) at org.apache.catalina.core.ContainerBase$ContainerBackgroundProcessor.r un(ContainerBase.java:1380) at java.lang.Thread.run(Thread.java:619) I would have expected the application to be available in the URI a/b. The bug seems to be in the "list()" method "of DirContextURLConnection.java. The method assumes that context name does not have any "/" characters in it. See the developer note just before the "if" block. I have added the "else if" condition that seems to have solved the problem for me. try { String file = getURL().getFile(); // This will be of the form /&lt;hostname&gt;/&lt;contextpath&gt;/file name // if &lt;contextpath&gt; is not empty otherwise this will be of the // form /&lt;hostname&gt;/file name // Strip off the hostname and the contextpath int start; if(context instanceof ProxyDirContext &amp;&amp; "".equals(((ProxyDirContext)context).getContextPath())){ start = file.indexOf('/',1); } else if(context instanceof ProxyDirContext){ 	start="/".length() 			+((ProxyDirContext)context).getHostName().length() 			+((ProxyDirContext)context).getContextPath().length(); 	/* 	 * Seems like a bug in Tomcat. below was the code in Tomcat. 	 * How can it handle contextpath like "/sample/one". It cannot 	 */ //start = file.indexOf('/', file.indexOf('/', 1) + 1); } else 	start = file.indexOf('/', file.indexOf('/', 1) + 1); NamingEnumeration&lt;NameClassPair&gt; enumeration = context.list(file.substring(start)); while (enumeration.hasMoreElements()) { NameClassPair ncp = enumeration.nextElement(); result.addElement(ncp.getName()); } } catch (NamingException e) {</column><column name="report_time">2011-08-10 10:00:36</column><column name="report_timestamp">1312980000</column><column name="status">resolved fixed</column><column name="commit">bb7072c</column><column name="commit_timestamp">1313000000</column><column name="files">java/org/apache/naming/resources/DirContextURLConnection.java</column><column name="result">1:java/org/apache/naming/resources/DirContextURLConnection.java</column></table><table name="tomcat"><column name="id">406</column><column name="bug_id">51640</column><column name="summary">clearReferencesJdbc seems to be causing leaks with com.oracle.ojdbc5 driver</column><column name="description">Created attachment 27365 Example Maven project to reproduce the problem clearReferencesJdbc seems to be causing reference leaks when used with com.oracle.ojdbc5 version 11.1.0.7.0, even if that class isn't loaded by the application. As best as I can tell, that function is loading one or more classes from the jar. Those classes are then adding a jmx MBean which then causes a reference leak. Error message: Aug 9, 2011 4:53:11 PM org.apache.catalina.loader.WebappClassLoader clearReferencesJdbc SEVERE: The web application [/mavenproject1-1.0-SNAPSHOT] registered the JDBC driver [oracle.jdbc.OracleDriver] but failed to unregister it when the web application was stopped. To prevent a memory leak, the JDBC Driver has been forcibly unregistered. List of classes in the class-loader: 0 : class org.apache.catalina.loader.JdbcLeakPrevention (84 bytes) 1 : class oracle.jdbc.driver.OracleDriver (84 bytes) 2 : class oracle.jdbc.OracleDriver (84 bytes) 3 : class oracle.jdbc.driver.OracleDriverExtension (84 bytes) 4 : class oracle.jdbc.driver.OracleDriver$1 (84 bytes) 5 : class oracle.jdbc.driver.DiagnosabilityMXBean (84 bytes) 6 : class oracle.jdbc.driver.OracleDiagnosabilityMBean (84 bytes) 7 : class oracle.jdbc.driver.DatabaseError (84 bytes) 8 : class oracle.jdbc.driver.OracleSQLException (84 bytes) 9 : class oracle.net.ns.NetException (84 bytes) 10 : class oracle.jdbc.driver.SQLStateMapping (84 bytes) 11 : class oracle.jdbc.driver.SQLStateMapping$Tokenizer (84 bytes) 12 : class oracle.jdbc.driver.Message (84 bytes) 13 : class oracle.jdbc.driver.Message11 (84 bytes) 14 : class oracle.jdbc.internal.ObjectDataFactory (84 bytes) 15 : class oracle.sql.ORADataFactory (84 bytes) 16 : class oracle.sql.AnyDataFactory (84 bytes) 17 : class oracle.jdbc.internal.ObjectData (84 bytes) 18 : class oracle.sql.ORAData (84 bytes) 19 : class oracle.sql.TypeDescriptorFactory (84 bytes) I believe this means that JdbcLeakPrevention is the first class to actually be loaded. Steps to reproduce: 1) Compile the project, using the driver from http://www.oracle.com/technetwork/database/enterprise-edition/jdbc-111060-084321.html 2) Deploy the project to tomcat. 3) Undeploy the project from tomcat. You should get the error about clearReferencesJdbc Expected: While I would expect Tomcat to not leak the class, I would be happy if there was an option to make Tomcat not run clearReferencesJdbc, allowing me to undeploy the app without leaking. This would not be as much of a problem if it wasn't causing the entire classloader and everything that implies to be leaked too.</column><column name="report_time">2011-08-10 00:21:38</column><column name="report_timestamp">1312950000</column><column name="status">resolved fixed</column><column name="commit">cd2fecd</column><column name="commit_timestamp">1312980000</column><column name="files">java/org/apache/catalina/core/JreMemoryLeakPreventionListener.java</column><column name="result">12:java/org/apache/catalina/core/JreMemoryLeakPreventionListener.java</column></table><table name="tomcat"><column name="id">407</column><column name="bug_id">51641</column><column name="summary">Http11NioProcessor not correct release</column><column name="description">org.apache.coyote.http11.Http11NioProtocol.Http11ConnectionHandler code segment: ================================== @Override public void release(SocketWrapper&lt;NioChannel&gt; socket) { Http11NioProcessor processor = connections.remove(socket); if (processor != null) { processor.recycle(); recycledProcessors.offer(processor); } } ================================== should be: ================================== @Override public void release(SocketWrapper&lt;NioChannel&gt; socket) { Http11NioProcessor processor = connections.remove(socket.getSocket()); if (processor != null) { processor.recycle(); recycledProcessors.offer(processor); } } ================================== type of connections is ConcurrentHashMap&lt;NioChannel, Http11NioProcessor&gt; , not ConcurrentHashMap&lt;SocketWrapper&lt;NioChannel&gt;, Http11NioProcessor&gt;.</column><column name="report_time">2011-08-10 03:37:44</column><column name="report_timestamp">1312960000</column><column name="status">resolved fixed</column><column name="commit">7ffca5b</column><column name="commit_timestamp">1312980000</column><column name="files">java/org/apache/coyote/http11/Http11NioProtocol.java</column><column name="result">2:java/org/apache/coyote/http11/Http11NioProtocol.java</column></table><table name="tomcat"><column name="id">408</column><column name="bug_id">51615</column><column name="summary">Line 267 of "org.apache.tomcat.jdbc.pool.PooledConnection": double assignment typo</column><column name="description">Nothing bad here, but my compiler lights up: connection = connection = driver.connect(driverURL, properties); Clearly, to be fixed.</column><column name="report_time">2011-08-04 19:14:11</column><column name="report_timestamp">1312500000</column><column name="status">resolved fixed</column><column name="commit">8c41e9c</column><column name="commit_timestamp">1312560000</column><column name="files">modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/PooledConnection.java</column><column name="result">1:modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/PooledConnection.java</column></table><table name="tomcat"><column name="id">409</column><column name="bug_id">51610</column><column name="summary">Context fails to reload after an error in web.xml was corrected</column><column name="description">With current trunk. Steps to reproduce: 1. Start Tomcat 7 2. Go to webapps/examples/WEB-INF/web.xml and uncomment &lt;filter-mapping&gt; for "Timing Filter" (line 75). 3. Wait several seconds. The examples webapp is reloaded, but fails to start. This happens because there is a typo. The &lt;filter-name&gt; value should be s/Timing Filter/Timing filter/. There is stack trace in the logs: [[[ 04.08.2011 8:09:39 org.apache.catalina.startup.HostConfig checkResources WARNING: Error during context [/examples] restart java.lang.IllegalArgumentException: Filter mapping specifies an unknown filter name Timing Filter 	at org.apache.catalina.core.StandardContext.validateFilterMap(StandardContext.java:2950) 	at org.apache.catalina.core.StandardContext.addFilterMap(StandardContext.java:2915) 	at org.apache.catalina.deploy.WebXml.configureContext(WebXml.java:1206) 	at org.apache.catalina.startup.ContextConfig.webConfig(ContextConfig.java:1343) 	at org.apache.catalina.startup.ContextConfig.configureStart(ContextConfig.java:896) 	at org.apache.catalina.startup.ContextConfig.lifecycleEvent(ContextConfig.java:322) 	at org.apache.catalina.util.LifecycleSupport.fireLifecycleEvent(LifecycleSupport.java:119) 	at org.apache.catalina.util.LifecycleBase.fireLifecycleEvent(LifecycleBase.java:89) 	at org.apache.catalina.core.StandardContext.startInternal(StandardContext.java:5103) 	at org.apache.catalina.util.LifecycleBase.start(LifecycleBase.java:145) 	at org.apache.catalina.startup.HostConfig.checkResources(HostConfig.java:1279) 	at org.apache.catalina.startup.HostConfig.check(HostConfig.java:1360) 	at org.apache.catalina.startup.HostConfig.lifecycleEvent(HostConfig.java:294) 	at org.apache.catalina.util.LifecycleSupport.fireLifecycleEvent(LifecycleSupport.java:119) 	at org.apache.catalina.util.LifecycleBase.fireLifecycleEvent(LifecycleBase.java:89) 	at org.apache.catalina.core.ContainerBase.backgroundProcess(ContainerBase.java:1240) 	at org.apache.catalina.core.ContainerBase$ContainerBackgroundProcessor.processChildren(ContainerBase.java:1398) 	at org.apache.catalina.core.ContainerBase$ContainerBackgroundProcessor.processChildren(ContainerBase.java:1408) 	at org.apache.catalina.core.ContainerBase$ContainerBackgroundProcessor.run(ContainerBase.java:1387) 	at java.lang.Thread.run(Thread.java:662) ]]] 4. Go to web.xml and edit it once again. E.g. re-comment the mapping, or correct the typo. 5. Wait several seconds. Here is an issue: EXPECTED: The examples webapp should reload successfully. ACTUAL: Reload fails. The following is printed in the logs: 04.08.2011 8:09:59 org.apache.catalina.startup.HostConfig checkResources INFO: Reloading context [/examples] 04.08.2011 8:09:59 org.apache.catalina.util.LifecycleBase start INFO: The start() method was called on component [StandardEngine[Catalina].StandardHost[localhost].StandardContext[/examples]] after start() had already been called. The second call will be ignored. 6. Stop Tomcat. Here is the second issue: EXPECTED: Successful shutdown ACTUAL: [[[ 04.08.2011 8:14:10 org.apache.catalina.startup.Catalina stop SEVERE: Catalina.stop org.apache.catalina.LifecycleException: An invalid Lifecycle transition was attempted ([before_stop]) for component [StandardEngine[Catalina].StandardHost[localhost].StandardContext[/examples]] in state [STARTING_PREP] 	at org.apache.catalina.util.LifecycleBase.invalidTransition(LifecycleBase.java:387) 	at org.apache.catalina.util.LifecycleBase.stop(LifecycleBase.java:212) 	at org.apache.catalina.core.ContainerBase.stopInternal(ContainerBase.java:1072) 	at org.apache.catalina.util.LifecycleBase.stop(LifecycleBase.java:225) 	at org.apache.catalina.core.ContainerBase.stopInternal(ContainerBase.java:1072) 	at org.apache.catalina.util.LifecycleBase.stop(LifecycleBase.java:225) 	at org.apache.catalina.core.StandardService.stopInternal(StandardService.java:502) 	at org.apache.catalina.util.LifecycleBase.stop(LifecycleBase.java:225) 	at org.apache.catalina.core.StandardServer.stopInternal(StandardServer.java:748) 	at org.apache.catalina.util.LifecycleBase.stop(LifecycleBase.java:225) 	at org.apache.catalina.startup.Catalina.stop(Catalina.java:694) 	at org.apache.catalina.startup.Catalina$CatalinaShutdownHook.run(Catalina.java:847) ]]] This exception at shutdown happens only if examples webapp was correct when Tomcat started, but was broken afterwards. If it was already broken at startup time, nothing happens. 7. Here is the third issue: when the above happens the shutdown sequence is apparently aborted abnormally. EXPECTED: "INFO: Stopping ProtocolHandler ["http-bio-8080"]" etc. messages ACTUAL: There are no messages after the "SEVERE: Catalina.stop" one that I cited above.</column><column name="report_time">2011-08-04 04:28:49</column><column name="report_timestamp">1312450000</column><column name="status">resolved fixed</column><column name="commit">ed0588b</column><column name="commit_timestamp">1312560000</column><column name="files">java/org/apache/catalina/util/LifecycleBase.java</column><column name="result">3:java/org/apache/catalina/util/LifecycleBase.java</column></table><table name="tomcat"><column name="id">410</column><column name="bug_id">51614</column><column name="summary">PersistentManager loads session from Store and calls session.expire() twice.</column><column name="description">To check whether session is loaded into memory, StoreBase#processExpires calls findSession(id). ===== ... if (manager.findSession(keys[i]) != null) { isLoaded = true; } ... ===== However, PersistentManager#findSession(id) loads session from Store when there is no session in memory. Because session loaded from Store is an invalid session PersistentManager logs errorlog, calls session.expire(), and deletes session from Store. As a result, findSession(id) returns null, and isLoaded becomes false. And, session.expire() is called again, and the session is deleted from Store. If manager is PersistentManager, it is necessary to call PersistentManagerBase#isLoaded(id). However, to avoid regression of r1033024, other managers call findSession(id). Best regards.</column><column name="report_time">2011-08-04 11:19:47</column><column name="report_timestamp">1312470000</column><column name="status">resolved fixed</column><column name="commit">29e9966</column><column name="commit_timestamp">1312460000</column><column name="files">java/org/apache/catalina/session/StoreBase.java</column><column name="result">2:java/org/apache/catalina/session/StoreBase.java</column></table><table name="tomcat"><column name="id">411</column><column name="bug_id">51588</column><column name="summary">Change access modifiers in AccessLogValve to make it easier to extend</column><column name="description">I'm adding some fields to a subclass of org.apache.catalina.valves.AccessLogValve but createLogElements() is the closest extension point available. Rather than reimplement the functionality there it would be preferable if both of the createAccessLogElement() methods were protected rather than private then it's a simple method of matching the char you want to use and falling back to super.createAccessLogElement().</column><column name="report_time">2011-07-30 02:33:45</column><column name="report_timestamp">1312010000</column><column name="status">resolved fixed</column><column name="commit">77213bb</column><column name="commit_timestamp">1312130000</column><column name="files">java/org/apache/catalina/valves/AccessLogValve.java</column><column name="result">1:java/org/apache/catalina/valves/AccessLogValve.java</column></table><table name="tomcat"><column name="id">412</column><column name="bug_id">51586</column><column name="summary">ContextConfig.checkHandlesTypes() doesn't check for VerifyError when loading class</column><column name="description">I've recently upgraded to Tomcat 7 and used to run with metadata-complete="true" in my web.xml. With Servlet 3 I decided I'd try some of the annotation features. When I turned off metadata-complete I got a VerifyError trying to load one of my classes. This class is meant to only work on Tomcat 6 so the fact Tomcat 7 cannot load this class is expected. What is not expected is that Tomcat 7 doesn't just ignore the error and continue scanning for annotations. Looking in ContextConfig.checkHandlesTypes() I checks for virtually every type of loading failure except VerifyError. Perhaps VerifyError should be added to this list? java.lang.VerifyError: class org.lds.stack.tomcat.decrypt.DecryptingStandardContext overrides final method start.()V 	at java.lang.ClassLoader.defineClass1(Native Method) 	at java.lang.ClassLoader.defineClassCond(ClassLoader.java:631) 	at java.lang.ClassLoader.defineClass(ClassLoader.java:615) 	at java.security.SecureClassLoader.defineClass(SecureClassLoader.java:141) 	at java.net.URLClassLoader.defineClass(URLClassLoader.java:283) 	at java.net.URLClassLoader.access$000(URLClassLoader.java:58) 	at java.net.URLClassLoader$1.run(URLClassLoader.java:197) 	at java.security.AccessController.doPrivileged(Native Method) 	at java.net.URLClassLoader.findClass(URLClassLoader.java:190) 	at java.lang.ClassLoader.loadClass(ClassLoader.java:306) 	at java.lang.ClassLoader.loadClass(ClassLoader.java:247) 	at java.lang.Class.forName0(Native Method) 	at java.lang.Class.forName(Class.java:247) 	at org.apache.catalina.loader.WebappClassLoader.loadClass(WebappClassLoader.java:1665) 	at org.apache.catalina.loader.WebappClassLoader.loadClass(WebappClassLoader.java:1523) 	at org.apache.catalina.startup.ContextConfig.checkHandlesTypes(ContextConfig.java:2006) 	at org.apache.catalina.startup.ContextConfig.processAnnotationsStream(ContextConfig.java:1969) 	at org.apache.catalina.startup.ContextConfig.processAnnotationsJar(ContextConfig.java:1858) 	at org.apache.catalina.startup.ContextConfig.processAnnotationsUrl(ContextConfig.java:1826) 	at org.apache.catalina.startup.ContextConfig.processAnnotations(ContextConfig.java:1812) 	at org.apache.catalina.startup.ContextConfig.webConfig(ContextConfig.java:1306) 	at org.apache.catalina.startup.ContextConfig.configureStart(ContextConfig.java:896) 	at org.apache.catalina.startup.ContextConfig.lifecycleEvent(ContextConfig.java:322) 	at org.apache.catalina.util.LifecycleSupport.fireLifecycleEvent(LifecycleSupport.java:119) 	at org.apache.catalina.util.LifecycleBase.fireLifecycleEvent(LifecycleBase.java:89) 	at org.apache.catalina.core.StandardContext.startInternal(StandardContext.java:5103) 	at org.apache.catalina.util.LifecycleBase.start(LifecycleBase.java:145) 	at org.apache.catalina.core.ContainerBase.addChildInternal(ContainerBase.java:812) 	at org.apache.catalina.core.ContainerBase.addChild(ContainerBase.java:787) 	at org.apache.catalina.core.StandardHost.addChild(StandardHost.java:607) 	at org.apache.catalina.startup.HostConfig.deployDescriptor(HostConfig.java:633) 	at org.apache.catalina.startup.HostConfig.deployDescriptors(HostConfig.java:558) 	at org.apache.catalina.startup.HostConfig.deployApps(HostConfig.java:468) 	at org.apache.catalina.startup.HostConfig.start(HostConfig.java:1322) 	at org.apache.catalina.startup.HostConfig.lifecycleEvent(HostConfig.java:311) 	at org.apache.catalina.util.LifecycleSupport.fireLifecycleEvent(LifecycleSupport.java:119) 	at org.apache.catalina.util.LifecycleBase.fireLifecycleEvent(LifecycleBase.java:89) 	at org.apache.catalina.util.LifecycleBase.setStateInternal(LifecycleBase.java:379) 	at org.apache.catalina.util.LifecycleBase.setState(LifecycleBase.java:324) 	at org.apache.catalina.core.ContainerBase.startInternal(ContainerBase.java:1041) 	at org.apache.catalina.core.StandardHost.startInternal(StandardHost.java:774) 	at org.apache.catalina.util.LifecycleBase.start(LifecycleBase.java:145) 	at org.apache.catalina.core.ContainerBase.startInternal(ContainerBase.java:1033) 	at org.apache.catalina.core.StandardEngine.startInternal(StandardEngine.java:291) 	at org.apache.catalina.util.LifecycleBase.start(LifecycleBase.java:145) 	at org.apache.catalina.core.StandardService.startInternal(StandardService.java:443) 	at org.apache.catalina.util.LifecycleBase.start(LifecycleBase.java:145) 	at org.apache.catalina.core.StandardServer.startInternal(StandardServer.java:727) 	at org.apache.catalina.util.LifecycleBase.start(LifecycleBase.java:145) 	at org.apache.catalina.startup.Catalina.start(Catalina.java:621) 	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) 	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) 	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25) 	at java.lang.reflect.Method.invoke(Method.java:597) 	at org.apache.catalina.startup.Bootstrap.start(Bootstrap.java:322) 	at org.apache.catalina.startup.Bootstrap.main(Bootstrap.java:450)</column><column name="report_time">2011-07-29 19:25:49</column><column name="report_timestamp">1311980000</column><column name="status">resolved fixed</column><column name="commit">0b340ac</column><column name="commit_timestamp">1312130000</column><column name="files">java/org/apache/catalina/startup/ContextConfig.java</column><column name="result">1:java/org/apache/catalina/startup/ContextConfig.java</column></table><table name="tomcat"><column name="id">413</column><column name="bug_id">51557</column><column name="summary">Newline during a http header field name obscures next value</column><column name="description">Created attachment 27314 Patch to stop CR &amp; LF in the header. InternalInputBuffer allows newlines in http header field names. As an example: Foo: Val1 Bar: Val2 MISS Hup: Val3 This will lead to a field name of 'MISSHup' and not 'Hup'. Digging into the specs, I think this goes back to RFC 822 which states: field-name = 1*&lt;any CHAR, excluding CTLs, SPACE, and ":"&gt; and CTL = &lt;any ASCII control ; ( 0- 37, 0.- 31.) character and DEL&gt; ; ( 177, 127.) I think this is saying that field-name should not contain CR or LF. I've attached a patch that stops CR &amp; LF. Two improvements I could see, if there's agreement with this as a bug, are adding a unit test to TestInternalInputBuffer and changing the code so it disallows space and any other ctrl character in the field name.</column><column name="report_time">2011-07-26 06:12:43</column><column name="report_timestamp">1311680000</column><column name="status">resolved fixed</column><column name="commit">6200dd9</column><column name="commit_timestamp">1311760000</column><column name="files">java/org/apache/coyote/http11/AbstractInputBuffer.java
java/org/apache/coyote/http11/InternalAprInputBuffer.java
java/org/apache/coyote/http11/InternalInputBuffer.java
java/org/apache/coyote/http11/InternalNioInputBuffer.java
test/org/apache/coyote/http11/TestInternalInputBuffer.java</column><column name="result">18:java/org/apache/coyote/http11/InternalInputBuffer.java
19:java/org/apache/coyote/http11/InternalAprInputBuffer.java
56:java/org/apache/coyote/http11/InternalNioInputBuffer.java
121:java/org/apache/coyote/http11/AbstractInputBuffer.java
338:test/org/apache/coyote/http11/TestInternalInputBuffer.java</column></table><table name="tomcat"><column name="id">414</column><column name="bug_id">51545</column><column name="summary">make threadname available in ExtendedAccessLogValve</column><column name="description">Created attachment 27309 Threadname usable in ExtendedAccessLogValve As discussed on the tomcat-users mailinglist http://old.nabble.com/thread-name-in-extended-access-log-valve-tt32101677.html make the threadname of the thread, that served the request, available to the ExtendedAccessLogValve.</column><column name="report_time">2011-07-23 09:07:02</column><column name="report_timestamp">1311430000</column><column name="status">resolved fixed</column><column name="commit">00a1fdf</column><column name="commit_timestamp">1311670000</column><column name="files">java/org/apache/catalina/valves/ExtendedAccessLogValve.java</column><column name="result">1:java/org/apache/catalina/valves/ExtendedAccessLogValve.java</column></table><table name="tomcat"><column name="id">415</column><column name="bug_id">51555</column><column name="summary">An invalid Lifecycle transition ([before_stop]) for component in state [INITIALIZED]: MapperListener</column><column name="description">Created attachment 27313 TEST-org.apache.tomcat.util.net.TestXxxEndpoint.BIO.txt While running TestXxxEndpoint test I observed the following error - see attached log: An invalid Lifecycle transition was attempted ([before_stop]) for component [org.apache.catalina.connector.MapperListener@e3849c] in state [INITIALIZED] org.apache.catalina.LifecycleException: An invalid Lifecycle transition was attempted ([before_stop]) for component [org.apache.catalina.connector.MapperListener@e3849c] in state [INITIALIZED] 	at org.apache.catalina.util.LifecycleBase.invalidTransition(LifecycleBase.java:386) 	at org.apache.catalina.util.LifecycleBase.stop(LifecycleBase.java:212) 	at org.apache.catalina.connector.Connector.stopInternal(Connector.java:973) 	at org.apache.catalina.util.LifecycleBase.stop(LifecycleBase.java:225) 	at org.apache.tomcat.util.net.TestXxxEndpoint.testStartStopBindOnStart(TestXxxEndpoint.java:172) The test case contains two tests. The first one (on port 8001) succeeded, while the second one (on port 8002) failed with "Address already in use: JVM_Bind". This failure to bind to 8002 was unexpected and does not occur during normal run. While Tomcat was stopping after failed start, the above "invalid Lifecycle transition" exception was thrown by MapperListener. I was testing with BIO connector only, running a single test (test.entry=org.apache.tomcat.util.net.TestXxxEndpoint). I think that the cause of the startup failure was that I accidentally started two copies of Ant in parallel. In Eclipse it happens if you double-click on "Run External Tool" button. Looking at o.a.catalina.connector.Connector#startInternal(), it does - protocolHandler.start(); - mapperListener.start(); The logs show that protocolHandler.start() call failed. Thus mapperListener.start() was not called. This second test TestXxxEndpoint.testStartStopBindOnStart() runs with "bindOnInit" property of connector set to "false". Thus binding failure did not happen in init(), but occurred in start().</column><column name="report_time">2011-07-25 21:40:38</column><column name="report_timestamp">1311640000</column><column name="status">resolved fixed</column><column name="commit">95d67fe</column><column name="commit_timestamp">1311670000</column><column name="files">java/org/apache/catalina/Lifecycle.java
java/org/apache/catalina/util/LifecycleBase.java</column><column name="result">2:java/org/apache/catalina/Lifecycle.java
4:java/org/apache/catalina/util/LifecycleBase.java</column></table><table name="tomcat"><column name="id">416</column><column name="bug_id">41709</column><column name="summary">When calling the API that relates to the buffer after the response is committed, ISE with no messages is thrown.</column><column name="description">After the response is committed, following API throws IllegalStateException. It's O.K. but the message of the exception is not set. - HttpServletResponse#resetBuffer - HttpServletResponse#sendError - HttpServletResponse#sendRedirect - HttpServletResponse#setBufferSize To understand the bug of the application, it is hoped that the message is set like other exceptions.</column><column name="report_time">2007-02-26 17:43:51</column><column name="report_timestamp">1172530000</column><column name="status">resolved fixed</column><column name="commit">8baaa98</column><column name="commit_timestamp">1311360000</column><column name="files">java/org/apache/catalina/connector/ResponseFacade.java</column><column name="result">7:java/org/apache/catalina/connector/ResponseFacade.java</column></table><table name="tomcat"><column name="id">417</column><column name="bug_id">51056</column><column name="summary">Disable / drop support for SSLv2</column><column name="description">Hi, SSL 2.0 support got removed from many Debian GNU/Linux (and many others linux distro) and SSL 2.0 is disabled by default in Internet Explorer 7, Mozilla Firefox 3, Opera and Safari. It's use has been deprecated, because of weaknesses in the security of the protocol. For exemple, http://www.openssl.org/news/secadv_20051011.txt I propose to simply drop any support for SSLv2 in Tomcat Native lib with the attached patch.</column><column name="report_time">2011-04-13 14:12:26</column><column name="report_timestamp">1302720000</column><column name="status">resolved fixed</column><column name="commit">4d9fcc0</column><column name="commit_timestamp">1311240000</column><column name="files">java/org/apache/tomcat/jni/SSL.java</column><column name="result">13:java/org/apache/tomcat/jni/SSL.java</column></table><table name="tomcat"><column name="id">418</column><column name="bug_id">51532</column><column name="summary">Performance Issue when retriving JAR files during TLD file parsing.</column><column name="description">Migrating from Tomcat 6.0.29 to 7.0.19 a large performance hit was noticed on pages containing lots of custom tags. Page rendering time jumped by an order of magnitude. Profiling the webapp through Netbeans, we narrowed down the problem to the getJarFile() method inside org.apache.jasper.compiler.ParseController. Screenshots of the Profiler Hotspots and Call Tree from both versions of Tomcat are available here: http://imgur.com/a/ZmeWM The URL path used to load the JAR file has changed from Tomcat 6. Below are the values as output by the debugger: Tomcat 6: "file:/C:/svn/[PATH_TO_PROJECT]/server/target/snapshot/WEB-INF/lib/[OUR_JAR].jar!/" Tomcat 7: "jndi:/localhost/snapshot/WEB-INF/lib/[OUR_JAR].jar!/" A comparison of the getJarFile() methods shows few differences aside from the URL path that could contribute to the problem: Tomcat 7: org.apache.jasper.compiler.JarURLResource public JarFile getJarFile() throws IOException { URL jarFileUrl = new URL("jar:" + jarUrl + "!/"); JarURLConnection conn = (JarURLConnection) jarFileUrl.openConnection(); conn.setUseCaches(false); conn.connect(); return conn.getJarFile(); } Tomcat 6: org.apache.japser.compiler.ParserController private JarFile getJarFile(URL jarFileUrl) throws IOException { JarFile jarFile = null; if (jarFileUrl != null) { JarURLConnection conn = (JarURLConnection) jarFileUrl.openConnection(); conn.setUseCaches(false); conn.connect(); jarFile = conn.getJarFile(); } return jarFile; }</column><column name="report_time">2011-07-19 21:47:15</column><column name="report_timestamp">1311130000</column><column name="status">resolved fixed</column><column name="commit">bcee77d</column><column name="commit_timestamp">1311190000</column><column name="files">java/org/apache/jasper/compiler/Compiler.java</column><column name="result">31:java/org/apache/jasper/compiler/Compiler.java</column></table><table name="tomcat"><column name="id">419</column><column name="bug_id">51509</column><column name="summary">Csrf Prevention Filter's LruCache is not thread save</column><column name="description">The LruCache (org.apache.catalina.filters.CsrfPreventionFilter$LruCache) use by Csrf Prevention Filter is base on LinkedHashMap. From the LinkedHashMap Java Doc: Note that this implementation is not synchronized. If multiple threads access a linked hash map concurrently, and at least one of the threads modifies the map structurally, it must be synchronized externally. ... But the LruCache implementation does not synchronize the access to the map.</column><column name="report_time">2011-07-14 14:54:22</column><column name="report_timestamp">1310670000</column><column name="status">resolved fixed</column><column name="commit">400745e</column><column name="commit_timestamp">1311100000</column><column name="files">java/org/apache/catalina/filters/CsrfPreventionFilter.java
test/org/apache/catalina/filters/TestCsrfPreventionFilter2.java</column><column name="result">1:java/org/apache/catalina/filters/CsrfPreventionFilter.java</column></table><table name="tomcat"><column name="id">420</column><column name="bug_id">51518</column><column name="summary">"/absolute-ordering/name/others" should not include "name" element</column><column name="description">method: org.apache.catalina.startup.WebRuleSet.addRuleInstances(Digester digester) code: ==================================================== digester.addCallMethod(fullPrefix + "/absolute-ordering/name/others", "addAbsoluteOrderingOthers"); ==================================================== web-common_3_0.xsd ==================================================== &lt;xsd:complexType name="absoluteOrderingType"&gt; &lt;xsd:annotation&gt; &lt;xsd:documentation&gt; Please see section 8.2.2 of the specification for details. &lt;/xsd:documentation&gt; &lt;/xsd:annotation&gt; &lt;xsd:choice minOccurs="0" maxOccurs="unbounded"&gt; &lt;xsd:element name="name" type="javaee:java-identifierType" minOccurs="0" maxOccurs="unbounded"/&gt; &lt;xsd:element name="others" type="javaee:ordering-othersType" minOccurs="0" maxOccurs="1"/&gt; &lt;/xsd:choice&gt; &lt;/xsd:complexType&gt; ====================================================</column><column name="report_time">2011-07-17 01:22:30</column><column name="report_timestamp">1310880000</column><column name="status">resolved fixed</column><column name="commit">5de2739</column><column name="commit_timestamp">1311080000</column><column name="files">java/org/apache/catalina/startup/WebRuleSet.java</column><column name="result">1:java/org/apache/catalina/startup/WebRuleSet.java</column></table><table name="tomcat"><column name="id">421</column><column name="bug_id">49595</column><column name="summary">Tomcat crashes in tcnative-1.dll frequently</column><column name="description"># # A fatal error has been detected by the Java Runtime Environment: # # EXCEPTION_ACCESS_VIOLATION (0xc0000005) at pc=0x485a4b16, pid=2556, tid=5112 # # JRE version: 6.0_20-b02 # Java VM: Java HotSpot(TM) Server VM (16.3-b01 mixed mode windows-x86 ) # Problematic frame: # C [tcnative-1.dll+0x4b16] # # If you would like to submit a bug report, please visit: # http://java.sun.com/webapps/bugreport/crash.jsp # The crash happened outside the Java Virtual Machine in native code. # See problematic frame for where to report the bug. # --------------- T H R E A D --------------- Current thread (0x47e3d000): JavaThread "ajp-8009-7" daemon [_thread_in_native, id=5112, stack(0x4b900000,0x4b950000)] siginfo: ExceptionCode=0xc0000005, reading address 0x00000020 Registers: EAX=0x00000000, EBX=0x0000200e, ECX=0x00000000, EDX=0x00000000 ESP=0x4b94e800, EBP=0x4b94e818, ESI=0x00000000, EDI=0x4ae2bfe8 EIP=0x485a4b16, EFLAGS=0x00010246 Top of Stack: (sp=0x4b94e800) 0x4b94e800: 00000000 00000000 4b94e820 47e3d000 0x4b94e810: 43e67730 43e67730 4b94e860 0063a484 0x4b94e820: 0000200e 4b94e868 4ae2bfe8 00000000 0x4b94e830: 00000000 0000200e 19872b78 4b94e83c 0x4b94e840: 4b94e840 00000000 4b94e87c 43e683f0 0x4b94e850: 00000000 43e67730 00000000 4b94e870 0x4b94e860: 4b94e8a0 00632f85 43e68390 00638359 0x4b94e870: 0000200e 00000000 4ae2bfe8 00000000 Instructions: (pc=0x485a4b16) 0x485a4b06: 55 18 51 8d 0c 16 8b 57 10 03 ca 8b 57 0c 51 52 0x485a4b16: ff 50 20 85 c0 75 14 03 75 08 3b f3 72 d4 85 c0 Stack: [0x4b900000,0x4b950000], sp=0x4b94e800, free space=13a4b94e33ck Native frames: (J=compiled Java code, j=interpreted, Vv=VM code, C=native code) C [tcnative-1.dll+0x4b16] j org.apache.tomcat.jni.Socket.sendbb(JII)I+0 j org.apache.coyote.ajp.AjpAprProcessor.flush()V+22 j org.apache.coyote.ajp.AjpAprProcessor$SocketOutputBuffer.doWrite(Lorg/apache/tomcat/util/buf/ByteChunk;Lorg/apache/coyote/Response;)I+114 j org.apache.coyote.Response.doWrite(Lorg/apache/tomcat/util/buf/ByteChunk;)V+6 j org.apache.catalina.connector.OutputBuffer.realWriteBytes([BII)V+38 j org.apache.tomcat.util.buf.ByteChunk.append([BII)V+202 j org.apache.catalina.connector.OutputBuffer.writeBytes([BII)V+15 j org.apache.catalina.connector.OutputBuffer.write([BII)V+12 j org.apache.catalina.connector.CoyoteOutputStream.write([BII)V+7 j org.apache.catalina.connector.CoyoteOutputStream.write([B)V+5 j com.fisc.ptao.common.PTNative.attachmentDataPut([BZ)V+47 v ~StubRoutines::call_stub V [jvm.dll+0x191d0c] V [jvm.dll+0x27e631] V [jvm.dll+0x191d8d] V [jvm.dll+0x19b68f] V [jvm.dll+0x19e487] Java frames: (J=compiled Java code, j=interpreted, Vv=VM code) j org.apache.tomcat.jni.Socket.sendbb(JII)I+0 j org.apache.coyote.ajp.AjpAprProcessor.flush()V+22 j org.apache.coyote.ajp.AjpAprProcessor$SocketOutputBuffer.doWrite(Lorg/apache/tomcat/util/buf/ByteChunk;Lorg/apache/coyote/Response;)I+114 j org.apache.coyote.Response.doWrite(Lorg/apache/tomcat/util/buf/ByteChunk;)V+6 j org.apache.catalina.connector.OutputBuffer.realWriteBytes([BII)V+38 j org.apache.tomcat.util.buf.ByteChunk.append([BII)V+202 j org.apache.catalina.connector.OutputBuffer.writeBytes([BII)V+15 j org.apache.catalina.connector.OutputBuffer.write([BII)V+12 j org.apache.catalina.connector.CoyoteOutputStream.write([BII)V+7 j org.apache.catalina.connector.CoyoteOutputStream.write([B)V+5 j com.fisc.ptao.common.PTNative.attachmentDataPut([BZ)V+47 v ~StubRoutines::call_stub j com.fisc.ptao.common.PTNative.PTReadAttachment(JLjava/lang/String;II)I+0 j com.fisc.ptao.servlets.PTReadAttachmentServlet.doGet(Ljavax/servlet/http/HttpServletRequest;Ljavax/servlet/http/HttpServletResponse;)V+612 j javax.servlet.http.HttpServlet.service(Ljavax/servlet/http/HttpServletRequest;Ljavax/servlet/http/HttpServletResponse;)V+35 j javax.servlet.http.HttpServlet.service(Ljavax/servlet/ServletRequest;Ljavax/servlet/ServletResponse;)V+30 j org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(Ljavax/servlet/ServletRequest;Ljavax/servlet/ServletResponse;)V+376 j org.apache.catalina.core.ApplicationFilterChain.doFilter(Ljavax/servlet/ServletRequest;Ljavax/servlet/ServletResponse;)V+101 j com.fisc.interpost.filters.LoginFilter.doFilter(Ljavax/servlet/ServletRequest;Ljavax/servlet/ServletResponse;Ljavax/servlet/FilterChain;)V+361 j org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(Ljavax/servlet/ServletRequest;Ljavax/servlet/ServletResponse;)V+119 j org.apache.catalina.core.ApplicationFilterChain.doFilter(Ljavax/servlet/ServletRequest;Ljavax/servlet/ServletResponse;)V+101 j org.apache.catalina.core.StandardWrapperValve.invoke(Lorg/apache/catalina/connector/Request;Lorg/apache/catalina/connector/Response;)V+804 j org.apache.catalina.core.StandardContextValve.invoke(Lorg/apache/catalina/connector/Request;Lorg/apache/catalina/connector/Response;)V+365 j org.apache.catalina.core.StandardHostValve.invoke(Lorg/apache/catalina/connector/Request;Lorg/apache/catalina/connector/Response;)V+64 j org.apache.catalina.valves.ErrorReportValve.invoke(Lorg/apache/catalina/connector/Request;Lorg/apache/catalina/connector/Response;)V+6 j org.apache.catalina.core.StandardEngineValve.invoke(Lorg/apache/catalina/connector/Request;Lorg/apache/catalina/connector/Response;)V+42 j org.apache.catalina.connector.CoyoteAdapter.service(Lorg/apache/coyote/Request;Lorg/apache/coyote/Response;)V+158 j org.apache.coyote.ajp.AjpAprProcessor.process(J)Z+309 j org.apache.coyote.ajp.AjpAprProtocol$AjpConnectionHandler.process(J)Lorg/apache/tomcat/util/net/AprEndpoint$Handler$SocketState;+39 j org.apache.tomcat.util.net.AprEndpoint$Worker.run()V+147 j java.lang.Thread.run()V+11 v ~StubRoutines::call_stub --------------- P R O C E S S --------------- Java Threads: ( =&gt; current thread ) 0x48b16400 JavaThread "ajp-8009-9" daemon [_thread_blocked, id=5916, stack(0x4b9b0000,0x4ba00000)] 0x4989b400 JavaThread "ajp-8009-8" daemon [_thread_blocked, id=5848, stack(0x4b950000,0x4b9a0000)] =&gt;0x47e3d000 JavaThread "ajp-8009-7" daemon [_thread_in_native, id=5112, stack(0x4b900000,0x4b950000)] 0x47e75400 JavaThread "ajp-8009-6" daemon [_thread_blocked, id=5564, stack(0x4b7a0000,0x4b7f0000)] 0x48fab400 JavaThread "File Reaper" daemon [_thread_blocked, id=4180, stack(0x4b750000,0x4b7a0000)] 0x492a4c00 JavaThread "ajp-8009-5" daemon [_thread_blocked, id=2648, stack(0x4b700000,0x4b750000)] 0x48c1a400 JavaThread "ajp-8009-4" daemon [_thread_in_native, id=2500, stack(0x4b660000,0x4b6b0000)] 0x48219000 JavaThread "ajp-8009-3" daemon [_thread_blocked, id=5060, stack(0x4b6b0000,0x4b700000)] 0x487f3400 JavaThread "ajp-8009-2" daemon [_thread_blocked, id=6028, stack(0x4b610000,0x4b660000)] 0x49498400 JavaThread "ajp-8009-1" daemon [_thread_in_native, id=1396, stack(0x4b4c0000,0x4b510000)] 0x488e5800 JavaThread "janitorThread" daemon [_thread_blocked, id=5976, stack(0x4b470000,0x4b4c0000)] 0x47fbc000 JavaThread "ajp-8009-Acceptor-0" daemon [_thread_in_native, id=1472, stack(0x4b420000,0x4b470000)] 0x488d2400 JavaThread "ajp-8009-CometPoller-7" daemon [_thread_blocked, id=5052, stack(0x4b3d0000,0x4b420000)] 0x484c8800 JavaThread "ajp-8009-CometPoller-6" daemon [_thread_blocked, id=4764, stack(0x4b380000,0x4b3d0000)] 0x48563000 JavaThread "ajp-8009-CometPoller-5" daemon [_thread_blocked, id=5244, stack(0x4b330000,0x4b380000)] 0x496ca800 JavaThread "ajp-8009-CometPoller-4" daemon [_thread_blocked, id=1536, stack(0x4b2e0000,0x4b330000)] 0x48c97800 JavaThread "ajp-8009-CometPoller-3" daemon [_thread_blocked, id=5904, stack(0x4b290000,0x4b2e0000)] 0x48b2c400 JavaThread "ajp-8009-CometPoller-2" daemon [_thread_blocked, id=5092, stack(0x4b240000,0x4b290000)] 0x4845a800 JavaThread "ajp-8009-CometPoller-1" daemon [_thread_blocked, id=1816, stack(0x4b1f0000,0x4b240000)] 0x48438800 JavaThread "ajp-8009-CometPoller-0" daemon [_thread_blocked, id=2436, stack(0x4b1a0000,0x4b1f0000)] 0x492c5800 JavaThread "ajp-8009-Poller-7" daemon [_thread_blocked, id=5536, stack(0x4b150000,0x4b1a0000)] 0x482d2800 JavaThread "ajp-8009-Poller-6" daemon [_thread_blocked, id=5576, stack(0x4b100000,0x4b150000)] 0x48c01400 JavaThread "ajp-8009-Poller-5" daemon [_thread_in_native, id=2456, stack(0x4b0b0000,0x4b100000)] 0x48380400 JavaThread "ajp-8009-Poller-4" daemon [_thread_in_native, id=4684, stack(0x4ac60000,0x4acb0000)] 0x48d07c00 JavaThread "ajp-8009-Poller-3" daemon [_thread_blocked, id=4288, stack(0x4ac10000,0x4ac60000)] 0x4886b400 JavaThread "ajp-8009-Poller-2" daemon [_thread_blocked, id=2908, stack(0x4abc0000,0x4ac10000)] 0x48be9400 JavaThread "ajp-8009-Poller-1" daemon [_thread_blocked, id=5208, stack(0x4ab70000,0x4abc0000)] 0x484f6400 JavaThread "ajp-8009-Poller-0" daemon [_thread_blocked, id=4956, stack(0x4ab20000,0x4ab70000)] 0x48304800 JavaThread "http-8080-Acceptor-0" daemon [_thread_in_native, id=5732, stack(0x4aad0000,0x4ab20000)] 0x483fe400 JavaThread "http-8080-Sendfile-0" daemon [_thread_blocked, id=5412, stack(0x4aa80000,0x4aad0000)] 0x48bb2400 JavaThread "http-8080-CometPoller-7" daemon [_thread_blocked, id=5056, stack(0x4aa30000,0x4aa80000)] 0x48331400 JavaThread "http-8080-CometPoller-6" daemon [_thread_blocked, id=4348, stack(0x4a9e0000,0x4aa30000)] 0x4835d400 JavaThread "http-8080-CometPoller-5" daemon [_thread_blocked, id=1168, stack(0x4a990000,0x4a9e0000)] 0x48b83400 JavaThread "http-8080-CometPoller-4" daemon [_thread_blocked, id=5936, stack(0x4a940000,0x4a990000)] 0x489e3800 JavaThread "http-8080-CometPoller-3" daemon [_thread_blocked, id=2956, stack(0x4a8f0000,0x4a940000)] 0x48190400 JavaThread "http-8080-CometPoller-2" daemon [_thread_blocked, id=1860, stack(0x4a8a0000,0x4a8f0000)] 0x49938400 JavaThread "http-8080-CometPoller-1" daemon [_thread_blocked, id=2180, stack(0x4a850000,0x4a8a0000)] 0x48466400 JavaThread "http-8080-CometPoller-0" daemon [_thread_blocked, id=4472, stack(0x4a800000,0x4a850000)] 0x48191400 JavaThread "http-8080-Poller-7" daemon [_thread_blocked, id=4952, stack(0x4a7b0000,0x4a800000)] 0x482d1400 JavaThread "http-8080-Poller-6" daemon [_thread_blocked, id=6024, stack(0x4a760000,0x4a7b0000)] 0x4854cc00 JavaThread "http-8080-Poller-5" daemon [_thread_blocked, id=1760, stack(0x4a510000,0x4a560000)] 0x488ec400 JavaThread "http-8080-Poller-4" daemon [_thread_blocked, id=536, stack(0x4a4c0000,0x4a510000)] 0x4857ac00 JavaThread "http-8080-Poller-3" daemon [_thread_blocked, id=4748, stack(0x4a470000,0x4a4c0000)] 0x48bb2c00 JavaThread "http-8080-Poller-2" daemon [_thread_blocked, id=5408, stack(0x4a420000,0x4a470000)] 0x4880f400 JavaThread "http-8080-Poller-1" daemon [_thread_blocked, id=6036, stack(0x4a3d0000,0x4a420000)] 0x48006400 JavaThread "http-8080-Poller-0" daemon [_thread_blocked, id=2596, stack(0x4a380000,0x4a3d0000)] 0x483a8c00 JavaThread "ContainerBackgroundProcessor[StandardEngine[Catalina]]" daemon [_thread_blocked, id=4516, stack(0x4a330000,0x4a380000)] 0x48334c00 JavaThread "SessionWorkerThread" daemon [_thread_blocked, id=4936, stack(0x4a2e0000,0x4a330000)] 0x4883bc00 JavaThread "ConectionPoolMgrThread" [_thread_blocked, id=2768, stack(0x4a290000,0x4a2e0000)] 0x48306400 JavaThread "LogTraceThread" daemon [_thread_blocked, id=2988, stack(0x48fd0000,0x49020000)] 0x48019400 JavaThread "GC Daemon" daemon [_thread_blocked, id=5216, stack(0x48780000,0x487d0000)] 0x47ec2400 JavaThread "Thread-2" [_thread_in_native, id=2136, stack(0x48130000,0x48180000)] 0x47e96400 JavaThread "RMI TCP Accept-0" daemon [_thread_in_native, id=716, stack(0x48090000,0x480e0000)] 0x47b42800 JavaThread "Low Memory Detector" daemon [_thread_blocked, id=2820, stack(0x47de0000,0x47e30000)] 0x47b40c00 JavaThread "CompilerThread1" daemon [_thread_blocked, id=5856, stack(0x47d90000,0x47de0000)] 0x47b3a800 JavaThread "CompilerThread0" daemon [_thread_blocked, id=4260, stack(0x47d40000,0x47d90000)] 0x47b39000 JavaThread "Attach Listener" daemon [_thread_blocked, id=5456, stack(0x47cf0000,0x47d40000)] 0x47b36800 JavaThread "Signal Dispatcher" daemon [_thread_blocked, id=4804, stack(0x47ca0000,0x47cf0000)] 0x47b27800 JavaThread "Finalizer" daemon [_thread_blocked, id=4772, stack(0x47c50000,0x47ca0000)] 0x47b22c00 JavaThread "Reference Handler" daemon [_thread_blocked, id=5340, stack(0x47c00000,0x47c50000)] 0x005f6c00 JavaThread "main" [_thread_in_native, id=1068, stack(0x00550000,0x005a0000)] Other Threads: 0x47b20000 VMThread [stack: 0x47bb0000,0x47c00000] [id=2580] 0x47b6e400 WatcherThread [stack: 0x480e0000,0x48130000] [id=1452] VM state:not at safepoint (normal execution) VM Mutex/Monitor currently owned by a thread: None Heap def new generation total 39424K, used 17871K [0x036f0000, 0x061b0000, 0x18c40000) eden space 35072K, 50% used [0x036f0000, 0x04863f10, 0x05930000) from space 4352K, 0% used [0x05d70000, 0x05d70000, 0x061b0000) to space 4352K, 0% used [0x05930000, 0x05930000, 0x05d70000) tenured generation total 87424K, used 22368K [0x18c40000, 0x1e1a0000, 0x436f0000) the space 87424K, 25% used [0x18c40000, 0x1a218108, 0x1a218200, 0x1e1a0000) compacting perm gen total 24064K, used 24039K [0x436f0000, 0x44e70000, 0x476f0000) the space 24064K, 99% used [0x436f0000, 0x44e69c68, 0x44e69e00, 0x44e70000) No shared spaces configured. Dynamic libraries: 0x00400000 - 0x0040f000 	C:\apache-tomcat-6.0.26\bin\tomcat6.exe 0x7c800000 - 0x7c8c0000 	C:\WINDOWS\system32\ntdll.dll 0x77e40000 - 0x77f42000 	C:\WINDOWS\system32\kernel32.dll 0x77380000 - 0x77412000 	C:\WINDOWS\system32\USER32.dll 0x77c00000 - 0x77c49000 	C:\WINDOWS\system32\GDI32.dll 0x77f50000 - 0x77fec000 	C:\WINDOWS\system32\ADVAPI32.dll 0x77c50000 - 0x77cef000 	C:\WINDOWS\system32\RPCRT4.dll 0x77ba0000 - 0x77bfa000 	C:\WINDOWS\system32\MSVCRT.dll 0x7c8d0000 - 0x7d0d4000 	C:\WINDOWS\system32\SHELL32.dll 0x77da0000 - 0x77df2000 	C:\WINDOWS\system32\SHLWAPI.dll 0x77420000 - 0x77523000 	C:\WINDOWS\WinSxS\x86_Microsoft.Windows.Common-Controls_6595b64144ccf1df_6.0.3790.2778_x-ww_A8F04F11\comctl32.dll 0x6db70000 - 0x6df9c000 	C:\Program Files\Java\jdk1.6.0_20\jre\bin\server\jvm.dll 0x76aa0000 - 0x76acd000 	C:\WINDOWS\system32\WINMM.dll 0x7c360000 - 0x7c3b6000 	C:\WINDOWS\system32\MSVCR71.dll 0x6d860000 - 0x6d86c000 	C:\Program Files\Java\jdk1.6.0_20\jre\bin\verify.dll 0x6d3e0000 - 0x6d3ff000 	C:\Program Files\Java\jdk1.6.0_20\jre\bin\java.dll 0x6d340000 - 0x6d348000 	C:\Program Files\Java\jdk1.6.0_20\jre\bin\hpi.dll 0x76b70000 - 0x76b7b000 	C:\WINDOWS\system32\PSAPI.DLL 0x76f50000 - 0x76f63000 	C:\WINDOWS\system32\Secur32.dll 0x6d8a0000 - 0x6d8af000 	C:\Program Files\Java\jdk1.6.0_20\jre\bin\zip.dll 0x6d6c0000 - 0x6d6d3000 	C:\Program Files\Java\jdk1.6.0_20\jre\bin\net.dll 0x71c00000 - 0x71c17000 	C:\WINDOWS\system32\WS2_32.dll 0x71bf0000 - 0x71bf8000 	C:\WINDOWS\system32\WS2HELP.dll 0x71b20000 - 0x71b61000 	C:\WINDOWS\System32\mswsock.dll 0x76ed0000 - 0x76eff000 	C:\WINDOWS\system32\DNSAPI.dll 0x76f70000 - 0x76f77000 	C:\WINDOWS\System32\winrnr.dll 0x76f10000 - 0x76f3e000 	C:\WINDOWS\system32\WLDAP32.dll 0x76f80000 - 0x76f88000 	C:\WINDOWS\system32\rasadhlp.dll 0x6d610000 - 0x6d619000 	C:\Program Files\Java\jdk1.6.0_20\jre\bin\management.dll 0x68000000 - 0x6802f000 	C:\WINDOWS\system32\rsaenh.dll 0x5f270000 - 0x5f2c9000 	C:\WINDOWS\system32\hnetcfg.dll 0x71ae0000 - 0x71ae8000 	C:\WINDOWS\System32\wshtcpip.dll 0x485a0000 - 0x48677000 	C:\apache-tomcat-6.0.26\bin\tcnative-1.dll 0x4a070000 - 0x4a0c6000 	C:\Fischer\InterPostExpress\interpost\japi\japi.dll 0x4a0d0000 - 0x4a174000 	c:\Fischer\InterPostExpress\interpost\japi\tao40_32.dll 0x71bb0000 - 0x71bb9000 	C:\WINDOWS\system32\WSOCK32.dll 0x49040000 - 0x4904a000 	c:\Fischer\InterPostExpress\interpost\japi\IMPLODE.DLL VM Arguments: jvm_args: -Dcatalina.base=C:\apache-tomcat-6.0.26 -Dcatalina.home=C:\apache-tomcat-6.0.26 -Djava.endorsed.dirs=C:\apache-tomcat-6.0.26\endorsed -Djava.io.tmpdir=C:\apache-tomcat-6.0.26\temp -Djava.util.logging.manager=org.apache.juli.ClassLoaderLogManager -Djava.util.logging.config.file=C:\apache-tomcat-6.0.26\conf\logging.properties -Dcom.sun.management.jmxremote vfprintf -Xms128m -Xmx1024m java_command: &lt;unknown&gt; Launcher Type: generic Environment Variables: JAVA_HOME=C:\Program Files\Java\jdk1.6.0_20 PATH=C:\WINDOWS\system32;C:\WINDOWS;C:\WINDOWS\System32\Wbem;C:\Program Files\Diskeeper Corporation\Diskeeper\;C:\Program Files\Java\jdk1.6.0_20\bin;c:\Fischer\InterPostExpress\interpost\japi;c:\Fischer\InterPostExpress\uninstall OS=Windows_NT PROCESSOR_IDENTIFIER=x86 Family 6 Model 15 Stepping 8, GenuineIntel --------------- S Y S T E M --------------- OS: Windows Server 2003 family Build 3790 Service Pack 1 CPU:total 1 (4 cores per cpu, 1 threads per core) family 6 model 15 stepping 7, cmov, cx8, fxsr, mmx, sse, sse2, sse3, ssse3 Memory: 4k page, physical 3931596k(3039332k free), swap 5346784k(4717796k free) vm_info: Java HotSpot(TM) Server VM (16.3-b01) for windows-x86 JRE (1.6.0_20-b02), built on Apr 12 2010 13:46:10 by "java_re" with MS VC++ 7.1 (VS2003) time: Wed Jul 14 12:43:58 2010 elapsed time: 7651 seconds</column><column name="report_time">2010-07-15 06:34:41</column><column name="report_timestamp">1279190000</column><column name="status">resolved fixed</column><column name="commit">a3f3379</column><column name="commit_timestamp">1311060000</column><column name="files">java/org/apache/coyote/ajp/AjpAprProcessor.java</column><column name="result">225:java/org/apache/coyote/ajp/AjpAprProcessor.java</column></table><table name="tomcat"><column name="id">422</column><column name="bug_id">51503</column><column name="summary">Additional error checking required for connector port attribute (e.g. for port="")</column><column name="description">With 7.0.18 packaged as a candidate for release and finally unreleased, when I stop the Tomcat service (only 1 war deployed), the service takes a lot of time to stop and finally was killed by system. Having a look into the stderr log, I see it paused right after the folowing line : INFO: Stopping ProtocolHandler [http-apr-0] Then went into a slow loop and fill the log with these lines : 13 juil. 2011 14:30:30 org.apache.tomcat.util.net.AprEndpoint stopInternal ATTENTION: Acceptor thread [http-apr-0-Acceptor-0] failed to unlock. Forcing hard socket shutdown. 13 juil. 2011 14:30:31 org.apache.tomcat.util.net.AprEndpoint stopInternal ATTENTION: Acceptor thread [http-apr-0-Acceptor-0] failed to unlock. Forcing hard socket shutdown. 13 juil. 2011 14:30:32 org.apache.tomcat.util.net.AprEndpoint stopInternal ATTENTION: Acceptor thread [http-apr-0-Acceptor-0] failed to unlock. Forcing hard socket shutdown. etc. (about 30 times before it was killed) I think there was no such issue with 7.0.16.</column><column name="report_time">2011-07-13 12:40:11</column><column name="report_timestamp">1310580000</column><column name="status">resolved fixed</column><column name="commit">1e79993</column><column name="commit_timestamp">1311010000</column><column name="files">java/org/apache/catalina/connector/Connector.java</column><column name="result">10:java/org/apache/catalina/connector/Connector.java</column></table><table name="tomcat"><column name="id">423</column><column name="bug_id">51477</column><column name="summary">Support all protocol combinations in SSLProtocol of APR Connector</column><column name="description">We have used SSLProtocol="SSLv3+TLSv1" with the APR connectors in 6.0.x and 7.0.x successfully to support both SSLv3 and TLSv1 protocols exclusively (no SSLv2 support). The following openssl s_client connection tests demonstrate this functionality with 7.0.8: $ openssl s_client -connect eiger.middleware.vt.edu:443 -tls1 CONNECTED(00000003) ... SSL handshake has read 6158 bytes and written 293 bytes --- New, TLSv1/SSLv3, Cipher is DHE-RSA-AES256-SHA Server public key is 2048 bit Secure Renegotiation IS supported Compression: zlib compression Expansion: zlib compression SSL-Session: Protocol : TLSv1 ... $ openssl s_client -connect eiger.middleware.vt.edu:443 -ssl3 CONNECTED(00000003) ... SSL handshake has read 6027 bytes and written 319 bytes --- New, TLSv1/SSLv3, Cipher is DHE-RSA-AES256-SHA Server public key is 2048 bit Secure Renegotiation IS supported Compression: zlib compression Expansion: zlib compression SSL-Session: Protocol : SSLv3 ... $ openssl s_client -connect eiger.middleware.vt.edu:443 -ssl2 15389:error:140A90C4:SSL routines:SSL_CTX_new:null ssl method passed:ssl_lib.c:1453: Upon upgrading to Tomcat 7.0.16, which includes the fix for https://issues.apache.org/bugzilla/show_bug.cgi?id=51073, our desired protocol combination fails with the expected "unsupported protocol" message. Unfortunately, none of the officially supported strings mentioned at http://tomcat.apache.org/tomcat-7.0-doc/config/http.html#SSL%20Support provide the desired protocol support. In particular the protocol values are exclusive, where setting SSLProtocol="SSLv3" prevents TLSv1 connections and vice versa. The following s_client tests confirm this behavior: (7.0.16 with SSLProtocol="SSLv3") $ openssl s_client -connect eiger.middleware.vt.edu:443 -tls1 CONNECTED(00000003) 15696:error:1408F10B:SSL routines:SSL3_GET_RECORD:wrong version number:s3_pkt.c:293: $ openssl s_client -connect eiger.middleware.vt.edu:443 -ssl3 CONNECTED(00000003) ... SSL handshake has read 6027 bytes and written 319 bytes --- New, TLSv1/SSLv3, Cipher is DHE-RSA-AES256-SHA Server public key is 2048 bit Secure Renegotiation IS supported Compression: zlib compression Expansion: zlib compression SSL-Session: Protocol : SSLv3 ... (7.0.16 with SSLProtocol="TLSv1") $ openssl s_client -connect eiger.middleware.vt.edu:443 -tls1 CONNECTED(00000003) ... SSL handshake has read 6158 bytes and written 293 bytes --- New, TLSv1/SSLv3, Cipher is DHE-RSA-AES256-SHA Server public key is 2048 bit Secure Renegotiation IS supported Compression: zlib compression Expansion: zlib compression SSL-Session: Protocol : TLSv1 ... $ openssl s_client -connect eiger.middleware.vt.edu:443 -ssl3 CONNECTED(00000003) 15816:error:14094410:SSL routines:SSL3_READ_BYTES:sslv3 alert handshake failure:s3_pkt.c:1102:SSL alert number 40 15816:error:1409E0E5:SSL routines:SSL3_WRITE_BYTES:ssl handshake failure:s3_pkt.c:539:</column><column name="report_time">2011-07-05 16:53:25</column><column name="report_timestamp">1309900000</column><column name="status">resolved fixed</column><column name="commit">6ee5a22</column><column name="commit_timestamp">1310400000</column><column name="files">java/org/apache/tomcat/jni/Library.java
java/org/apache/tomcat/util/net/AprEndpoint.java</column><column name="result">1:java/org/apache/tomcat/jni/Library.java
2:java/org/apache/tomcat/util/net/AprEndpoint.java</column></table><table name="tomcat"><column name="id">424</column><column name="bug_id">46252</column><column name="summary">Tomcat access log doesn't support Unicode</column><column name="description">AccessLogValve, which is responsible for handling the access log uses FileWriter (that doesn't support Unicode). I guess that instantiating the writer like this would solve the case: writer = new PrintWriter(new OutputStreamWriter(new FileOutputStream(pathname), "UTF-8"), true);</column><column name="report_time">2008-11-20 11:18:55</column><column name="report_timestamp">1227200000</column><column name="status">resolved fixed</column><column name="commit">871dabd</column><column name="commit_timestamp">1310400000</column><column name="files">java/org/apache/catalina/valves/AccessLogValve.java</column><column name="result">1:java/org/apache/catalina/valves/AccessLogValve.java</column></table><table name="tomcat"><column name="id">425</column><column name="bug_id">51494</column><column name="summary">NPE in StandardContextValve.invoke() when a webapp is redeployed while a request is still being processed</column><column name="description">Hi, The following applies to Tomcat 7.0.18, but I couldn't select that version. When a request to a Servlet takes a long time to process, and the webapp is redeployed in that time (e.g. by replacing the .war file), the following NPE is thrown in org.apache.catalina.core.StandardContextValve.invoke(): 10.07.2011 03:27:05 org.apache.catalina.connector.CoyoteAdapter service SCHWERWIEGEND: An exception or error occurred in the container during the request processing java.lang.NullPointerException 	at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:183) 	at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:462) 	at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:164) 	at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:100) 	at org.apache.catalina.valves.AccessLogValve.invoke(AccessLogValve.java:754) 	at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:118) 	at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:404) 	at org.apache.coyote.http11.Http11AprProcessor.process(Http11AprProcessor.java:274) 	at org.apache.coyote.http11.Http11AprProtocol$Http11ConnectionHandler.process(Http11AprProtocol.java:237) 	at org.apache.tomcat.util.net.AprEndpoint$SocketProcessor.run(AprEndpoint.java:1731) 	at java.util.concurrent.ThreadPoolExecutor$Worker.runTask(ThreadPoolExecutor.java:886) 	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:908) 	at java.lang.Thread.run(Thread.java:662) This is because "context" attribute in StandardContextValve is null at that time. I could reproduce this behaviour on Windows 7 (32 bit) with Sun/Oracle Java 1.6.0_26, using the Windows x86 binaries of Tomcat 7.0.18 (from http://people.apache.org/~markt/dev/tomcat-7/v7.0.18/) with the included Tomcat Native 1.1.20. To reproduce: 0) Download and install Tomcat 7.0.18 (I used the windows x86 zip binaries). 1) Create a simple webapp with a servlet, that takes a long time to process requests, e.g. by calling Thread.sleep(). For example, I used: @WebServlet("/LongRequest") public class LongRequest extends HttpServlet { 	 protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { PrintWriter out = response.getWriter(); out.println("Start..."); 	out.flush(); try { Thread.sleep(20000); } catch (InterruptedException ex) { out.println(ex.toString()); } out.println("Finished."); out.close(); } } 2) Package the webapp as ".war" file, and make two versions of that file. 3) Deploy the first version to Tomcat by copying the .war file into the "webapps" directory. 4) Open a browser and make a GET request to the above servlet. 5) Now immediately replace the .war file in the webapp directory with the second version, so that Tomcat will undeploy the old version and deploy the new one. 5) After the request finishes, the NPE is thrown. I originally observed a NPE in StandardWrapperValve.invoke() with Tomcat 7.0.16 that I reported on the users list [1], which occured when the webapp was redeployed while a servlet was still processing a request. However, I couldn't reproduce the NPE in StandardWrapperValve.invoke(), but in StandardContextValve.invoke(). [1] http://markmail.org/message/2tumlfipaotkshst</column><column name="report_time">2011-07-10 01:56:23</column><column name="report_timestamp">1310280000</column><column name="status">resolved fixed</column><column name="commit">3a95db4</column><column name="commit_timestamp">1310390000</column><column name="files">java/org/apache/catalina/core/StandardContextValve.java</column><column name="result">1:java/org/apache/catalina/core/StandardContextValve.java</column></table><table name="tomcat"><column name="id">426</column><column name="bug_id">51475</column><column name="summary">GzipInterceptor#decompress is not completly implemented</column><column name="description">Created attachment 27254 Patch file fr GzipInterceptor While testing the GzipInterceptor I was wondering about the strange errors: "Unable to decompress byte contents". At first I thougt, I was using the interceptor in wrong order. But taking a look the source shows a TODO at method decompress: "Fix to create an automatically growing buffer." Because we have session properties which are compressed larger than 2048 bytes, the interceptor didn't work, in our case. I've created a patch. See my attachement.</column><column name="report_time">2011-07-05 09:58:12</column><column name="report_timestamp">1309870000</column><column name="status">resolved fixed</column><column name="commit">acc5619</column><column name="commit_timestamp">1309880000</column><column name="files">java/org/apache/catalina/tribes/group/interceptors/GzipInterceptor.java
test/org/apache/catalina/tribes/group/interceptors/TestGzipInterceptor.java</column><column name="result">1:java/org/apache/catalina/tribes/group/interceptors/GzipInterceptor.java
2:test/org/apache/catalina/tribes/group/interceptors/TestGzipInterceptor.java</column></table><table name="tomcat"><column name="id">427</column><column name="bug_id">51473</column><column name="summary">SecurityConfigset "package.definition" security property to "nullsun.,java.,..."</column><column name="description">Created attachment 27251 eclipse debug In method "org.apache.catalina.security.SecurityConfig.setSecurityProperty" when i enable the SecurityManager if 'properties' var equals "package.definition", Security.getProperty(properties) will return null, so Security.setProperty(properties, definition + packageList); will be Security.setProperty("package.definition", null + packageList); BTW: "package.access" security property no problem my jdk: java version "1.6.0_20" Java(TM) SE Runtime Environment (build 1.6.0_20-b02) Java HotSpot(TM) Client VM (build 16.3-b01, mixed mode, sharing)</column><column name="report_time">2011-07-05 05:37:09</column><column name="report_timestamp">1309860000</column><column name="status">resolved fixed</column><column name="commit">ec00abf</column><column name="commit_timestamp">1309850000</column><column name="files">java/org/apache/catalina/security/SecurityConfig.java</column><column name="result">1:java/org/apache/catalina/security/SecurityConfig.java</column></table><table name="tomcat"><column name="id">428</column><column name="bug_id">51467</column><column name="summary">usage of method run instead of start to start a thread</column><column name="description">In StandardContext method Thread#run is used. This is most probably a mistake, since a few lines below Thread#join is called to wait for the completion of the thread. So we could either remove the join and get rid of the thread by using just a runnable, or start the thread.</column><column name="report_time">2011-07-03 10:19:46</column><column name="report_timestamp">1309700000</column><column name="status">resolved fixed</column><column name="commit">eb98373</column><column name="commit_timestamp">1309780000</column><column name="files">java/org/apache/catalina/core/StandardContext.java</column><column name="result">1:java/org/apache/catalina/core/StandardContext.java</column></table><table name="tomcat"><column name="id">429</column><column name="bug_id">51466</column><column name="summary">typos in comments of HostManagerServlet</column><column name="description">Created attachment 27244 correct typos Comment of method stop says "start" and two instances of "if" are written as "of".</column><column name="report_time">2011-07-02 14:09:02</column><column name="report_timestamp">1309630000</column><column name="status">resolved fixed</column><column name="commit">6020bf6</column><column name="commit_timestamp">1309780000</column><column name="files">java/org/apache/catalina/manager/host/HostManagerServlet.java</column><column name="result">1:java/org/apache/catalina/manager/host/HostManagerServlet.java</column></table><table name="tomcat"><column name="id">430</column><column name="bug_id">51453</column><column name="summary">Requests to open URL that include an Authorization header do not reach servlet</column><column name="description">In Tomcat 7, I've noticed that a request to a URL that does not require authentication will get forwarded to the login page if the request contains an "Authorization" header. Our application expects these requests to be processed by the servlet. The servlet parses the Authorization header and takes appropriate action (possibly redirecting to the login page or allowing the request if the headers contain an acceptible token). This has worked in older versions of Tomcat. The relevant part of our web.xml looks like: &lt;security-constraint&gt; &lt;web-resource-collection&gt; &lt;web-resource-name&gt;open&lt;/web-resource-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;!-- several other url patterns --&gt; &lt;/web-resource-collection&gt; &lt;user-data-constraint&gt; &lt;transport-guarantee&gt;CONFIDENTIAL&lt;/transport-guarantee&gt; &lt;/user-data-constraint&gt; &lt;!-- Notice no auth-constraint element --&gt; &lt;/security-constraint&gt; I observed the behavior of org.apache.catalina.authenticator.AuthenticatorBase.invoke(), here's what I saw: The constraints variable contains a single constraint that matches the security constraint from our web.xml above. On line 520, authRequired is set to true because of the presence of the Authorization header. The authenticate() call on line 535 fails and redirects to the login page.</column><column name="report_time">2011-06-30 14:10:50</column><column name="report_timestamp">1309460000</column><column name="status">resolved fixed</column><column name="commit">df9bc17</column><column name="commit_timestamp">1309450000</column><column name="files">java/org/apache/catalina/authenticator/AuthenticatorBase.java</column><column name="result">2:java/org/apache/catalina/authenticator/AuthenticatorBase.java</column></table><table name="tomcat"><column name="id">431</column><column name="bug_id">51088</column><column name="summary">ArrayIndexOutOfBoundsException from org.apache.el.parser.JJTELParserState</column><column name="description">I found the following ArrayIndexOutOfBoundsException in my logfile. It occurred directly after login into my webApp without any further user interaction. Unfortunately it is not reproducible at all. I am not sure whether Jasper is the right component. However the class JJTELParserState is in the jasper-el.jar. Environment: Tomcat 6.0.32 Facelets 1.1.14 Myfaces 1.2.9 SCHWERWIEGEND: Error Rendering View[/facelets/myview.xhtml] java.lang.ArrayIndexOutOfBoundsException: -1 	at java.util.ArrayList.remove(ArrayList.java:390) 	at org.apache.el.parser.JJTELParserState.closeNodeScope(JJTELParserState.java:108) 	at org.apache.el.parser.ELParser.CompositeExpression(ELParser.java:74) 	at org.apache.el.lang.ExpressionBuilder.createNodeInternal(ExpressionBuilder.java:115) 	at org.apache.el.lang.ExpressionBuilder.build(ExpressionBuilder.java:172) 	at org.apache.el.lang.ExpressionBuilder.createValueExpression(ExpressionBuilder.java:216) 	at org.apache.el.ExpressionFactoryImpl.createValueExpression(ExpressionFactoryImpl.java:68) 	at com.sun.facelets.el.ELText$ELTextVariable.apply(ELText.java:161) 	at com.sun.facelets.compiler.AttributeInstruction.apply(AttributeInstruction.java:60) 	at com.sun.facelets.compiler.UIInstructionHandler.apply(UIInstructionHandler.java:95) 	at com.sun.facelets.tag.CompositeFaceletHandler.apply(CompositeFaceletHandler.java:47) 	at com.sun.facelets.tag.jstl.core.IfHandler.apply(IfHandler.java:54) 	at com.sun.facelets.tag.CompositeFaceletHandler.apply(CompositeFaceletHandler.java:47) 	at com.sun.facelets.tag.jsf.ComponentHandler.applyNextHandler(ComponentHandler.java:360) 	at com.sun.facelets.tag.jsf.ComponentHandler.apply(ComponentHandler.java:190) 	at com.sun.facelets.tag.CompositeFaceletHandler.apply(CompositeFaceletHandler.java:47) 	at com.sun.facelets.tag.jsf.ComponentHandler.applyNextHandler(ComponentHandler.java:360) 	at com.sun.facelets.tag.jsf.ComponentHandler.apply(ComponentHandler.java:190) 	at com.sun.facelets.tag.CompositeFaceletHandler.apply(CompositeFaceletHandler.java:47) 	at com.sun.facelets.tag.jsf.ComponentHandler.applyNextHandler(ComponentHandler.java:360) 	at org.apache.myfaces.custom.aliasbean.AliasBeansScopeTagHandler.applyNextHandler(AliasBeansScopeTagHandler.java:52) 	at com.sun.facelets.tag.jsf.ComponentHandler.apply(ComponentHandler.java:190) 	at com.sun.facelets.tag.CompositeFaceletHandler.apply(CompositeFaceletHandler.java:47) 	at com.sun.facelets.tag.ui.CompositionHandler.apply(CompositionHandler.java:124) 	at com.sun.facelets.compiler.NamespaceHandler.apply(NamespaceHandler.java:49) 	at com.sun.facelets.compiler.EncodingHandler.apply(EncodingHandler.java:39) 	at com.sun.facelets.impl.DefaultFacelet.include(DefaultFacelet.java:248) 	at com.sun.facelets.impl.DefaultFacelet.include(DefaultFacelet.java:294) 	at com.sun.facelets.impl.DefaultFacelet.include(DefaultFacelet.java:273) 	at com.sun.facelets.impl.DefaultFaceletContext.includeFacelet(DefaultFaceletContext.java:140) 	at com.sun.facelets.tag.ui.IncludeHandler.apply(IncludeHandler.java:66) 	at com.sun.facelets.tag.ui.DefineHandler.applyDefinition(DefineHandler.java:64) 	at com.sun.facelets.tag.ui.CompositionHandler.apply(CompositionHandler.java:136) 	at com.sun.facelets.impl.DefaultFaceletContext$TemplateManager.apply(DefaultFaceletContext.java:337) 	at com.sun.facelets.impl.DefaultFaceletContext.includeDefinition(DefaultFaceletContext.java:307) 	at com.sun.facelets.tag.ui.InsertHandler.apply(InsertHandler.java:68) 	at com.sun.facelets.tag.CompositeFaceletHandler.apply(CompositeFaceletHandler.java:47) 	at com.sun.facelets.tag.jsf.ComponentHandler.applyNextHandler(ComponentHandler.java:360) 	at com.sun.facelets.tag.jsf.ComponentHandler.apply(ComponentHandler.java:190) 	at com.sun.facelets.tag.CompositeFaceletHandler.apply(CompositeFaceletHandler.java:47) 	at com.sun.facelets.tag.jsf.ComponentHandler.applyNextHandler(ComponentHandler.java:360) 	at com.sun.facelets.tag.jsf.ComponentHandler.apply(ComponentHandler.java:190) 	at com.sun.facelets.tag.CompositeFaceletHandler.apply(CompositeFaceletHandler.java:47) 	at com.sun.facelets.tag.ui.CompositionHandler.apply(CompositionHandler.java:124) 	at com.sun.facelets.compiler.NamespaceHandler.apply(NamespaceHandler.java:49) 	at com.sun.facelets.compiler.EncodingHandler.apply(EncodingHandler.java:39) 	at com.sun.facelets.impl.DefaultFacelet.include(DefaultFacelet.java:248) 	at com.sun.facelets.impl.DefaultFacelet.include(DefaultFacelet.java:294) 	at com.sun.facelets.impl.DefaultFacelet.include(DefaultFacelet.java:273) 	at com.sun.facelets.impl.DefaultFaceletContext.includeFacelet(DefaultFaceletContext.java:140) 	at com.sun.facelets.tag.ui.CompositionHandler.apply(CompositionHandler.java:116) 	at com.sun.facelets.compiler.NamespaceHandler.apply(NamespaceHandler.java:49) 	at com.sun.facelets.compiler.EncodingHandler.apply(EncodingHandler.java:39) 	at com.sun.facelets.impl.DefaultFacelet.apply(DefaultFacelet.java:95) 	at com.sun.facelets.FaceletViewHandler.buildView(FaceletViewHandler.java:596) 	at com.sun.facelets.FaceletViewHandler.renderView(FaceletViewHandler.java:651) 	at org.ajax4jsf.application.ViewHandlerWrapper.renderView(ViewHandlerWrapper.java:100) 	at org.ajax4jsf.application.AjaxViewHandler.renderView(AjaxViewHandler.java:176) 	at org.apache.myfaces.lifecycle.RenderResponseExecutor.execute(RenderResponseExecutor.java:41) 	at org.apache.myfaces.lifecycle.LifecycleImpl.render(LifecycleImpl.java:140) 	at org.apache.myfaces.custom.ppr.PPRLifecycleWrapper.render(PPRLifecycleWrapper.java:84) 	at javax.faces.webapp.FacesServlet.service(FacesServlet.java:187) 	at com.foo..client.web.servlets.FacesServletWrapper.service(FacesServletWrapper.java:125) 	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:290) 	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:206) 	at org.ajax4jsf.webapp.BaseXMLFilter.doXmlFilter(BaseXMLFilter.java:206) 	at org.ajax4jsf.webapp.BaseFilter.handleRequest(BaseFilter.java:290) 	at org.ajax4jsf.webapp.BaseFilter.processUploadsAndHandleRequest(BaseFilter.java:388) 	at org.ajax4jsf.webapp.BaseFilter.doFilter(BaseFilter.java:515) 	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:235) 	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:206) 	at org.apache.myfaces.webapp.filter.ExtensionsFilter.doFilter(ExtensionsFilter.java:392) 	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:235) 	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:206) 	at com.foo..client.web.filters.LoginFilter.doFilter(LoginFilter.java:219) 	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:235) 	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:206) 	at com.foo..client.web.filters.CacheFilter.doFilter(CacheFilter.java:110) 	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:235) 	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:206) 	at com.foo..client.web.filters.EncodingFilter.doFilter(EncodingFilter.java:54) 	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:235) 	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:206) 	at com.foo..client.web.filters.TimerFilter.doFilter(TimerFilter.java:80) 	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:235) 	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:206) 	at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:233) 	at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:191) 	at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:470) 	at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:127) 	at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:102) 	at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:109) 	at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:298) 	at org.apache.coyote.http11.Http11Processor.process(Http11Processor.java:859) 	at org.apache.coyote.http11.Http11Protocol$Http11ConnectionHandler.process(Http11Protocol.java:588) 	at org.apache.tomcat.util.net.JIoEndpoint$Worker.run(JIoEndpoint.java:489) 	at java.lang.Thread.run(Thread.java:662)</column><column name="report_time">2011-04-20 05:42:42</column><column name="report_timestamp">1303290000</column><column name="status">resolved wontfix</column><column name="commit">92af111</column><column name="commit_timestamp">1309360000</column><column name="files">java/org/apache/el/lang/ExpressionBuilder.java</column><column name="result">37:java/org/apache/el/lang/ExpressionBuilder.java</column></table><table name="tomcat"><column name="id">432</column><column name="bug_id">51436</column><column name="summary">ServletRequestListener fails to access request parameters when an Expect-Header is sent</column><column name="description">Created attachment 27209 Acknowledge a request before any listeners are called. I wrote a ServletRequestListener that tries to access a Request Parameter in requestInitialized(.) with: sre.getServletRequest().getParameter("x"); This works fine with POST-Requests. But when I send the "Expect: 100-continue" HTTP Header the Listener hangs, waiting for the Request Body. See the stacktrace at: http://pastebin.com/r2J0P3qx This happens because the Request isn't acknowledged and thus the body (containing the parameters) isn't send. The attached patch fixes this by acknowledging the request before the listeners are called. With the patch applied everything works fine and all tests pass.</column><column name="report_time">2011-06-27 09:56:45</column><column name="report_timestamp">1309180000</column><column name="status">resolved fixed</column><column name="commit">6dffc54</column><column name="commit_timestamp">1309280000</column><column name="files">java/org/apache/catalina/core/StandardContextValve.java
java/org/apache/catalina/core/StandardWrapperValve.java</column><column name="result">13:java/org/apache/catalina/core/StandardContextValve.java
375:java/org/apache/catalina/core/StandardWrapperValve.java</column></table><table name="tomcat"><column name="id">433</column><column name="bug_id">50353</column><column name="summary">Calling asyncContext.getResponse() returns null after async timeout</column><column name="description">If the async thread calls asyncContext.getResponse() after the async timeout, it gets a null reference. In the following example, it leads to a NPE. The servlet spec is not very clear on the behavior to adopt after a timeout, but I don't think null should be returned. Maybe an IllegalStateException instead ? It seems to be the case if complete() is called after the timeout. package test; import java.io.IOException; import java.io.PrintWriter; import javax.servlet.AsyncContext; import javax.servlet.AsyncEvent; import javax.servlet.AsyncListener; import javax.servlet.ServletException; import javax.servlet.ServletResponse; import javax.servlet.annotation.WebServlet; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; /** * Servlet implementation class MyServlet */ @WebServlet(value = "/MyServlet", asyncSupported = true) public class MyServlet extends HttpServlet implements AsyncListener { 	private static final long serialVersionUID = 1L; 	protected void doGet(HttpServletRequest request, 			HttpServletResponse response) throws ServletException, IOException { 		final AsyncContext asyncContext = request.startAsync(request, response); 		asyncContext.addListener(this); 		asyncContext.setTimeout(10*1000); 		asyncContext.start(new Runnable() { 			@Override 			public void run() { 				System.out.println("Entering async thread"); 				try { 					Thread.sleep(20 * 1000); 					System.out.println("&lt;Asyncthread&gt; about to write response"); 					ServletResponse response2 = asyncContext.getResponse(); 					PrintWriter writer = response2.getWriter(); 					writer.write("Hello world"); 					System.out.println("&lt;Asyncthread&gt; about to complete"); 					asyncContext.complete(); 				} catch (Exception e) { 					e.printStackTrace(); 				} 			} 		}); 	} 	@Override 	public void onComplete(AsyncEvent evt) throws IOException { 		System.out.println("onComplete " + evt); 	} 	@Override 	public void onError(AsyncEvent evt) throws IOException { 		System.out.println("onError " + evt); 	} 	@Override 	public void onStartAsync(AsyncEvent evt) throws IOException { 		System.out.println("onStartAsync " + evt); 	} 	@Override 	public void onTimeout(AsyncEvent evt) throws IOException { 		System.out.println("onTimeout " + evt); 		evt.getAsyncContext().getResponse().getWriter().write("Timed out"); 		evt.getAsyncContext().complete(); 	} }</column><column name="report_time">2010-11-27 17:45:41</column><column name="report_timestamp">1290900000</column><column name="status">resolved fixed</column><column name="commit">d36c5d9</column><column name="commit_timestamp">1309280000</column><column name="files">java/org/apache/catalina/core/AsyncContextImpl.java</column><column name="result">6:java/org/apache/catalina/core/AsyncContextImpl.java</column></table><table name="tomcat"><column name="id">434</column><column name="bug_id">51447</column><column name="summary">Session type changes from Backup to Primary</column><column name="description">Created attachment 27223 patch Steps to reproduce: (1) Start 3 Tomcat instances that are using BackupManager. (2) Run 3 HTMLManagers corresponding to each node. (3) Run web application that has distributable in its web.xml. (4) Click the link of the number of sessions for this application. (5) If the displayed session type is Backup, click the link of session id. And return to sessions list page soon. Then, the session type change to Primary. When the session detail page is displayed, getSessionForNameAndId() calls ctxt.getManager().findSession(), and findSession() calls session.get(id). If the cluster is using BackupManager, "session" is instance of LazyReplicatedMap. And LazyReplicatedMap.get() set session type to "primary". I thought the solutions of this issue. (A) Not use findSession(). Retrieve session information from local map. -&gt; see attached patch Or (B) Write the note as follows to the sessions list page. "If you click the backup type's sessionid, then the type change to primary." Regards.</column><column name="report_time">2011-06-28 11:15:18</column><column name="report_timestamp">1309270000</column><column name="status">resolved fixed</column><column name="commit">3d85a85</column><column name="commit_timestamp">1309280000</column><column name="files">java/org/apache/catalina/manager/HTMLManagerServlet.java</column><column name="result">14:java/org/apache/catalina/manager/HTMLManagerServlet.java</column></table><table name="tomcat"><column name="id">435</column><column name="bug_id">51418</column><column name="summary">Allow more flexibility in adding webapps to org.apache.catalina.startup.Tomcat</column><column name="description">Created attachment 27194 A patch to Tomcat.java as described. the Tomcat.addWebapp all create a context, set up the default realm, and set up the surrogate global web.xml lifecycle listener. They differ according to allowing more or less specific configuration of the new webapp. At the end, they add the new context to the host. Once the container is running, the act of calling addChild starts it. Some configuration steps have to precede 'start' -- for example, setting the loader. Thus, in a complex case, the user needs to take more control of the process. As things are today, this requires subclassing the Tomcat class and then copying code from the four-arg addWebapp. The patch provided here allows non-subclasses to take complete control of the process. It accomplishes this by providing methods to obtain three things that are otherwise buried in the Tomcat class: the default in-memory realm, the listener that serves as a surrogate global web.xml, and a dummy pathname to allow the listener to work without conflicts. Given these accessors, a user can simple create a the context (and its ContextConfig) and configure it to their heart's content, and then pass it to the addChild method of a Host.</column><column name="report_time">2011-06-22 15:54:00</column><column name="report_timestamp">1308770000</column><column name="status">resolved fixed</column><column name="commit">f83c07e</column><column name="commit_timestamp">1308770000</column><column name="files">java/org/apache/catalina/startup/Tomcat.java</column><column name="result">1:java/org/apache/catalina/startup/Tomcat.java</column></table><table name="tomcat"><column name="id">436</column><column name="bug_id">51403</column><column name="summary">Avoid NullPointerException in JULI FileHandler if formatter is misconfigured</column><column name="description">If formatter assigned to org.apache.juli.FileHandler in logging.properties is misconfigured and fails to load, the FileHandler starts without formatter and fails with an NPE later. To reproduce: assign some bogus value to 1catalina.org.apache.juli.FileHandler.formatter When Tomcat starts, the following will be printed at the console: java.util.logging.ErrorManager: 4 java.lang.NullPointerException at org.apache.juli.FileHandler.openWriter(FileHandler.java:377) at org.apache.juli.FileHandler.&lt;init&gt;(FileHandler.java:99) at org.apache.juli.FileHandler.&lt;init&gt;(FileHandler.java:90) I think we can be more tolerant to this configuration error and fall back to the default formatter. I will commit a fix shortly.</column><column name="report_time">2011-06-21 13:13:00</column><column name="report_timestamp">1308680000</column><column name="status">resolved fixed</column><column name="commit">f2dd57b</column><column name="commit_timestamp">1308660000</column><column name="files">java/org/apache/juli/FileHandler.java</column><column name="result">1:java/org/apache/juli/FileHandler.java</column></table><table name="tomcat"><column name="id">437</column><column name="bug_id">51401</column><column name="summary">java.lang.IllegalArgumentException: &lt;session-config&gt; element is limited to 1 occurrence</column><column name="description">Created attachment 27188 logfile I got following Exception when I started Tomcat. I hadn't changed any configuration. ----- java.lang.IllegalArgumentException: &lt;session-config&gt; element is limited to 1 occurrence at org.apache.catalina.startup.SetSessionConfig.begin(WebRuleSet.java:722) at org.apache.tomcat.util.digester.Digester.startElement(Digester.java:1282) at com.sun.org.apache.xerces.internal.parsers.AbstractSAXParser.startElement(AbstractSAXParser.java:501) at com.sun.org.apache.xerces.internal.impl.XMLDocumentFragmentScannerImpl.scanStartElement(XMLDocumentFragmentScannerImpl.java:1363) at com.sun.org.apache.xerces.internal.impl.XMLDocumentFragmentScannerImpl$FragmentContentDriver.next(XMLDocumentFragmentScannerImpl.java:2755) at com.sun.org.apache.xerces.internal.impl.XMLDocumentScannerImpl.next(XMLDocumentScannerImpl.java:648) at com.sun.org.apache.xerces.internal.impl.XMLDocumentFragmentScannerImpl.scanDocument(XMLDocumentFragmentScannerImpl.java:511) at com.sun.org.apache.xerces.internal.parsers.XML11Configuration.parse(XML11Configuration.java:808) at com.sun.org.apache.xerces.internal.parsers.XML11Configuration.parse(XML11Configuration.java:737) at com.sun.org.apache.xerces.internal.parsers.XMLParser.parse(XMLParser.java:119) at com.sun.org.apache.xerces.internal.parsers.AbstractSAXParser.parse(AbstractSAXParser.java:1205) at com.sun.org.apache.xerces.internal.jaxp.SAXParserImpl$JAXPSAXParser.parse(SAXParserImpl.java:522) at org.apache.tomcat.util.digester.Digester.parse(Digester.java:1543) at org.apache.catalina.startup.ContextConfig.parseWebXml(ContextConfig.java:1744) at org.apache.catalina.startup.ContextConfig.webConfig(ContextConfig.java:1241) at org.apache.catalina.startup.ContextConfig.configureStart(ContextConfig.java:885) at org.apache.catalina.startup.ContextConfig.lifecycleEvent(ContextConfig.java:344) at org.apache.catalina.util.LifecycleSupport.fireLifecycleEvent(LifecycleSupport.java:119) at org.apache.catalina.util.LifecycleBase.fireLifecycleEvent(LifecycleBase.java:89) at org.apache.catalina.core.StandardContext.startInternal(StandardContext.java:5103) at org.apache.catalina.util.LifecycleBase.start(LifecycleBase.java:145) at org.apache.catalina.core.ContainerBase.addChildInternal(ContainerBase.java:812) at org.apache.catalina.core.ContainerBase.addChild(ContainerBase.java:787) at org.apache.catalina.core.StandardHost.addChild(StandardHost.java:607) at org.apache.catalina.startup.HostConfig.deployWAR(HostConfig.java:932) at org.apache.catalina.startup.HostConfig.deployWARs(HostConfig.java:723) at org.apache.catalina.startup.HostConfig.deployApps(HostConfig.java:470) at org.apache.catalina.startup.HostConfig.start(HostConfig.java:1322) at org.apache.catalina.startup.HostConfig.lifecycleEvent(HostConfig.java:311) at org.apache.catalina.util.LifecycleSupport.fireLifecycleEvent(LifecycleSupport.java:119) at org.apache.catalina.util.LifecycleBase.fireLifecycleEvent(LifecycleBase.java:89) at org.apache.catalina.util.LifecycleBase.setStateInternal(LifecycleBase.java:379) at org.apache.catalina.util.LifecycleBase.setState(LifecycleBase.java:324) at org.apache.catalina.core.ContainerBase.startInternal(ContainerBase.java:1041) at org.apache.catalina.core.StandardHost.startInternal(StandardHost.java:774) at org.apache.catalina.util.LifecycleBase.start(LifecycleBase.java:145) at org.apache.catalina.core.ContainerBase.startInternal(ContainerBase.java:1033) at org.apache.catalina.core.StandardEngine.startInternal(StandardEngine.java:291) at org.apache.catalina.util.LifecycleBase.start(LifecycleBase.java:145) at org.apache.catalina.core.StandardService.startInternal(StandardService.java:443) at org.apache.catalina.util.LifecycleBase.start(LifecycleBase.java:145) at org.apache.catalina.core.StandardServer.startInternal(StandardServer.java:727) at org.apache.catalina.util.LifecycleBase.start(LifecycleBase.java:145) at org.apache.catalina.startup.Catalina.start(Catalina.java:620) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25) at java.lang.reflect.Method.invoke(Method.java:597) at org.apache.catalina.startup.Bootstrap.start(Bootstrap.java:321) at org.apache.catalina.startup.Bootstrap.main(Bootstrap.java:449) --- This exception occurs at the applications that contain &lt;session-config&gt; or &lt;login-config&gt; in the web.xml. When I reverted the code back to the revision 1137764, I got no exception. Regards.</column><column name="report_time">2011-06-21 01:36:08</column><column name="report_timestamp">1308630000</column><column name="status">resolved fixed</column><column name="commit">7c274bb</column><column name="commit_timestamp">1308650000</column><column name="files">java/org/apache/catalina/startup/WebRuleSet.java</column><column name="result">4:java/org/apache/catalina/startup/WebRuleSet.java</column></table><table name="tomcat"><column name="id">438</column><column name="bug_id">51396</column><column name="summary">Embedding class cannot launch a webapp with a jsp servlet</column><column name="description">https://github.com/bimargulies/Tomcat-Solr-Test-Case is a test case. It creates an instance of Tomcat and then adds a webapp from Apache Solr. This webapp has 'jsp' servlets. The code crashes, because the implicit default web.xml used in this case does not include a servlet named jsp, resulting in the following backtrace. 2011-06-20 12:56:24,598 [Embedded Tomcat] INFO org.apache.catalina.startup.ContextConfig - No global web.xml found Exception in thread "Embedded Tomcat" java.lang.NullPointerException 	at org.apache.catalina.startup.ContextConfig.convertJsp(ContextConfig.java:1379) 	at org.apache.catalina.startup.ContextConfig.convertJsps(ContextConfig.java:1358) 	at org.apache.catalina.startup.ContextConfig.webConfig(ContextConfig.java:1349) 	at org.apache.catalina.startup.ContextConfig.configureStart(ContextConfig.java:881) 	at org.apache.catalina.startup.ContextConfig.lifecycleEvent(ContextConfig.java:316) 	at org.apache.catalina.util.LifecycleSupport.fireLifecycleEvent(LifecycleSupport.java:119) 	at org.apache.catalina.util.LifecycleBase.fireLifecycleEvent(LifecycleBase.java:89) 	at org.apache.catalina.core.StandardContext.startInternal(StandardContext.java:5103) 	at org.apache.catalina.util.LifecycleBase.start(LifecycleBase.java:145) 	at org.apache.catalina.core.ContainerBase.addChildInternal(ContainerBase.java:812) 	at org.apache.catalina.core.ContainerBase.addChild(ContainerBase.java:787) 	at org.apache.catalina.core.StandardHost.addChild(StandardHost.java:607) 	at org.apache.catalina.startup.Tomcat.addWebapp(Tomcat.java:509) 	at org.apache.catalina.startup.Tomcat.addWebapp(Tomcat.java:483) 	at org.apache.catalina.startup.Tomcat.addWebapp(Tomcat.java:171) 	at org.apache.tomcat.tc.solrWebapp.LaunchWithSolr.tryToAddSolr(LaunchWithSolr.java:111) 	at org.apache.tomcat.tc.solrWebapp.LaunchWithSolr.access$1(LaunchWithSolr.java:106) 	at org.apache.tomcat.tc.solrWebapp.LaunchWithSolr$1.run(LaunchWithSolr.java:91)</column><column name="report_time">2011-06-20 17:02:09</column><column name="report_timestamp">1308600000</column><column name="status">resolved fixed</column><column name="commit">f75418b</column><column name="commit_timestamp">1308610000</column><column name="files">java/org/apache/catalina/startup/ContextConfig.java
test/org/apache/catalina/startup/TestContextConfig.java</column><column name="result">11:java/org/apache/catalina/startup/ContextConfig.java
259:test/org/apache/catalina/startup/TestContextConfig.java</column></table><table name="tomcat"><column name="id">439</column><column name="bug_id">49165</column><column name="summary">Enhancement - Allow %{TIME_FORMAT}t As Configuration for AccessLogValve</column><column name="description">AccessLogValve.DateAndTimeElement() can currently be configured only with %t which output the date/time in Common Log Format. By adding the capability to configure with %{TIME_FORMAT}, one could override (at least) the timeFormatter property of the class ... or it could go further and allow overriding of all the [day, month, year, time]Formatter properties. Justification for enhancement: The log currenlty provide the ability to log processing time in millis (via %T), but an accurate log of the order in which requests are received cannot be determined without the capabilities of logging a a format with milliseconds using the %t element.</column><column name="report_time">2010-04-21 14:20:08</column><column name="report_timestamp">1271870000</column><column name="status">resolved fixed</column><column name="commit">7d6c439</column><column name="commit_timestamp">1308480000</column><column name="files">java/org/apache/catalina/valves/AccessLogValve.java</column><column name="result">1:java/org/apache/catalina/valves/AccessLogValve.java</column></table><table name="tomcat"><column name="id">440</column><column name="bug_id">51386</column><column name="summary">@HandlingType not correctly handled at server startup leads to incorrect classes set passed to initializers</column><column name="description">The following code in org.apache.catalina.startup.ContextConfig.checkHandlesTypes(JavaClass) looks very buggy : boolean match = false; for (Map.Entry&lt;Class&lt;?&gt;, Set&lt;ServletContainerInitializer&gt;&gt; entry : typeInitializerMap.entrySet()) { if (entry.getKey().isAnnotation()) { AnnotationEntry[] annotationEntries = javaClass.getAnnotationEntries(); for (AnnotationEntry annotationEntry : annotationEntries) { if (entry.getKey().getName().equals( getClassName(annotationEntry.getAnnotationType()))) { match = true; break; } } } else if (entry.getKey().isAssignableFrom(clazz)) { match = true; } if (match) { for (ServletContainerInitializer sci : entry.getValue()) { initializerClassMap.get(sci).add(clazz); } } } Shouldn't "match" variable be reset to false at each iteration ? As it is for now, my SpringServletContainerInitializer (3.1M2), handling only WebApplicationInitializers, will finally receive a huge set of various applicative classes, starting from the first class parsed matching any type handled by any previously parsed ServletContainerInitializer !!! http://svn.apache.org/repos/asf/tomcat/trunk/java/org/apache/catalina/startup/ContextConfig.java</column><column name="report_time">2011-06-16 14:12:27</column><column name="report_timestamp">1308250000</column><column name="status">resolved fixed</column><column name="commit">9f8b983</column><column name="commit_timestamp">1308240000</column><column name="files">java/org/apache/catalina/startup/ContextConfig.java
test/org/apache/catalina/startup/TestContextConfigAnnotation.java</column><column name="result">6:java/org/apache/catalina/startup/ContextConfig.java
307:test/org/apache/catalina/startup/TestContextConfigAnnotation.java</column></table><table name="tomcat"><column name="id">441</column><column name="bug_id">48956</column><column name="summary">SSI regular expressions not working</column><column name="description">I was trying to use Tomcat SSI filter: http://tomcat.apache.org/tomcat-6.0-doc/ssi-howto.html While it generally works, I have discovered that SSI regular expressions are not supported. As much as I can see from tomcat source code, this feature is just not implemented. For example, those expressions always return "did not match": &lt;!--#if expr="abc = /abc/" --&gt;matches&lt;!--#else --&gt;did not match&lt;!--#endif --&gt; &lt;!--#if expr="abc = /[a-z]/" --&gt;matches&lt;!--#else --&gt;did not match&lt;!--#endif --&gt; This bug is a showstopper for me, because in my application I need SSI regular expressions support.</column><column name="report_time">2010-03-22 11:48:29</column><column name="report_timestamp">1269270000</column><column name="status">resolved fixed</column><column name="commit">874048a</column><column name="commit_timestamp">1308180000</column><column name="files">java/org/apache/catalina/ssi/ExpressionParseTree.java</column><column name="result">3:java/org/apache/catalina/ssi/ExpressionParseTree.java</column></table><table name="tomcat"><column name="id">442</column><column name="bug_id">43538</column><column name="summary">[patch] Show the hostname and IP address in the manager webapp</column><column name="description">We have an environment with a couple of load-balanced Tomcats fronted by httpd. If someone accesses the manager application through the load-balancer, they will not know which of the load-balanced Tomcats they end up at. In these situations, and others as well, it would be nice if the manager could tell the hostname and IP address of the machine it is running on.</column><column name="report_time">2007-10-02 14:42:39</column><column name="report_timestamp">1191350000</column><column name="status">resolved fixed</column><column name="commit">2b8e6cf</column><column name="commit_timestamp">1308180000</column><column name="files">java/org/apache/catalina/manager/Constants.java
java/org/apache/catalina/manager/HTMLManagerServlet.java
java/org/apache/catalina/manager/StatusManagerServlet.java</column><column name="result">5:java/org/apache/catalina/manager/HTMLManagerServlet.java
209:java/org/apache/catalina/manager/Constants.java
278:java/org/apache/catalina/manager/StatusManagerServlet.java</column></table><table name="tomcat"><column name="id">443</column><column name="bug_id">51306</column><column name="summary">NPE in DeltaRequest.writeExternal(DeltaRequest.java:267) when handling remote session expiration</column><column name="description">Occasionally we got errors like following: ====== 2011-05-30 03:40:17,697 ERROR [pool-1-thread-2] (org.apache.catalina.ha.session.DeltaManager) Manager [localhost#]: Unable to receive message through TCP channel java.lang.NullPointerException at java.io.ObjectOutputStream$BlockDataOutputStream.getUTFLength(ObjectOutputStream.java:2106) at java.io.ObjectOutputStream$BlockDataOutputStream.writeUTF(ObjectOutputStream.java:1977) at java.io.ObjectOutputStream.writeUTF(ObjectOutputStream.java:849) at org.apache.catalina.ha.session.DeltaRequest.writeExternal(DeltaRequest.java:267) at org.apache.catalina.ha.session.DeltaRequest.serialize(DeltaRequest.java:287) at org.apache.catalina.ha.session.DeltaManager.serializeDeltaRequest(DeltaManager.java:716) at org.apache.catalina.ha.session.DeltaManager.requestCompleted(DeltaManager.java:1224) at org.apache.catalina.ha.session.DeltaSession.expire(DeltaSession.java:403) at org.apache.catalina.ha.session.DeltaManager.handleSESSION_EXPIRED(DeltaManager.java:1546) at org.apache.catalina.ha.session.DeltaManager.messageReceived(DeltaManager.java:1452) at org.apache.catalina.ha.session.DeltaManager.messageDataReceived(DeltaManager.java:1173) at org.apache.catalina.ha.session.ClusterSessionListener.messageReceived(ClusterSessionListener.java:92) at org.apache.catalina.ha.tcp.SimpleTcpCluster.messageReceived(SimpleTcpCluster.java:901) at org.apache.catalina.ha.tcp.SimpleTcpCluster.messageReceived(SimpleTcpCluster.java:882) at org.apache.catalina.tribes.group.GroupChannel.messageReceived(GroupChannel.java:269) at org.apache.catalina.tribes.group.ChannelInterceptorBase.messageReceived(ChannelInterceptorBase.java:79) at org.apache.catalina.tribes.group.interceptors.TcpFailureDetector.messageReceived(TcpFailureDetector.java:110) at org.apache.catalina.tribes.group.ChannelInterceptorBase.messageReceived(ChannelInterceptorBase.java:79) at org.apache.catalina.tribes.group.ChannelInterceptorBase.messageReceived(ChannelInterceptorBase.java:79) at org.apache.catalina.tribes.group.ChannelCoordinator.messageReceived(ChannelCoordinator.java:241) at org.apache.catalina.tribes.transport.ReceiverBase.messageDataReceived(ReceiverBase.java:225) at org.apache.catalina.tribes.transport.nio.NioReplicationTask.drainChannel(NioReplicationTask.java:188) at org.apache.catalina.tribes.transport.nio.NioReplicationTask.run(NioReplicationTask.java:91) at java.util.concurrent.ThreadPoolExecutor$Worker.runTask(ThreadPoolExecutor.java:886) at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:908) at java.lang.Thread.run(Thread.java:662) It looks like the functionality of Tomcat is not affected by this. The NPE comes from trying to write null sessionId, but why does Tomcat try to send something from handling received authoritative SESSION_EXPIRED message?</column><column name="report_time">2011-06-01 12:21:28</column><column name="report_timestamp">1306950000</column><column name="status">resolved fixed</column><column name="commit">4e5571f</column><column name="commit_timestamp">1307960000</column><column name="files">java/org/apache/catalina/ha/session/DeltaManager.java
java/org/apache/catalina/ha/session/DeltaSession.java</column><column name="result">1:java/org/apache/catalina/ha/session/DeltaManager.java
3:java/org/apache/catalina/ha/session/DeltaSession.java</column></table><table name="tomcat"><column name="id">444</column><column name="bug_id">51348</column><column name="summary">Potential NullPointerException in org.apache.catalina.servlets.WebdavServlet at line 1336</column><column name="description">A WebDAV LOCK_REFRESH request may cause a NullPointerException because of an (IMHO) wrong check at line 1332 in WebdavServlet.java 1056763 2011-01-08 18:56:57Z markt. I suggest line 1332 should be: ... if (toRenew != null) { ...</column><column name="report_time">2011-06-09 08:53:41</column><column name="report_timestamp">1307620000</column><column name="status">resolved fixed</column><column name="commit">71b18c8</column><column name="commit_timestamp">1307650000</column><column name="files">java/org/apache/catalina/servlets/WebdavServlet.java</column><column name="result">1:java/org/apache/catalina/servlets/WebdavServlet.java</column></table><table name="tomcat"><column name="id">445</column><column name="bug_id">51344</column><column name="summary">org.apache.catalina.startup.Embedded overrides Lifecycle incorrectly?</column><column name="description">Not sure if this is a bug or just my mis-coding... I've been using the Embedded component in Tomcat 6.0.29 for integration testing. Something like this: server = new EmbeddedTomcat("/test", 7890, "JVM-1"); PeerToPeerCacheLifecycleListener p2pListener = new PeerToPeerCacheLifecycleListener(); p2pListener.setProperty("mcast-port", "19991"); server.getEmbedded().addLifecycleListener(p2pListener); sessionManager = new DeltaSessionManager(); server.getRootContext().setManager(sessionManager); Here the EmbeddedTomcat class is simply a wrapper for Embedded - I'm passing in the context, port and 'JVM route' - nothing special. Then I add a listener which should be the programmatic equivalent of having the following server.xml snippet: &lt;Server&gt; &lt;Listener className="PeerToPeerCacheLifecycleListener"/&gt; &lt;/Server&gt; DeltaSessionManager performs custom session management and thus extends ManagerBase and implements Lifecycle and SessionManager. During the start of DeltaSessionManager I initialize the listener by doing this.lifecycle.fireLifecycleEvent(START_EVENT, null); The listener picks up this event and starts. All works nicely under Tomcat 6, but breaks under Tomcat 7.0.12. My initial investigation shows that the LifecycleEvent, being fired, is not reaching the Embedded component which is where the listener is registered. Removing the overridden Lifecycle methods from Embedded (so that the Lifecyle processing happens in LifecycleBase) seems to work as the triggered event then reaches my listener.</column><column name="report_time">2011-06-08 21:35:55</column><column name="report_timestamp">1307580000</column><column name="status">resolved fixed</column><column name="commit">4892b57</column><column name="commit_timestamp">1307650000</column><column name="files">java/org/apache/catalina/startup/Embedded.java</column><column name="result">1:java/org/apache/catalina/startup/Embedded.java</column></table><table name="tomcat"><column name="id">446</column><column name="bug_id">51340</column><column name="summary">Intermittent java.lang.IllegalArgumentException: &lt;session-config&gt; element is limited to 1 occurrence</column><column name="description">An Eclipse Virgo CI build recently failed with the stack trace below. I haven't seen the problem before, but it seems that at least one user of vanilla Tomcat has hit the same problem, on Tomcat 6 in 2009 ([1]). I am raising this bug to get this on the record and perhaps to help identify a pattern of usage that may ultimately lead to a solution. It is possible that the bug is in the JRE XML processing, of course. Environment: Java 6 R21 64 bit (Sun) Sles 11 x86-64 Tomcat 7.0.12 embedded in development version of Eclipse Virgo 3.0 [1] http://mail-archives.apache.org/mod_mbox/tomcat-users/200902.mbox/%3C36E4692623C5974BA6661C0B18EE8EDFE4138B@MAILSERV.hcrest.com%3E [2011-06-07 11:07:17.741] ERROR start-signalling-4 System.err Jun 7, 2011 11:07:17 AM org.apache.tomcat.util.digester.Digester startElement [2011-06-07 11:07:17.741] ERROR start-signalling-4 System.err SEVERE: Begin event threw exception [2011-06-07 11:07:17.741] ERROR start-signalling-4 System.err java.lang.IllegalArgumentException: &lt;session-config&gt; element is limited to 1 occurrence [2011-06-07 11:07:17.742] ERROR start-signalling-4 System.err 	at org.apache.catalina.startup.SetSessionConfig.begin(WebRuleSet.java:722) [2011-06-07 11:07:17.742] ERROR start-signalling-4 System.err 	at org.apache.tomcat.util.digester.Digester.startElement(Digester.java:1282) [2011-06-07 11:07:17.742] ERROR start-signalling-4 System.err 	at com.sun.org.apache.xerces.internal.parsers.AbstractSAXParser.startElement(AbstractSAXParser.java:501) [2011-06-07 11:07:17.742] ERROR start-signalling-4 System.err 	at com.sun.org.apache.xerces.internal.impl.XMLDocumentFragmentScannerImpl.scanStartElement(XMLDocumentFragmentScannerImpl.java:1363) [2011-06-07 11:07:17.742] ERROR start-signalling-4 System.err 	at com.sun.org.apache.xerces.internal.impl.XMLDocumentFragmentScannerImpl$FragmentContentDriver.next(XMLDocumentFragmentScannerImpl.java:2755) [2011-06-07 11:07:17.742] ERROR start-signalling-4 System.err 	at com.sun.org.apache.xerces.internal.impl.XMLDocumentScannerImpl.next(XMLDocumentScannerImpl.java:648) [2011-06-07 11:07:17.742] ERROR start-signalling-4 System.err 	at com.sun.org.apache.xerces.internal.impl.XMLDocumentFragmentScannerImpl.scanDocument(XMLDocumentFragmentScannerImpl.java:511) [2011-06-07 11:07:17.742] ERROR start-signalling-4 System.err 	at com.sun.org.apache.xerces.internal.parsers.XML11Configuration.parse(XML11Configuration.java:808) [2011-06-07 11:07:17.742] ERROR start-signalling-4 System.err 	at com.sun.org.apache.xerces.internal.parsers.XML11Configuration.parse(XML11Configuration.java:737) [2011-06-07 11:07:17.743] ERROR start-signalling-4 System.err 	at com.sun.org.apache.xerces.internal.parsers.XMLParser.parse(XMLParser.java:119) [2011-06-07 11:07:17.743] ERROR start-signalling-4 System.err 	at com.sun.org.apache.xerces.internal.parsers.AbstractSAXParser.parse(AbstractSAXParser.java:1205) [2011-06-07 11:07:17.743] ERROR start-signalling-4 System.err 	at com.sun.org.apache.xerces.internal.jaxp.SAXParserImpl$JAXPSAXParser.parse(SAXParserImpl.java:522) [2011-06-07 11:07:17.743] ERROR start-signalling-4 System.err 	at org.apache.tomcat.util.digester.Digester.parse(Digester.java:1543) [2011-06-07 11:07:17.743] ERROR start-signalling-4 System.err 	at org.apache.catalina.startup.ContextConfig.parseWebXml(ContextConfig.java:1694) [2011-06-07 11:07:17.743] ERROR start-signalling-4 System.err 	at org.apache.catalina.startup.ContextConfig.webConfig(ContextConfig.java:1197) [2011-06-07 11:07:17.743] ERROR start-signalling-4 System.err 	at org.apache.catalina.startup.ContextConfig.configureStart(ContextConfig.java:882) [2011-06-07 11:07:17.743] ERROR start-signalling-4 System.err 	at org.apache.catalina.startup.ContextConfig.lifecycleEvent(ContextConfig.java:317) [2011-06-07 11:07:17.743] ERROR start-signalling-4 System.err 	at org.apache.catalina.util.LifecycleSupport.fireLifecycleEvent(LifecycleSupport.java:119) [2011-06-07 11:07:17.744] ERROR start-signalling-4 System.err 	at org.apache.catalina.util.LifecycleBase.fireLifecycleEvent(LifecycleBase.java:89) [2011-06-07 11:07:17.744] ERROR start-signalling-4 System.err 	at org.apache.catalina.core.StandardContext.startInternal(StandardContext.java:5081) [2011-06-07 11:07:17.744] ERROR start-signalling-4 System.err 	at org.apache.catalina.util.LifecycleBase.start(LifecycleBase.java:145) [2011-06-07 11:07:17.744] ERROR start-signalling-4 System.err 	at org.apache.catalina.core.ContainerBase.addChildInternal(ContainerBase.java:812) [2011-06-07 11:07:17.744] ERROR start-signalling-4 System.err 	at org.apache.catalina.core.ContainerBase.addChild(ContainerBase.java:787) [2011-06-07 11:07:17.744] ERROR start-signalling-4 System.err 	at org.apache.catalina.core.StandardHost.addChild(StandardHost.java:607) [2011-06-07 11:07:17.744] ERROR start-signalling-4 System.err 	at org.eclipse.gemini.web.tomcat.internal.TomcatServletContainer.startWebApplication(TomcatServletContainer.java:122) [2011-06-07 11:07:17.744] ERROR start-signalling-4 System.err 	at org.eclipse.gemini.web.internal.StandardWebApplication.start(StandardWebApplication.java:91) [2011-06-07 11:07:17.745] ERROR start-signalling-4 System.err 	at org.eclipse.virgo.web.core.internal.WebBundleLifecycleListener.onStarted(WebBundleLifecycleListener.java:122) [2011-06-07 11:07:17.745] ERROR start-signalling-4 System.err 	at org.eclipse.virgo.kernel.install.artifact.internal.StandardArtifactStateMonitor.onStarted(StandardArtifactStateMonitor.java:247) [2011-06-07 11:07:17.745] ERROR start-signalling-4 System.err 	at org.eclipse.virgo.kernel.install.artifact.internal.AbstractInstallArtifact.asyncStartSucceeded(AbstractInstallArtifact.java:294) [2011-06-07 11:07:17.745] ERROR start-signalling-4 System.err 	at org.eclipse.virgo.kernel.install.artifact.internal.AbstractInstallArtifact.access$0(AbstractInstallArtifact.java:291) [2011-06-07 11:07:17.745] ERROR start-signalling-4 System.err 	at org.eclipse.virgo.kernel.install.artifact.internal.AbstractInstallArtifact$StateMonitorSignal.signalSuccessfulCompletion(AbstractInstallArtifact.java:229) [2011-06-07 11:07:17.745] ERROR start-signalling-4 System.err 	at org.eclipse.virgo.kernel.core.internal.BundleStartTracker$1.run(BundleStartTracker.java:143) [2011-06-07 11:07:17.745] ERROR start-signalling-4 System.err 	at java.util.concurrent.ThreadPoolExecutor$Worker.runTask(ThreadPoolExecutor.java:886) [2011-06-07 11:07:17.745] ERROR start-signalling-4 System.err 	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:908) [2011-06-07 11:07:17.746] ERROR start-signalling-4 System.err 	at java.lang.Thread.run(Thread.java:619) [2011-06-07 11:07:17.747] ERROR start-signalling-4 System.err Jun 7, 2011 11:07:17 AM org.apache.catalina.startup.ContextConfig parseWebXml [2011-06-07 11:07:17.748] ERROR start-signalling-4 System.err SEVERE: Parse error in application web.xml file at file:/opt/users/hudsonbuild/workspace/virgo.web-server.snapshot/org.eclipse.virgo.server.smoketest/target/test-expanded/virgo-tomcat-server-3.0.0.CI-2011-06-07_11-01-11/work/org.eclipse.virgo.kernel.deployer_3.0.0.D-20110603101321/staging/global/bundle/org.eclipse.gemini.web.tomcat/2.0.0.BUILD-20110603145554/org.eclipse.gemini.web.tomcat-2.0.0.BUILD-20110603145554.jar/conf/web.xml [2011-06-07 11:07:17.748] ERROR start-signalling-4 System.err java.lang.IllegalArgumentException: &lt;session-config&gt; element is limited to 1 occurrence [2011-06-07 11:07:17.748] ERROR start-signalling-4 System.err 	at org.apache.tomcat.util.digester.Digester.createSAXException(Digester.java:2687) [2011-06-07 11:07:17.748] ERROR start-signalling-4 System.err 	at org.apache.tomcat.util.digester.Digester.createSAXException(Digester.java:2713) [2011-06-07 11:07:17.748] ERROR start-signalling-4 System.err 	at org.apache.tomcat.util.digester.Digester.startElement(Digester.java:1285) [2011-06-07 11:07:17.748] ERROR start-signalling-4 System.err 	at com.sun.org.apache.xerces.internal.parsers.AbstractSAXParser.startElement(AbstractSAXParser.java:501) [2011-06-07 11:07:17.749] ERROR start-signalling-4 System.err 	at com.sun.org.apache.xerces.internal.impl.XMLDocumentFragmentScannerImpl.scanStartElement(XMLDocumentFragmentScannerImpl.java:1363) [2011-06-07 11:07:17.749] ERROR start-signalling-4 System.err 	at com.sun.org.apache.xerces.internal.impl.XMLDocumentFragmentScannerImpl$FragmentContentDriver.next(XMLDocumentFragmentScannerImpl.java:2755) [2011-06-07 11:07:17.749] ERROR start-signalling-4 System.err 	at com.sun.org.apache.xerces.internal.impl.XMLDocumentScannerImpl.next(XMLDocumentScannerImpl.java:648) [2011-06-07 11:07:17.749] ERROR start-signalling-4 System.err 	at com.sun.org.apache.xerces.internal.impl.XMLDocumentFragmentScannerImpl.scanDocument(XMLDocumentFragmentScannerImpl.java:511) [2011-06-07 11:07:17.749] ERROR start-signalling-4 System.err 	at com.sun.org.apache.xerces.internal.parsers.XML11Configuration.parse(XML11Configuration.java:808) [2011-06-07 11:07:17.749] ERROR start-signalling-4 System.err 	at com.sun.org.apache.xerces.internal.parsers.XML11Configuration.parse(XML11Configuration.java:737) [2011-06-07 11:07:17.749] ERROR start-signalling-4 System.err 	at com.sun.org.apache.xerces.internal.parsers.XMLParser.parse(XMLParser.java:119) [2011-06-07 11:07:17.749] ERROR start-signalling-4 System.err 	at com.sun.org.apache.xerces.internal.parsers.AbstractSAXParser.parse(AbstractSAXParser.java:1205) [2011-06-07 11:07:17.750] ERROR start-signalling-4 System.err 	at com.sun.org.apache.xerces.internal.jaxp.SAXParserImpl$JAXPSAXParser.parse(SAXParserImpl.java:522) [2011-06-07 11:07:17.750] ERROR start-signalling-4 System.err 	at org.apache.tomcat.util.digester.Digester.parse(Digester.java:1543) [2011-06-07 11:07:17.750] ERROR start-signalling-4 System.err 	at org.apache.catalina.startup.ContextConfig.parseWebXml(ContextConfig.java:1694) [2011-06-07 11:07:17.750] ERROR start-signalling-4 System.err 	at org.apache.catalina.startup.ContextConfig.webConfig(ContextConfig.java:1197) [2011-06-07 11:07:17.750] ERROR start-signalling-4 System.err 	at org.apache.catalina.startup.ContextConfig.configureStart(ContextConfig.java:882) [2011-06-07 11:07:17.750] ERROR start-signalling-4 System.err 	at org.apache.catalina.startup.ContextConfig.lifecycleEvent(ContextConfig.java:317) [2011-06-07 11:07:17.750] ERROR start-signalling-4 System.err 	at org.apache.catalina.util.LifecycleSupport.fireLifecycleEvent(LifecycleSupport.java:119) [2011-06-07 11:07:17.750] ERROR start-signalling-4 System.err 	at org.apache.catalina.util.LifecycleBase.fireLifecycleEvent(LifecycleBase.java:89) [2011-06-07 11:07:17.750] ERROR start-signalling-4 System.err 	at org.apache.catalina.core.StandardContext.startInternal(StandardContext.java:5081) [2011-06-07 11:07:17.751] ERROR start-signalling-4 System.err 	at org.apache.catalina.util.LifecycleBase.start(LifecycleBase.java:145) [2011-06-07 11:07:17.751] ERROR start-signalling-4 System.err 	at org.apache.catalina.core.ContainerBase.addChildInternal(ContainerBase.java:812) [2011-06-07 11:07:17.751] ERROR start-signalling-4 System.err 	at org.apache.catalina.core.ContainerBase.addChild(ContainerBase.java:787) [2011-06-07 11:07:17.751] ERROR start-signalling-4 System.err 	at org.apache.catalina.core.StandardHost.addChild(StandardHost.java:607) [2011-06-07 11:07:17.751] ERROR start-signalling-4 System.err 	at org.eclipse.gemini.web.tomcat.internal.TomcatServletContainer.startWebApplication(TomcatServletContainer.java:122) [2011-06-07 11:07:17.751] ERROR start-signalling-4 System.err 	at org.eclipse.gemini.web.internal.StandardWebApplication.start(StandardWebApplication.java:91) [2011-06-07 11:07:17.751] ERROR start-signalling-4 System.err 	at org.eclipse.virgo.web.core.internal.WebBundleLifecycleListener.onStarted(WebBundleLifecycleListener.java:122) [2011-06-07 11:07:17.751] ERROR start-signalling-4 System.err 	at org.eclipse.virgo.kernel.install.artifact.internal.StandardArtifactStateMonitor.onStarted(StandardArtifactStateMonitor.java:247) [2011-06-07 11:07:17.751] ERROR start-signalling-4 System.err 	at org.eclipse.virgo.kernel.install.artifact.internal.AbstractInstallArtifact.asyncStartSucceeded(AbstractInstallArtifact.java:294) [2011-06-07 11:07:17.752] ERROR start-signalling-4 System.err 	at org.eclipse.virgo.kernel.install.artifact.internal.AbstractInstallArtifact.access$0(AbstractInstallArtifact.java:291) [2011-06-07 11:07:17.752] ERROR start-signalling-4 System.err 	at org.eclipse.virgo.kernel.install.artifact.internal.AbstractInstallArtifact$StateMonitorSignal.signalSuccessfulCompletion(AbstractInstallArtifact.java:229) [2011-06-07 11:07:17.752] ERROR start-signalling-4 System.err 	at org.eclipse.virgo.kernel.core.internal.BundleStartTracker$1.run(BundleStartTracker.java:143) [2011-06-07 11:07:17.752] ERROR start-signalling-4 System.err 	at java.util.concurrent.ThreadPoolExecutor$Worker.runTask(ThreadPoolExecutor.java:886) [2011-06-07 11:07:17.752] ERROR start-signalling-4 System.err 	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:908) [2011-06-07 11:07:17.752] ERROR start-signalling-4 System.err 	at java.lang.Thread.run(Thread.java:619) [2011-06-07 11:07:17.752] ERROR start-signalling-4 System.err Caused by: java.lang.IllegalArgumentException: &lt;session-config&gt; element is limited to 1 occurrence [2011-06-07 11:07:17.752] ERROR start-signalling-4 System.err 	at org.apache.catalina.startup.SetSessionConfig.begin(WebRuleSet.java:722) [2011-06-07 11:07:17.752] ERROR start-signalling-4 System.err 	at org.apache.tomcat.util.digester.Digester.startElement(Digester.java:1282) [2011-06-07 11:07:17.753] ERROR start-signalling-4 System.err 	... 33 more [2011-06-07 11:07:17.753] ERROR start-signalling-4 System.err Jun 7, 2011 11:07:17 AM org.apache.catalina.startup.ContextConfig parseWebXml [2011-06-07 11:07:17.753] ERROR start-signalling-4 System.err SEVERE: Occurred at line 468 column 21 [2011-06-07 11:07:17.759] ERROR start-signalling-1 System.err Jun 7, 2011 11:07:17 AM org.apache.tomcat.util.digester.Digester startElement [2011-06-07 11:07:17.759] ERROR start-signalling-1 System.err SEVERE: Begin event threw exception [2011-06-07 11:07:17.760] ERROR start-signalling-1 System.err java.lang.IllegalArgumentException: &lt;session-config&gt; element is limited to 1 occurrence [2011-06-07 11:07:17.760] ERROR start-signalling-1 System.err 	at org.apache.catalina.startup.SetSessionConfig.begin(WebRuleSet.java:722) [2011-06-07 11:07:17.760] ERROR start-signalling-1 System.err 	at org.apache.tomcat.util.digester.Digester.startElement(Digester.java:1282) [2011-06-07 11:07:17.760] ERROR start-signalling-1 System.err 	at com.sun.org.apache.xerces.internal.parsers.AbstractSAXParser.startElement(AbstractSAXParser.java:501) [2011-06-07 11:07:17.761] ERROR start-signalling-1 System.err 	at com.sun.org.apache.xerces.internal.impl.XMLDocumentFragmentScannerImpl.scanStartElement(XMLDocumentFragmentScannerImpl.java:1363) [2011-06-07 11:07:17.761] ERROR start-signalling-1 System.err 	at com.sun.org.apache.xerces.internal.impl.XMLDocumentFragmentScannerImpl$FragmentContentDriver.next(XMLDocumentFragmentScannerImpl.java:2755) [2011-06-07 11:07:17.762] ERROR start-signalling-1 System.err 	at com.sun.org.apache.xerces.internal.impl.XMLDocumentScannerImpl.next(XMLDocumentScannerImpl.java:648) [2011-06-07 11:07:17.762] ERROR start-signalling-1 System.err 	at com.sun.org.apache.xerces.internal.impl.XMLDocumentFragmentScannerImpl.scanDocument(XMLDocumentFragmentScannerImpl.java:511) [2011-06-07 11:07:17.763] ERROR start-signalling-1 System.err 	at com.sun.org.apache.xerces.internal.parsers.XML11Configuration.parse(XML11Configuration.java:808) [2011-06-07 11:07:17.763] ERROR start-signalling-1 System.err 	at com.sun.org.apache.xerces.internal.parsers.XML11Configuration.parse(XML11Configuration.java:737) [2011-06-07 11:07:17.763] ERROR start-signalling-1 System.err 	at com.sun.org.apache.xerces.internal.parsers.XMLParser.parse(XMLParser.java:119) [2011-06-07 11:07:17.764] ERROR start-signalling-1 System.err 	at com.sun.org.apache.xerces.internal.parsers.AbstractSAXParser.parse(AbstractSAXParser.java:1205) [2011-06-07 11:07:17.764] ERROR start-signalling-1 System.err 	at com.sun.org.apache.xerces.internal.jaxp.SAXParserImpl$JAXPSAXParser.parse(SAXParserImpl.java:522) [2011-06-07 11:07:17.765] ERROR start-signalling-1 System.err 	at org.apache.tomcat.util.digester.Digester.parse(Digester.java:1543) [2011-06-07 11:07:17.765] ERROR start-signalling-1 System.err 	at org.apache.catalina.startup.ContextConfig.parseWebXml(ContextConfig.java:1694) [2011-06-07 11:07:17.765] ERROR start-signalling-1 System.err 	at org.apache.catalina.startup.ContextConfig.webConfig(ContextConfig.java:1197) [2011-06-07 11:07:17.766] ERROR start-signalling-1 System.err 	at org.apache.catalina.startup.ContextConfig.configureStart(ContextConfig.java:882) [2011-06-07 11:07:17.766] ERROR start-signalling-1 System.err 	at org.apache.catalina.startup.ContextConfig.lifecycleEvent(ContextConfig.java:317) [2011-06-07 11:07:17.766] ERROR start-signalling-1 System.err 	at org.apache.catalina.util.LifecycleSupport.fireLifecycleEvent(LifecycleSupport.java:119) [2011-06-07 11:07:17.767] ERROR start-signalling-1 System.err 	at org.apache.catalina.util.LifecycleBase.fireLifecycleEvent(LifecycleBase.java:89) [2011-06-07 11:07:17.767] ERROR start-signalling-1 System.err 	at org.apache.catalina.core.StandardContext.startInternal(StandardContext.java:5081) [2011-06-07 11:07:17.767] ERROR start-signalling-1 System.err 	at org.apache.catalina.util.LifecycleBase.start(LifecycleBase.java:145) [2011-06-07 11:07:17.768] ERROR start-signalling-1 System.err 	at org.apache.catalina.core.ContainerBase.addChildInternal(ContainerBase.java:812) [2011-06-07 11:07:17.768] ERROR start-signalling-1 System.err 	at org.apache.catalina.core.ContainerBase.addChild(ContainerBase.java:787) [2011-06-07 11:07:17.769] ERROR start-signalling-1 System.err 	at org.apache.catalina.core.StandardHost.addChild(StandardHost.java:607) [2011-06-07 11:07:17.769] ERROR start-signalling-1 System.err 	at org.eclipse.gemini.web.tomcat.internal.TomcatServletContainer.startWebApplication(TomcatServletContainer.java:122) [2011-06-07 11:07:17.769] ERROR start-signalling-1 System.err 	at org.eclipse.gemini.web.internal.StandardWebApplication.start(StandardWebApplication.java:91) [2011-06-07 11:07:17.770] ERROR start-signalling-1 System.err 	at org.eclipse.virgo.web.core.internal.WebBundleLifecycleListener.onStarted(WebBundleLifecycleListener.java:122) [2011-06-07 11:07:17.770] ERROR start-signalling-1 System.err 	at org.eclipse.virgo.kernel.install.artifact.internal.StandardArtifactStateMonitor.onStarted(StandardArtifactStateMonitor.java:247) [2011-06-07 11:07:17.771] ERROR start-signalling-1 System.err 	at org.eclipse.virgo.kernel.install.artifact.internal.AbstractInstallArtifact.asyncStartSucceeded(AbstractInstallArtifact.java:294) [2011-06-07 11:07:17.771] ERROR start-signalling-1 System.err 	at org.eclipse.virgo.kernel.install.artifact.internal.AbstractInstallArtifact.access$0(AbstractInstallArtifact.java:291) [2011-06-07 11:07:17.772] ERROR start-signalling-1 System.err 	at org.eclipse.virgo.kernel.install.artifact.internal.AbstractInstallArtifact$StateMonitorSignal.signalSuccessfulCompletion(AbstractInstallArtifact.java:229) [2011-06-07 11:07:17.772] ERROR start-signalling-1 System.err 	at org.eclipse.virgo.kernel.core.internal.BundleStartTracker$1.run(BundleStartTracker.java:143) [2011-06-07 11:07:17.773] ERROR start-signalling-1 System.err 	at java.util.concurrent.ThreadPoolExecutor$Worker.runTask(ThreadPoolExecutor.java:886) [2011-06-07 11:07:17.773] ERROR start-signalling-1 System.err 	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:908) [2011-06-07 11:07:17.773] ERROR start-signalling-1 System.err 	at java.lang.Thread.run(Thread.java:619) [2011-06-07 11:07:17.775] ERROR start-signalling-1 System.err Jun 7, 2011 11:07:17 AM org.apache.catalina.startup.ContextConfig parseWebXml [2011-06-07 11:07:17.776] ERROR start-signalling-1 System.err SEVERE: Parse error in application web.xml file at file:/opt/users/hudsonbuild/workspace/virgo.web-server.snapshot/org.eclipse.virgo.server.smoketest/target/test-expanded/virgo-tomcat-server-3.0.0.CI-2011-06-07_11-01-11/work/org.eclipse.virgo.kernel.deployer_3.0.0.D-20110603101321/staging/global/bundle/org.eclipse.gemini.web.tomcat/2.0.0.BUILD-20110603145554/org.eclipse.gemini.web.tomcat-2.0.0.BUILD-20110603145554.jar/conf/web.xml [2011-06-07 11:07:17.777] ERROR start-signalling-1 System.err java.lang.IllegalArgumentException: &lt;session-config&gt; element is limited to 1 occurrence [2011-06-07 11:07:17.777] ERROR start-signalling-1 System.err 	at org.apache.tomcat.util.digester.Digester.createSAXException(Digester.java:2687) [2011-06-07 11:07:17.777] ERROR start-signalling-1 System.err 	at org.apache.tomcat.util.digester.Digester.createSAXException(Digester.java:2713) [2011-06-07 11:07:17.778] ERROR start-signalling-1 System.err 	at org.apache.tomcat.util.digester.Digester.startElement(Digester.java:1285) [2011-06-07 11:07:17.778] ERROR start-signalling-1 System.err 	at com.sun.org.apache.xerces.internal.parsers.AbstractSAXParser.startElement(AbstractSAXParser.java:501) [2011-06-07 11:07:17.779] ERROR start-signalling-1 System.err 	at com.sun.org.apache.xerces.internal.impl.XMLDocumentFragmentScannerImpl.scanStartElement(XMLDocumentFragmentScannerImpl.java:1363) [2011-06-07 11:07:17.779] ERROR start-signalling-1 System.err 	at com.sun.org.apache.xerces.internal.impl.XMLDocumentFragmentScannerImpl$FragmentContentDriver.next(XMLDocumentFragmentScannerImpl.java:2755) [2011-06-07 11:07:17.780] ERROR start-signalling-1 System.err 	at com.sun.org.apache.xerces.internal.impl.XMLDocumentScannerImpl.next(XMLDocumentScannerImpl.java:648) [2011-06-07 11:07:17.780] ERROR start-signalling-1 System.err 	at com.sun.org.apache.xerces.internal.impl.XMLDocumentFragmentScannerImpl.scanDocument(XMLDocumentFragmentScannerImpl.java:511) [2011-06-07 11:07:17.781] ERROR start-signalling-1 System.err 	at com.sun.org.apache.xerces.internal.parsers.XML11Configuration.parse(XML11Configuration.java:808) [2011-06-07 11:07:17.781] ERROR start-signalling-1 System.err 	at com.sun.org.apache.xerces.internal.parsers.XML11Configuration.parse(XML11Configuration.java:737) [2011-06-07 11:07:17.781] ERROR start-signalling-1 System.err 	at com.sun.org.apache.xerces.internal.parsers.XMLParser.parse(XMLParser.java:119) [2011-06-07 11:07:17.782] ERROR start-signalling-1 System.err 	at com.sun.org.apache.xerces.internal.parsers.AbstractSAXParser.parse(AbstractSAXParser.java:1205) [2011-06-07 11:07:17.782] ERROR start-signalling-1 System.err 	at com.sun.org.apache.xerces.internal.jaxp.SAXParserImpl$JAXPSAXParser.parse(SAXParserImpl.java:522) [2011-06-07 11:07:17.782] ERROR start-signalling-1 System.err 	at org.apache.tomcat.util.digester.Digester.parse(Digester.java:1543) [2011-06-07 11:07:17.783] ERROR start-signalling-1 System.err 	at org.apache.catalina.startup.ContextConfig.parseWebXml(ContextConfig.java:1694) [2011-06-07 11:07:17.783] ERROR start-signalling-1 System.err 	at org.apache.catalina.startup.ContextConfig.webConfig(ContextConfig.java:1197) [2011-06-07 11:07:17.783] ERROR start-signalling-1 System.err 	at org.apache.catalina.startup.ContextConfig.configureStart(ContextConfig.java:882) [2011-06-07 11:07:17.784] ERROR start-signalling-1 System.err 	at org.apache.catalina.startup.ContextConfig.lifecycleEvent(ContextConfig.java:317) [2011-06-07 11:07:17.784] ERROR start-signalling-1 System.err 	at org.apache.catalina.util.LifecycleSupport.fireLifecycleEvent(LifecycleSupport.java:119) [2011-06-07 11:07:17.785] ERROR start-signalling-1 System.err 	at org.apache.catalina.util.LifecycleBase.fireLifecycleEvent(LifecycleBase.java:89) [2011-06-07 11:07:17.785] ERROR start-signalling-1 System.err 	at org.apache.catalina.core.StandardContext.startInternal(StandardContext.java:5081) [2011-06-07 11:07:17.785] ERROR start-signalling-1 System.err 	at org.apache.catalina.util.LifecycleBase.start(LifecycleBase.java:145) [2011-06-07 11:07:17.786] ERROR start-signalling-1 System.err 	at org.apache.catalina.core.ContainerBase.addChildInternal(ContainerBase.java:812) [2011-06-07 11:07:17.786] ERROR start-signalling-1 System.err 	at org.apache.catalina.core.ContainerBase.addChild(ContainerBase.java:787) [2011-06-07 11:07:17.786] ERROR start-signalling-1 System.err 	at org.apache.catalina.core.StandardHost.addChild(StandardHost.java:607) [2011-06-07 11:07:17.787] ERROR start-signalling-1 System.err 	at org.eclipse.gemini.web.tomcat.internal.TomcatServletContainer.startWebApplication(TomcatServletContainer.java:122) [2011-06-07 11:07:17.787] ERROR start-signalling-1 System.err 	at org.eclipse.gemini.web.internal.StandardWebApplication.start(StandardWebApplication.java:91) [2011-06-07 11:07:17.788] ERROR start-signalling-1 System.err 	at org.eclipse.virgo.web.core.internal.WebBundleLifecycleListener.onStarted(WebBundleLifecycleListener.java:122) [2011-06-07 11:07:17.788] ERROR start-signalling-1 System.err 	at org.eclipse.virgo.kernel.install.artifact.internal.StandardArtifactStateMonitor.onStarted(StandardArtifactStateMonitor.java:247) [2011-06-07 11:07:17.789] ERROR start-signalling-1 System.err 	at org.eclipse.virgo.kernel.install.artifact.internal.AbstractInstallArtifact.asyncStartSucceeded(AbstractInstallArtifact.java:294) [2011-06-07 11:07:17.789] ERROR start-signalling-1 System.err 	at org.eclipse.virgo.kernel.install.artifact.internal.AbstractInstallArtifact.access$0(AbstractInstallArtifact.java:291) [2011-06-07 11:07:17.790] ERROR start-signalling-1 System.err 	at org.eclipse.virgo.kernel.install.artifact.internal.AbstractInstallArtifact$StateMonitorSignal.signalSuccessfulCompletion(AbstractInstallArtifact.java:229) [2011-06-07 11:07:17.790] ERROR start-signalling-1 System.err 	at org.eclipse.virgo.kernel.core.internal.BundleStartTracker$1.run(BundleStartTracker.java:143) [2011-06-07 11:07:17.790] ERROR start-signalling-1 System.err 	at java.util.concurrent.ThreadPoolExecutor$Worker.runTask(ThreadPoolExecutor.java:886) [2011-06-07 11:07:17.791] ERROR start-signalling-1 System.err 	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:908) [2011-06-07 11:07:17.791] ERROR start-signalling-1 System.err 	at java.lang.Thread.run(Thread.java:619) [2011-06-07 11:07:17.791] ERROR start-signalling-1 System.err Caused by: java.lang.IllegalArgumentException: &lt;session-config&gt; element is limited to 1 occurrence [2011-06-07 11:07:17.792] ERROR start-signalling-1 System.err 	at org.apache.catalina.startup.SetSessionConfig.begin(WebRuleSet.java:722) [2011-06-07 11:07:17.792] ERROR start-signalling-1 System.err 	at org.apache.tomcat.util.digester.Digester.startElement(Digester.java:1282) [2011-06-07 11:07:17.792] ERROR start-signalling-1 System.err 	... 33 more [2011-06-07 11:07:17.793] ERROR start-signalling-1 System.err Jun 7, 2011 11:07:17 AM org.apache.catalina.startup.ContextConfig parseWebXml [2011-06-07 11:07:17.793] ERROR start-signalling-1 System.err SEVERE: Occurred at line 468 column 21 [2011-06-07 11:07:17.806] ERROR start-signalling-4 System.err Jun 7, 2011 11:07:17 AM org.apache.catalina.startup.ContextConfig configureStart [2011-06-07 11:07:17.806] ERROR start-signalling-4 System.err SEVERE: Marking this application unavailable due to previous error(s) [2011-06-07 11:07:17.808] ERROR start-signalling-1 System.err Jun 7, 2011 11:07:17 AM org.apache.catalina.startup.ContextConfig configureStart [2011-06-07 11:07:17.808] ERROR start-signalling-1 System.err SEVERE: Marking this application unavailable due to previous error(s) [2011-06-07 11:07:18.034] ERROR start-signalling-1 System.err Jun 7, 2011 11:07:18 AM org.apache.catalina.core.StandardContext startInternal [2011-06-07 11:07:18.035] ERROR start-signalling-1 System.err SEVERE: Error getConfigured [2011-06-07 11:07:18.036] ERROR start-signalling-1 System.err Jun 7, 2011 11:07:18 AM org.apache.catalina.core.StandardContext startInternal [2011-06-07 11:07:18.037] ERROR start-signalling-1 System.err SEVERE: Context [/org.eclipse.virgo.apps.repository] startup failed due to previous errors</column><column name="report_time">2011-06-08 13:37:25</column><column name="report_timestamp">1307550000</column><column name="status">resolved fixed</column><column name="commit">1fe28a6</column><column name="commit_timestamp">1307550000</column><column name="files">java/org/apache/catalina/startup/ContextConfig.java</column><column name="result">7:java/org/apache/catalina/startup/ContextConfig.java</column></table><table name="tomcat"><column name="id">447</column><column name="bug_id">51324</column><column name="summary">When OutputBuffer.doFlush gets Exception, doFlush gets stuck to true</column><column name="description">Created attachment 27114 The line that causes doFlush to be stuck at true if it gets an exception First time opening a bug, please forgive me if this report isn't perfect! I recently ran into an issue where OutputBuffer's doFlush gets stuck to true. In OutputBuffer.doFlush(boolean) it sets doFlush = true, then calls bb.flushBuffer, then sets doFlush = false. I issue I ran into was bb.flushBuffer eventually calls OutputBuffer.realWriteBytes. The realWriteBytes eventually calls coyoteResponse.doWrite. If coyoteResponse.doWrite throws an IOException, then it rethrows a ClientAbortException. What I am seeing is my client disconnecting early, and causing the doWrite to throw a SocketException of "Broken pipe". That broken pipe causes a ClientAbortException to be thrown. When that is thrown, the error is bubbled up and doFlush is stuck as "true". The next time the processor is used, it calls the recycle() method in OutputBuffer. However, the recycle doesn't reset doFlush so its still set to true. I imagine there are quite a few ways to fix this, but the two obvious ones that come to mind are: - Have recycle() set doFlush back to false or - Have throw a finally in try/catch/finally in OutputBuffer.doFlush so doFlush is set back to false when an Exception is catch</column><column name="report_time">2011-06-05 05:17:12</column><column name="report_timestamp">1307270000</column><column name="status">resolved fixed</column><column name="commit">1bbbdb2</column><column name="commit_timestamp">1307460000</column><column name="files">java/org/apache/catalina/connector/OutputBuffer.java</column><column name="result">1:java/org/apache/catalina/connector/OutputBuffer.java</column></table><table name="tomcat"><column name="id">448</column><column name="bug_id">51251</column><column name="summary">Patch to add version parameter to ant task</column><column name="description">Created attachment 27049 add version support Add version parameter support to the following ant tasks. - StartTask - StopTask - ReloadTask - UndeployTask - SessionsTask (also idle parameter) Regards.</column><column name="report_time">2011-05-24 01:28:35</column><column name="report_timestamp">1306210000</column><column name="status">resolved fixed</column><column name="commit">d19daf5</column><column name="commit_timestamp">1307140000</column><column name="files">java/org/apache/catalina/ant/AbstractCatalinaCommandTask.java
java/org/apache/catalina/ant/ReloadTask.java
java/org/apache/catalina/ant/SessionsTask.java
java/org/apache/catalina/ant/StartTask.java
java/org/apache/catalina/ant/StopTask.java
java/org/apache/catalina/ant/UndeployTask.java</column><column name="result">5:java/org/apache/catalina/ant/UndeployTask.java
46:java/org/apache/catalina/ant/StartTask.java
47:java/org/apache/catalina/ant/StopTask.java
49:java/org/apache/catalina/ant/ReloadTask.java
60:java/org/apache/catalina/ant/SessionsTask.java</column></table><table name="tomcat"><column name="id">449</column><column name="bug_id">51276</column><column name="summary">Startup time is too high if there are few JARs in "lib/" and a few webapps.</column><column name="description">Startup time in tomcat 7.0.14 is 10x higher than 7.0.12, if there are a few shared JARs in tomcat/lib and a few webapps. The issue is very simple to reproduce, simply add 10 empty directories in tomcat/webapps and (for example) the Metro webservices jars in tomcat/lib. On my machine the startup time increase from 0.5 secs (default installation) to 35.2 secs. When using tomcat 7.0.12 the startup time is about 3 secs on my machine in this test case.</column><column name="report_time">2011-05-27 11:09:03</column><column name="report_timestamp">1306510000</column><column name="status">resolved fixed</column><column name="commit">5109678</column><column name="commit_timestamp">1307010000</column><column name="files">java/org/apache/catalina/startup/ContextConfig.java
java/org/apache/catalina/startup/TldConfig.java
java/org/apache/jasper/compiler/TldLocationsCache.java
java/org/apache/tomcat/util/scan/FileUrlJar.java
java/org/apache/tomcat/util/scan/Jar.java
java/org/apache/tomcat/util/scan/JarFactory.java
java/org/apache/tomcat/util/scan/UrlJar.java</column><column name="result">2:java/org/apache/catalina/startup/ContextConfig.java
3:java/org/apache/catalina/startup/TldConfig.java
22:java/org/apache/jasper/compiler/TldLocationsCache.java</column></table><table name="tomcat"><column name="id">450</column><column name="bug_id">51277</column><column name="summary">NPE during the form authentication when form-login-config is missed</column><column name="description">Created attachment 27075 Log from a browser Hi! There is NPE during the form authentication when form-login-config is missed I missed form-login-config by mistake (converted it from the BASIC): &lt;login-config&gt; &lt;auth-method&gt;FORM&lt;/auth-method&gt; &lt;realm-name&gt;Tomcat Manager Application&lt;/realm-name&gt; &lt;/login-config&gt; Unfortunately I get NPE (see below and attached). I do understand that Form authentication can not work, but I think NPE is bad output. I think better is HTTP 500. Best regards, Michael java.lang.NullPointerException 	org.apache.catalina.authenticator.FormAuthenticator.forwardToLoginPage(FormAuthenticator.java:373) 	org.apache.catalina.authenticator.FormAuthenticator.authenticate(FormAuthenticator.java:267) 	org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:539) 	org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:100) 	org.apache.catalina.valves.AccessLogValve.invoke(AccessLogValve.java:562) 	org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:395) 	org.apache.coyote.http11.Http11Processor.process(Http11Processor.java:250) 	org.apache.coyote.http11.Http11Protocol$Http11ConnectionHandler.process(Http11Protocol.java:188) 	org.apache.tomcat.util.net.JIoEndpoint$SocketProcessor.run(JIoEndpoint.java:302) 	java.util.concurrent.ThreadPoolExecutor$Worker.runTask(ThreadPoolExecutor.java:886) 	java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:908) 	java.lang.Thread.run(Thread.java:662)</column><column name="report_time">2011-05-27 12:04:07</column><column name="report_timestamp">1306510000</column><column name="status">resolved fixed</column><column name="commit">5b0919c</column><column name="commit_timestamp">1306850000</column><column name="files">java/org/apache/catalina/authenticator/FormAuthenticator.java</column><column name="result">2:java/org/apache/catalina/authenticator/FormAuthenticator.java</column></table><table name="tomcat"><column name="id">451</column><column name="bug_id">51240</column><column name="summary">maxConnections not honors config when acceptorThreadCount &gt; 1</column><column name="description">When acceptorThreadCount &gt; 1, maxConnections not honors config, this affects BIO &amp; NIO connector (others don't know). ---------- test config begin -------- &lt;Executor name="tomcatThreadPool" namePrefix="catalina-exec-" maxThreads="300" minSpareThreads="4"/&gt; &lt;Connector port="9993" protocol="org.apache.coyote.http11.Http11Protocol" URIEncoding="ISO-8859-1" enableLookups="false" acceptorThreadCount="2" executor="tomcatThreadPool" acceptCount="1" maxConnections="1" /&gt; &lt;Connector port="9994" protocol="org.apache.coyote.http11.Http11NioProtocol" URIEncoding="ISO-8859-1" enableLookups="false" acceptorThreadCount="2" executor="tomcatThreadPool" acceptCount="1" maxConnections="1" /&gt; ---------- test config end ---------- ---- Test-1 (acceptorThreadCount="1") --- OK --- $ ab2 -n 20000 -c 1000 http://localhost:999x/ $ netstat -atn | grep :999x | grep ESTABLISHED This show range 3-5 connections (acceptable number) ---- Test-2 (acceptorThreadCount="2") --- KO --- $ ab2 -n 20000 -c 1000 http://localhost:999x/ $ netstat -atn | grep :999x | grep ESTABLISHED This show +100 connections &gt; "OOPS", too much far ---- Logs show traces like this when socket closes: ----- catalina.out begin ----- May 22, 2011 9:10:51 PM org.apache.tomcat.util.net.AbstractEndpoint countDownConnection WARNING: Incorrect connection count, multiple socket.close called on the same socket. ----- catalina.out end -------</column><column name="report_time">2011-05-22 19:22:26</column><column name="report_timestamp">1306110000</column><column name="status">resolved fixed</column><column name="commit">73f9592</column><column name="commit_timestamp">1306420000</column><column name="files">java/org/apache/tomcat/util/net/AbstractEndpoint.java
java/org/apache/tomcat/util/net/AprEndpoint.java
java/org/apache/tomcat/util/net/JIoEndpoint.java
java/org/apache/tomcat/util/net/NioEndpoint.java
java/org/apache/tomcat/util/threads/CounterLatch.java
java/org/apache/tomcat/util/threads/LimitLatch.java
test/org/apache/tomcat/util/threads/TestCounterLatch.java
test/org/apache/tomcat/util/threads/TestLimitLatch.java</column><column name="result">1:java/org/apache/tomcat/util/net/AprEndpoint.java
2:java/org/apache/tomcat/util/net/NioEndpoint.java
3:java/org/apache/tomcat/util/net/JIoEndpoint.java
4:java/org/apache/tomcat/util/net/AbstractEndpoint.java
341:test/org/apache/tomcat/util/threads/TestCounterLatch.java
351:java/org/apache/tomcat/util/threads/CounterLatch.java</column></table><table name="tomcat"><column name="id">452</column><column name="bug_id">51226</column><column name="summary">[Patch] to add FindLeaks ant task</column><column name="description">There is no ant task for FindLeaks.</column><column name="report_time">2011-05-19 06:26:15</column><column name="report_timestamp">1305800000</column><column name="status">resolved fixed</column><column name="commit">1cd5e7b</column><column name="commit_timestamp">1306250000</column><column name="files">java/org/apache/catalina/ant/FindLeaksTask.java
java/org/apache/catalina/manager/HTMLManagerServlet.java
java/org/apache/catalina/manager/ManagerServlet.java</column><column name="result">1:java/org/apache/catalina/manager/ManagerServlet.java
2:java/org/apache/catalina/manager/HTMLManagerServlet.java</column></table><table name="tomcat"><column name="id">453</column><column name="bug_id">27122</column><column name="summary">IE plugins cannot access components through Tomcat 5 over SSL</column><column name="description">SSL seems to be failing when the Content-Type header is set to "image/svg+xml". I've only seen this failure when SSL was running on a Solaris machine. (uname -a: SunOS [hostname removed] 5.8 Generic_108528-18 sun4u sparc SUNW,Ultra-60) When attempted on Windows, we were unable to duplicate the error. This reliably fails when attempted on this specific Solaris machine. If I get a chance, I'll try to create a test-case and see if I can reproduce this on other Solaris machines. Unfortunately, this was a show-stopper for a release that's being made today so I'm pressed for time. Basically, what happens is that we're using a JSP page to create an SVG file. Because of this, we have to set the Content-Type header to "image/svg+xml". When the MIME type is set to this value, the page fails to load in Internet Explorer 6 (SP1) with a message of "connection failed" or something similar. When an attempt was made in Opera, Opera responded by crashing. Mozilla successfully downloaded the file, though. However, when resetting the MIME type in the page to "text/plain" all three browsers can access the page without failure. By back-revving Tomcat to version 4.1.29, we were able to resolve this issue and access the page in all three browsers. I'll try and create a test-case later today and verify that it isn't just our SVG JSP that's failing but any that creates SVG but I'm currently pressed for time - sorry.</column><column name="report_time">2004-02-20 21:09:17</column><column name="report_timestamp">1077330000</column><column name="status">resolved fixed</column><column name="commit">4161179</column><column name="commit_timestamp">1306100000</column><column name="files">java/org/apache/catalina/authenticator/AuthenticatorBase.java</column><column name="result">5:java/org/apache/catalina/authenticator/AuthenticatorBase.java</column></table><table name="tomcat"><column name="id">454</column><column name="bug_id">51185</column><column name="summary">Performance : DataSourceProxy#createPool should use more fine grained synchronisation</column><column name="description">Hello, I don't know if this is the right component. My Enhancement concerns new Tomcat JDBC POOL. Looking at code I think that DataSourceProxy#createPool should not be synchronized but use another private method that is synchronized and used only when creation is needed, something like that: /** * Sets up the connection pool, by creating a pooling driver. * @return Driver * @throws SQLException */ public ConnectionPool createPool() throws SQLException { if (pool != null) { return pool; } else { 	return pCreatePool(); } } /** * * @return * @throws SQLException */ private synchronized ConnectionPool pCreatePool() throws SQLException { if (pool != null) { return pool; } else { pool = new ConnectionPool(poolProperties); return pool; } } Currently since createPool() is called for lots of getters we get this synchro IMPACT without really needing it. Regards Philippe http://www.ubik-ingenierie.com</column><column name="report_time">2011-05-11 10:21:44</column><column name="report_timestamp">1305120000</column><column name="status">resolved fixed</column><column name="commit">4bdd8d0</column><column name="commit_timestamp">1305930000</column><column name="files">modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/DataSourceProxy.java</column><column name="result">1:modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/DataSourceProxy.java</column></table><table name="tomcat"><column name="id">455</column><column name="bug_id">35054</column><column name="summary">warn if appBase is not existing as a File or directory</column><column name="description">otherwise, it may very hard to find what is wrong</column><column name="report_time">2005-05-25 10:03:08</column><column name="report_timestamp">1117030000</column><column name="status">resolved fixed</column><column name="commit">9bb6e4f</column><column name="commit_timestamp">1305920000</column><column name="files">java/org/apache/catalina/startup/HostConfig.java</column><column name="result">1:java/org/apache/catalina/startup/HostConfig.java</column></table><table name="tomcat"><column name="id">456</column><column name="bug_id">51220</column><column name="summary">Add system property that makes it possible for jsp pages with the extends page directive to take advantage of tag pooling</column><column name="description">Created attachment 27022 Patch file I would like to propose that a system property be added which would allow a JSP page that uses the extends page directive to take advantage of tag pooling. Patch file included.</column><column name="report_time">2011-05-18 15:42:54</column><column name="report_timestamp">1305750000</column><column name="status">resolved fixed</column><column name="commit">c46e56c</column><column name="commit_timestamp">1305800000</column><column name="files">java/org/apache/jasper/compiler/Generator.java</column><column name="result">6:java/org/apache/jasper/compiler/Generator.java</column></table><table name="tomcat"><column name="id">457</column><column name="bug_id">51229</column><column name="summary">Some async examples are not work correctly</column><column name="description">Created attachment 27031 patch for async examples Async0: The code that is befind complete() is not executed. StockTicker: The link for StockTicker is wrong. Regards.</column><column name="report_time">2011-05-19 06:55:54</column><column name="report_timestamp">1305800000</column><column name="status">resolved fixed</column><column name="commit">55d8b72</column><column name="commit_timestamp">1305800000</column><column name="files">webapps/examples/WEB-INF/classes/async/Async0.java</column><column name="result">84:webapps/examples/WEB-INF/classes/async/Async0.java</column></table><table name="tomcat"><column name="id">458</column><column name="bug_id">51212</column><column name="summary">QueryStats has synchornisation issues</column><column name="description">Created attachment 27017 Patch with Atomic approach Hello, I don't know if it is volontary but I think QueryStats fields should be Atomic because they are accessed by multiple threads at same time. I made a Load test with heavy load and collected results of SlowQueryReport and I get Sql queries with 0 as number of executions which is wrong as they have been executed at least once. By the way I don't know which approach will perform better: - synchronize add/failure - Use Atomic Maybe you did this for performance reasons. Regards Philippe Mouawad http://www.ubik-ingenierie.com</column><column name="report_time">2011-05-17 16:25:52</column><column name="report_timestamp">1305660000</column><column name="status">resolved fixed</column><column name="commit">b24b17c</column><column name="commit_timestamp">1305740000</column><column name="files">modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/interceptor/SlowQueryReport.java</column><column name="result">2:modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/interceptor/SlowQueryReport.java</column></table><table name="tomcat"><column name="id">459</column><column name="bug_id">51208</column><column name="summary">SVN TRUNK : JDBC interceptor options are not taken into account</column><column name="description">Created attachment 27013 Fix Hello, I added the following jdbcInterceptor: org.apache.tomcat.jdbc.pool.interceptor.SlowQueryReportJmx(threshold=100, maxQueries=5000) But options are not taken into account, what happens is that options are applied to the N-1 interceptor due to the Hard positionning of TrapException. I provide the patch that fixes the issue. Regards Philippe Mouawad http://www.ubik-ingenierie.com</column><column name="report_time">2011-05-17 09:14:29</column><column name="report_timestamp">1305640000</column><column name="status">resolved fixed</column><column name="commit">2bb247a</column><column name="commit_timestamp">1305640000</column><column name="files">modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/PoolProperties.java</column><column name="result">5:modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/PoolProperties.java</column></table><table name="tomcat"><column name="id">460</column><column name="bug_id">51156</column><column name="summary">"Expire sessions" button not visible for context configured in server.xml</column><column name="description">If app is configured in server.xml like this: {code} &lt;Host name="www.myapp.pl" appBase="/usr/lib/tomcat/webapps" unpackWARs="false" autoDeploy="false" xmlValidation="false" xmlNamespaceAware="false" &gt; &lt;Context docBase="/var/www/myapp" path="" cacheMaxSize="5120" cacheTTL="60000" cachingAllowed="true" &gt; &lt;/Context&gt; &lt;Context path="/manager" privileged="true" docBase="/usr/lib/tomcat/webapps/manager"&gt; &lt;/Context&gt; &lt;/Host&gt; {code} In Tomcat Manager, on the application list, there is a button "Expire sessions" available only for "/manager" application. There is no button "Expire sessions" for "/" path. I think bug is in HTMLManagerServlet.java in this part: {code} if (context.getPath().equals(this.context.getPath())) { writer.print(MessageFormat.format( MANAGER_APP_ROW_BUTTON_SECTION, args)); } else if (context.getAvailable() &amp;&amp; isDeployed) { writer.print(MessageFormat.format( STARTED_DEPLOYED_APPS_ROW_BUTTON_SECTION, args)); } else if (context.getAvailable() &amp;&amp; !isDeployed) { writer.print(MessageFormat.format( STARTED_NONDEPLOYED_APPS_ROW_BUTTON_SECTION, args)); } else if (!context.getAvailable() &amp;&amp; isDeployed) { writer.print(MessageFormat.format( STOPPED_DEPLOYED_APPS_ROW_BUTTON_SECTION, args)); } else { writer.print(MessageFormat.format( STOPPED_NONDEPLOYED_APPS_ROW_BUTTON_SECTION, args)); } {code}</column><column name="report_time">2011-05-06 00:30:54</column><column name="report_timestamp">1304660000</column><column name="status">resolved fixed</column><column name="commit">de7f0e1</column><column name="commit_timestamp">1304670000</column><column name="files">java/org/apache/catalina/manager/HTMLManagerServlet.java</column><column name="result">1:java/org/apache/catalina/manager/HTMLManagerServlet.java</column></table><table name="tomcat"><column name="id">461</column><column name="bug_id">51155</column><column name="summary">Missing @deprecated comments</column><column name="description">Created attachment 26961 Patch to add the missing comments There are several @deprecated tags without any information at all. The tags should say when the deprecation was added and what the replacement is.</column><column name="report_time">2011-05-05 19:36:28</column><column name="report_timestamp">1304640000</column><column name="status">resolved fixed</column><column name="commit">f477068</column><column name="commit_timestamp">1304670000</column><column name="files">java/javax/servlet/jsp/el/ELException.java
java/javax/servlet/jsp/el/ELParseException.java
java/javax/servlet/jsp/el/Expression.java
java/javax/servlet/jsp/el/ExpressionEvaluator.java
java/javax/servlet/jsp/el/FunctionMapper.java
java/javax/servlet/jsp/el/VariableResolver.java</column><column name="result">27:java/javax/servlet/jsp/el/ELParseException.java
35:java/javax/servlet/jsp/el/ELException.java
41:java/javax/servlet/jsp/el/FunctionMapper.java
43:java/javax/servlet/jsp/el/VariableResolver.java
44:java/javax/servlet/jsp/el/Expression.java
57:java/javax/servlet/jsp/el/ExpressionEvaluator.java</column></table><table name="tomcat"><column name="id">462</column><column name="bug_id">51154</column><column name="summary">Spurious @deprecated tags in ServletContext</column><column name="description">Created attachment 26960 Remove spurious tags There are some spurious @deprecated tags in ServletContext.</column><column name="report_time">2011-05-05 19:33:18</column><column name="report_timestamp">1304640000</column><column name="status">resolved fixed</column><column name="commit">01e1850</column><column name="commit_timestamp">1304670000</column><column name="files">java/javax/servlet/ServletContext.java</column><column name="result">2:java/javax/servlet/ServletContext.java</column></table><table name="tomcat"><column name="id">463</column><column name="bug_id">50950</column><column name="summary">NotSerializableException: org.apache.catalina.realm.GenericPrincipal</column><column name="description">Because this issue (https://issues.apache.org/bugzilla/show_bug.cgi?id=47502) is fixed I re-enabled using the security-constraint in web.xml to protect some pages instead of using my own workaround. But now I get a somewhat similar exception. This is running Tomcat 6.0.32 (directly from your tar.gz) on Debian 5 in a cluster of 3 nodes. I access my password protected pages over https. Mar 11, 2011 1:20:48 PM org.apache.catalina.ha.session.DeltaManager requestCompleted SEVERE: Unable to serialize delta request for sessionid [7D6D6A80C080C132F7EDCDAA3DFCEFB7] java.io.NotSerializableException: org.apache.catalina.realm.GenericPrincipal at java.io.ObjectOutputStream.writeObject0(ObjectOutputStream.java:1164) at java.io.ObjectOutputStream.writeObject(ObjectOutputStream.java:330) at java.util.LinkedList.writeObject(LinkedList.java:943) at sun.reflect.GeneratedMethodAccessor65.invoke(Unknown Source) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25) at java.lang.reflect.Method.invoke(Method.java:597) at java.io.ObjectStreamClass.invokeWriteObject(ObjectStreamClass.java:945) at java.io.ObjectOutputStream.writeSerialData(ObjectOutputStream.java:1469) at java.io.ObjectOutputStream.writeOrdinaryObject(ObjectOutputStream.java:1400) at java.io.ObjectOutputStream.writeObject0(ObjectOutputStream.java:1158) at java.io.ObjectOutputStream.access$300(ObjectOutputStream.java:143) at java.io.ObjectOutputStream$PutFieldImpl.writeFields(ObjectOutputStream.java:1677) at java.io.ObjectOutputStream.writeFields(ObjectOutputStream.java:462) at javax.security.auth.Subject$SecureSet.writeObject(Subject.java:1281) at sun.reflect.GeneratedMethodAccessor64.invoke(Unknown Source) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25) at java.lang.reflect.Method.invoke(Method.java:597) at java.io.ObjectStreamClass.invokeWriteObject(ObjectStreamClass.java:945) at java.io.ObjectOutputStream.writeSerialData(ObjectOutputStream.java:1469) at java.io.ObjectOutputStream.writeOrdinaryObject(ObjectOutputStream.java:1400) at java.io.ObjectOutputStream.writeObject0(ObjectOutputStream.java:1158) at java.io.ObjectOutputStream.defaultWriteFields(ObjectOutputStream.java:1518) at java.io.ObjectOutputStream.defaultWriteObject(ObjectOutputStream.java:422) at java.util.Collections$SynchronizedCollection.writeObject(Collections.java:1602) at sun.reflect.GeneratedMethodAccessor63.invoke(Unknown Source) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25) at java.lang.reflect.Method.invoke(Method.java:597) at java.io.ObjectStreamClass.invokeWriteObject(ObjectStreamClass.java:945) at java.io.ObjectOutputStream.writeSerialData(ObjectOutputStream.java:1469)</column><column name="report_time">2011-03-20 13:28:18</column><column name="report_timestamp">1300640000</column><column name="status">resolved fixed</column><column name="commit">0559491</column><column name="commit_timestamp">1304600000</column><column name="files">java/org/apache/catalina/ha/session/DeltaSession.java</column><column name="result">9:java/org/apache/catalina/ha/session/DeltaSession.java</column></table><table name="tomcat"><column name="id">464</column><column name="bug_id">51099</column><column name="summary">SPNEGO loginConfigName does not work</column><column name="description">As reported by fhanik on the dev list: 2. com.sun.security.jgss.krb5.accept is not configurable While the authenticator has the attribute loginConfigName, there seems to be a place in the code where it omits this entry. renaming this entry in jaas.conf and setting the loginConfigName will fail to validate a ticket The problem code is here: gssContext = manager.createContext(manager.createCredential(null, GSSCredential.DEFAULT_LIFETIME, new Oid("1.3.6.1.5.5.2"), GSSCredential.ACCEPT_ONLY)); should look like final GSSManager manager = GSSManager.getInstance(); final PrivilegedExceptionAction&lt;GSSCredential&gt; action = new PrivilegedExceptionAction&lt;GSSCredential&gt;() { public GSSCredential run() throws GSSException { return manager.createCredential(null, GSSCredential.DEFAULT_LIFETIME, new Oid("1.3.6.1.5.5.2"), GSSCredential.ACCEPT_ONLY); } }; gssContext = manager.createContext(Subject.doAs(lc.getSubject(), action));|| best Filip</column><column name="report_time">2011-04-21 05:11:31</column><column name="report_timestamp">1303380000</column><column name="status">resolved fixed</column><column name="commit">343a609</column><column name="commit_timestamp">1304550000</column><column name="files">java/org/apache/catalina/authenticator/SpnegoAuthenticator.java</column><column name="result">1:java/org/apache/catalina/authenticator/SpnegoAuthenticator.java</column></table><table name="tomcat"><column name="id">465</column><column name="bug_id">51119</column><column name="summary">extras - JmxRemoteLifecycleListener does not support JAAS based authentication and authorisation</column><column name="description">(Also true in Tomcat 7) The JmxRemoteLifecycleListener does not support JAAS based authentication. That is, when authentication is required, it only supports file based authentication.</column><column name="report_time">2011-04-26 05:29:40</column><column name="report_timestamp">1303810000</column><column name="status">resolved fixed</column><column name="commit">2ffa0f7</column><column name="commit_timestamp">1304540000</column><column name="files">java/org/apache/catalina/mbeans/JmxRemoteLifecycleListener.java</column><column name="result">1:java/org/apache/catalina/mbeans/JmxRemoteLifecycleListener.java</column></table><table name="tomcat"><column name="id">466</column><column name="bug_id">51124</column><column name="summary">ArrayIndexOutOfBoundsException after setting org.apache.jasper.runtime.BodyContentImpl.LIMIT_BUFFER=true</column><column name="description">First of all, I know that there has been a bug regarding a similar problem before and that it was fixed. But currently this bugs occurs even with tomcat version 6.0.32. We have a problem with the tomcat runnign with the parameter org.apache.jasper.runtime.BodyContentImpl.LIMIT_BUFFER=true. After the tomcat has just started, everything is fine but after one or two days a lot of ArrayIndexOutOfBoundsException occur on random pages of the application. Tomcats started without this parameter don't seem to have that problem. Unfortunately we weren't able reproduce the bug locally, It appears only on our production system. Could there be a concurrency problem, that only shows if a lot it going on on the platform? I can provide two small stackstraces that can show the classes where the problem occurs: 1. Caused by: java.lang.ArrayIndexOutOfBoundsException at org.apache.jasper.runtime.BodyContentImpl.write(Unknown Source) at java.io.PrintWriter.write(PrintWriter.java:382) at org.apache.jasper.runtime.JspWriterImpl.flushBuffer(Unknown Source) at org.apache.jasper.runtime.PageContextImpl.release(Unknown Source) at org.apache.jasper.runtime.JspFactoryImpl.internalReleasePageContext(Unknown Source) at org.apache.jasper.runtime.JspFactoryImpl.releasePageContext(Unknown Source) at org.apache.jsp.members.lists.short_.incomingShortList_jsp._jspService(incomingShortList_jsp.java:796) at org.apache.jasper.runtime.HttpJspBase.service(Unknown Source) at javax.servlet.http.HttpServlet.service(Unknown Source) 2. Caused by: java.lang.ArrayIndexOutOfBoundsException at java.lang.String.getChars(String.java:854) at org.apache.jasper.runtime.BodyContentImpl.write(Unknown Source) at org.apache.jasper.runtime.BodyContentImpl.write(Unknown Source) at org.apache.jasper.runtime.BodyContentImpl.print(Unknown Source) at org.apache.taglibs.standard.tag.common.fmt.MessageSupport.doEndTag(MessageSupport.java:203) at org.apache.jsp.members.profiles.profile_jsp._jspx_meth_fmt_005fmessage_005f2(profile_jsp.java:4897) at org.apache.jsp.members.profiles.profile_jsp._jspService(profile_jsp.java:481) at org.apache.jasper.runtime.HttpJspBase.service(Unknown Source) at javax.servlet.http.HttpServlet.service(Unknown Source)</column><column name="report_time">2011-04-27 06:31:47</column><column name="report_timestamp">1303900000</column><column name="status">resolved fixed</column><column name="commit">2cdbcd5</column><column name="commit_timestamp">1304540000</column><column name="files">java/org/apache/jasper/runtime/BodyContentImpl.java</column><column name="result">4:java/org/apache/jasper/runtime/BodyContentImpl.java</column></table><table name="tomcat"><column name="id">467</column><column name="bug_id">51136</column><column name="summary">Allow to set the context name through Tomcat's embeded class before adding it to the host</column><column name="description">org.apache.catalina.startup.Tomcat creates contexts and add them to the host directly. It would be nice if we could set the name of the context before adding it to the host. I'm including a patch that overloads the methods "addWebapp" and "addContext" to take that name as a parameter.</column><column name="report_time">2011-04-29 16:18:31</column><column name="report_timestamp">1304110000</column><column name="status">resolved fixed</column><column name="commit">2dc54c4</column><column name="commit_timestamp">1304500000</column><column name="files">java/org/apache/catalina/startup/Tomcat.java</column><column name="result">3:java/org/apache/catalina/startup/Tomcat.java</column></table><table name="tomcat"><column name="id">468</column><column name="bug_id">51095</column><column name="summary">NPE in AprEndpoint.java</column><column name="description">Created attachment 26917 Patch to AprEndpoint.java OVERVIEW: In all of the most recent versions of Tomcat 7, including Trunk. When running with APR SSL and the site is accessed using an improper SSL handshake, then a SEVERE NullPointerException will is logged into catalina.out. STEPS TO REPRODUCE: It's pretty easy to test this, just type the following: curl http://localhost:8444/ Where 8444 is the port that SSL is running on for Tomcat 7. ACTUAL RESULTS: If you look in the catalina.out when you do this, you'll see the following stack trace and error message: Apr 20, 2011 1:55:32 AM org.apache.coyote.http11.Http11AprProtocol$Http11ConnectionHandler process SEVERE: Error reading request, ignored java.lang.NullPointerException 	at org.apache.coyote.http11.Http11AprProcessor.process(Http11AprProcessor.java:208) 	at org.apache.coyote.http11.Http11AprProtocol$Http11ConnectionHandler.process(Http11AprProtocol.java:322) 	at org.apache.tomcat.util.net.AprEndpoint$SocketWithOptionsProcessor.run(AprEndpoint.java:1670) 	at java.util.concurrent.ThreadPoolExecutor$Worker.runTask(ThreadPoolExecutor.java:886) 	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:908) 	at java.lang.Thread.run(Thread.java:662) Exception in thread ""http-apr-8444"-exec-2727" java.lang.NullPointerException 	at org.apache.tomcat.util.net.AprEndpoint$SocketWithOptionsProcessor.run(AprEndpoint.java:1673) 	at java.util.concurrent.ThreadPoolExecutor$Worker.runTask(ThreadPoolExecutor.java:886) 	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:908) EXPECTED RESULTS: The expected behavior is for Tomcat to not generate a NullPointerException when someone improperly accesses the SSL port. BUILD INFO: Taken from the latest subversion trunk, 1095243. I've attached a patch that fixes this.</column><column name="report_time">2011-04-20 12:51:05</column><column name="report_timestamp">1303320000</column><column name="status">resolved fixed</column><column name="commit">75d28d4</column><column name="commit_timestamp">1303600000</column><column name="files">java/org/apache/tomcat/util/net/AprEndpoint.java</column><column name="result">1:java/org/apache/tomcat/util/net/AprEndpoint.java</column></table><table name="tomcat"><column name="id">469</column><column name="bug_id">50173</column><column name="summary">JDBCSampler discards ResultSet from a PreparedStatement.</column><column name="description">Hi, I am using JMeter with a Test Plan that uses a JDBC Request with a PreparedStatement query type. When running this I am getting the following error in the jmeter.log file 2010/10/28 11:30:31 INFO - jmeter.threads.JMeterThread: Thread started: JDBC Users 1-1 2010/10/28 12:13:38 ERROR - jmeter.threads.JMeterThread: Error while processing sampler 'PREPARED SELECT Customer JDBC Request' : java.lang.NullPointerException 	at org.apache.jmeter.protocol.jdbc.sampler.JDBCSampler.getStringFromResultSet(JDBCSampler.java:415) 	at org.apache.jmeter.protocol.jdbc.sampler.JDBCSampler.resultSetsToString(JDBCSampler.java:268) 	at org.apache.jmeter.protocol.jdbc.sampler.JDBCSampler.sample(JDBCSampler.java:208) 	at org.apache.jmeter.threads.JMeterThread.process_sampler(JMeterThread.java:348) 	at org.apache.jmeter.threads.JMeterThread.run(JMeterThread.java:243) 	at java.lang.Thread.run(Thread.java:619) The query (below) can be expected to return a number of records SELECT * FROM Customer WHERE ID=?; the param is set to 1 If I use instead a SelectStatement results are returned so the query itself is not at fault. I have retrieved the code for the v2_4 tag to identify the root cause for the NPE and create a patch. This bug report includes a patch against trunk as the issue is also in trunk. The root cause is due to: org.apache.jmeter.protocol.jdbc.sampler.JDBCSampler.sample(Entry e) The code path for PreparedStatements types starting on line 204 has in it a call to org.hsqldb.jdbc.JDBCPreparedStatement.executeUpdate() which returns a ResultSet. The side effect of the call is to set the JDBCPreparedStatement.currentResultSet field member to null. JDBCSampler does not keep the ResultSet reference. Instead it is discarded. The call on the next line (208) String sb = resultSetsToString(pstmt,true,null) again tries to get the ResultSet on line 267. This causes a NullPointerException because the JDBCPreparedStatement.currentResultSet field was set to null earlier. Looking at the code path for a CALLABLE statement type (line 190) shows better handling for queries that return ResultSet. The two lines 207,208 replaced with boolean hasResultSet = pstmt.execute(); String sb = resultSetsToString(pstmt,hasResultSet,null); fixes the defect. Regards, Jeremy Whiting Red Hat</column><column name="report_time">2010-10-28 10:14:39</column><column name="report_timestamp">1288280000</column><column name="status">resolved fixed</column><column name="commit">3a847c7</column><column name="commit_timestamp">1303000000</column><column name="files">java/org/apache/tomcat/util/net/AprEndpoint.java</column><column name="result">41:java/org/apache/tomcat/util/net/AprEndpoint.java</column></table><table name="tomcat"><column name="id">470</column><column name="bug_id">51042</column><column name="summary">HttpSessionListener.sessionCreated() is called a second time when user is authenticated with no matching sessionDestroyed() call.</column><column name="description">When my web application has a HttpSessionListener configured in its web.xml, then that classes sessionCreated() is called when a user is assigned a new session. However, that method is *also* called when that user authenticates itself and the session is assigned a new ID (whether or not this is actually a "new session" can be disputed, but that's not the point of this bug). When the session is removed (due to a timeout, for example), then a single sessionDestroyed() call is executed. When the HttpSessionListener manages some kind of external resource, this behaviour leads to a resource leak, because sessionCreated() is called twice, while sessionRemoved() is only called once! I'm aware of the reason for changing the session ID and (somehow) understand why sessionCreated() is called again (after all there's a new session ID), but there must be *some* way for the SessionListener to be notified that the "old session" no longer exists. The same behaviour is seen in Tomcat 6.0 (and probably 5.5 as well, but I didn't test that).</column><column name="report_time">2011-04-08 05:54:06</column><column name="report_timestamp">1302260000</column><column name="status">resolved fixed</column><column name="commit">dc3758e</column><column name="commit_timestamp">1302990000</column><column name="files">java/org/apache/catalina/Session.java
java/org/apache/catalina/ha/session/DeltaManager.java
java/org/apache/catalina/ha/session/DeltaSession.java
java/org/apache/catalina/ha/session/JvmRouteBinderValve.java
java/org/apache/catalina/manager/DummyProxySession.java
java/org/apache/catalina/session/ManagerBase.java
java/org/apache/catalina/session/StandardSession.java</column><column name="result">3:java/org/apache/catalina/ha/session/DeltaManager.java
5:java/org/apache/catalina/session/StandardSession.java
6:java/org/apache/catalina/Session.java
9:java/org/apache/catalina/manager/DummyProxySession.java
10:java/org/apache/catalina/ha/session/DeltaSession.java
11:java/org/apache/catalina/session/ManagerBase.java
63:java/org/apache/catalina/ha/session/JvmRouteBinderValve.java</column></table><table name="tomcat"><column name="id">471</column><column name="bug_id">51038</column><column name="summary">No access logs for Servlet 3.0 async requests</column><column name="description">Access logs written by org.apache.catalina.valves.AccessLogValve are not being written for servlet 3.0 async requests. To reproduce: - Handle a request asynchronously by marking the servlet with @WebServlet(asyncSupported=true) - Send some traffic and notice that nothing is being written to the access logs. AccessLogValve.log() is called by org.apache.catalina.Context.logAccess(). From the source for version 7.0.11, in org.apache.catalina.connector.CoyoteAdapter.java, line 416: AsyncContextImpl asyncConImpl = (AsyncContextImpl)request.getAsyncContext(); if (asyncConImpl != null) { async = true; } else if (!comet) { response.finishResponse(); if (postParseSuccess) { // Log only if processing was invoked. // If postParseRequest() failed, it has already logged it. ((Context) request.getMappingData().context).logAccess( request, response, System.currentTimeMillis() - req.getStartTime(), false); } req.action(ActionCode.POST_REQUEST , null); } In the async case logAccess() isn't called here. I've searched through the code and don't see logAccess() being called anywhere else, except in error cases. So, it looks like the async case is missing a call to logAccess() somewhere.</column><column name="report_time">2011-04-07 11:18:30</column><column name="report_timestamp">1302190000</column><column name="status">resolved fixed</column><column name="commit">dc3dff4</column><column name="commit_timestamp">1302990000</column><column name="files">java/org/apache/catalina/connector/CoyoteAdapter.java
test/org/apache/catalina/core/TestAsyncContextImpl.java
test/org/apache/catalina/valves/TesterAccessLogValve.java</column><column name="result">1:java/org/apache/catalina/connector/CoyoteAdapter.java
30:test/org/apache/catalina/core/TestAsyncContextImpl.java</column></table><table name="tomcat"><column name="id">472</column><column name="bug_id">50997</column><column name="summary">StandardJarScanner ignores web-fragment.xml files in unpacked jars if they are not ending with ".jar"</column><column name="description">Created attachment 26816 Fix for directories in classpath not ending with .jar We use eclipse sysdeo tomcat plugin for eclipse. It allows us to add target build directories of eclipse into tomcat classpath. All works fine until we decided to use web-fragment functionality. It failed to work despite the config: &lt;JarScanner scanAllDirectories="true"/&gt; I fixed the problem. Please, see attached proposed patch.</column><column name="report_time">2011-03-30 11:57:49</column><column name="report_timestamp">1301500000</column><column name="status">resolved fixed</column><column name="commit">62ddb9e</column><column name="commit_timestamp">1301520000</column><column name="files">java/org/apache/catalina/startup/ContextConfig.java
java/org/apache/tomcat/util/scan/StandardJarScanner.java</column><column name="result">2:java/org/apache/catalina/startup/ContextConfig.java
4:java/org/apache/tomcat/util/scan/StandardJarScanner.java</column></table><table name="tomcat"><column name="id">473</column><column name="bug_id">50927</column><column name="summary">[patch] More specific error message for missing SSLCertificateFile</column><column name="description">Created attachment 26767 Patch to check and report error If using SSL with APR, a missing SSLCertificateFile attribute currently results in a somewhat cryptic message from the native code. This patch checks whether the attribute is null before calling the native code, and reports a more specific error.</column><column name="report_time">2011-03-14 08:59:04</column><column name="report_timestamp">1300110000</column><column name="status">resolved fixed</column><column name="commit">e34f848</column><column name="commit_timestamp">1300270000</column><column name="files">java/org/apache/tomcat/util/net/AprEndpoint.java</column><column name="result">1:java/org/apache/tomcat/util/net/AprEndpoint.java</column></table><table name="tomcat"><column name="id">474</column><column name="bug_id">50929</column><column name="summary">[patch] Ensure rethrown exceptions retain the original cause</column><column name="description">Created attachment 26770 Patch to fix problem in some files Where an exception is caught an rethrown, it helps to provide the original exception as the cause.</column><column name="report_time">2011-03-14 11:08:56</column><column name="report_timestamp">1300120000</column><column name="status">resolved fixed</column><column name="commit">0c96676</column><column name="commit_timestamp">1300230000</column><column name="files">java/javax/servlet/http/HttpUtils.java
java/org/apache/catalina/connector/CoyoteInputStream.java
java/org/apache/catalina/realm/JDBCRealm.java
java/org/apache/catalina/valves/JDBCAccessLogValve.java
java/org/apache/naming/resources/WARDirContext.java
java/org/apache/tomcat/util/digester/NodeCreateRule.java</column><column name="result">13:java/org/apache/catalina/realm/JDBCRealm.java
81:java/org/apache/catalina/valves/JDBCAccessLogValve.java
341:java/org/apache/naming/resources/WARDirContext.java
627:java/org/apache/catalina/connector/CoyoteInputStream.java
665:java/javax/servlet/http/HttpUtils.java
670:java/org/apache/tomcat/util/digester/NodeCreateRule.java</column></table><table name="tomcat"><column name="id">475</column><column name="bug_id">50903</column><column name="summary">Current keep-alive request processed after connector.stop()</column><column name="description">When the connector is stopped, if a connection is in a keep-alive state the next request received by that connection will be processed and then the connection will be closed. When the request is received, it should be rejected. Outstanding questions: - What return code (if any) should be sent back to the client? - If the reading of a request starts before the connector is stopped, should that request be allowed to complete or should it be rejected?</column><column name="report_time">2011-03-09 14:34:53</column><column name="report_timestamp">1299700000</column><column name="status">resolved fixed</column><column name="commit">c8ea62e</column><column name="commit_timestamp">1300210000</column><column name="files">java/org/apache/coyote/ajp/AjpProcessor.java
java/org/apache/coyote/http11/Http11AprProcessor.java
java/org/apache/coyote/http11/Http11NioProcessor.java
java/org/apache/coyote/http11/Http11Processor.java
test/org/apache/catalina/connector/TestConnector.java
test/org/apache/catalina/startup/TesterServlet.java
test/org/apache/catalina/startup/TomcatBaseTest.java</column><column name="result">9:java/org/apache/coyote/http11/Http11Processor.java
11:java/org/apache/coyote/http11/Http11AprProcessor.java
21:java/org/apache/coyote/http11/Http11NioProcessor.java
28:java/org/apache/coyote/ajp/AjpProcessor.java
255:test/org/apache/catalina/startup/TomcatBaseTest.java</column></table><table name="tomcat"><column name="id">476</column><column name="bug_id">50887</column><column name="summary">Enhancement to set security-provider within AjpAprProcessor</column><column name="description">Created attachment 26742 Patches to set a securityProvider We need support of X.509 certificates using elliptic curves for client-auth within an servlet-application. The certificates we use are coded using DomainParameters within the PublicKey object. When using the sun-jdk this will lead to an error because the sun-jce implementation only supports elliptic curves as NamedCurves. The best way to fix this is to use another security-provider e.g. bouncycastle. For that we need a way to configure it within tomcat.</column><column name="report_time">2011-03-08 04:49:48</column><column name="report_timestamp">1299580000</column><column name="status">resolved fixed</column><column name="commit">552c4b7</column><column name="commit_timestamp">1300020000</column><column name="files">java/org/apache/catalina/valves/SSLValve.java
java/org/apache/coyote/AbstractProtocolHandler.java
java/org/apache/coyote/ajp/AbstractAjpProcessor.java
java/org/apache/coyote/ajp/AjpAprProtocol.java
java/org/apache/coyote/ajp/AjpProtocol.java
java/org/apache/coyote/http11/Http11AprProcessor.java
java/org/apache/coyote/http11/Http11AprProtocol.java</column><column name="result">3:java/org/apache/coyote/ajp/AjpAprProtocol.java
4:java/org/apache/coyote/http11/Http11AprProcessor.java
7:java/org/apache/coyote/ajp/AbstractAjpProcessor.java
8:java/org/apache/coyote/ajp/AjpProtocol.java
13:java/org/apache/coyote/http11/Http11AprProtocol.java
57:java/org/apache/coyote/AbstractProtocolHandler.java
280:java/org/apache/catalina/valves/SSLValve.java</column></table><table name="tomcat"><column name="id">477</column><column name="bug_id">50895</column><column name="summary">JSP compiler initializes classes during compile which can result in failures</column><column name="description">The fix for Bug 49555 adds the following code call: clazz = Class.forName(className, true, tccl); The 2nd argument (initialize) is set to true resulting in it attempting to initialize the class. This can result in compilation failures if the class has ugly static initializer requirements. It can also increases the time and memory footprint of compilation as the classes. I think for the purposes of the getCanonicalName() call, the second argument should be set to false to prevent initialization of the class in question.</column><column name="report_time">2011-03-08 15:27:00</column><column name="report_timestamp">1299620000</column><column name="status">resolved fixed</column><column name="commit">5d61212</column><column name="commit_timestamp">1299680000</column><column name="files">java/org/apache/jasper/compiler/ELFunctionMapper.java</column><column name="result">47:java/org/apache/jasper/compiler/ELFunctionMapper.java</column></table><table name="tomcat"><column name="id">478</column><column name="bug_id">25060</column><column name="summary">Reloading context orphans currently open jndi datasource connections</column><column name="description">I fiddled around with this a while and have determined to the best of my ability that this is a real bug. I have a jndi datasource connected to a postgresql server. I have two jndi resources (a reader and writer) so that later I can implement a system with replication etc and deal with writes and reads to different connections. To summarize, after using the system, there are two connections to postgres that get reused -- one reader and writer. Under load, this number increases and will slowly go back down. I usually end up with two idle connections (one reader and one writer) left under no load. If you reload the context where the datasource is at (it's a context specific datasource), the number of connections will jump by two when used. Each reload produces 2 more connections min until I restart the server. It appears that after a reload, the 'persisted connections' get abandoned / orphaned. Eventually, I hit my max connections and cannot aquire any more and the system fails. I have tried the abandond collection parameters and have added debug logging to my code to ensure that I am indeed calling close on the connections I checkout, even on exceptions and error cases. Under normal useage without reloads, no connection leakage happens. This is on a solaris 8 machine with the 4.1.27-hotfix-22096.tar.gz applied. Let me know if more information is required. I have this in a development environment and can let somone attach in jdb and hammer on the thing since it's not a production system -- if that will help in getting a repro. Wayne</column><column name="report_time">2003-11-27 21:15:10</column><column name="report_timestamp">1069990000</column><column name="status">resolved fixed</column><column name="commit">1211dbe</column><column name="commit_timestamp">1299620000</column><column name="files">java/org/apache/catalina/core/StandardContext.java
java/org/apache/catalina/deploy/NamingResources.java</column><column name="result">1:java/org/apache/catalina/core/StandardContext.java
36:java/org/apache/catalina/deploy/NamingResources.java</column></table><table name="tomcat"><column name="id">479</column><column name="bug_id">26701</column><column name="summary">Enabling web applications to register their own stream handlers</column><column name="description">A stream handler factory can be registered once per VM and tomcat registers the DirContextStreamHandlerFactory for the jndi protocol. However if there are web applications running inside that want to register handlers for custom scheme currently it is not possible. Can the DirContextStreamHandlerFactory be enhanced to allow applications to register stream handler for custom schemes they might have. Or better can this be a made a property in the context.xml file ? Is this already there - or can this enhanced in the future?</column><column name="report_time">2004-02-05 21:30:18</column><column name="report_timestamp">1076030000</column><column name="status">resolved fixed</column><column name="commit">f622e3a</column><column name="commit_timestamp">1299450000</column><column name="files">java/org/apache/catalina/loader/WebappLoader.java
java/org/apache/naming/resources/Constants.java
java/org/apache/naming/resources/DirContextURLStreamHandlerFactory.java
test/org/apache/naming/resources/TestDirContextURLStreamHandlerFactory.java</column><column name="result">5:java/org/apache/naming/resources/DirContextURLStreamHandlerFactory.java
43:java/org/apache/catalina/loader/WebappLoader.java
147:java/org/apache/naming/resources/Constants.java</column></table><table name="tomcat"><column name="id">480</column><column name="bug_id">50855</column><column name="summary">NullPointerException thrown in AuthenticatorBase.register method for null principal</column><column name="description">The description is the same as for the older bug 39255, except it is produced at org.apache.catalina.authenticator.AuthenticatorBase.register(AuthenticatorBase.java:688) Please, see the following link https://issues.apache.org/bugzilla/show_bug.cgi?id=39255 This bug has been fixed for Tomcat 5.5.16, but it looks to appear again in Tomcat 7. This is the excerpt from AuthenticatorBase.java: public void register(Request request, HttpServletResponse response, Principal principal, String authType, String username, String password) { if (log.isDebugEnabled()) log.debug("Authenticated '" + principal.getName() + "' with type '" + authType + "'"); It is seen that there is no more condition to verify if principal is null. Specifically, the NullPointerException is thrown when calling HttpServletRequest.logout method from a JSF managed bean. According to Java EE 6 documentation, the logout method establishes null as the value returned when getUserPrincipal, getRemoteUser, and getAuthType is called on the request. Hence, the exception thrown.</column><column name="report_time">2011-03-02 11:19:27</column><column name="report_timestamp">1299080000</column><column name="status">resolved fixed</column><column name="commit">b24b0c0</column><column name="commit_timestamp">1299400000</column><column name="files">java/org/apache/catalina/authenticator/AuthenticatorBase.java</column><column name="result">1:java/org/apache/catalina/authenticator/AuthenticatorBase.java</column></table><table name="tomcat"><column name="id">481</column><column name="bug_id">50857</column><column name="summary">Test failures on Windows 7, 24 thread system</column><column name="description">testPoolThreads20Connections10FairAsync [junit] java.sql.SQLException: [tomcat-pool-10] NoWait: Pool empty. Unable to fetch a connection, none available[10 in use]. [junit] at org.apache.tomcat.jdbc.pool.ConnectionPool.borrowConnection(ConnectionPool.java:615) [junit] at org.apache.tomcat.jdbc.pool.ConnectionPool.getConnectionAsync(ConnectionPool.java:143) [junit] at org.apache.tomcat.jdbc.pool.DataSourceProxy.getConnectionAsync(DataSourceProxy.java:122) [junit] at org.apache.tomcat.jdbc.test.FairnessTest$TestThread.run(FairnessTest.java:231)</column><column name="report_time">2011-03-02 15:50:18</column><column name="report_timestamp">1299100000</column><column name="status">resolved fixed</column><column name="commit">ef547fb</column><column name="commit_timestamp">1299100000</column><column name="files">modules/jdbc-pool/java/org/apache/tomcat/jdbc/pool/ConnectionPool.java</column><column name="result">1:modules/jdbc-pool/java/org/apache/tomcat/jdbc/pool/ConnectionPool.java</column></table><table name="tomcat"><column name="id">482</column><column name="bug_id">27988</column><column name="summary">Unhelpful FileNotFoundException raised</column><column name="description">org.apache.naming.resources.DirContextURLConnection raises FileNotFoundException on lines 311, 344, 382 and 396. It would be more helpful if these provided a message string. For example, change line 344 to throw new FileNotFoundException(getURL().getFile()); This would make it easier to diagnose mistakes in server configurations.</column><column name="report_time">2004-03-26 17:01:25</column><column name="report_timestamp">1080340000</column><column name="status">resolved fixed</column><column name="commit">4a4d86e</column><column name="commit_timestamp">1299070000</column><column name="files">java/org/apache/naming/resources/DirContextURLConnection.java</column><column name="result">1:java/org/apache/naming/resources/DirContextURLConnection.java</column></table><table name="tomcat"><column name="id">483</column><column name="bug_id">28852</column><column name="summary">failonerror attribute on Ant tasks</column><column name="description">failonerror boolean attribute on manager Ant tasks would be a nice have to allow for more flexible operation within Ant build files. I will attach a patch next week that also fixes unecessary CRs during response read/print and missing url encoding in some tasks.</column><column name="report_time">2004-05-08 20:23:38</column><column name="report_timestamp">1084060000</column><column name="status">resolved fixed</column><column name="commit">e1bf740</column><column name="commit_timestamp">1298920000</column><column name="files">java/org/apache/catalina/ant/JMXGetTask.java
java/org/apache/catalina/ant/JMXQueryTask.java
java/org/apache/catalina/ant/JMXSetTask.java
java/org/apache/catalina/ant/ResourcesTask.java
java/org/apache/catalina/ant/UndeployTask.java</column><column name="result">10:java/org/apache/catalina/ant/ResourcesTask.java
15:java/org/apache/catalina/ant/UndeployTask.java
27:java/org/apache/catalina/ant/JMXGetTask.java
37:java/org/apache/catalina/ant/JMXSetTask.java
78:java/org/apache/catalina/ant/JMXQueryTask.java</column></table><table name="tomcat"><column name="id">484</column><column name="bug_id">31027</column><column name="summary">major error from minor whitespace error in properties file</column><column name="description">A developer accidentally placed a tab character after the port number in the properties file for a tomcat instance. This prevented tomcat from listening on that port, but it was difficult to track down whether tomcat was running. Seems like the properties-file reader could easily trim excess whitespace before trying to use entries.</column><column name="report_time">2004-09-02 22:36:52</column><column name="report_timestamp">1094180000</column><column name="status">resolved wontfix</column><column name="commit">4b4ef0c</column><column name="commit_timestamp">1298810000</column><column name="files">java/org/apache/catalina/startup/CatalinaProperties.java</column><column name="result">3:java/org/apache/catalina/startup/CatalinaProperties.java</column></table><table name="tomcat"><column name="id">485</column><column name="bug_id">50836</column><column name="summary">LifecycleState#isAvailable() to be more restrictive</column><column name="description">I think some of the values returned by LifecycleState#isAvailable() are wrong. 1. I am certain that MUST_DESTROY should return false, because it is a state that is later than stopped. 2. I think that STOPPING_PREP should return false, because we can get there from the FAILED state. 3. I think that STARTING should return false, because it is too early to return true there. As a result, the following is the complete list of states are to return true in #isAvailable(): STARTED, MUST_STOP</column><column name="report_time">2011-02-26 14:05:18</column><column name="report_timestamp">1298750000</column><column name="status">resolved fixed</column><column name="commit">92ff888</column><column name="commit_timestamp">1298800000</column><column name="files">java/org/apache/catalina/Lifecycle.java
java/org/apache/catalina/LifecycleListener.java
java/org/apache/catalina/LifecycleState.java
java/org/apache/catalina/util/LifecycleBase.java</column><column name="result">5:java/org/apache/catalina/util/LifecycleBase.java
6:java/org/apache/catalina/Lifecycle.java
166:java/org/apache/catalina/LifecycleListener.java</column></table><table name="tomcat"><column name="id">486</column><column name="bug_id">49284</column><column name="summary">Implement SSL renegotiation for the NIO connector</column><column name="description">Summary says it all. Entered as a reminder that it would be good to do this.</column><column name="report_time">2010-05-12 19:06:24</column><column name="report_timestamp">1273710000</column><column name="status">resolved fixed</column><column name="commit">dcda15d</column><column name="commit_timestamp">1298660000</column><column name="files">java/org/apache/coyote/http11/Http11NioProcessor.java
java/org/apache/tomcat/util/net/NioChannel.java
java/org/apache/tomcat/util/net/SecureNioChannel.java</column><column name="result">3:java/org/apache/coyote/http11/Http11NioProcessor.java
51:java/org/apache/tomcat/util/net/SecureNioChannel.java
56:java/org/apache/tomcat/util/net/NioChannel.java</column></table><table name="tomcat"><column name="id">487</column><column name="bug_id">50826</column><column name="summary">(Embedded) Tomcat.destroy() throws java.lang.IllegalArgumentException</column><column name="description">Embedded Tomcat sometimes throws this exception when calling destroy() method: java.lang.IllegalArgumentException: null source 	at java.util.EventObject.&lt;init&gt;(EventObject.java:56) 	at javax.management.Notification.&lt;init&gt;(Notification.java:184) 	at org.apache.catalina.core.StandardContext.destroyInternal(StandardContext.java:5433) 	at org.apache.catalina.util.LifecycleBase.destroy(LifecycleBase.java:285) 	at org.apache.catalina.core.ContainerBase.removeChild(ContainerBase.java:969) 	at org.apache.catalina.core.ContainerBase.destroyInternal(ContainerBase.java:1108) 	at org.apache.catalina.util.LifecycleBase.destroy(LifecycleBase.java:285) 	at org.apache.catalina.core.ContainerBase.removeChild(ContainerBase.java:969) 	at org.apache.catalina.core.ContainerBase.destroyInternal(ContainerBase.java:1108) 	at org.apache.catalina.util.LifecycleBase.destroy(LifecycleBase.java:285) 	at org.apache.catalina.core.StandardService.destroyInternal(StandardService.java:593) 	at org.apache.catalina.util.LifecycleBase.destroy(LifecycleBase.java:285) 	at org.apache.catalina.core.StandardServer.destroyInternal(StandardServer.java:786) 	at org.apache.catalina.util.LifecycleBase.destroy(LifecycleBase.java:285) 	at org.apache.catalina.startup.Tomcat.destroy(Tomcat.java:323) 	at su.msk.jet.nioproxy.rule.config.EmbeddedWebserver.stop(EmbeddedWebserver.java:26) I think that StandardContext.destroyInternal() misses check that this.getObjectName()!=null</column><column name="report_time">2011-02-24 08:47:47</column><column name="report_timestamp">1298560000</column><column name="status">resolved fixed</column><column name="commit">9d542ed</column><column name="commit_timestamp">1298570000</column><column name="files">java/org/apache/catalina/core/StandardContext.java
test/org/apache/catalina/startup/TestTomcat.java</column><column name="result">2:java/org/apache/catalina/core/StandardContext.java
102:test/org/apache/catalina/startup/TestTomcat.java</column></table><table name="tomcat"><column name="id">488</column><column name="bug_id">21669</column><column name="summary">JNDIRealm roleBase pattern enahncement</column><column name="description">Currently the roleBase attribute must be a fxed location in the directory. A simple change would allow the role base to be specified relative to the user DN. My enhancement suggestion would change the roleBase definition as follows: roleBase - the base entry for the role search. If not specified, the search base is the top level directory context. If specified it may optionally include pattern replacements "{0}".."{n}" corrosponding to the name parts of the user's distinguished name (as returned by javax.naming.Name.get()). For example, in the &lt;Realm&gt; defintion in server.xml you could specify the roleBase as: roleBase="ou=Groups,{1},{0}" The majority of the code to accomplish this would be in JNDIRealm.getRoles() and could look like this: 	String base = null; 	if ( roleBaseFormat != null ) 	{ 		NameParser np = context.getNameParser(""); 		Name name = np.parse(dn); 		String nameParts[] = new String[name.size()]; 		for ( int idx = 0 ; idx &lt; name.size() ; idx++ ) 			nameParts[idx] = name.get(idx); 	base = roleBaseFormat.format(nameParts); 	} // Perform the configured search and process the results if (debug &gt;= 3) { log(" Searching role base '" + base + "' for attribute '" + roleName + "'"); log(" With filter expression '" + filter + "'"); } NamingEnumeration results = context.search(base, filter, controls); Thank You, Art</column><column name="report_time">2003-07-16 22:59:24</column><column name="report_timestamp">1058410000</column><column name="status">resolved fixed</column><column name="commit">f22600c</column><column name="commit_timestamp">1298380000</column><column name="files">java/org/apache/catalina/realm/JNDIRealm.java</column><column name="result">1:java/org/apache/catalina/realm/JNDIRealm.java</column></table><table name="tomcat"><column name="id">489</column><column name="bug_id">19444</column><column name="summary">JNDI Authentication roles must be anonymous accessible</column><column name="description">It appears that for the JNDIRealm to be able to locate roles, they must be anonymous accessible. I believe that for security purposes this should not be necessary if we are validating the user by binding to the directory. In that case the roles could be accessible to any bound user or that particular user. I discussed this very briefly on the Tomcat user list. It sounds like this had been discussed previously and for whatever reason, the idea rejected. Anyhow I submit that there is a bug, either in the code - which requires the roles to be anonymous, or in the documentation which does not make it clear that this is the case (at least in "Tomcat 4 Servlet/JSP Container - Realm Configuration HOW- TO). It seems reasonable to me that if we are binding to the directory to authenticate, we would have that user's access to roles. Perhaps the documentation should more explicetly state that this is not the case. In the hope that it would be accepted as an enhancement, I am going to attempt to attach a modified JNDIRealm that uses the authenticated connection to obtain the roles. Thank You, Art</column><column name="report_time">2003-04-29 21:58:13</column><column name="report_timestamp">1051670000</column><column name="status">resolved fixed</column><column name="commit">a085c4a</column><column name="commit_timestamp">1298370000</column><column name="files">java/org/apache/catalina/realm/JNDIRealm.java</column><column name="result">1:java/org/apache/catalina/realm/JNDIRealm.java</column></table><table name="tomcat"><column name="id">490</column><column name="bug_id">50189</column><column name="summary">AJP connector sends GET BODY CHUNK when reading after response closed</column><column name="description">If a servlet (probably incorrectly) closes the writer/outputstream of a response, and then attempts to read from the request, the AJP connector sends GET BODY CHUNK to the mod_jk worker. This then starts a series of very confusing communication between the worker and tomcat. The worker doesn't read it until it makes its next request. After making its next request, it reads it, and then sends a response with 0 length. At the same time, Tomcat responds to the request made by the worker with another GET BODY CHUNK, which the worker also responds with a message of 0 length. Then the really weird thing happens, Tomcat replays the first request made by that worker. At this point, based on what I'm looking at with tcpdump, I get too confused to work out exactly what is happening.</column><column name="report_time">2010-10-31 23:27:02</column><column name="report_timestamp">1288580000</column><column name="status">resolved fixed</column><column name="commit">514e713</column><column name="commit_timestamp">1298050000</column><column name="files">java/org/apache/catalina/connector/OutputBuffer.java</column><column name="result">188:java/org/apache/catalina/connector/OutputBuffer.java</column></table><table name="tomcat"><column name="id">491</column><column name="bug_id">50802</column><column name="summary">Deviation from servlet3 spec concerning resource lookup from META-INF/resources</column><column name="description">Created attachment 26675 test application to reproduce. extract, deploy the war, make a query to root URL, see the system-out for evidence of standard-deviating behavior Hi! I'm writing you from ZeroTurnaround and we are currently building JRebel integration with new containers aiming to implement the servlet3 standard. I've stumbled on a bug in your implementation that is actually at the very core of the servlet standard and thus quite important, and actually a major issue for our integration. Namely, i'm copy-pasting you a fragment of the reference javadoc of the servlet3 spec for the method ServletContext#getResourcePaths(): ============= SPEC START ================= For example, for a web application containing: /welcome.html /catalog/index.html /catalog/products.html /catalog/offers/books.html /catalog/offers/music.html /customer/login.jsp /WEB-INF/web.xml /WEB-INF/classes/com.acme.OrderServlet.class /WEB-INF/lib/catalog.jar!/META-INF/resources/catalog/moreOffers/books.html getResourcePaths("/") would return {"/welcome.html", "/catalog/", "/customer/", "/WEB-INF/"}, and getResourcePaths("/catalog/") would return {"/catalog/index.html", "/catalog/products.html", "/catalog/offers/", "/catalog/moreOffers/"}. ============= SPEC END ================= Now run my test-application, you'll discover immediately that Tomcat doesn't respect that standard. getResourcesPath("/catalog") would not return "/catalog/moreOffers" if there were 2 embedded jars containing web-fragments. And even more importantly, had there been a new folder coming solely from a jar's META-INF/resources, this wouldn't get listed with getResourcePaths("/"). Please note that these are important issues! Many frameworks rely on various scanning techniques for recursive resource lookup, and so forth. I've tested this thing with Tomcat 7.0.6 and 7.0.8, problems are present with both. (Btw, we've received information about the same problems from users of latest glassfish version as well.. i think they are just re-using this part of tomcat and thus getting the same problems... not sure.) Thanks a lot if you can have a look at this!</column><column name="report_time">2011-02-17 13:20:33</column><column name="report_timestamp">1297970000</column><column name="status">resolved fixed</column><column name="commit">a9c3193</column><column name="commit_timestamp">1297980000</column><column name="files">java/org/apache/naming/resources/BaseDirContext.java
java/org/apache/naming/resources/FileDirContext.java
java/org/apache/naming/resources/VirtualDirContext.java
java/org/apache/naming/resources/WARDirContext.java</column><column name="result">17:java/org/apache/naming/resources/WARDirContext.java
21:java/org/apache/naming/resources/BaseDirContext.java
23:java/org/apache/naming/resources/VirtualDirContext.java
30:java/org/apache/naming/resources/FileDirContext.java</column></table><table name="tomcat"><column name="id">492</column><column name="bug_id">50780</column><column name="summary">AjpConnectionHandler keeps many connections causing memory leak</column><column name="description">Hi, Sorry for my english. I use Tomcat 7.0.6 with APR 1.1.20. I noticed (from heap dump) many org.apache.tomcat.util.net.SocketWrapper objects, which are kept by "connections" atribute in org.apache.coyote.ajp.AjpAprProtocol$AjpConnectionHandler object. I don't understand, why there are so many objects representing old connections which are not active. In my example it was 300000 objects created, after 7 days of Tomcat work. Has someone forgotten to clean this HashMap from time to time? best regards Sergiusz Brzezinski</column><column name="report_time">2011-02-15 04:51:49</column><column name="report_timestamp">1297760000</column><column name="status">resolved fixed</column><column name="commit">b56bf50</column><column name="commit_timestamp">1297960000</column><column name="files">java/org/apache/coyote/ajp/AjpAprProtocol.java</column><column name="result">1:java/org/apache/coyote/ajp/AjpAprProtocol.java</column></table><table name="tomcat"><column name="id">493</column><column name="bug_id">50789</column><column name="summary">custom error pages and CDI/weld problem</column><column name="description">Created attachment 26662 test case I can't seem to use CDI/weld in custom error pages. A testcase is attached. Build with "mvn install", deploy. "index.html" links to "404.jsf". If you visit this url, the page is displayed correctly. If you go somewhere else, thereby provoking a 404, it should display the same. Instead, I see tomcat's generic 404 page and this stacktrace: Feb 15, 2011 6:04:43 PM org.apache.catalina.core.ApplicationDispatcher invoke SEVERE: Servlet.service() for servlet Faces Servlet threw exception java.lang.IllegalStateException: Must call associate() before calling activate() at org.jboss.weld.context.AbstractConversationContext.activate(AbstractConversationContext.java:273) at org.jboss.weld.jsf.WeldPhaseListener.activateConversations(WeldPhaseListener.java:110) at org.jboss.weld.jsf.WeldPhaseListener.beforePhase(WeldPhaseListener.java:84) at com.sun.faces.lifecycle.Phase.handleBeforePhase(Phase.java:224) at com.sun.faces.lifecycle.Phase.doPhase(Phase.java:95) at com.sun.faces.lifecycle.RestoreViewPhase.doPhase(RestoreViewPhase.java:107) at com.sun.faces.lifecycle.LifecycleImpl.execute(LifecycleImpl.java:114) at javax.faces.webapp.FacesServlet.service(FacesServlet.java:308) at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:306) at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:210) at org.apache.catalina.core.ApplicationDispatcher.invoke(ApplicationDispatcher.java:672) at org.apache.catalina.core.ApplicationDispatcher.processRequest(ApplicationDispatcher.java:465) at org.apache.catalina.core.ApplicationDispatcher.doForward(ApplicationDispatcher.java:402) at org.apache.catalina.core.ApplicationDispatcher.forward(ApplicationDispatcher.java:329) at org.apache.catalina.core.StandardHostValve.custom(StandardHostValve.java:466) at org.apache.catalina.core.StandardHostValve.status(StandardHostValve.java:387) at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:181) at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:100) at org.apache.catalina.valves.AccessLogValve.invoke(AccessLogValve.java:541) at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:118) at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:383) at org.apache.coyote.http11.Http11AprProcessor.process(Http11AprProcessor.java:284) at org.apache.coyote.http11.Http11AprProtocol$Http11ConnectionHandler.process(Http11AprProtocol.java:322) at org.apache.tomcat.util.net.AprEndpoint$SocketProcessor.run(AprEndpoint.java:1684) at java.util.concurrent.ThreadPoolExecutor$Worker.runTask(ThreadPoolExecutor.java:886) at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:908) at java.lang.Thread.run(Thread.java:662) Feb 15, 2011 6:04:43 PM org.apache.catalina.core.StandardHostValve custom SEVERE: Exception Processing ErrorPage[errorCode=404, location=/404.jsf] javax.servlet.ServletException: Must call associate() before calling activate() at javax.faces.webapp.FacesServlet.service(FacesServlet.java:321) at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:306) at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:210) at org.apache.catalina.core.ApplicationDispatcher.invoke(ApplicationDispatcher.java:672) at org.apache.catalina.core.ApplicationDispatcher.processRequest(ApplicationDispatcher.java:465) at org.apache.catalina.core.ApplicationDispatcher.doForward(ApplicationDispatcher.java:402) at org.apache.catalina.core.ApplicationDispatcher.forward(ApplicationDispatcher.java:329) at org.apache.catalina.core.StandardHostValve.custom(StandardHostValve.java:466) at org.apache.catalina.core.StandardHostValve.status(StandardHostValve.java:387) at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:181) at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:100) at org.apache.catalina.valves.AccessLogValve.invoke(AccessLogValve.java:541) at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:118) at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:383) at org.apache.coyote.http11.Http11AprProcessor.process(Http11AprProcessor.java:284) at org.apache.coyote.http11.Http11AprProtocol$Http11ConnectionHandler.process(Http11AprProtocol.java:322) at org.apache.tomcat.util.net.AprEndpoint$SocketProcessor.run(AprEndpoint.java:1684) at java.util.concurrent.ThreadPoolExecutor$Worker.runTask(ThreadPoolExecutor.java:886) at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:908) at java.lang.Thread.run(Thread.java:662) Caused by: java.lang.IllegalStateException: Must call associate() before calling activate() at org.jboss.weld.context.AbstractConversationContext.activate(AbstractConversationContext.java:273) at org.jboss.weld.jsf.WeldPhaseListener.activateConversations(WeldPhaseListener.java:110) at org.jboss.weld.jsf.WeldPhaseListener.beforePhase(WeldPhaseListener.java:84) at com.sun.faces.lifecycle.Phase.handleBeforePhase(Phase.java:224) at com.sun.faces.lifecycle.Phase.doPhase(Phase.java:95) at com.sun.faces.lifecycle.RestoreViewPhase.doPhase(RestoreViewPhase.java:107) at com.sun.faces.lifecycle.LifecycleImpl.execute(LifecycleImpl.java:114) at javax.faces.webapp.FacesServlet.service(FacesServlet.java:308) ... 19 more tomcat 7.0.8, java 1.6.0_23, windows XP SP3. This issue reminds me of https://issues.apache.org/bugzilla/show_bug.cgi?id=49991, that was on the issue of using CDI/weld in the login/login failed pages used when doing form authentication.</column><column name="report_time">2011-02-15 12:09:28</column><column name="report_timestamp">1297790000</column><column name="status">resolved fixed</column><column name="commit">3810b04</column><column name="commit_timestamp">1297940000</column><column name="files">java/org/apache/catalina/Context.java
java/org/apache/catalina/core/ApplicationDispatcher.java
java/org/apache/catalina/core/StandardContext.java</column><column name="result">1:java/org/apache/catalina/core/StandardContext.java
9:java/org/apache/catalina/Context.java
281:java/org/apache/catalina/core/ApplicationDispatcher.java</column></table><table name="tomcat"><column name="id">494</column><column name="bug_id">50790</column><column name="summary">EL parser needs to be more dynamic</column><column name="description">String.containes(CharSequence) is not being resolved correctly in the following situation: &lt;span class="#{(facesContext.externalContext.request.requestURI.contains(item.url)) ? 'activepage' : ''}"&gt;#{template[item.labelKey]}&lt;/span&gt; Exception: javax.el.ELException: /faces/template/mainLayout.xhtml: java.lang.NoSuchMethodException: java.lang.String.contains(java.lang.String) 	at com.sun.faces.facelets.compiler.AttributeInstruction.write(AttributeInstruction.java:87) 	at com.sun.faces.facelets.compiler.UIInstructions.encodeBegin(UIInstructions.java:75) 	at com.sun.faces.renderkit.html_basic.HtmlBasicRenderer.encodeRecursive(HtmlBasicRenderer.java:285) 	at com.sun.faces.renderkit.html_basic.OutputLinkRenderer.encodeChildren(OutputLinkRenderer.java:125) 	at javax.faces.component.UIComponentBase.encodeChildren(UIComponentBase.java:848) 	at javax.faces.component.UIComponent.encodeAll(UIComponent.java:1613) 	at com.sun.faces.facelets.component.RepeatRenderer.encodeChildren(RepeatRenderer.java:97) 	at com.sun.faces.facelets.component.UIRepeat.process(UIRepeat.java:496) 	at com.sun.faces.facelets.component.UIRepeat.encodeChildren(UIRepeat.java:926) 	at javax.faces.component.UIComponent.encodeAll(UIComponent.java:1613) 	at javax.faces.render.Renderer.encodeChildren(Renderer.java:168) 	at javax.faces.component.UIComponentBase.encodeChildren(UIComponentBase.java:848) 	at javax.faces.component.UIComponent.encodeAll(UIComponent.java:1613) 	at javax.faces.component.UIComponent.encodeAll(UIComponent.java:1616) 	at javax.faces.component.UIComponent.encodeAll(UIComponent.java:1616) 	at com.sun.faces.application.view.FaceletViewHandlingStrategy.renderView(FaceletViewHandlingStrategy.java:380) 	at com.sun.faces.application.view.MultiViewHandler.renderView(MultiViewHandler.java:126) 	at com.ocpsoft.pretty.faces.application.PrettyViewHandler.renderView(PrettyViewHandler.java:157) 	at com.sun.faces.lifecycle.RenderResponsePhase.execute(RenderResponsePhase.java:127) 	at com.sun.faces.lifecycle.Phase.doPhase(Phase.java:101) 	at com.sun.faces.lifecycle.LifecycleImpl.render(LifecycleImpl.java:139) 	at javax.faces.webapp.FacesServlet.service(FacesServlet.java:313) 	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:306) 	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:210) 	at com.reardeninc.tigris.ui.facesutil.FacesFilter.doFilter(FacesFilter.java:86) 	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:244) 	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:210) 	at org.primefaces.webapp.filter.FileUploadFilter.doFilter(FileUploadFilter.java:79) 	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:244) 	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:210) 	at com.ocpsoft.pretty.PrettyFilter.doFilter(PrettyFilter.java:100) 	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:244) 	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:210) 	at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:240) 	at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:161) 	at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:496) 	at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:164) 	at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:100) 	at org.apache.catalina.valves.AccessLogValve.invoke(AccessLogValve.java:541) 	at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:118) 	at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:383) 	at org.apache.coyote.http11.Http11Processor.process(Http11Processor.java:243) 	at org.apache.coyote.http11.Http11Protocol$Http11ConnectionHandler.process(Http11Protocol.java:188) 	at org.apache.tomcat.util.net.JIoEndpoint$SocketProcessor.run(JIoEndpoint.java:288) 	at java.util.concurrent.ThreadPoolExecutor$Worker.runTask(ThreadPoolExecutor.java:886) 	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:908) 	at java.lang.Thread.run(Thread.java:680) Caused by: java.lang.NoSuchMethodException: java.lang.String.contains(java.lang.String) 	at java.lang.Class.getMethod(Class.java:1605) 	at javax.el.BeanELResolver.invoke(BeanELResolver.java:405) 	at javax.el.CompositeELResolver.invoke(CompositeELResolver.java:161) 	at org.apache.el.parser.AstValue.getValue(AstValue.java:159) 	at org.apache.el.parser.AstChoice.getValue(AstChoice.java:45) 	at org.apache.el.ValueExpressionImpl.getValue(ValueExpressionImpl.java:189) 	at com.sun.faces.facelets.el.ELText$ELTextVariable.toString(ELText.java:207) 	at com.sun.faces.facelets.compiler.AttributeInstruction.write(AttributeInstruction.java:82) 	... 46 more</column><column name="report_time">2011-02-15 15:04:47</column><column name="report_timestamp">1297800000</column><column name="status">resolved fixed</column><column name="commit">cfab791</column><column name="commit_timestamp">1297940000</column><column name="files">java/javax/el/BeanELResolver.java
java/org/apache/el/parser/AstValue.java
test/org/apache/el/TestMethodExpressionImpl.java</column><column name="result">35:java/org/apache/el/parser/AstValue.java
125:java/javax/el/BeanELResolver.java
280:test/org/apache/el/TestMethodExpressionImpl.java</column></table><table name="tomcat"><column name="id">495</column><column name="bug_id">50793</column><column name="summary">Invalid DispatchType in ServletRequestListener on async dispatch</column><column name="description">If a ServletRequestListener is defined, when is invoked after a call to AsyncContext#dispatch() the DispatcherType returned from the ServletRequest is REQUEST rather than ASYNC. When the actual servlet is invoked, the type is correctly set to ASYNC. If the listener is intended to be invoked for each dispatch, then the DispatcherType should match the value returned in the filter/servlet.</column><column name="report_time">2011-02-15 22:47:30</column><column name="report_timestamp">1297830000</column><column name="status">closed fixed</column><column name="commit">72418ba</column><column name="commit_timestamp">1297880000</column><column name="files">java/org/apache/catalina/connector/CoyoteAdapter.java
java/org/apache/catalina/core/StandardContext.java
java/org/apache/catalina/core/StandardContextValve.java
test/org/apache/catalina/core/TestAsyncContextImpl.java</column><column name="result">1:java/org/apache/catalina/core/StandardContext.java
23:test/org/apache/catalina/core/TestAsyncContextImpl.java
43:java/org/apache/catalina/connector/CoyoteAdapter.java
57:java/org/apache/catalina/core/StandardContextValve.java</column></table><table name="tomcat"><column name="id">496</column><column name="bug_id">50713</column><column name="summary">The "roles" command doesn't work</column><column name="description">Created attachment 26601 patch for context.xml of the Manager application The Manager application has the "roles" command that list the security role names. But now this command doesn't work correctly. The "roles" command returns following message: FAIL - Cannot resolve user database reference And gets Exception: SEVERE: Manager: java:comp/env/users javax.naming.NamingException: Cannot create resource instance at org.apache.naming.factory.ResourceEnvFactory.getObjectInstance(ResourceEnvFactory.java:117) at javax.naming.spi.NamingManager.getObjectInstance(NamingManager.java:304) at org.apache.naming.NamingContext.lookup(NamingContext.java:826) at org.apache.naming.NamingContext.lookup(NamingContext.java:145) at org.apache.naming.NamingContext.lookup(NamingContext.java:814) at org.apache.naming.NamingContext.lookup(NamingContext.java:145) at org.apache.naming.NamingContext.lookup(NamingContext.java:814) at org.apache.naming.NamingContext.lookup(NamingContext.java:159) at org.apache.naming.SelectorContext.lookup(SelectorContext.java:158) at javax.naming.InitialContext.lookup(InitialContext.java:392) at org.apache.catalina.manager.ManagerServlet.roles(ManagerServlet.java:1055) at org.apache.catalina.manager.ManagerServlet.doGet(ManagerServlet.java:366) at javax.servlet.http.HttpServlet.service(HttpServlet.java:621) at javax.servlet.http.HttpServlet.service(HttpServlet.java:722) at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:306) at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:210) at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:240) at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:161) at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:589) at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:164) at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:100) at org.apache.catalina.valves.AccessLogValve.invoke(AccessLogValve.java:541) at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:118) at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:382) at org.apache.coyote.http11.Http11Processor.process(Http11Processor.java:243) at org.apache.coyote.http11.Http11Protocol$Http11ConnectionHandler.process(Http11Protocol.java:188) at org.apache.tomcat.util.net.JIoEndpoint$SocketProcessor.run(JIoEndpoint.java:288) at java.util.concurrent.ThreadPoolExecutor$Worker.runTask(ThreadPoolExecutor.java:886) at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:908) at java.lang.Thread.run(Thread.java:619) Tomcat 6.x contains same issue. The workaround for this issue is to add &lt;ResourceLink&gt; to context.xml of the Manager application. And I made the patch for this issue. regards.</column><column name="report_time">2011-02-03 02:38:46</column><column name="report_timestamp">1296720000</column><column name="status">resolved fixed</column><column name="commit">4b21973</column><column name="commit_timestamp">1297860000</column><column name="files">java/org/apache/catalina/ant/RolesTask.java
java/org/apache/catalina/manager/ManagerServlet.java</column><column name="result">16:java/org/apache/catalina/manager/ManagerServlet.java
36:java/org/apache/catalina/ant/RolesTask.java</column></table><table name="tomcat"><column name="id">497</column><column name="bug_id">50700</column><column name="summary">Context parameters are being overridden with parameters from the web application deployment descriptor</column><column name="description">Context parameters are being overridden with parameters from the web application deployment descriptor even through "override" attribute is set to "false" For example: lines from context file &lt;Context path="/path" docBase="/path/to/docbase" cookies="true"&gt; &lt;Parameter name="parameter_name" value="test1" override="false"/&gt; .... &lt;/Context&gt; lines from web.xml &lt;context-param&gt; &lt;description&gt;default value for parameter_name&lt;/description&gt; &lt;param-name&gt;parameter_name&lt;/param-name&gt; &lt;param-value&gt;test2&lt;/param-value&gt; &lt;/context-param&gt; Now servletContext.getInitParameter("parameter_name") returns "test2"</column><column name="report_time">2011-02-01 13:04:17</column><column name="report_timestamp">1296580000</column><column name="status">resolved fixed</column><column name="commit">a073ac8</column><column name="commit_timestamp">1297710000</column><column name="files">java/org/apache/catalina/core/StandardContext.java</column><column name="result">1:java/org/apache/catalina/core/StandardContext.java</column></table><table name="tomcat"><column name="id">498</column><column name="bug_id">50771</column><column name="summary">HttpServletRequest#getAuthType() returns null though the request is authenticated.</column><column name="description">Created attachment 26648 I made a patch. When Tomcat registers an authenticated Principal and authentication Type with current session, only authenticated Principal is replicated, and authentication Type is not replicated. Therefore, Request#getAuthType() returns null though the request is authenticated when the node changed. Best Regards.</column><column name="report_time">2011-02-14 03:30:02</column><column name="report_timestamp">1297670000</column><column name="status">resolved fixed</column><column name="commit">877a3df</column><column name="commit_timestamp">1297670000</column><column name="files">java/org/apache/catalina/ha/session/DeltaRequest.java
java/org/apache/catalina/ha/session/DeltaSession.java</column><column name="result">75:java/org/apache/catalina/ha/session/DeltaSession.java
400:java/org/apache/catalina/ha/session/DeltaRequest.java</column></table><table name="tomcat"><column name="id">499</column><column name="bug_id">50726</column><column name="summary">Jasper can generate uncompilable source code if genStringAsCharArray is turned on</column><column name="description">Our jsp pages are compiled at build time. If I turn on genStringAsCharArray optimization switch, in some cases there will be longer lines in the generated java code than the javac compiler can process. It provides the following error message: [javac] Compiling 1609 source files to d:\...\jspc\classes [javac] d:\...\jspc\src\org\apache\jsp\WEB_002dINF\..._005fAPP\pages\termsconditions\TermsAndConditions_005fms_005fMY_jsp.java:96: constant string too long</column><column name="report_time">2011-02-07 08:14:03</column><column name="report_timestamp">1297080000</column><column name="status">resolved fixed</column><column name="commit">d0f3899</column><column name="commit_timestamp">1297540000</column><column name="files">java/org/apache/jasper/compiler/Generator.java</column><column name="result">9:java/org/apache/jasper/compiler/Generator.java</column></table><table name="tomcat"><column name="id">500</column><column name="bug_id">50759</column><column name="summary">ValidatorClassName Validation fails to set lastValidated timestamp</column><column name="description">When using a custom validator (48817), after the first validation event occurs, every subsequent query on the connection results in the Validator being run. I believe this is due to the lastValidated timestamp not being set when the Validator class is run: http://svn.apache.org/viewvc/tomcat/tags/JDBC_POOL_1_0_9_3/java/org/apache/tomcat/jdbc/pool/PooledConnection.java?revision=1061025&amp;view=markup (lines 419-420) public boolean validate(int validateAction,String sql) { ... if (poolProperties.getValidator() != null) { return poolProperties.getValidator().validate(connection, validateAction); } .... } maybe should be: public boolean validate(int validateAction,String sql) { ... if (poolProperties.getValidator() != null) { boolean val = poolProperties.getValidator().validate(connection, validateAction); this.lastValidated = now; return val; } .... } /dom</column><column name="report_time">2011-02-10 19:12:21</column><column name="report_timestamp">1297380000</column><column name="status">resolved fixed</column><column name="commit">50f16fe</column><column name="commit_timestamp">1297440000</column><column name="files">modules/jdbc-pool/java/org/apache/tomcat/jdbc/pool/PooledConnection.java</column><column name="result">2:modules/jdbc-pool/java/org/apache/tomcat/jdbc/pool/PooledConnection.java</column></table><table name="tomcat"><column name="id">501</column><column name="bug_id">50751</column><column name="summary">JNDIRealm invokes getAttributes with no attribute ids. Prevents using DOMAIN\{0} to login.</column><column name="description">Created attachment 26633 Patch for this issue vs. 6_0_29. I would like to configure JNDIRealm to authenticate to an Active Directory server using userPattern=DOMAIN\{0}. Active Directory will accept this username in bind requests, however context.getAttributes(...) will fail if that name is used. JNDIRealm makes a request for user attributes before logging in, even when there are no user attributes to request. As a result, the above configuration fails with an InvalidNameException: javax.naming.InvalidNameException: DOMAIN\username: [LDAP: error code 34 - 0000208F: LdapErr: DSID-0C090654, comment: Error processing name, data 0, vece ]; remaining name 'DOMAIN\username I have a patch for this (against 6.0.29) that I will attach. The patch fixes the issue for my specific case (bind mode, no roles), but it seems like there is a more fundamental problem in accessing the user's attributes before the user is even authenticated. This makes sense if it is configured for password comparison mode, but for bind mode it seems unnecessary until the user's password is validated. If only there were a way to get the DN of the authenticated user (not just the name that was used to authenticate), then it would be straightforward to fix this to query for roles after auth. I could not find such an API. I would be happy to write that patch if someone can point me in the right direction on that API. More discussion on this issue from the tomcat-users list: http://mail-archives.apache.org/mod_mbox/tomcat-users/201102.mbox/%3CAANLkTinTS3qBx5Wb6jLXCzozv+wTXQ9XwtJHN0O=FAXn@mail.gmail.com%3E</column><column name="report_time">2011-02-10 12:11:43</column><column name="report_timestamp">1297360000</column><column name="status">resolved fixed</column><column name="commit">0313ded</column><column name="commit_timestamp">1297440000</column><column name="files">java/org/apache/catalina/realm/JNDIRealm.java</column><column name="result">1:java/org/apache/catalina/realm/JNDIRealm.java</column></table><table name="tomcat"><column name="id">502</column><column name="bug_id">50752</column><column name="summary">Typo in Embedded.java log message</column><column name="description">There's a debug log message in Embedded.java with a typo in it: "INITIAL_CONTEXT_FACTORY alread set " Attached is a patch against the 6_0_29 tag, but the issue exists in tc6.0.x/trunk</column><column name="report_time">2011-02-10 12:17:31</column><column name="report_timestamp">1297360000</column><column name="status">resolved fixed</column><column name="commit">272e30c</column><column name="commit_timestamp">1297430000</column><column name="files">java/org/apache/catalina/startup/Embedded.java</column><column name="result">1:java/org/apache/catalina/startup/Embedded.java</column></table><table name="tomcat"><column name="id">503</column><column name="bug_id">50720</column><column name="summary">When using jsp mapped as servlet in web.xml, cyrillic characters are not allowed in web.xml</column><column name="description">Created attachment 26605 Simple test web application I am using web.xml in it simplest, incomlete form (note that making it 100% Servlet API 3.0 compliant does not help) &lt;?xml version="1.0" encoding="Windows-1251"?&gt; &lt;web-app&gt; &lt;!-- below are word testing Testoviy in cyrillic, try to use another symbols --&gt; &lt;display-name&gt; web.xml&lt;/display-name&gt; &lt;servlet&gt; &lt;servlet-name&gt;TestJSPMount&lt;/servlet-name&gt; &lt;jsp-file&gt;/test.jsp&lt;/jsp-file&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;TestJSPMount&lt;/servlet-name&gt; &lt;url-pattern&gt;/test.html&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;/web-app&gt; During startup, tomcat throws exception: 04/02/2011 16:07:39 S - - StandardContext.loadOnStartup: Servlet /testcyrwebxml threw load() exception com.sun.org.apache.xerces.internal.impl.io.MalformedByteSequenceException: Invalid byte 2 of 2-byte UTF-8 sequence. at com.sun.org.apache.xerces.internal.impl.io.UTF8Reader.invalidByte(Unknown Source) at com.sun.org.apache.xerces.internal.impl.io.UTF8Reader.read(Unknown Source) at com.sun.org.apache.xerces.internal.impl.XMLEntityScanner.load(Unknown Source) at com.sun.org.apache.xerces.internal.impl.XMLEntityScanner.peekChar(Unknown Source) at com.sun.org.apache.xerces.internal.impl.XMLDocumentFragmentScannerImpl$FragmentContentDriver.next(Unknown Source) at com.sun.org.apache.xerces.internal.impl.XMLDocumentScannerImpl.next(Unknown Source) at com.sun.org.apache.xerces.internal.impl.XMLNSDocumentScannerImpl.next(Unknown Source) at com.sun.org.apache.xerces.internal.impl.XMLDocumentFragmentScannerImpl.scanDocument(Unknown Source) at com.sun.org.apache.xerces.internal.parsers.XML11Configuration.parse(Unknown Source) at com.sun.org.apache.xerces.internal.parsers.XML11Configuration.parse(Unknown Source) at com.sun.org.apache.xerces.internal.parsers.XMLParser.parse(Unknown Source) at com.sun.org.apache.xerces.internal.parsers.DOMParser.parse(Unknown Source) at com.sun.org.apache.xerces.internal.jaxp.DocumentBuilderImpl.parse(Unknown Source) at org.apache.jasper.xmlparser.ParserUtils.parseXMLDocument(ParserUtils.java:96) at org.apache.jasper.compiler.JspConfig.processWebDotXml(JspConfig.java:83) at org.apache.jasper.compiler.JspConfig.init(JspConfig.java:231) at org.apache.jasper.compiler.JspConfig.findJspProperty(JspConfig.java:290) at org.apache.jasper.compiler.Compiler.generateJava(Compiler.java:113) at org.apache.jasper.compiler.Compiler.compile(Compiler.java:365) at org.apache.jasper.compiler.Compiler.compile(Compiler.java:345) at org.apache.jasper.compiler.Compiler.compile(Compiler.java:332) at org.apache.jasper.JspCompilationContext.compile(JspCompilationContext.java:594) at org.apache.jasper.servlet.JspServletWrapper.service(JspServletWrapper.java:342) at org.apache.jasper.servlet.JspServlet.serviceJspFile(JspServlet.java:391) at org.apache.jasper.servlet.JspServlet.init(JspServlet.java:128) at org.apache.catalina.core.StandardWrapper.initServlet(StandardWrapper.java:1133) at org.apache.catalina.core.StandardWrapper.loadServlet(StandardWrapper.java:1087) at org.apache.catalina.core.StandardWrapper.load(StandardWrapper.java:996) at org.apache.catalina.core.StandardContext.loadOnStartup(StandardContext.java:4741) at org.apache.catalina.core.StandardContext$3.call(StandardContext.java:5062) at org.apache.catalina.core.StandardContext$3.call(StandardContext.java:5057) at java.util.concurrent.FutureTask$Sync.innerRun(Unknown Source) at java.util.concurrent.FutureTask.run(Unknown Source) at java.util.concurrent.ThreadPoolExecutor$Worker.runTask(Unknown Source) at java.util.concurrent.ThreadPoolExecutor$Worker.run(Unknown Source) at java.lang.Thread.run(Unknown Source) Platform in use: Tomcat 7.0.6 binary windows release JDK 1.6.0_18 x86 Windows 7 x64 If I change encoding of web.xml to UTF-8 it does not help also. The only fix for this problem is to use only ISO-8859-1 characters. I believe it is somehow related to some early initialization sequence, when jsp is mapped as servlet.</column><column name="report_time">2011-02-04 09:07:57</column><column name="report_timestamp">1296830000</column><column name="status">resolved fixed</column><column name="commit">e4bc803</column><column name="commit_timestamp">1297360000</column><column name="files">java/org/apache/jasper/compiler/WebXml.java</column><column name="result">7:java/org/apache/jasper/compiler/WebXml.java</column></table><table name="tomcat"><column name="id">504</column><column name="bug_id">50721</column><column name="summary">RequestUtil.URLDecode() throws IllegalArgumentException for URLs with %xx-Code as last character</column><column name="description">When calling org.apache.catalina.util.RequestUtil.URLDecode() for a valid URL ending with a %xx-Code, the method throws the IllegalArgumentException "The % character must be followed by two hexademical digits". This only happens, if the %xx-Code is at the at the end of the URL. It works fine for URLs ending with normal characters. Example: RequestUtil.URLDecode("http://localhost:8080/webdav/test%C3%A4", "UTF8") fails RequestUtil.URLDecode("http://localhost:8080/webdav/test%C3%A4n", "UTF8") works fine The problem is with the the test in line 329 (added in revision: 905073): if (ix + 2 &gt;= len) { Because the index ix is already incremented in line 325, after reading the current byte b (e.g. the %-character), this test fails if "%A4" is at the end, but does not fail for "%A4n". Simple fix: In line 329 the '&gt;=' should be replaced by a '&gt;': if (ix + 2 &gt; len) { This change should have no side effects, because ix is checked again before the next iteration. Because this change is trivial I did not include a patch. Best regards Christof</column><column name="report_time">2011-02-04 20:42:49</column><column name="report_timestamp">1296870000</column><column name="status">resolved fixed</column><column name="commit">5c9e352</column><column name="commit_timestamp">1297290000</column><column name="files">java/org/apache/catalina/util/RequestUtil.java
test/org/apache/catalina/util/TestRequestUtil.java</column><column name="result">1:java/org/apache/catalina/util/RequestUtil.java
11:test/org/apache/catalina/util/TestRequestUtil.java</column></table><table name="tomcat"><column name="id">505</column><column name="bug_id">50709</column><column name="summary">Make class org.apache.catalina.core.ApplicationContextFacade non-final</column><column name="description">Please make class org.apache.catalina.core.ApplicationContextFacade non-final so it can be subclassed. Need to extend ApplicationContextFacade so Mobicents Sip Servlet, working on top of Tomcat 7, to integrate with Weld. Thanks George</column><column name="report_time">2011-02-02 13:11:45</column><column name="report_timestamp">1296670000</column><column name="status">resolved fixed</column><column name="commit">9f41c91</column><column name="commit_timestamp">1296820000</column><column name="files">java/org/apache/catalina/core/ApplicationContextFacade.java</column><column name="result">1:java/org/apache/catalina/core/ApplicationContextFacade.java</column></table><table name="tomcat"><column name="id">506</column><column name="bug_id">50673</column><column name="summary">Error when stopping Tomcat using services.msc</column><column name="description">When stopping Tomcat using services.msc, an error message is displayed: "Windows could not stop the Apache Tomcat 7 service on Local Computer. Error 109: The pipe has been ended." Despite this error, Tomcat appears to stop normally. No such problem was encountered in 6.0.29.</column><column name="report_time">2011-01-27 10:09:50</column><column name="report_timestamp">1296140000</column><column name="status">resolved fixed</column><column name="commit">6ac4a27</column><column name="commit_timestamp">1296610000</column><column name="files">java/org/apache/catalina/core/StandardServer.java
java/org/apache/catalina/startup/Catalina.java</column><column name="result">3:java/org/apache/catalina/startup/Catalina.java
12:java/org/apache/catalina/core/StandardServer.java</column></table><table name="tomcat"><column name="id">507</column><column name="bug_id">50631</column><column name="summary">InternalNioInputBuffer should honor maxHttpHeadSize</column><column name="description">InternalNioInputBuffer automatically expands its buffer while reading in request line, effectively ignoring the maxHttpHeaderSize setting.</column><column name="report_time">2011-01-21 13:23:52</column><column name="report_timestamp">1295630000</column><column name="status">resolved fixed</column><column name="commit">0084470</column><column name="commit_timestamp">1296550000</column><column name="files">java/org/apache/coyote/http11/InternalNioInputBuffer.java</column><column name="result">1:java/org/apache/coyote/http11/InternalNioInputBuffer.java</column></table><table name="tomcat"><column name="id">508</column><column name="bug_id">50325</column><column name="summary">Update Tomcat to use JRE provided solutions for CVE-2009-3555 if available</column><column name="description">See http://www.oracle.com/technetwork/java/javase/documentation/tlsreadme2-176330.html for information on the Oracle provided features. Need to review this to see what - if anything - we can do in Tomcat.</column><column name="report_time">2010-11-24 05:38:15</column><column name="report_timestamp">1290600000</column><column name="status">resolved fixed</column><column name="commit">b4e9488</column><column name="commit_timestamp">1296520000</column><column name="files">java/org/apache/tomcat/util/net/jsse/JSSESocketFactory.java</column><column name="result">83:java/org/apache/tomcat/util/net/jsse/JSSESocketFactory.java</column></table><table name="tomcat"><column name="id">509</column><column name="bug_id">50683</column><column name="summary">Servlet 3.0 annotations not scanned if unpackWars="false"</column><column name="description">Created attachment 26572 minimal test case war with source Overview: Given a very simple HelloServlet using @WebServlet annotation, and packed in a war file without a web.xml, the container does not scan for annotations if unpackWars="false" in the &lt;Host&gt; element of server.xml and the servlet is never added to the context. Steps to Reproduce: 1) Set unpackWars="fase" 2) copy attached war file to webapps 3) launch Tomcat 4) navigate to: http://&lt;servername&gt;/Hello/SayHello Actual Results: HTTP Status 404 - /Hello/SayHello type Status report message /Hello/SayHello description The requested resource (/Hello/SayHello) is not available. Apache Tomcat/7.0.6 Expected Results: Hello</column><column name="report_time">2011-01-28 18:36:29</column><column name="report_timestamp">1296260000</column><column name="status">resolved fixed</column><column name="commit">d21437e</column><column name="commit_timestamp">1296260000</column><column name="files">java/org/apache/naming/resources/WARDirContext.java</column><column name="result">42:java/org/apache/naming/resources/WARDirContext.java</column></table><table name="tomcat"><column name="id">510</column><column name="bug_id">46819</column><column name="summary">Remove redundant object instantiations in JspRuntimeLibrary</column><column name="description">Created attachment 23353 Patch file to replace new with valueOf, and some valueOf with parse While perusing the code, I noticed that java\org\apache\jasper\runtime\JspRuntimeLibrary.java code was doing a few things that I think can be improved: 1. coerce methods were instantiating new objects, only to convert them to primitives. For example: return Boolean.valueOf(s).booleanValue(); This can be rewritten (and simplified) as: return Boolean.parseBoolean(s); This pattern was repeated for numerous primitive types. 2. Objects were being instantiated using new instead of calling valueOf. For example: return new Byte((byte) 0); instead of: return Byte.valueOf((byte) 0); According to the Java API, valueOf should generally be used in preference to the constructor as this method is likely to yield significantly better space and time performance. 3. toString methods are instantiating a temporary object just to turn it into a string value. For example: return new Integer(i).toString(); This can be rewritten (and simplified) as: return Integer.toString(i); This pattern was repeated for numerous primitive types. I took the liberty of creating a patch. These changes should yield improved performance and reduce the memory footprint.</column><column name="report_time">2009-03-07 23:30:10</column><column name="report_timestamp">1236490000</column><column name="status">resolved fixed</column><column name="commit">20ace41</column><column name="commit_timestamp">1296260000</column><column name="files">java/org/apache/jasper/runtime/JspRuntimeLibrary.java</column><column name="result">1:java/org/apache/jasper/runtime/JspRuntimeLibrary.java</column></table><table name="tomcat"><column name="id">511</column><column name="bug_id">50680</column><column name="summary">NPE in TagFileProcessor when tag file is in an expanded directory "jar"</column><column name="description">Created attachment 26570 Patch against current trunk to add a null check to TagFileProcessor When using VirtualDirContext, or the equivalent in the Web Tools Tomcat support, an expanded directory can be used in place of a jar file. In this case, tag files in the directory's META-INF folder will result in an NPE because the jarResource obtained from the TldLocation is null.</column><column name="report_time">2011-01-28 09:03:07</column><column name="report_timestamp">1296220000</column><column name="status">resolved fixed</column><column name="commit">af4549f</column><column name="commit_timestamp">1296250000</column><column name="files">java/org/apache/jasper/compiler/TagFileProcessor.java</column><column name="result">1:java/org/apache/jasper/compiler/TagFileProcessor.java</column></table><table name="tomcat"><column name="id">512</column><column name="bug_id">50679</column><column name="summary">FarmDeployer doesn't support parallel deployment</column><column name="description">Version: Tomcat 7.0.6 Component: Catalina OS: Windows 7 64bit Overview: Parallel deployment works like a charm in a non-clustered environment. But when deploying a versioned app (APPNAME##VERSION.war) to a farm deployer directory, it seems that the filename encoding of the ## delimiter is not translated correctly to identify the war file on the file system: ## is translated to %23%23 Reproduce: 1. Create a version app file 2. Deploy file to watched farm deployer directory Expected result: - Versioned app is copyied to cluster members and deployed Actual result: - Versioned app is NOT copyied to cluster members. catalina.log displays the following error messages: [ContainerBackgroundProcessor[StandardEngine[Catalina]]] INFO org.apache.catalina.ha.deploy.FarmWarDeployer- Installing webapp[/Shop##201101261] from C:\Apache\Tomcat7\cluster\webapps\Shop##201101261.war [ContainerBackgroundProcessor[StandardEngine[Catalina]]] INFO org.apache.catalina.ha.deploy.FarmWarDeployer- Cluster wide remove of web app /Shop##201101261 [ContainerBackgroundProcessor[StandardEngine[Catalina]]] ERROR org.apache.catalina.ha.deploy.FarmWarDeployer- Unable to install WAR file java.io.FileNotFoundException: C:\Apache\Tomcat7\cluster\webapps\Shop%23%23201101261.war (Das System kann die angegebene Datei nicht finden) at java.io.FileInputStream.open(Native Method) at java.io.FileInputStream.&lt;init&gt;(FileInputStream.java:106) at org.apache.catalina.ha.deploy.FileMessageFactory.&lt;init&gt;(FileMessageFactory.java:152) at org.apache.catalina.ha.deploy.FileMessageFactory.getInstance(FileMessageFactory.java:175) at org.apache.catalina.ha.deploy.FarmWarDeployer.install(FarmWarDeployer.java:372) at org.apache.catalina.ha.deploy.FarmWarDeployer.fileModified(FarmWarDeployer.java:468) at org.apache.catalina.ha.deploy.WarWatcher.check(WarWatcher.java:95) at org.apache.catalina.ha.deploy.FarmWarDeployer.backgroundProcess(FarmWarDeployer.java:591) at org.apache.catalina.ha.tcp.SimpleTcpCluster.backgroundProcess(SimpleTcpCluster.java:627) at org.apache.catalina.core.ContainerBase.backgroundProcess(ContainerBase.java:1200) at org.apache.catalina.core.ContainerBase$ContainerBackgroundProcessor.processChildren(ContainerBase.java:1393) at org.apache.catalina.core.ContainerBase$ContainerBackgroundProcessor.processChildren(ContainerBase.java:1403) at org.apache.catalina.core.ContainerBase$ContainerBackgroundProcessor.run(ContainerBase.java:1382) at java.lang.Thread.run(Thread.java:662) [ContainerBackgroundProcessor[StandardEngine[Catalina]]] INFO org.apache.catalina.startup.HostConfig- Deploying web application archive Shop##201101261.war Relevant configuration in server.xml: ... &lt;Host name="sbwebapp1" appBase="${catalina.base}/cluster/webapps" unpackWARs="true" autoDeploy="true"&gt; 	 &lt;Cluster className="org.apache.catalina.ha.tcp.SimpleTcpCluster" 	 channelSendOptions="8"&gt; 	 	 &lt;Manager className="org.apache.catalina.ha.session.DeltaManager" 	 expireSessionsOnShutdown="true" 	 notifyListenersOnReplication="false" 									 stateTransferTimeout="5"/&gt; 	 	 &lt;Channel className="org.apache.catalina.tribes.group.GroupChannel"&gt; 	 &lt;Membership className="org.apache.catalina.tribes.membership.McastService" 	 address="228.0.0.4" 	 port="45564" 	 frequency="500" 	 dropTime="3000"/&gt; 	 &lt;Receiver className="org.apache.catalina.tribes.transport.nio.NioReceiver" 	 address="192.168.222.220" 	 port="4000" 	 autoBind="100" 	 selectorTimeout="5000" 	 maxThreads="6"/&gt; 	 	 &lt;Sender className="org.apache.catalina.tribes.transport.ReplicationTransmitter"&gt; 	 &lt;Transport className="org.apache.catalina.tribes.transport.nio.PooledParallelSender"/&gt; 	 &lt;/Sender&gt; 	 &lt;Interceptor className="org.apache.catalina.tribes.group.interceptors.TcpFailureDetector"/&gt; 	 &lt;Interceptor className="org.apache.catalina.tribes.group.interceptors.MessageDispatch15Interceptor"/&gt; 	 &lt;Interceptor className="org.apache.catalina.tribes.group.interceptors.ThroughputInterceptor"/&gt; 	 &lt;/Channel&gt; 	 	 &lt;Valve className="org.apache.catalina.ha.tcp.ReplicationValve" 	 filter=".*\.gif;.*\.js;.*\.jpg;.*\.png;.*\.htm;.*\.html;.*\.css;.*\.txt;.*\.swf;.*\.flv;"/&gt; 	 &lt;Valve className="org.apache.catalina.ha.session.JvmRouteBinderValve"/&gt;	 	 	 &lt;ClusterListener className="org.apache.catalina.ha.session.JvmRouteSessionIDBinderListener"/&gt; 	 &lt;ClusterListener className="org.apache.catalina.ha.session.ClusterSessionListener"/&gt; 	 	 &lt;Deployer className="org.apache.catalina.ha.deploy.FarmWarDeployer" 	 tempDir="${catalina.base}/cluster/temp/" 	 deployDir="${catalina.base}/cluster/webapps/" 	 watchDir="${catalina.base}/cluster/deploy/" 	 watchEnabled="true"/&gt; 	 &lt;/Cluster&gt; &lt;!-- Access log processes all example. Documentation at: /docs/config/valve.html Note: The pattern used is equivalent to using pattern="common" --&gt; &lt;Valve className="org.apache.catalina.valves.AccessLogValve" directory="logs" prefix="ajp_access_" suffix=".log" pattern="%h %l %u %t &amp;quot;%r&amp;quot; %s %b" resolveHosts="false"/&gt; &lt;/Host&gt; ...</column><column name="report_time">2011-01-28 03:22:33</column><column name="report_timestamp">1296200000</column><column name="status">resolved fixed</column><column name="commit">2377f51</column><column name="commit_timestamp">1296250000</column><column name="files">java/org/apache/catalina/ha/ClusterDeployer.java
java/org/apache/catalina/ha/deploy/FarmWarDeployer.java
java/org/apache/catalina/ha/deploy/FileMessage.java
java/org/apache/catalina/ha/deploy/FileMessageFactory.java
java/org/apache/catalina/ha/deploy/UndeployMessage.java</column><column name="result">2:java/org/apache/catalina/ha/deploy/FarmWarDeployer.java
33:java/org/apache/catalina/ha/deploy/FileMessageFactory.java
42:java/org/apache/catalina/ha/ClusterDeployer.java
272:java/org/apache/catalina/ha/deploy/FileMessage.java
424:java/org/apache/catalina/ha/deploy/UndeployMessage.java</column></table><table name="tomcat"><column name="id">513</column><column name="bug_id">50642</column><column name="summary">keepAliveProtection doesn't work</column><column name="description">Created attachment 26541 ServletContextListener that removes the leaked ClassLoader reference sun.net.www.http.HttpClient.kac.keepAliveTimer.contextClassLoader causes a memory leak as it references the webapp's classloader rather than Tomcat's. JreMemoryLeakPreventionListener claims to fix this, but only loads sun.net.www.http.HttpClient and does not create the timer thread. Thus the leak still exists. AFAICT, the attached listener does successfully prevent the leak.</column><column name="report_time">2011-01-24 10:45:14</column><column name="report_timestamp">1295880000</column><column name="status">resolved fixed</column><column name="commit">5c13d8c</column><column name="commit_timestamp">1296220000</column><column name="files">java/org/apache/catalina/core/JreMemoryLeakPreventionListener.java
java/org/apache/catalina/core/StandardContext.java
java/org/apache/catalina/loader/WebappClassLoader.java
java/org/apache/catalina/loader/WebappLoader.java</column><column name="result">1:java/org/apache/catalina/core/JreMemoryLeakPreventionListener.java
5:java/org/apache/catalina/core/StandardContext.java
23:java/org/apache/catalina/loader/WebappClassLoader.java
87:java/org/apache/catalina/loader/WebappLoader.java</column></table><table name="tomcat"><column name="id">514</column><column name="bug_id">50646</column><column name="summary">Tribes ByteMessage will get corrupted if message size exceeds the underlying buffer size</column><column name="description">The Tribes ByteMessage class is used to transfer byte payloads in the context of the tribes communication framework. Due to how the message is deserialized, there will be data loss (and hence corruption) if the message size exceeds the underlying buffer size. The solution is to replace an ObjectInput#read(byte[]) call by ObjectInput#readFully(byte[]). Fix is attached.</column><column name="report_time">2011-01-25 07:08:10</column><column name="report_timestamp">1295960000</column><column name="status">resolved fixed</column><column name="commit">0119483</column><column name="commit_timestamp">1296070000</column><column name="files">java/org/apache/catalina/tribes/ByteMessage.java</column><column name="result">1:java/org/apache/catalina/tribes/ByteMessage.java</column></table><table name="tomcat"><column name="id">515</column><column name="bug_id">50629</column><column name="summary">Make the bindThread/unbindThread method protected</column><column name="description">In the latest Tomcat codes, I saw that a new thread is created for listener start, filter start and loadOnStartup. But the two methods bindThread and unbindThread is marked as private, how about making those methods protected ? So that other containers could use those two methods for their own initialization works. Thanks.</column><column name="report_time">2011-01-21 07:23:54</column><column name="report_timestamp">1295610000</column><column name="status">resolved fixed</column><column name="commit">3898ed0</column><column name="commit_timestamp">1295620000</column><column name="files">java/org/apache/catalina/core/StandardContext.java</column><column name="result">1:java/org/apache/catalina/core/StandardContext.java</column></table><table name="tomcat"><column name="id">516</column><column name="bug_id">50620</column><column name="summary">Session related errors prevent clean recycle of Request and Response objects by CoyoteAdapter</column><column name="description">Created attachment 26521 Patch created against tomcat/tc6.0.x/trunk Session related errors prevent clean recycle of org.apache.catalina.connector.Request and org.apache.catalina.connector.Response objects by CoyoteAdapter. In org.apache.catalina.connector.Request.recycle() method, if an exception is thrown by session.endAccess() call, request object recycling aborts failing to cleanup fully and leaving the request object in inconsistent state. Further requests processed by CoyoteAdapter.service() using this inconsistent request object result in request being redirected to the last url that resulted in inconsistent request object which is still holding on to wrong session and contexts.</column><column name="report_time">2011-01-19 15:54:38</column><column name="report_timestamp">1295470000</column><column name="status">resolved fixed</column><column name="commit">fbd0110</column><column name="commit_timestamp">1295550000</column><column name="files">java/org/apache/catalina/connector/Request.java</column><column name="result">7:java/org/apache/catalina/connector/Request.java</column></table><table name="tomcat"><column name="id">517</column><column name="bug_id">50606</column><column name="summary">Error running CGI executable in Tomcat 6.0.30</column><column name="description">Created attachment 26502 localhost.2011-01-18.log I have web application hosting CGI executable with the following settings for CGI &lt;servlet&gt; &lt;servlet-name&gt;cgi&lt;/servlet-name&gt; &lt;servlet-class&gt;org.apache.catalina.servlets.CGIServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;debug&lt;/param-name&gt; &lt;param-value&gt;2&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;cgiPathPrefix&lt;/param-name&gt; &lt;param-value&gt;WEB-INF/cgi&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;executable&lt;/param-name&gt; &lt;param-value&gt;&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;passShellEnvironment&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt; &lt;/servlet&gt; This was Ok in Tomcat 6.0.29 but not in 6.0.30, see attachment.</column><column name="report_time">2011-01-18 02:26:41</column><column name="report_timestamp">1295340000</column><column name="status">resolved fixed</column><column name="commit">c0cd721</column><column name="commit_timestamp">1295550000</column><column name="files">java/org/apache/catalina/servlets/CGIServlet.java</column><column name="result">3:java/org/apache/catalina/servlets/CGIServlet.java</column></table><table name="tomcat"><column name="id">518</column><column name="bug_id">50613</column><column name="summary">ConnectionPool.size corruption when evictions enabled:</column><column name="description">When (the various forms of) eviction run on the connection pool, ConnectionPool.size goes negative. This appears to be a concurrency problem. Attached is a unit test that illustrates the issue.</column><column name="report_time">2011-01-18 17:33:53</column><column name="report_timestamp">1295390000</column><column name="status">resolved fixed</column><column name="commit">5cb0b7a</column><column name="commit_timestamp">1295470000</column><column name="files">modules/jdbc-pool/java/org/apache/tomcat/jdbc/pool/ConnectionPool.java
modules/jdbc-pool/test/org/apache/tomcat/jdbc/test/TestSizePreservation.java</column><column name="result">2:modules/jdbc-pool/java/org/apache/tomcat/jdbc/pool/ConnectionPool.java</column></table><table name="tomcat"><column name="id">519</column><column name="bug_id">50601</column><column name="summary">Redundant null checks before instanceof in equals()</column><column name="description">Created attachment 26497 Patch to remove null checks There are several instances of the following code in equals methods: if (obj == null) return false; if (!(obj instanceof SomeClass)) return false; The null check is redundant, as null will fail the instanceof check.</column><column name="report_time">2011-01-17 08:54:21</column><column name="report_timestamp">1295270000</column><column name="status">resolved fixed</column><column name="commit">d95db3f</column><column name="commit_timestamp">1295460000</column><column name="files">java/org/apache/catalina/core/ApplicationTaglibDescriptor.java
java/org/apache/catalina/deploy/LoginConfig.java
java/org/apache/catalina/tribes/tipis/AbstractReplicatedMap.java
java/org/apache/el/parser/SimpleNode.java
java/org/apache/naming/NamingEntry.java
java/org/apache/tomcat/util/net/URL.java</column><column name="result">27:java/org/apache/catalina/tribes/tipis/AbstractReplicatedMap.java
59:java/org/apache/naming/NamingEntry.java
75:java/org/apache/el/parser/SimpleNode.java
106:java/org/apache/tomcat/util/net/URL.java
136:java/org/apache/catalina/core/ApplicationTaglibDescriptor.java
214:java/org/apache/catalina/deploy/LoginConfig.java</column></table><table name="tomcat"><column name="id">520</column><column name="bug_id">50598</column><column name="summary">Sample build.xml uses wrong manager.url</column><column name="description">In http://tomcat.apache.org/tomcat-7.0-doc/appdev/build.xml.txt , referenced from http://tomcat.apache.org/tomcat-7.0-doc/appdev/processes.html sample manager.url is given as "http://localhost:8080/manager" but should be "http://localhost:8080/manager/text"</column><column name="report_time">2011-01-16 14:08:25</column><column name="report_timestamp">1295200000</column><column name="status">resolved fixed</column><column name="commit">de188ad</column><column name="commit_timestamp">1295280000</column><column name="files">java/org/apache/catalina/ant/AbstractCatalinaTask.java</column><column name="result">23:java/org/apache/catalina/ant/AbstractCatalinaTask.java</column></table><table name="tomcat"><column name="id">521</column><column name="bug_id">50597</column><column name="summary">Class.newInstance is used for Dynamic instance filters causing InstantiationException</column><column name="description">Class.newInstance is called even when the following method ServletContext.addFilter method is called: javax.servlet.FilterRegistration.Dynamic addFilter(java.lang.String s, javax.servlet.Filter filter); This leads to an InstantiationException at runtime if there is no no-args constructor for the filter (pasted below). I'll supply a simple patch that fixes the issue for me. SEVERE: Exception starting filter testFilter java.lang.InstantiationException: test.TestFilter at java.lang.Class.newInstance0(Class.java:340) at java.lang.Class.newInstance(Class.java:308) at org.apache.catalina.core.DefaultInstanceManager.newInstance(DefaultIn stanceManager.java:119) at org.apache.catalina.core.ApplicationFilterConfig.getFilter(Applicatio nFilterConfig.java:252) at org.apache.catalina.core.ApplicationFilterConfig.setFilterDef(Applica tionFilterConfig.java:372) at org.apache.catalina.core.ApplicationFilterConfig.&lt;init&gt;(ApplicationFi lterConfig.java:98) at org.apache.catalina.core.StandardContext.filterStart(StandardContext. java:4382) at org.apache.catalina.core.StandardContext$2.call(StandardContext.java: 5040) at org.apache.catalina.core.StandardContext$2.call(StandardContext.java:5035) at java.util.concurrent.FutureTask$Sync.innerRun(FutureTask.java:303) at java.util.concurrent.FutureTask.run(FutureTask.java:138) at java.util.concurrent.ThreadPoolExecutor$Worker.runTask(ThreadPoolExecutor.java:886) at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:908) at java.lang.Thread.run(Thread.java:662)</column><column name="report_time">2011-01-16 12:25:24</column><column name="report_timestamp">1295200000</column><column name="status">resolved fixed</column><column name="commit">30468b7</column><column name="commit_timestamp">1295280000</column><column name="files">java/org/apache/catalina/core/ApplicationFilterConfig.java</column><column name="result">4:java/org/apache/catalina/core/ApplicationFilterConfig.java</column></table><table name="tomcat"><column name="id">522</column><column name="bug_id">50600</column><column name="summary">ConcurrentModificationException removing WAR via FarmWarDeployer</column><column name="description">The following exception was reported via $work WARNING: Exception processing cluster org.apache.catalina.ha.tcp.SimpleTcpCluster@68e4e358 background process java.util.ConcurrentModificationException at java.util.HashMap$HashIterator.nextEntry(HashMap.java:810) at java.util.HashMap$EntryIterator.next(HashMap.java:851) at java.util.HashMap$EntryIterator.next(HashMap.java:849) at org.apache.catalina.ha.deploy.WarWatcher.check(WarWatcher.java:87) at org.apache.catalina.ha.deploy.FarmWarDeployer.backgroundProcess(FarmWarDeployer.java:609) at org.apache.catalina.ha.tcp.SimpleTcpCluster.backgroundProcess(SimpleTcpCluster.java:596) at org.apache.catalina.core.ContainerBase.backgroundProcess(ContainerBase.java:1302) at org.apache.catalina.core.ContainerBase$ContainerBackgroundProcessor.processChildren(ContainerBase.java:1601) at org.apache.catalina.core.ContainerBase$ContainerBackgroundProcessor.processChildren(ContainerBase.java:1610) at org.apache.catalina.core.ContainerBase$ContainerBackgroundProcessor.run(ContainerBase.java:1590) at java.lang.Thread.run(Thread.java:636) The root cause is removing the entry directly from the Map rather than from the iterator. I have a patch that I'll apply shortly.</column><column name="report_time">2011-01-17 06:20:11</column><column name="report_timestamp">1295260000</column><column name="status">resolved fixed</column><column name="commit">d269ce3</column><column name="commit_timestamp">1295260000</column><column name="files">java/org/apache/catalina/ha/deploy/WarWatcher.java</column><column name="result">4:java/org/apache/catalina/ha/deploy/WarWatcher.java</column></table><table name="tomcat"><column name="id">523</column><column name="bug_id">50582</column><column name="summary">Small JSPs do not set Content-Length (and use chunked encoding) if AccessLogValve is configured</column><column name="description">Reported in the following thread on users@: http://markmail.org/thread/awcu5ler2m77jjok Steps to reproduce: 1. Create the following JSP page, simple.jsp: &lt;%= "hello!" %&gt; 2. Send the following request: GET /simple.jsp HTTP/1.1 Host: localhost Keep-Alive: 115 Connection: keep-alive 3. Expected response: (Tomcat 7.0.4) HTTP/1.1 200 OK Server: Apache-Coyote/1.1 Set-Cookie: JSESSIONID=0AFC2875C06A962DF8A02DE6A780F721; Path=/; HttpOnly Content-Type: text/html;charset=ISO-8859-1 Content-Length: 6 Date: Thu, 13 Jan 2011 21:16:23 GMT hello! 4. Actual response: (Tomcat 7.0.6) HTTP/1.1 200 OK Server: Apache-Coyote/1.1 Set-Cookie: JSESSIONID=2C176DBAC054D5BBF3D99FBE5C026915; Path=/; HttpOnly Content-Type: text/html;charset=ISO-8859-1 Transfer-Encoding: chunked Date: Thu, 13 Jan 2011 21:23:19 GMT 6 hello! 0 =============================================== Investigation. If I place a breakpoint in AbstractHttp11Processor#prepareResponse() I see the following line long contentLength = response.getContentLengthLong(); returns -1 and the call stack is: Daemon Thread ["http-bio-8080"-exec-1] (Suspended)	 	Response.getContentLengthLong() line: 523	 	Http11Processor(AbstractHttp11Processor).prepareResponse() line: 887	 	Http11Processor(AbstractHttp11Processor).action(ActionCode, Object) line: 739	 	Response.action(ActionCode, Object) line: 170	 	Response.sendHeaders() line: 350	 	OutputBuffer.doFlush(boolean) line: 308	 	OutputBuffer.flush() line: 291	 	Response.getBytesWritten(boolean) line: 327	 	AccessLogValve$ByteSentElement.addElement(StringBuilder, Date, Request, Response, long) line: 1052	 	AccessLogValve.log(Request, Response, long) line: 579	 	AccessLogValve.invoke(Request, Response) line: 562	 	StandardEngineValve.invoke(Request, Response) line: 118	 	CoyoteAdapter.service(Request, Response) line: 380	 	Http11Processor.process(SocketWrapper&lt;Socket&gt;) line: 243	 	Http11Protocol$Http11ConnectionHandler.process(SocketWrapper&lt;Socket&gt;, SocketStatus) line: 188	 	Http11Protocol$Http11ConnectionHandler.process(SocketWrapper&lt;Socket&gt;) line: 166	 	JIoEndpoint$SocketProcessor.run() line: 288	 	ThreadPoolExecutor$Worker.runTask(Runnable) line: 886	 	ThreadPoolExecutor$Worker.run() line: 908	 	TaskThread(Thread).run() line: 662	 Note OutputBuffer.flush() call above. If I remove AccessLogValve from configuration, the response.getContentLengthLong(); call returns "8" as expected and call stack is: Daemon Thread ["http-bio-8080"-exec-1] (Suspended)	 	Http11Processor(AbstractHttp11Processor).prepareResponse() line: 888	 	Http11Processor(AbstractHttp11Processor).action(ActionCode, Object) line: 739	 	Response.action(ActionCode, Object) line: 170	 	Response.sendHeaders() line: 350	 	OutputBuffer.doFlush(boolean) line: 308	 	OutputBuffer.close() line: 275	 	Response.finishResponse() line: 501	 	CoyoteAdapter.service(Request, Response) line: 406	 	Http11Processor.process(SocketWrapper&lt;Socket&gt;) line: 243	 	Http11Protocol$Http11ConnectionHandler.process(SocketWrapper&lt;Socket&gt;, SocketStatus) line: 188	 	Http11Protocol$Http11ConnectionHandler.process(SocketWrapper&lt;Socket&gt;) line: 166	 	JIoEndpoint$SocketProcessor.run() line: 288	 	ThreadPoolExecutor$Worker.runTask(Runnable) line: 886	 	ThreadPoolExecutor$Worker.run() line: 908	 	TaskThread(Thread).run() line: 662	 =============================================== The value returned by response.getContentLengthLong() should be set explicitly (e.g. with content-length header). The second stack trace includes OutputBuffer.close() call and it sets the length value to the response: &gt; coyoteResponse.setContentLength(bb.getLength()); This regression is triggered by flushing when AccessLogValve asks for the count of bytes written and was introduced when implementing #50496.</column><column name="report_time">2011-01-14 02:16:41</column><column name="report_timestamp">1294990000</column><column name="status">resolved fixed</column><column name="commit">35a84d1</column><column name="commit_timestamp">1295180000</column><column name="files">java/org/apache/catalina/connector/CoyoteAdapter.java
java/org/apache/catalina/valves/AccessLogValve.java
java/org/apache/catalina/valves/JDBCAccessLogValve.java
java/org/apache/coyote/http11/AbstractOutputBuffer.java</column><column name="result">1:java/org/apache/catalina/valves/AccessLogValve.java
20:java/org/apache/catalina/valves/JDBCAccessLogValve.java
41:java/org/apache/catalina/connector/CoyoteAdapter.java
156:java/org/apache/coyote/http11/AbstractOutputBuffer.java</column></table><table name="tomcat"><column name="id">524</column><column name="bug_id">50591</column><column name="summary">NPE in ReplicationValve in 7.0.6</column><column name="description">It was reported on the users@ list: http://tomcat.markmail.org/thread/44rnbj7gbkevzb32 SEVERE: Unable to perform replication request. java.lang.NullPointerException at org.apache.catalina.ha.tcp.ReplicationValve.isRequestWithoutSessionChange(ReplicationValve.java:554) It will occur when ReplicationValve#filter attribute has an empty value.</column><column name="report_time">2011-01-15 12:33:11</column><column name="report_timestamp">1295110000</column><column name="status">resolved fixed</column><column name="commit">d8f8be1</column><column name="commit_timestamp">1295110000</column><column name="files">java/org/apache/catalina/ha/tcp/ReplicationValve.java</column><column name="result">1:java/org/apache/catalina/ha/tcp/ReplicationValve.java</column></table><table name="tomcat"><column name="id">525</column><column name="bug_id">18797</column><column name="summary">MemoryUserRule doesn't validate user attributes</column><column name="description">The implementation of org.apache.catalina.realm.MemoryRuleSet.begin dosen't validate the attribute values before adding a user to the MemoryRealm. If username or name are not present then a null username is used which can cause odd problems later on. Basically the method should check that parameters passed to MemoryRealm.addUser are not null before calling the method.</column><column name="report_time">2003-04-08 06:33:14</column><column name="report_timestamp">1049800000</column><column name="status">resolved fixed</column><column name="commit">51650a1</column><column name="commit_timestamp">1294940000</column><column name="files">java/org/apache/catalina/users/MemoryUserDatabase.java</column><column name="result">19:java/org/apache/catalina/users/MemoryUserDatabase.java</column></table><table name="tomcat"><column name="id">526</column><column name="bug_id">18462</column><column name="summary">System.err gets overriden to output to System.out</column><column name="description">I am using Eclipse to do my development and I am running tomcat 4.1.24 from within eclipse. One of the nice features of eclipse is that anything you display with System.out comes out in blue and anything you send to System.err is displayed in red. However when tomcat is running Catalina overrides System.err and makes it point to System.out. This is very inconvinient because its much harder to search for severe error messages in a list of millions of trivial ones.</column><column name="report_time">2003-03-28 12:35:32</column><column name="report_timestamp">1048870000</column><column name="status">resolved fixed</column><column name="commit">164fd40</column><column name="commit_timestamp">1294880000</column><column name="files">java/org/apache/catalina/startup/Catalina.java
java/org/apache/catalina/startup/Embedded.java</column><column name="result">2:java/org/apache/catalina/startup/Catalina.java
59:java/org/apache/catalina/startup/Embedded.java</column></table><table name="tomcat"><column name="id">527</column><column name="bug_id">15688</column><column name="summary">full-qualified names instead of imports</column><column name="description">Hi, Jasper generated *.java-files that are compiled. The template for those files is very "unaesthetic". I could demonstrate nice side-effects using a simple &lt;%@ page import="mypackage.Jspfactory" %&gt; You should use full qualified names instead of a bunch of import-staments. For example _jspxFactory = JspFactory.getDefaultFactory(); would become _jspxFactory = javax.servlet.jsp.JspFactory.getDefaultFactory(); and if you don't already do, you should use the this-reference where possible. I don't know what the spec says about that conflict, but it shouldn't be a bad idea to use full-qualified names instead of imports.</column><column name="report_time">2002-12-27 22:30:47</column><column name="report_timestamp">1041050000</column><column name="status">resolved fixed</column><column name="commit">e69347b</column><column name="commit_timestamp">1294830000</column><column name="files">java/org/apache/jasper/compiler/Generator.java
java/org/apache/jasper/compiler/JspUtil.java</column><column name="result">2:java/org/apache/jasper/compiler/Generator.java
23:java/org/apache/jasper/compiler/JspUtil.java</column></table><table name="tomcat"><column name="id">528</column><column name="bug_id">50333</column><column name="summary">IllegalArgumentException occurs when setting maxActive to smaller than 1.</column><column name="description">Created attachment 26340 patch IllegalArgumentException occurs when setting maxActive to smaller than 1. ----- java.lang.IllegalArgumentException at java.util.concurrent.ArrayBlockingQueue.&lt;init&gt;(ArrayBlockingQueue.java:164) at org.apache.tomcat.jdbc.pool.ConnectionPool.init(ConnectionPool.java:365) at org.apache.tomcat.jdbc.pool.ConnectionPool.&lt;init&gt;(ConnectionPool.java:130) at org.apache.tomcat.jdbc.pool.DataSourceProxy.createPool(DataSourceProxy.java:93) at org.apache.tomcat.jdbc.pool.DataSourceFactory.createDataSource(DataSourceFactory.java:490) at org.apache.tomcat.jdbc.pool.DataSourceFactory.getObjectInstance(DataSourceFactory.java:219) at org.apache.naming.factory.ResourceFactory.getObjectInstance(ResourceFactory.java:142) at javax.naming.spi.NamingManager.getObjectInstance(NamingManager.java:304) at org.apache.naming.NamingContext.lookup(NamingContext.java:826) at org.apache.naming.NamingContext.lookup(NamingContext.java:145) at org.apache.naming.NamingContext.lookup(NamingContext.java:814) at org.apache.naming.NamingContext.lookup(NamingContext.java:159) at org.apache.catalina.core.NamingContextListener.addResource(NamingContextListener.java:1020) at org.apache.catalina.core.NamingContextListener.createNamingContext(NamingContextListener.java:631) at org.apache.catalina.core.NamingContextListener.lifecycleEvent(NamingContextListener.java:237) at org.apache.catalina.util.LifecycleSupport.fireLifecycleEvent(LifecycleSupport.java:119) at org.apache.catalina.util.LifecycleBase.fireLifecycleEvent(LifecycleBase.java:89) at org.apache.catalina.core.StandardServer.startInternal(StandardServer.java:668) at org.apache.catalina.util.LifecycleBase.start(LifecycleBase.java:140) at org.apache.catalina.startup.Catalina.start(Catalina.java:596) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25) at java.lang.reflect.Method.invoke(Method.java:597) at org.apache.catalina.startup.Bootstrap.start(Bootstrap.java:303) at org.apache.catalina.startup.Bootstrap.main(Bootstrap.java:431) --- In DBCP, if the negative value is set to maxActive, the pool size is unlimited. However, because ArrayBlockingQueue is used in JDBC-Pool, values that are smaller than 1 cannot be set to maxActive. In my patch, if maxActive is smaller than 1, default value (100) is set to maxActive. Regards.</column><column name="report_time">2010-11-25 00:22:29</column><column name="report_timestamp">1290660000</column><column name="status">resolved fixed</column><column name="commit">0ccff07</column><column name="commit_timestamp">1294680000</column><column name="files">modules/jdbc-pool/java/org/apache/tomcat/jdbc/pool/ConnectionPool.java
modules/jdbc-pool/java/org/apache/tomcat/jdbc/pool/PoolProperties.java</column><column name="result">1:modules/jdbc-pool/java/org/apache/tomcat/jdbc/pool/PoolProperties.java
9:modules/jdbc-pool/java/org/apache/tomcat/jdbc/pool/ConnectionPool.java</column></table><table name="tomcat"><column name="id">529</column><column name="bug_id">49953</column><column name="summary">Missing @Override annotations</column><column name="description">Created attachment 26045 Add missing annotations</column><column name="report_time">2010-09-17 14:00:04</column><column name="report_timestamp">1284750000</column><column name="status">resolved wontfix</column><column name="commit">fd990a4</column><column name="commit_timestamp">1294680000</column><column name="files">modules/jdbc-pool/java/org/apache/tomcat/jdbc/pool/interceptor/StatementCache.java
modules/jdbc-pool/java/org/apache/tomcat/jdbc/pool/jmx/ConnectionPool.java</column><column name="result">806:modules/jdbc-pool/java/org/apache/tomcat/jdbc/pool/jmx/ConnectionPool.java
978:modules/jdbc-pool/java/org/apache/tomcat/jdbc/pool/interceptor/StatementCache.java</column></table><table name="tomcat"><column name="id">530</column><column name="bug_id">21157</column><column name="summary">CookieExample is setting cookie after writing data</column><column name="description">A servlet can not set the headers and cookies after writing data to the servlet's output stream. Once the servlet writes data, headers are committed. However CookieExample writes some data first before doing addCookie on the response. The reason why this code works at all even with the above bug is: The CookieExample is only writing a small amount of data before doing response.addCookie. That data is still held in buffer and not yet sent over the wire. Hence the headers are not yet committed. So it is pure luck that this example works. You can easily expose the bug by writing say 20K characters in this example before response.addCookie is called. You will see that the cookies that are adding to response are not actually sent back to client. Fix is simple. Move up the response.addCookie() before response.getWriter()</column><column name="report_time">2003-06-27 23:12:00</column><column name="report_timestamp">1056770000</column><column name="status">resolved fixed</column><column name="commit">4ce656a</column><column name="commit_timestamp">1294530000</column><column name="files">webapps/examples/WEB-INF/classes/CookieExample.java</column><column name="result" /></table><table name="tomcat"><column name="id">531</column><column name="bug_id">50552</column><column name="summary">Ant Tasks give a null pointer exception when an error occurs, masking true error</column><column name="description">Created attachment 26463 Fix to abstract catalina task class to set up redirector correctly Using the Ant List Task with outputproperty set causes a null pointer exception in the event of any error. For example, if tomcat is not running or the url given is incorrect. Since the bug is in a base class, this probably affects all the ant tasks. The bug is due to the fact that the code to clean up the redirector is called in the finally block, but the equivalent code to set it up is not. This problem is also present in Tomcat 6. The attached patch fixes the problem. With the patch in place, using the list task when tomcat is down gives "Connection refused" instead.</column><column name="report_time">2011-01-06 12:39:49</column><column name="report_timestamp">1294340000</column><column name="status">resolved fixed</column><column name="commit">a6b37af</column><column name="commit_timestamp">1294400000</column><column name="files">java/org/apache/catalina/ant/BaseRedirectorHelperTask.java</column><column name="result">43:java/org/apache/catalina/ant/BaseRedirectorHelperTask.java</column></table><table name="tomcat"><column name="id">532</column><column name="bug_id">50554</column><column name="summary">Bad use of getClass() could potentially lead to concurrency bugs in future</column><column name="description">The method org.apache.naming.java.javaURLContextFactory.getInitialContext(Hashtable&lt;?,?&gt;) has a synchronized block on getClass(). Using getClass() as lock is a bug pattern because if some class subclasses javaURLContextFactory and getInitialContext gets called on an instance of such a subclass, getClass() will return a different Class object for that instance. Locking different objects for different classes is usually not the expected behavior. Therefore, I suggest to remove this bug pattern by simply replacing getClass() by javaURLContextFactory.class. See https://www.securecoding.cert.org/confluence/display/java/LCK02-J.+Do+not+synchronize+on+the+class+object+returned+by+getClass%28%29 for more information about this bug pattern. Keshmesh (https://github.com/reprogrammer/keshmesh/) is an Eclipse plugin that analyzes the source code of Java programs to detect concurrency bug patterns such the one I reported.</column><column name="report_time">2011-01-06 14:38:25</column><column name="report_timestamp">1294340000</column><column name="status">resolved fixed</column><column name="commit">06b8609</column><column name="commit_timestamp">1294400000</column><column name="files">java/org/apache/naming/java/javaURLContextFactory.java</column><column name="result">382:java/org/apache/naming/java/javaURLContextFactory.java</column></table><table name="tomcat"><column name="id">533</column><column name="bug_id">50477</column><column name="summary">If you set 0 to initialSize, can't obtain Connection by using getConnectionAsync method.</column><column name="description">Created attachment 26408 patch for ConnectionPool.java The getConnectionAsync method returns a ItemFuture, and the ItemFuture.get method retrieves Connection from the idle queue (= FairBlockingQueue). If initialSize is 0, there is no PooledConnection in the idle queue. (And, there is no way to insert PooledConnection to the idle queue except to use the getConnection method.) Therefore, the ItemFuture.get method doesn't return Connection. I made the patch. It is the following. If the pool size is empty then create a PooledConnection and insert it to the idle queue. regards.</column><column name="report_time">2010-12-15 04:40:32</column><column name="report_timestamp">1292410000</column><column name="status">resolved fixed</column><column name="commit">869c6f4</column><column name="commit_timestamp">1294360000</column><column name="files">modules/jdbc-pool/java/org/apache/tomcat/jdbc/pool/ConnectionPool.java
modules/jdbc-pool/test/org/apache/tomcat/jdbc/test/Async0IdleTestBug50477.java</column><column name="result">5:modules/jdbc-pool/java/org/apache/tomcat/jdbc/pool/ConnectionPool.java</column></table><table name="tomcat"><column name="id">534</column><column name="bug_id">49543</column><column name="summary">Request for a "shared" datasource configuration as in DBCP</column><column name="description">The ability to configure the datasource at the server level and have it shared amongst all applications on that server with each application supplying their own credentials for the datasource. This type of configuration is supported by DBCP and is called a "shared" datasource configuration.</column><column name="report_time">2010-07-02 15:07:50</column><column name="report_timestamp">1278100000</column><column name="status">resolved fixed</column><column name="commit">3560f39</column><column name="commit_timestamp">1294340000</column><column name="files">java/org/apache/naming/factory/DataSourceLinkFactory.java</column><column name="result" /></table><table name="tomcat"><column name="id">535</column><column name="bug_id">50550</column><column name="summary">PropFind 404 error after MkCol succes</column><column name="description">A propfind call on a resource returns a 404 error when executed after a mkcol for the same resource. The mkcol should be preceeded with a propfind to trigger the issue. Steps to reproduce - See the following access log; 127.0.0.1 - - [06/Jan/2011:14:09:19 +0100] "PROPFIND /webdav/output/f469e3d6-e536-4072-82da-d989acaf57a2/ HTTP/1.1" 404 1084 127.0.0.1 - - [06/Jan/2011:14:09:19 +0100] "MKCOL /webdav/output/f469e3d6-e536-4072-82da-d989acaf57a2/ HTTP/1.1" 201 - 127.0.0.1 - - [06/Jan/2011:14:09:19 +0100] "PROPFIND /webdav/output/f469e3d6-e536-4072-82da-d989acaf57a2/ HTTP/1.1" 404 1084 When the first request would be omitted, the third request would have been succesful, as the following access log shows; 127.0.0.1 - - [06/Jan/2011:14:10:39 +0100] "MKCOL /webdav/output/81a97360-ea49-44d3-b764-d8c7e60e885e/ HTTP/1.1" 201 - 127.0.0.1 - - [06/Jan/2011:14:10:39 +0100] "PROPFIND /webdav/output/81a97360-ea49-44d3-b764-d8c7e60e885e/ HTTP/1.1" 207 628 Note: After a few seconds, the response to propfind for that resource is OK again. This suggests this has to do with caching. Note2: This situation sounds similar to call 21288 (FIXED - 'DirContext caching problem with Dreamweaver 6 when recursively creating directories'). Reproducable using a jackrabbit client; ____ HttpClient client = new HttpClient(); String newDir = "http://localhost:8080/webdav/output/" + UUID.randomUUID() + "/"; // Comment out this request to make second propfind succesful HttpMethod propFindMethod1 = new PropFindMethod(newDir); client.executeMethod(propFindMethod1); propFindMethod1.releaseConnection(); HttpMethod mkcolMethod = new MkColMethod(newDir); client.executeMethod(mkcolMethod); mkcolMethod.releaseConnection(); HttpMethod propFindMethod = new PropFindMethod(newDir); client.executeMethod(propFindMethod); propFindMethod.releaseConnection(); ____</column><column name="report_time">2011-01-06 09:11:12</column><column name="report_timestamp">1294320000</column><column name="status">resolved fixed</column><column name="commit">5c2742c</column><column name="commit_timestamp">1294340000</column><column name="files">java/org/apache/naming/resources/ProxyDirContext.java</column><column name="result">52:java/org/apache/naming/resources/ProxyDirContext.java</column></table><table name="tomcat"><column name="id">536</column><column name="bug_id">47319</column><column name="summary">With APR, getRemoteHost() returns NULL for unknown clients</column><column name="description">Hello, I posted this info to the tomcat users mailing list and am following Mark Thomas' advice to open a bug report: My setup is a RedHat 5 server (32 bit) running Tomcat 6.0.20 with Tomcat Native 1.1.16 libraries and Sun JDK 1.6.0_14. I've built and installed Tomcat Native as described in http://tomcat.apache.org/native-doc/ The server.xml file has been modified to add enableLookups="true" to the HTTP Connector entry: &lt;Connector port="8080" protocol="HTTP/1.1" connectionTimeout="20000" enableLookups="true" redirectPort="8443" /&gt; Now, when the client exists in the DNS, reverse lookups via HttpServletRequest.getRemoteHost() work fine whether or not I'm using APR. The problem is, when attempting a reverse lookup for a client that is not found in the naming service, the behaviour of getRemoteHost() depends on whether or not APR is being used. Specifically, without APR, the method returns the dotted-string form of the IP address (consistent with the doc http://java.sun.com/webservices/docs/1.6/api/javax/servlet/ServletRequest.html#getRemoteHost() ). However, when APR is enabled, the method returns NULL. I can reproduce the problem using a simple test servlet: # cat GetAddress.java import java.io.*; import java.util.*; import javax.servlet.*; import javax.servlet.http.*; public class GetAddress extends HttpServlet { public void doGet(HttpServletRequest request,HttpServletResponse response) throws IOException, ServletException{ response.setContentType("text/html"); PrintWriter out = response.getWriter(); out.println("&lt;b&gt;&lt;font color='red'&gt;Hostname of request : &lt;/font&gt;&lt;/b&gt;" +request.getRemoteHost()+"&lt;p&gt;"); out.println("&lt;b&gt;&lt;font color='blue'&gt;IP Address of request : &lt;/font&gt;&lt;/b&gt;" +request.getRemoteAddr()); } } If LD_LIBRARY_PATH is set to $CATALINA_HOME/lib, catalina.out confirms APR is enabled: 05-Jun-2009 11:09:01 org.apache.catalina.core.AprLifecycleListener init INFO: Loaded APR based Apache Tomcat Native library 1.1.16. 05-Jun-2009 11:09:01 org.apache.catalina.core.AprLifecycleListener init INFO: APR capabilities: IPv6 [true], sendfile [true], accept filters [false], random [true]. 05-Jun-2009 11:09:02 org.apache.coyote.http11.Http11AprProtocol init From my client unknown to the DNS, the web page shows "Hostname of request: null ... IP Address of request: &lt;client IP address&gt;" Now, after simply unsetting LD_LIBRARY_PATH and restarting Tomcat (catalina.out confirms APR is not used), a request from the same client correctly shows "Hostname of request: &lt;client IP address&gt;... IP Address of request: &lt;client IP address&gt;" This behaviour with APR is causing problems for a third-party application that relies on identifying the client IP/host for authentication - as the code does not expect NULL from getRemoteHost() it denies access to the client (coming from another company via LAN-to-LAN VPN). Any ideas on how to debug this further? Nothing is logged to catalina.out when the error occurs. I also had a quick look in the APR source but couldn't find any reference to getRemoteHost or enableLookups so I'm not sure where this side effect is coming from. Thanks in advance for any feedback, Best regards - Paul.</column><column name="report_time">2009-06-05 05:11:52</column><column name="report_timestamp">1244190000</column><column name="status">resolved fixed</column><column name="commit">ce64f9b</column><column name="commit_timestamp">1294330000</column><column name="files">java/org/apache/coyote/http11/Http11AprProcessor.java</column><column name="result">8:java/org/apache/coyote/http11/Http11AprProcessor.java</column></table><table name="tomcat"><column name="id">537</column><column name="bug_id">50547</column><column name="summary">The CHANGE_SESSION_ID message that received during cluster session synchronization is dropped.</column><column name="description">Neither CHANGE_SESSION_ID message nor SESSION_EXPIRED message set timestamp. If these messages are received during cluster sessions synchronization in DeltaManager startup, because the timestamp is not set, they are dropped. I made a patch that add timestamp for CHANGE_SESSION_ID and SESSION_EXPIRED message. Best Regards.</column><column name="report_time">2011-01-06 03:48:03</column><column name="report_timestamp">1294300000</column><column name="status">resolved fixed</column><column name="commit">a0ef3e6</column><column name="commit_timestamp">1294310000</column><column name="files">java/org/apache/catalina/ha/session/DeltaManager.java</column><column name="result">1:java/org/apache/catalina/ha/session/DeltaManager.java</column></table><table name="tomcat"><column name="id">538</column><column name="bug_id">50453</column><column name="summary">Multiple X-Forwarded-For headers not handled by RemoteIP valve</column><column name="description">When a request comes in with multiple X-Forwarded-For headers the RemoteIP valve should be examining all of them in reverse order. As defined by the standard: "Multiple message-header fields with the same field-name MAY be present in a message if and only if the entire field-value for that header field is defined as a comma-separated list [i.e., #(values)]. It MUST be possible to combine the multiple header fields into one "field-name: field-value" pair, without changing the semantics of the message, by appending each subsequent field-value to the first, each separated by a comma. The order in which header fields with the same field-name are received is therefore significant to the interpretation of the combined field value, and thus a proxy MUST NOT change the order of these field values when a message is forwarded." thus: (a) X-Forwarded-For: 192.168.0.3 X-Forwarded-For: 222.234.0.4 Is semantically equivalent to: (b) X-Forwarded-For: 192.168.0.3, 222.234.0.4 However (a) is not handled by the RemoteIP valve as it only ever looks at the first header. For reference, this was raised on the HAproxy mailing list: http://www.formilux.org/archives/haproxy/1012/4122.html and tomcat user's mailing list: http://mail-archives.apache.org/mod_mbox/tomcat-users/201012.mbox/%3C4D022C57.1070005@apache.org%3E Tomcat users suggested raising a bug. Hence this.</column><column name="report_time">2010-12-10 09:29:39</column><column name="report_timestamp">1291990000</column><column name="status">resolved fixed</column><column name="commit">3541fc6</column><column name="commit_timestamp">1294240000</column><column name="files">java/org/apache/catalina/filters/RemoteIpFilter.java
java/org/apache/catalina/valves/RemoteIpValve.java
test/org/apache/catalina/filters/TestRemoteIpFilter.java
test/org/apache/catalina/valves/TestRemoteIpValve.java</column><column name="result">1:java/org/apache/catalina/valves/RemoteIpValve.java
2:java/org/apache/catalina/filters/RemoteIpFilter.java
6:test/org/apache/catalina/valves/TestRemoteIpValve.java
13:test/org/apache/catalina/filters/TestRemoteIpFilter.java</column></table><table name="tomcat"><column name="id">539</column><column name="bug_id">50467</column><column name="summary">Occasional NIO connector lockups on high load</column><column name="description">We've been running Tomcat 6.0.29 on FC8 2.6.21 with tens of thousands of long polling threads which usually work fine. Every few days though we will experience a sudden lockup of the NIO connector and it has to be restarted. These have been seen to be accompanied by the following stack trace: Exception in thread "http-8082-ClientPoller-0" java.lang.NullPointerException 	at org.apache.tomcat.util.net.NioEndpoint$Poller.run(NioEndpoint.java:1620) 	at java.lang.Thread.run(Thread.java:662) Looking at the source it seems the issue is likely to be a race condition where access() is called on a null attachment, probably while it's in the process of being cancelled: while (iterator != null &amp;&amp; iterator.hasNext()) { SelectionKey sk = (SelectionKey) iterator.next(); KeyAttachment attachment = (KeyAttachment)sk.attachment(); /*NPE*/ attachment.access(); iterator.remove(); processKey(sk, attachment); }//while</column><column name="report_time">2010-12-13 14:02:35</column><column name="report_timestamp">1292270000</column><column name="status">resolved fixed</column><column name="commit">688e61e</column><column name="commit_timestamp">1294240000</column><column name="files">java/org/apache/tomcat/util/net/NioEndpoint.java</column><column name="result">1:java/org/apache/tomcat/util/net/NioEndpoint.java</column></table><table name="tomcat"><column name="id">540</column><column name="bug_id">50541</column><column name="summary">JNDIRealm: support configuring LDAP sizeLimit (countLimit in SearchControls)</column><column name="description">Today, when enabling an application's LDAP authentication through Active Directory, I've discovered that with apparently a completely correct LDAP Realm configuration on the Tomcat side, AD returns the following error all the time: LDAP: error code 1 - 000004DC: LdapErr: DSID-0C0906DD, comment: In order to perform this operation a successful bind must be completed on the connection., data 0, v1771 After some hours of Googling and experimenting with referrals, subtree search modes et cetera, I've found out (through network packet analysis) that the problem is caused by LDAP sizeLimit being set to zero in the searches sent by Tomcat. After closer inspection of Tomcat source code, I've dug out this class: http://svn.apache.org/repos/asf/tomcat/trunk/java/org/apache/catalina/realm/JNDIRealm.java And this code fragment in the method getUserBySearch(DirContext context, String username, String[] attrIds): // Set up the search controls SearchControls constraints = new SearchControls(); if (userSubtree) { constraints.setSearchScope(SearchControls.SUBTREE_SCOPE); } else { constraints.setSearchScope(SearchControls.ONELEVEL_SCOPE); } // Specify the attributes to be retrieved if (attrIds == null) attrIds = new String[0]; constraints.setReturningAttributes(attrIds); NamingEnumeration&lt;SearchResult&gt; results = context.search(userBase, filter, constraints); As you can see (http://tomcat.apache.org/tomcat-7.0-doc/realm-howto.html#JNDIRealm), currently there's no way to customize other search controls than search scope and returning attributes by means of XML configuration. In javax.naming.directory.SearchControls, the LDAP sizeLimit is determined by the countLimit property: http://download.oracle.com/javase/6/docs/api/javax/naming/directory/SearchControls.html#setCountLimit(long) I propose to create a new configuration attribute for the Realm XML element that would enable setting this limit, and naming it "sizeLimit" (not "countLimit" like the Java property, because in LDAP world people are used to the former term). While we're at it, adding "timeLimit" (measured in milliseconds) attribute would be also nice. So for example one would be able to set 1000 entries sizeLimit and 5 seconds timeLimit this way: &lt;Realm className="org.apache.catalina.realm.JNDIRealm" debug="99" connectionURL="ldap://localhost:389" userPattern="uid={0},ou=people,dc=mycompany,dc=com" sizeLimit="1000" timeLimit="5000" /&gt;</column><column name="report_time">2011-01-04 11:35:07</column><column name="report_timestamp">1294160000</column><column name="status">resolved fixed</column><column name="commit">76b6415</column><column name="commit_timestamp">1294160000</column><column name="files">java/org/apache/catalina/realm/JNDIRealm.java</column><column name="result">1:java/org/apache/catalina/realm/JNDIRealm.java</column></table><table name="tomcat"><column name="id">541</column><column name="bug_id">50500</column><column name="summary">EL evaluation of floating-point String value vs BigInteger loses precision</column><column name="description">According to the EL spec ch.1.7.1, the A+B,A-B,A*B expressions when A is a "String containing ., e, or E" and B is a BigInteger have to be evaluated as follows: "coerce both A and B to BigDecimal and apply operator" The actual implementation though, instead of coercing A as String -&gt; BigDecimal, does two coercions: String -&gt; Double -&gt; BigDecimal, which produces a different result. To reproduce, run the following JSP page: &lt;% pageContext.setAttribute("a", "1.1"); pageContext.setAttribute("b", new java.math.BigInteger("1000000000000000000000")); // "c" is used to explicitly coerce arguments to BigDecimal pageContext.setAttribute("c", new java.math.BigDecimal("0")); %&gt;${a + b}&lt;br&gt; ${(a+c) + (b+c)}&lt;br&gt; ${a - b}&lt;br&gt; ${(a+c) - (b+c)}&lt;br&gt; ${a * b}&lt;br&gt; ${(a+c) * (b+c)} Actual result: 1000000000000000000001.100000000000000088817841970012523233890533447265625 1000000000000000000001.1 -999999999999999999998.899999999999999911182158029987476766109466552734375 -999999999999999999998.9 1100000000000000088817.841970012523233890533447265625000000000000000000000 1100000000000000000000.0 Expected result: 1000000000000000000001.1 1000000000000000000001.1 -999999999999999999998.9 -999999999999999999998.9 1100000000000000000000.0 1100000000000000000000.0 I think it is a minor issue, though. This is reproducible in the current tc6.0.x as well. Maybe o.a.el.lang.ELArithmetic#add(Object, Object) should delegate to BIGDECIMAL instead of DOUBLE with these types of arguments.</column><column name="report_time">2010-12-19 19:00:53</column><column name="report_timestamp">1292800000</column><column name="status">resolved fixed</column><column name="commit">b19fb3b</column><column name="commit_timestamp">1294150000</column><column name="files">java/org/apache/el/lang/ELArithmetic.java
test/org/apache/el/lang/TestELArithmetic.java</column><column name="result">1:java/org/apache/el/lang/ELArithmetic.java</column></table><table name="tomcat"><column name="id">542</column><column name="bug_id">50025</column><column name="summary">getConnection method in class DataSourceProxy is ignoring credentials</column><column name="description">See http://forum.springsource.org/showthread.php?t=95980 for a description of the problem.</column><column name="report_time">2010-09-29 09:48:26</column><column name="report_timestamp">1285770000</column><column name="status">resolved fixed</column><column name="commit">59b17c1</column><column name="commit_timestamp">1294090000</column><column name="files">modules/jdbc-pool/java/org/apache/tomcat/jdbc/pool/ConnectionPool.java
modules/jdbc-pool/java/org/apache/tomcat/jdbc/pool/DataSourceFactory.java
modules/jdbc-pool/java/org/apache/tomcat/jdbc/pool/DataSourceProxy.java
modules/jdbc-pool/java/org/apache/tomcat/jdbc/pool/PoolConfiguration.java
modules/jdbc-pool/java/org/apache/tomcat/jdbc/pool/PoolProperties.java
modules/jdbc-pool/java/org/apache/tomcat/jdbc/pool/PooledConnection.java
modules/jdbc-pool/java/org/apache/tomcat/jdbc/pool/jmx/ConnectionPool.java
modules/jdbc-pool/test/org/apache/tomcat/jdbc/test/AlternateUsernameTest.java
modules/jdbc-pool/test/org/apache/tomcat/jdbc/test/driver/Connection.java
modules/jdbc-pool/test/org/apache/tomcat/jdbc/test/driver/Driver.java</column><column name="result">1:modules/jdbc-pool/java/org/apache/tomcat/jdbc/pool/DataSourceProxy.java
2:modules/jdbc-pool/java/org/apache/tomcat/jdbc/pool/PooledConnection.java
8:modules/jdbc-pool/java/org/apache/tomcat/jdbc/pool/DataSourceFactory.java
16:modules/jdbc-pool/java/org/apache/tomcat/jdbc/pool/ConnectionPool.java
24:modules/jdbc-pool/java/org/apache/tomcat/jdbc/pool/PoolConfiguration.java
29:modules/jdbc-pool/java/org/apache/tomcat/jdbc/pool/jmx/ConnectionPool.java
119:modules/jdbc-pool/java/org/apache/tomcat/jdbc/pool/PoolProperties.java
154:modules/jdbc-pool/test/org/apache/tomcat/jdbc/test/driver/Connection.java
261:modules/jdbc-pool/test/org/apache/tomcat/jdbc/test/driver/Driver.java</column></table><table name="tomcat"><column name="id">543</column><column name="bug_id">50503</column><column name="summary">Engine level Clustering does not work correctly if the web application has a version.</column><column name="description">In Engine level clustering, the name of the cluster manager is "HostName#contextName". SimpleTcpCluster#getManagerName(String, Manager) is as follows. ==== public String getManagerName(String name, Manager manager) { String clusterName = name ; if ( clusterName == null ) clusterName = manager.getContainer().getName(); if(getContainer() instanceof Engine) { Container context = manager.getContainer() ; if(context != null &amp;&amp; context instanceof Context) { Container host = ((Context)context).getParent(); if(host != null &amp;&amp; host instanceof Host &amp;&amp; clusterName!=null &amp;&amp; !(clusterName.indexOf("#")&gt;=0)) clusterName = host.getName() +"#" + clusterName ; } } return clusterName; } ==== In this method, clusterName.indexOf("#") &gt;= 0 is checked. Because the context name becomes contextName##version if the web application has a version, the name of the cluster manager doesn't become a format of "HostName#contextName". As a result, Engine level Clustering doesn't work correctly. Best regards.</column><column name="report_time">2010-12-21 01:42:21</column><column name="report_timestamp">1292910000</column><column name="status">resolved fixed</column><column name="commit">701d5dc</column><column name="commit_timestamp">1292910000</column><column name="files">java/org/apache/catalina/ha/tcp/SimpleTcpCluster.java</column><column name="result">1:java/org/apache/catalina/ha/tcp/SimpleTcpCluster.java</column></table><table name="tomcat"><column name="id">544</column><column name="bug_id">13731</column><column name="summary">Final request, response, session and other variables.</column><column name="description">Provide a capability to declare request, response, session and other variables in jspService function as final. As tunable feature, just like others, in tomcat`s web.xml file. Why need this feature? To use request, response, session variables in anonymous implementations of classes. For example - declaration of iterator through elements, which includes some other JSP file (statically). And usage of this iterator in other JSP file.</column><column name="report_time">2002-10-17 13:23:42</column><column name="report_timestamp">1034880000</column><column name="status">resolved fixed</column><column name="commit">73531cb</column><column name="commit_timestamp">1292540000</column><column name="files">java/org/apache/jasper/compiler/Generator.java</column><column name="result">22:java/org/apache/jasper/compiler/Generator.java</column></table><table name="tomcat"><column name="id">545</column><column name="bug_id">10972</column><column name="summary">&lt;Realm&gt; without className in server.xml produces NullPointerException</column><column name="description">If the className attribute is not included with the &lt;Realm&gt; tag in server.xml, the server dies with a cryptic NullPointerException. It would be nice if it produced a more meaningful error message (like "Missing className attribute for &lt;Realm&gt; tag").</column><column name="report_time">2002-07-19 02:30:07</column><column name="report_timestamp">1027060000</column><column name="status">resolved fixed</column><column name="commit">71ad1bd</column><column name="commit_timestamp">1292440000</column><column name="files">java/org/apache/catalina/startup/Catalina.java
java/org/apache/tomcat/util/digester/Digester.java
java/org/apache/tomcat/util/digester/ObjectCreateRule.java</column><column name="result">31:java/org/apache/catalina/startup/Catalina.java
50:java/org/apache/tomcat/util/digester/Digester.java
106:java/org/apache/tomcat/util/digester/ObjectCreateRule.java</column></table><table name="tomcat"><column name="id">546</column><column name="bug_id">10526</column><column name="summary">Authenticators do not always cache the Principal</column><column name="description">Once a user is authenticated a Principal object is supposed to be cached for the duration of the user's session. This is especially important when using JDBCRealm or JNDIRealm to reduce the load on external authentication services. Most authenticators (BasicAuthenticator, SSLAuthenticator and DigestAuthenticator) call AuthenticatorBase.register()to cache the Principal. However register() does nothing if a session object does not already exist, so caching does not occur when the application does not create a session object itself. The problem can be seen by setting a security constraint on tomcat-docs and then browsing the Tomcat documentation - the external authentication service is hit on every request. The problem does not occur with form based login, because FormAuthenticator caches the Principal itself and creates a new session if necessary to do it. Probably the best fix would be to change AuthenticatorBase.register() to create a new session by calling getSession(request, true) instead of getSession (request, false). However, perhaps there is a reason why this is not being done - though if so I cannot see what it is. An alternative is to change the concrete authentication classes to make sure a session exists before calling register(), e.g. --- BasicAuthenticator.java 23 Mar 2002 17:52:16 -0000 1.12 +++ BasicAuthenticator.java 6 Jul 2002 12:46:30 -0000 @@ -160,6 +160,7 @@ String password = parsePassword(authorization); principal = context.getRealm().authenticate(username, password); if (principal != null) { + Session session = getSession(request, true); register(request, response, principal, Constants.BASIC_METHOD, username, password); return (true); Similar patches would be required for SSLAuthenticator and DigestAuthenticator of course.</column><column name="report_time">2002-07-06 13:11:40</column><column name="report_timestamp">1025980000</column><column name="status">resolved fixed</column><column name="commit">ca34a30</column><column name="commit_timestamp">1292430000</column><column name="files">java/org/apache/catalina/authenticator/AuthenticatorBase.java</column><column name="result">4:java/org/apache/catalina/authenticator/AuthenticatorBase.java</column></table><table name="tomcat"><column name="id">547</column><column name="bug_id">49125</column><column name="summary">toString on byte[] array probably is not correct</column><column name="description">Two examples of using toString() on a byte[] array, which is unlikely to produce the desired output: ha.deploy.FileMessageFactory.writeMessage() log message uses toString on msg.getData() which is a byte[] array coyote.ajp.AjpMessage.dump use toString on "msg" which is of type byte[]</column><column name="report_time">2010-04-14 18:54:35</column><column name="report_timestamp">1271290000</column><column name="status">resolved fixed</column><column name="commit">5614817</column><column name="commit_timestamp">1292360000</column><column name="files">java/org/apache/catalina/ha/deploy/FileMessageFactory.java
java/org/apache/coyote/ajp/AjpMessage.java
java/org/apache/tomcat/util/buf/HexUtils.java</column><column name="result">1:java/org/apache/coyote/ajp/AjpMessage.java
2:java/org/apache/catalina/ha/deploy/FileMessageFactory.java
333:java/org/apache/tomcat/util/buf/HexUtils.java</column></table><table name="tomcat"><column name="id">548</column><column name="bug_id">50460</column><column name="summary">First access to a jspx page causes classloader leak in JspDocumentParser</column><column name="description">Running latest 6.0.x, To reproduce: 1. Stop Tomcat 2. Deploy the examples webapp 3. Create /webapps/examples/foo.jsp file containing the following text: &lt;jsp:include page="/jsp/jsp2/jspx/basic.jspx"/&gt; 4. Make sure that the work folder of Tomcat is empty. 5. Start Tomcat 6. Go to http://localhost:8080/examples/foo.jsp 7. Go to the Manager web application and stop the examples webapp. 8. Press the "Find leaks" button there. ACTUAL RESULT: It is reported that "/examples" causes a leak. EXPECTED RESULT: No leaks. This issue is apparently caused by an instance of org.apache.jasper.compiler.JspDocumentParser$EnableDTDValidationException that is being kept in a static final field. More discussion of such leaks can be found in thread [1] on dev@. [1] http://tomcat.markmail.org/thread/v4xmg5v5t6oa4mrs http://marc.info/?l=tomcat-dev&amp;m=129211856426188&amp;w=2 Additional comments: 1) This issue affects the first request that loads the JspDocumentParser class. Subsequent requests do not cause the issue. Thus only a single webapp is affected. 2) The issue does not happen when there is no webapp code in the call stack. I.e., it does not happen if the JSPX page was requested directly. That is why the reproduction recipe uses &lt;jsp:include/&gt;. Possible solutions: 1) Preload the JspDocumentParser class when Tomcat starts. 2) Do not cache the Exception. Create a new instance each time. 3) Override the fillInStackTrace() method, like it was done in AbstractDOMParser$Abort in Apache Xerces [2]. I do not know, whether that helps or not. [2] http://svn.apache.org/viewvc/xerces/java/trunk/src/org/apache/xerces/parsers/AbstractDOMParser.java?annotate=782187#l162</column><column name="report_time">2010-12-11 21:33:47</column><column name="report_timestamp">1292120000</column><column name="status">resolved fixed</column><column name="commit">345e6b5</column><column name="commit_timestamp">1292200000</column><column name="files">java/org/apache/jasper/compiler/JspDocumentParser.java
java/org/apache/naming/resources/ImmutableNameNotFoundException.java</column><column name="result">1:java/org/apache/jasper/compiler/JspDocumentParser.java
397:java/org/apache/naming/resources/ImmutableNameNotFoundException.java</column></table><table name="tomcat"><column name="id">549</column><column name="bug_id">50448</column><column name="summary">StandardSession.expire causes IllegalStateException: getCreationTime: Session already invalidated</column><column name="description">Hi, when verifying the fix for #50360 I ran into an issue with expired sessions during processExpires: Dec 10, 2010 12:59:32 AM org.apache.catalina.core.ContainerBase backgroundProcess WARNING: Exception processing manager de.javakaffee.web.msm.MemcachedBackupSessionManager[/] background process java.lang.IllegalStateException: getCreationTime: Session already invalidated 	at org.apache.catalina.session.StandardSession.getCreationTime(StandardSession.java:1096) 	at org.apache.catalina.session.ManagerBase.remove(ManagerBase.java:802) 	at org.apache.catalina.session.StandardSession.expire(StandardSession.java:840) 	at org.apache.catalina.session.StandardSession.isValid(StandardSession.java:655) 	at org.apache.catalina.session.ManagerBase.processExpires(ManagerBase.java:609) 	at org.apache.catalina.session.ManagerBase.backgroundProcess(ManagerBase.java:594) 	at de.javakaffee.web.msm.MemcachedBackupSessionManager.backgroundProcess(MemcachedBackupSessionManager.java:1130) 	at org.apache.catalina.core.ContainerBase.backgroundProcess(ContainerBase.java:1214) AFAICS in MemcachedBackupSessionManager I could override remove(Session session, boolean update) with calling super.remove(session, false) for invalid sessions. Another option would be to change StandardSession.expire(StandardSession.java:840) so that it does not invoke manager.remove(this, true) but manager.remove(this, false). Or even better: change ManagerBase.remove(ManagerBase.java:802) to invoke some session.getCreationTimeInternal() which skips validation. What do you think? Cheers, Martin</column><column name="report_time">2010-12-09 19:23:29</column><column name="report_timestamp">1291940000</column><column name="status">resolved fixed</column><column name="commit">4117b78</column><column name="commit_timestamp">1291990000</column><column name="files">java/org/apache/catalina/Session.java
java/org/apache/catalina/manager/DummyProxySession.java
java/org/apache/catalina/session/ManagerBase.java
java/org/apache/catalina/session/StandardSession.java</column><column name="result">1:java/org/apache/catalina/session/StandardSession.java
2:java/org/apache/catalina/session/ManagerBase.java
6:java/org/apache/catalina/Session.java
27:java/org/apache/catalina/manager/DummyProxySession.java</column></table><table name="tomcat"><column name="id">550</column><column name="bug_id">50408</column><column name="summary">Scoped EL variable in methodexpression is treated as Object</column><column name="description">Consider following example: &lt;dl&gt; &lt;c:forEach items="${pageContext.response.headerNames}" var="name"&gt; &lt;c:forEach items="${pageContext.response.getHeaders(name)}" var="value"&gt; &lt;dt&gt;${name}&lt;/dt&gt;&lt;dd&gt;${value}&lt;/dd&gt; &lt;/c:forEach&gt; &lt;/c:forEach&gt; &lt;/dl&gt; The ${name} is a String. The ${name.class.name} also proves that. The getHeaders(name) call however results in: org.apache.jasper.el.JspELException: /test.jsp(23,12) '${pageContext.response.getHeaders(name)}' java.lang.NoSuchMethodException: org.apache.catalina.connector.ResponseFacade.getHeaders(java.lang.Object) Another example which also results in NoSuchMethodException which suggests that an Object is been passed as argument: &lt;c:set var="name" value="test" /&gt; ${pageContext.response.getHeader(name)} This works all fine on Glassfish v3.</column><column name="report_time">2010-12-03 12:37:00</column><column name="report_timestamp">1291400000</column><column name="status">resolved fixed</column><column name="commit">4ed7b7e</column><column name="commit_timestamp">1291410000</column><column name="files">java/javax/el/CompositeELResolver.java
test/javax/el/TestCompositeELResolver.java</column><column name="result">356:java/javax/el/CompositeELResolver.java</column></table><table name="tomcat"><column name="id">551</column><column name="bug_id">48692</column><column name="summary">Provide option to parse application/x-www-form-urlencoded PUT requests</column><column name="description">Provide an option to treat application/x-www-form-urlencoded encoded parameters in a PUT request in a similar manner to application/x-www-form-urlencoded parameters in a POST request</column><column name="report_time">2010-02-07 02:41:33</column><column name="report_timestamp">1265530000</column><column name="status">resolved fixed</column><column name="commit">e34b164</column><column name="commit_timestamp">1291390000</column><column name="files">java/org/apache/catalina/connector/Connector.java
java/org/apache/catalina/connector/Request.java
test/org/apache/catalina/connector/TestRequest.java</column><column name="result">1:java/org/apache/catalina/connector/Request.java
46:java/org/apache/catalina/connector/Connector.java
85:test/org/apache/catalina/connector/TestRequest.java</column></table><table name="tomcat"><column name="id">552</column><column name="bug_id">50358</column><column name="summary">Embedded.stopInternal sets state to STARTING, should be STOPPING</column><column name="description">Embedded.stopInternal invokes setState(LifecycleState.STARTING), this should be changed to setState(LifecycleState.STOPPING). Setting LifecycleState.STARTING during stopInternal leads to a LifecycleException when the Embedded is shut down: LifecycleException: An invalid Lifecycle transition was attempted ([after_stop]) for component [StandardService[null]] in state [STARTING] 	at org.apache.catalina.util.LifecycleBase.invalidTransition(LifecycleBase.java:321) 	at org.apache.catalina.util.LifecycleBase.stop(LifecycleBase.java:226) 	at de.javakaffee.web.msm.MemcachedSessionManagerIntegrationTest.tearDown(MemcachedSessionManagerIntegrationTest.java:112) This failure leads to failing tests in my case. I'm using the (deprecated) Embedded for integration testing the memcached-session-manager (http://code.google.com/p/memcached-session-manager/). I'm just working on a tomcat7 branch, which shall diverge as little as possible from the master/trunk, therefore I'm still using Embedded instead of the newly introduced Tomcat.</column><column name="report_time">2010-11-28 18:13:10</column><column name="report_timestamp">1290990000</column><column name="status">resolved fixed</column><column name="commit">07b72f1</column><column name="commit_timestamp">1291040000</column><column name="files">java/org/apache/catalina/startup/Embedded.java</column><column name="result">1:java/org/apache/catalina/startup/Embedded.java</column></table><table name="tomcat"><column name="id">553</column><column name="bug_id">49142</column><column name="summary">Missing serialVersionUIDs</column><column name="description">org.apache.catalina.ha.ClusterMessageBase is Serializable; consider declaring a serialVersionUID Similarly for: org.apache.catalina.ha.session.ReplicatedSession org.apache.catalina.ha.session.SerializablePrincipal org.apache.catalina.session.StandardSession org.apache.catalina.tribes.tipis.AbstractReplicatedMap.MapMessage org.apache.tomcat.util.modeler.ManagedBean</column><column name="report_time">2010-04-16 21:25:34</column><column name="report_timestamp">1271470000</column><column name="status">resolved fixed</column><column name="commit">4cbb52f</column><column name="commit_timestamp">1290640000</column><column name="files">java/javax/servlet/GenericServlet.java
java/javax/servlet/ServletContextAttributeEvent.java
java/javax/servlet/ServletContextEvent.java
java/javax/servlet/ServletException.java
java/javax/servlet/ServletRequestAttributeEvent.java
java/javax/servlet/ServletRequestEvent.java
java/javax/servlet/UnavailableException.java
java/javax/servlet/http/HttpServlet.java
java/javax/servlet/http/HttpSessionBindingEvent.java
java/javax/servlet/http/HttpSessionEvent.java
java/javax/servlet/jsp/JspException.java
java/javax/servlet/jsp/JspTagException.java
java/javax/servlet/jsp/SkipPageException.java
java/javax/servlet/jsp/el/ELException.java
java/javax/servlet/jsp/el/ELParseException.java
java/javax/servlet/jsp/tagext/TagSupport.java
java/org/apache/catalina/ha/deploy/FileMessage.java
java/org/apache/catalina/ha/deploy/UndeployMessage.java
java/org/apache/catalina/manager/StatusManagerServlet.java
java/org/apache/catalina/session/StandardSession.java
java/org/apache/catalina/ssi/SSIServlet.java
java/org/apache/catalina/ssi/SSIStopProcessingException.java
java/org/apache/catalina/tribes/ChannelException.java
java/org/apache/catalina/tribes/RemoteProcessException.java
java/org/apache/catalina/tribes/UniqueId.java
java/org/apache/catalina/tribes/io/ChannelData.java
java/org/apache/catalina/tribes/tipis/AbstractReplicatedMap.java
java/org/apache/catalina/tribes/tipis/LazyReplicatedMap.java
java/org/apache/catalina/tribes/tipis/ReplicatedMap.java
java/org/apache/catalina/tribes/util/ExecutorFactory.java
java/org/apache/catalina/util/ParameterMap.java
java/org/apache/catalina/util/ResourceSet.java
java/org/apache/jasper/JasperException.java
java/org/apache/jasper/compiler/JspDocumentParser.java
java/org/apache/jasper/runtime/HttpJspBase.java
java/org/apache/juli/logging/LogConfigurationException.java
java/org/apache/naming/EjbRef.java
java/org/apache/naming/HandlerRef.java
java/org/apache/naming/JndiPermission.java
java/org/apache/naming/ResourceEnvRef.java
java/org/apache/naming/ResourceLinkRef.java
java/org/apache/naming/ServiceRef.java
java/org/apache/naming/TransactionRef.java
java/org/apache/tomcat/util/buf/CharChunk.java
java/org/apache/tomcat/util/buf/MessageBytes.java
java/org/apache/tomcat/util/modeler/BaseAttributeFilter.java
java/org/apache/tomcat/util/modeler/FixedNotificationFilter.java
java/org/apache/tomcat/util/modeler/ManagedBean.java
java/org/apache/tomcat/util/net/URL.java
test/org/apache/catalina/tribes/demos/MapDemo.java
webapps/examples/WEB-INF/jsp/applet/Clock2.java</column><column name="result">1:java/org/apache/catalina/tribes/tipis/AbstractReplicatedMap.java
2:java/org/apache/catalina/session/StandardSession.java
3:java/org/apache/catalina/tribes/tipis/ReplicatedMap.java
4:java/org/apache/catalina/tribes/tipis/LazyReplicatedMap.java
21:java/org/apache/tomcat/util/modeler/ManagedBean.java
34:java/org/apache/catalina/tribes/io/ChannelData.java
45:java/org/apache/catalina/tribes/UniqueId.java
130:java/javax/servlet/http/HttpSessionBindingEvent.java
132:java/org/apache/catalina/util/ParameterMap.java
135:java/org/apache/jasper/compiler/JspDocumentParser.java
227:test/org/apache/catalina/tribes/demos/MapDemo.java
239:java/org/apache/catalina/ssi/SSIStopProcessingException.java
276:java/org/apache/tomcat/util/buf/MessageBytes.java
297:java/org/apache/tomcat/util/buf/CharChunk.java
339:java/javax/servlet/http/HttpSessionEvent.java
417:java/org/apache/catalina/ha/deploy/FileMessage.java
444:java/javax/servlet/UnavailableException.java
456:java/javax/servlet/http/HttpServlet.java
478:java/javax/servlet/GenericServlet.java
501:java/javax/servlet/jsp/tagext/TagSupport.java
513:java/javax/servlet/ServletRequestEvent.java
558:java/javax/servlet/ServletContextAttributeEvent.java
559:java/javax/servlet/ServletRequestAttributeEvent.java
615:java/org/apache/jasper/JasperException.java
641:java/org/apache/catalina/ha/deploy/UndeployMessage.java
655:java/org/apache/jasper/runtime/HttpJspBase.java
664:java/org/apache/catalina/ssi/SSIServlet.java
734:java/org/apache/tomcat/util/modeler/BaseAttributeFilter.java
840:java/javax/servlet/jsp/SkipPageException.java
850:java/javax/servlet/jsp/el/ELException.java
867:java/javax/servlet/jsp/JspException.java
870:java/org/apache/catalina/manager/StatusManagerServlet.java
875:java/org/apache/tomcat/util/net/URL.java
877:java/javax/servlet/ServletException.java
893:java/org/apache/catalina/tribes/ChannelException.java
898:java/javax/servlet/jsp/el/ELParseException.java
916:java/org/apache/tomcat/util/modeler/FixedNotificationFilter.java
931:java/org/apache/catalina/util/ResourceSet.java
992:java/org/apache/juli/logging/LogConfigurationException.java
1066:java/org/apache/catalina/tribes/RemoteProcessException.java
1111:java/javax/servlet/jsp/JspTagException.java
1143:java/org/apache/naming/HandlerRef.java
1144:java/org/apache/naming/ServiceRef.java
1165:java/org/apache/naming/JndiPermission.java
1178:java/org/apache/catalina/tribes/util/ExecutorFactory.java
1214:java/javax/servlet/ServletContextEvent.java
1335:java/org/apache/naming/ResourceEnvRef.java
1337:java/org/apache/naming/TransactionRef.java
1393:java/org/apache/naming/ResourceLinkRef.java
1399:java/org/apache/naming/EjbRef.java</column></table><table name="tomcat"><column name="id">554</column><column name="bug_id">48837</column><column name="summary">Memory leaks protection does not detect leaks triggered by JSP pages code</column><column name="description">Created attachment 25077 webapps/examples/foo.jsp The memory leaks protection feature of TC6/TC7 is able to heal certain types of memory leaks caused by servlet code (where classes are loaded by WebappClassLoader), but does not provide a cure for ones caused by JSP code (where classes are loaded by JasperLoader). I think that is of little concern, as the code that triggers a memory leak is unlikely to be present on a JSP page or a tag file, but at least it provides us with an example to test the "Find leaks" diagnostics in the Manager webapp. To reproduce: 1. Place the attached foo.jsp into the examples webapp 2. Open http://localhost:8080/examples/foo.jsp 3. Open the Manager web application 4. Reload or stop/start the examples application 5. Press the "Find leaks" button in the Manager 6. The message will be displayed that "/examples" app triggered a memory leak. The leak is caused by foo.jsp creating a ThreadLocal holding an instance of some inner class of that JSP. (That inner class was loaded through JasperLoader, and thus was not detected when enumerating ThreadLocals in leaks protection code.) 7. Another ThreadLocal (holding a reference to some servlet) is successfully cleared by memory leak protection code when the examples application is stopped. You can see a message about that in the Tomcat logs.</column><column name="report_time">2010-03-01 18:51:11</column><column name="report_timestamp">1267490000</column><column name="status">resolved fixed</column><column name="commit">ddbbfc1</column><column name="commit_timestamp">1290630000</column><column name="files">java/org/apache/catalina/loader/WebappClassLoader.java</column><column name="result">5:java/org/apache/catalina/loader/WebappClassLoader.java</column></table><table name="tomcat"><column name="id">555</column><column name="bug_id">50108</column><column name="summary">Add missing setter/getter to AbstractXXXProtocol</column><column name="description">Created attachment 26182 patch for AbstractXXXProtocol Add missing following methods to AbstractHttp11Protocol and AbstractAjpProtocol. - setMinSpareThreads - getMinSpareThreads Best regards.</column><column name="report_time">2010-10-18 03:22:19</column><column name="report_timestamp">1287390000</column><column name="status">resolved fixed</column><column name="commit">5a84fdb</column><column name="commit_timestamp">1290630000</column><column name="files">java/org/apache/coyote/ajp/AbstractAjpProtocol.java
java/org/apache/coyote/http11/AbstractHttp11Protocol.java</column><column name="result">9:java/org/apache/coyote/http11/AbstractHttp11Protocol.java
10:java/org/apache/coyote/ajp/AbstractAjpProtocol.java</column></table><table name="tomcat"><column name="id">556</column><column name="bug_id">50207</column><column name="summary">CometProcessor async timeout events are not being fired</column><column name="description">This is reproducible using the the default chat example (ie: ChatServlet, /examples/jsp/chat) and the following additional changes: 1) Enabled Http11Nio in conf/server.xml: &lt;Connector address="0.0.0.0" port="8080" protocol="org.apache.coyote.http11.Http11NioProtocol" connectionTimeout="20000" enableLookups="false" acceptCount="100" disableUploadTimeout="true" maxThreads="15" minSpareThreads="15" maxSpareThreads="15" RECYCLE_FACADES="true"/&gt; 2) Enabled the comet valve in conf/context.xml: &lt;Valve className="org.apache.catalina.valves.CometConnectionManagerValve" /&gt; The problem is CometEvent.EventType.ERROR (and subtype TIMEOUT) and CometEvent.EventType.END are never being fired. This can be confirmed in the logs; the messages for these events are never printed. This worked on Tomcat 6.0.29. As an aside, what is the most complete/robust way to do async IO in tomcat 7 today, Servlet 3.0 or CometProcessor?</column><column name="report_time">2010-11-03 14:52:32</column><column name="report_timestamp">1288810000</column><column name="status">resolved fixed</column><column name="commit">46e7d1e</column><column name="commit_timestamp">1290530000</column><column name="files">java/org/apache/coyote/http11/Http11NioProtocol.java
java/org/apache/tomcat/util/net/NioEndpoint.java</column><column name="result">9:java/org/apache/coyote/http11/Http11NioProtocol.java
26:java/org/apache/tomcat/util/net/NioEndpoint.java</column></table><table name="tomcat"><column name="id">557</column><column name="bug_id">50316</column><column name="summary">Minor glitch with display of negative TTL on sessionDetail.jsp</column><column name="description">Created attachment 26331 sessionDetail.jpg - screenshot To reproduce 1. Start Tomcat 2. Create a session 3. Stop Tomcat. Wait for more than TTL (default: 30 minutes). Start Tomcat. 4. Go to the Manager web application and look at the Session Details page for the session. I had some instance of 6.0.29 lying on my drive for several months. The TTL value was printed as "0-2982:0-20:0-59" instead of "-2982:20:59". I am attaching the screenshot. I wonder why the session was still alive, but that is a different question. The bug is in JspHelper.secondsToTimeString(), as it does not deal with negative values.</column><column name="report_time">2010-11-22 11:29:24</column><column name="report_timestamp">1290440000</column><column name="status">resolved fixed</column><column name="commit">278a36a</column><column name="commit_timestamp">1290460000</column><column name="files">java/org/apache/catalina/manager/JspHelper.java
java/org/apache/catalina/manager/StatusTransformer.java</column><column name="result">76:java/org/apache/catalina/manager/JspHelper.java
209:java/org/apache/catalina/manager/StatusTransformer.java</column></table><table name="tomcat"><column name="id">558</column><column name="bug_id">50308</column><column name="summary">Call to AsyncContext.dispatch() in the onTimeout callback throws exception</column><column name="description">When dispatch() method is called inside the onTimeout() function of the AsyncListener, the exception is thrown: SEVERE: An exception or error occurred in the container during the request processing java.lang.IllegalStateException: Calling [dispatchAsync()] is not valid for a request with Async state [TIMING_OUT] 	at org.apache.coyote.AsyncStateMachine.asyncDispatch(AsyncStateMachine.java:220) 	at org.apache.coyote.http11.Http11NioProcessor.actionInternal(Http11NioProcessor.java:672) 	at org.apache.coyote.http11.AbstractHttp11Processor.action(AbstractHttp11Processor.java:937) 	at org.apache.coyote.Request.action(Request.java:348) 	at org.apache.catalina.core.AsyncContextImpl.dispatch(AsyncContextImpl.java:173) 	at org.apache.catalina.core.AsyncContextImpl.dispatch(AsyncContextImpl.java:135) 	at org.apache.catalina.core.AsyncContextImpl.dispatch(AsyncContextImpl.java:130) 	at com.juriy.snowball.SnowServlet$1.onTimeout(SnowServlet.java:23) 	at org.apache.catalina.core.AsyncListenerWrapper.fireOnTimeout(AsyncListenerWrapper.java:45) 	at org.apache.catalina.core.AsyncContextImpl.timeout(AsyncContextImpl.java:109) 	at org.apache.catalina.connector.CoyoteAdapter.asyncDispatch(CoyoteAdapter.java:270) 	at org.apache.coyote.http11.Http11NioProcessor.asyncDispatch(Http11NioProcessor.java:232) 	at org.apache.coyote.http11.Http11NioProtocol$Http11ConnectionHandler.event(Http11NioProtocol.java:305) 	at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.run(NioEndpoint.java:1526) 	at java.util.concurrent.ThreadPoolExecutor$Worker.runTask(ThreadPoolExecutor.java:886) 	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:908) 	at java.lang.Thread.run(Thread.java:619) The sample code is below: 	protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { 		AsyncContext context = request.startAsync(); 		context.setTimeout(3000); 		context.addListener(new AsyncListener() { 			public void onComplete(AsyncEvent asyncEvent) throws IOException {} 			public void onTimeout(AsyncEvent asyncEvent) throws IOException { 				System.out.println("HITTING TIMEOUT"); 				asyncEvent.getAsyncContext().dispatch(); 			} 			public void onError(AsyncEvent asyncEvent) throws IOException {} 			public void onStartAsync(AsyncEvent asyncEvent) throws IOException {} 		}); } It looks like the Servlet 3.0 specification allows to do such call, here's the quotation that explicitly states the flow of the timeouted async contexts (page 18): "In the event that an asynchronous operation times out, the container must run through the following steps:  Invoke the AsyncListener.onTimeout method on all the AsyncListener instances registered with the ServletRequest on which the asynchronous operation was initiated.  If none of the listeners called AsyncContext.complete() or any of the AsyncContext.dispatch methods, perform an error dispatch with a status code equal to HttpServletResponse.SC_INTERNAL_SERVER_ERROR.  If no matching error page was found, or the error page did not call AsyncContext.complete() or any of the AsyncContext.dispatch methods, the container MUST call AsyncContext.complete()" Second step assumes that the call to dispatch in onTimeout() is allowed.</column><column name="report_time">2010-11-20 11:00:06</column><column name="report_timestamp">1290270000</column><column name="status">resolved fixed</column><column name="commit">991702c</column><column name="commit_timestamp">1290440000</column><column name="files">java/org/apache/coyote/AsyncStateMachine.java
test/org/apache/catalina/core/TestAsyncContextImpl.java</column><column name="result">18:test/org/apache/catalina/core/TestAsyncContextImpl.java
27:java/org/apache/coyote/AsyncStateMachine.java</column></table><table name="tomcat"><column name="id">559</column><column name="bug_id">50310</column><column name="summary">Manager detailed status page does not display servlets</column><column name="description">To reproduce: 1. Login to the Manager webapp 2. Click "Server Status" and then "Complete Server Status" links. In TC6 the "Complete Server Status" page lists servlets for each deployed application. In the current TC7 it does not list them. Only summary information on each webapp is displayed. Looking at the StatusManagerServlet and StatusTransformer classes, the code to iterate over servlets is still there, but probably the JMX names have changed and are not working any more.</column><column name="report_time">2010-11-21 21:08:35</column><column name="report_timestamp">1290390000</column><column name="status">resolved fixed</column><column name="commit">ade20d2</column><column name="commit_timestamp">1290430000</column><column name="files">java/org/apache/catalina/core/StandardWrapper.java</column><column name="result">19:java/org/apache/catalina/core/StandardWrapper.java</column></table><table name="tomcat"><column name="id">560</column><column name="bug_id">50293</column><column name="summary">javax.el.CompositeELResolver synchronization issue</column><column name="description">Created attachment 26310 Synchronize change in CompositeELResolver.add The javax.el.CompositeELResolver.add method needs to synchronize around the update to the resolvers. If two threads call add, then it is possible for both threads get past the size check, then one thread updates the size, and when the next thread tries to update the size, it fails with an ArrayIndexOutOfBoundsException. Also, it makes sense to increase the default size of the ELResolver array since even the jasper EL adds 5 ELResolvers. I propose a default of 8.</column><column name="report_time">2010-11-18 16:58:18</column><column name="report_timestamp">1290120000</column><column name="status">resolved fixed</column><column name="commit">7b89af8</column><column name="commit_timestamp">1290190000</column><column name="files">java/javax/el/CompositeELResolver.java</column><column name="result">1:java/javax/el/CompositeELResolver.java</column></table><table name="tomcat"><column name="id">561</column><column name="bug_id">50192</column><column name="summary">performance issue after revision 746425</column><column name="description">Revision 746425 changed at least 2 files: ELResolverImpl and ELContextImpl. I believe this causes an unnecessary performance regression in these two files. In ELResolverImpl, every time that getDefaultResolver is called with security enabled, a new Object is going to be created. It appears as if getDefaultResolver is going to be called a lot and this could significantly hurt performance. I understand changing the DefaultResolver to be private and allowing access to it through the getter method, however, I don't believe a new object needs to be created every time the method is called. In ELContextImpl, why does a new FunctionMapper need to be created for each ELContextImpl? Thanks.</column><column name="report_time">2010-11-01 15:17:42</column><column name="report_timestamp">1288640000</column><column name="status">resolved fixed</column><column name="commit">e075c4b</column><column name="commit_timestamp">1289590000</column><column name="files">java/org/apache/jasper/el/ELContextImpl.java
java/org/apache/jasper/el/ELResolverImpl.java</column><column name="result" /></table><table name="tomcat"><column name="id">562</column><column name="bug_id">50230</column><column name="summary">Recursive dependency between the tomcat-catalina-ha and tomcat-catalina</column><column name="description">From the pom file of tomcat-catalina-ha, it depends on the tomcat-catalina. But one class HTMLManagerServlet in the tomcat-catalina has a reference to a class BackupManager in the tomcat-catalina-ha. Is there a way to remove the recursive dependency between those two components ? By the way, there mightbe a NullPointerException issue while using the BackupManager in the HTMLManagerServlet. ---&gt; line.523 Manager manager = ctxt.getManager(); if (manager instanceof BackupManager &amp;&amp; showProxySessions) { args[5] = new Integer( ((BackupManager)manager).getActiveSessionsFull()); } else if (ctxt.getManager() != null){ args[5] = new Integer(manager.getActiveSessions()); } else { args[5] = new Integer(0); } &lt;--- Please also check the thread from http://www.mail-archive.com/users@tomcat.apache.org/msg83188.html</column><column name="report_time">2010-11-07 21:04:22</column><column name="report_timestamp">1289180000</column><column name="status">resolved fixed</column><column name="commit">96020cb</column><column name="commit_timestamp">1289510000</column><column name="files">java/org/apache/catalina/DistributedManager.java
java/org/apache/catalina/ha/session/BackupManager.java
java/org/apache/catalina/manager/HTMLManagerServlet.java</column><column name="result">33:java/org/apache/catalina/manager/HTMLManagerServlet.java
59:java/org/apache/catalina/ha/session/BackupManager.java</column></table><table name="tomcat"><column name="id">563</column><column name="bug_id">50252</column><column name="summary">ClassCastException occurs if context.xml contains &lt;ResourceLink&gt;.</column><column name="description">Created attachment 26281 patch for NamingContext.java If context.xml contains &lt;ResourceLink&gt;, ClassCastException occurs as follows. java.lang.ClassCastException: org.apache.naming.ResourceLinkRef cannot be cast to org.apache.naming.ResourceRef at org.apache.naming.NamingContext.lookup(NamingContext.java:828) at org.apache.naming.NamingContext.lookup(NamingContext.java:145) at org.apache.naming.NamingContext.lookup(NamingContext.java:814) at org.apache.naming.NamingContext.lookup(NamingContext.java:159) at org.apache.catalina.core.DefaultInstanceManager.lookupFieldResource(DefaultInstanceManager.java:460) at org.apache.catalina.core.DefaultInstanceManager.processAnnotations(DefaultInstanceManager.java:299) at org.apache.catalina.core.DefaultInstanceManager.newInstance(DefaultInstanceManager.java:137) at org.apache.catalina.core.DefaultInstanceManager.newInstance(DefaultInstanceManager.java:119) at org.apache.catalina.core.StandardWrapper.loadServlet(StandardWrapper.java:1046) at org.apache.catalina.core.StandardWrapper.allocate(StandardWrapper.java:797) at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:135) at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:161) at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:164) at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:108) at org.apache.catalina.valves.AccessLogValve.invoke(AccessLogValve.java:558) at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:118) at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:379) at org.apache.coyote.http11.Http11Processor.process(Http11Processor.java:242) at org.apache.coyote.http11.Http11Protocol$Http11ConnectionHandler.process(Http11Protocol.java:259) at org.apache.coyote.http11.Http11Protocol$Http11ConnectionHandler.process(Http11Protocol.java:237) at org.apache.tomcat.util.net.JIoEndpoint$SocketProcessor.run(JIoEndpoint.java:281) at java.util.concurrent.ThreadPoolExecutor$Worker.runTask(ThreadPoolExecutor.java:886) at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:908) at java.lang.Thread.run(Thread.java:619) This issue is relating to the following issue. https://issues.apache.org/bugzilla/show_bug.cgi?id=50159 I attached the patch for this issue. Regards.</column><column name="report_time">2010-11-11 01:08:11</column><column name="report_timestamp">1289460000</column><column name="status">resolved fixed</column><column name="commit">7e7283d</column><column name="commit_timestamp">1289480000</column><column name="files">java/org/apache/naming/NamingContext.java</column><column name="result">161:java/org/apache/naming/NamingContext.java</column></table><table name="tomcat"><column name="id">564</column><column name="bug_id">50183</column><column name="summary">[Tribes] Bio Sender is not scheduling the task to the excecutors</column><column name="description">Created attachment 26228 proposed patch Hi, I'm using apache tribes outside of Tomcat. Although my version is not the latest one, the bug also occurs in Trunk. It seems that there was a refactor (using executors instead of threads and monitors) and BioReceiver is not scheduling the task. (I think that the patch is much more descriptive than any comment I could write) Regards, Ariel</column><column name="report_time">2010-10-29 16:55:40</column><column name="report_timestamp">1288390000</column><column name="status">resolved fixed</column><column name="commit">84efb0a</column><column name="commit_timestamp">1289480000</column><column name="files">java/org/apache/catalina/tribes/transport/bio/BioReceiver.java
java/org/apache/catalina/tribes/transport/bio/BioReplicationTask.java</column><column name="result">6:java/org/apache/catalina/tribes/transport/bio/BioReplicationTask.java
8:java/org/apache/catalina/tribes/transport/bio/BioReceiver.java</column></table><table name="tomcat"><column name="id">565</column><column name="bug_id">50169</column><column name="summary">Trying to register wrapper and welcomeFile to Mapper before context is registered on Mapper.</column><column name="description">Created attachment 26220 patch for StandardContext and StandardWrapper When I used "Host start operation" via JMX, I got error messages. 2010/10/28 11:04:10 org.apache.tomcat.util.http.mapper.Mapper addWrapper SEVERE: No context found: 2010/10/28 11:04:10 org.apache.tomcat.util.http.mapper.Mapper addWrapper SEVERE: No context found: 2010/10/28 11:04:10 org.apache.tomcat.util.http.mapper.Mapper addWrapper SEVERE: No context found: 2010/10/28 11:04:10 org.apache.tomcat.util.http.mapper.Mapper addWrapper SEVERE: No context found: 2010/10/28 11:04:10 org.apache.tomcat.util.http.mapper.Mapper addWrapper SEVERE: No context found: 2010/10/28 11:04:10 org.apache.tomcat.util.http.mapper.Mapper addWrapper SEVERE: No context found: 2010/10/28 11:04:10 org.apache.tomcat.util.http.mapper.Mapper addWelcomeFile SEVERE: No context found: 2010/10/28 11:04:10 org.apache.tomcat.util.http.mapper.Mapper addWelcomeFile SEVERE: No context found: 2010/10/28 11:04:10 org.apache.tomcat.util.http.mapper.Mapper addWelcomeFile SEVERE: No context found: 2010/10/28 11:04:10 org.apache.tomcat.util.http.mapper.Mapper addWelcomeFile SEVERE: No context found: 2010/10/28 11:04:10 org.apache.tomcat.util.http.mapper.Mapper addWelcomeFile SEVERE: No context found: 2010/10/28 11:04:10 org.apache.tomcat.util.http.mapper.Mapper addWelcomeFile SEVERE: No context found: At first StandardHost starts /manager context. (1) LifecycleState is STARTING_PREP now. Wrapper is not registered because host has not been registered. 	Mapper.addWrapper(String, String, String, Object, boolean) line: 331	 	MapperListener.containerEvent(ContainerEvent) line: 169	 	StandardWrapper(ContainerBase).fireContainerEvent(String, Object) line: 1253	 	StandardWrapper.addMapping(String) line: 740	 	StandardContext.addServletMapping(String, String, boolean) line: 2921	 	StandardContext.addServletMapping(String, String) line: 2881	 	WebXml.configureContext(Context) line: 1274	 	ContextConfig.webConfig() line: 1283	 	ContextConfig.configureStart() line: 881	 	ContextConfig.lifecycleEvent(LifecycleEvent) line: 315	 	LifecycleSupport.fireLifecycleEvent(String, Object) line: 119	 	StandardContext(LifecycleBase).fireLifecycleEvent(String, Object) line: 89	 	StandardContext.startInternal() line: 4834	 	StandardContext(LifecycleBase).start() line: 140	 	StandardHost(ContainerBase).startInternal() line: 1027	 	StandardHost.startInternal() line: 788	 	StandardHost(LifecycleBase).start() line: 140	 (2) Set LifecycleState to STARTED. Register context and host on Mapper. 	Mapper.addHost(String, String[], Object) line: 96	 	Mapper.addContext(String, Object, String, Object, String[], Context) line: 226	 	MapperListener.registerContext(Context) line: 339	 	MapperListener.lifecycleEvent(LifecycleEvent) line: 411	 	LifecycleSupport.fireLifecycleEvent(String, Object) line: 119	 	StandardContext(LifecycleBase).fireLifecycleEvent(String, Object) line: 89	 	StandardContext(LifecycleBase).setState(LifecycleState, Object) line: 325	 	StandardContext(LifecycleBase).setState(LifecycleState) line: 305	 	StandardContext(LifecycleBase).start() line: 156	 	StandardHost(ContainerBase).startInternal() line: 1027	 	StandardHost.startInternal() line: 788	 	StandardHost(LifecycleBase).start() line: 140	 (3) Register wrapper again. It succeeds because context has been registered on Mapper. 	Mapper.addWrapper(String, String, String, Object, boolean) line: 328	 	MapperListener.registerWrapper(Wrapper) line: 394	 	MapperListener.registerContext(Context) line: 343	 	MapperListener.lifecycleEvent(LifecycleEvent) line: 411	 	LifecycleSupport.fireLifecycleEvent(String, Object) line: 119	 	StandardContext(LifecycleBase).fireLifecycleEvent(String, Object) line: 89	 	StandardContext(LifecycleBase).setState(LifecycleState, Object) line: 325	 	StandardContext(LifecycleBase).setState(LifecycleState) line: 305	 	StandardContext(LifecycleBase).start() line: 156	 	StandardHost(ContainerBase).startInternal() line: 1027	 	StandardHost.startInternal() line: 788	 	StandardHost(LifecycleBase).start() line: 140	 Next, StandardHost starts ROOT context. (4) Register wrapper. Then, gets error as follows because context has not been registered. 2010/10/28 11:04:10 org.apache.tomcat.util.http.mapper.Mapper addWrapper SEVERE: No context found: 	Mapper.addWrapper(String, String, String, Object, boolean) line: 338	 	MapperListener.containerEvent(ContainerEvent) line: 169	 	StandardWrapper(ContainerBase).fireContainerEvent(String, Object) line: 1253	 	StandardWrapper.addMapping(String) line: 740	 	StandardContext.addServletMapping(String, String, boolean) line: 2921	 	StandardContext.addServletMapping(String, String) line: 2881	 	WebXml.configureContext(Context) line: 1274	 	ContextConfig.webConfig() line: 1283	 	ContextConfig.configureStart() line: 881	 	ContextConfig.lifecycleEvent(LifecycleEvent) line: 315	 	LifecycleSupport.fireLifecycleEvent(String, Object) line: 119	 	StandardContext(LifecycleBase).fireLifecycleEvent(String, Object) line: 89	 	StandardContext.startInternal() line: 4834	 	StandardContext(LifecycleBase).start() line: 140	 	StandardHost(ContainerBase).startInternal() line: 1027	 	StandardHost.startInternal() line: 788	 	StandardHost(LifecycleBase).start() line: 140	 (5) Set LifecycleState to STARTED, and register context. 	Mapper.addContext(String, Object, String, Object, String[], Context) line: 223	 	MapperListener.registerContext(Context) line: 339	 	MapperListener.lifecycleEvent(LifecycleEvent) line: 411	 	LifecycleSupport.fireLifecycleEvent(String, Object) line: 119	 	StandardContext(LifecycleBase).fireLifecycleEvent(String, Object) line: 89	 	StandardContext(LifecycleBase).setState(LifecycleState, Object) line: 325	 	StandardContext(LifecycleBase).setState(LifecycleState) line: 305	 	StandardContext(LifecycleBase).start() line: 156	 	StandardHost(ContainerBase).startInternal() line: 1027	 	StandardHost.startInternal() line: 788	 	StandardHost(LifecycleBase).start() line: 140	 (6) Register wrapper. It succeeds because context has been registered on Mapper. 	Mapper.addWrapper(String, String, String, Object, boolean) line: 328	 	MapperListener.registerWrapper(Wrapper) line: 394	 	MapperListener.registerContext(Context) line: 343	 	MapperListener.lifecycleEvent(LifecycleEvent) line: 411	 	LifecycleSupport.fireLifecycleEvent(String, Object) line: 119	 	StandardContext(LifecycleBase).fireLifecycleEvent(String, Object) line: 89	 	StandardContext(LifecycleBase).setState(LifecycleState, Object) line: 325	 	StandardContext(LifecycleBase).setState(LifecycleState) line: 305	 	StandardContext(LifecycleBase).start() line: 156	 	StandardHost(ContainerBase).startInternal() line: 1027	 	StandardHost.startInternal() line: 788	 	StandardHost(LifecycleBase).start() line: 140	 I think that addWrapper() is unnecessary until LifecycleState for StandardContext become STARTED. addWelcomeFile() is also similar. I attached the patch that prevent this error message. Best regards.</column><column name="report_time">2010-10-28 03:21:29</column><column name="report_timestamp">1288250000</column><column name="status">resolved fixed</column><column name="commit">476921f</column><column name="commit_timestamp">1289480000</column><column name="files">java/org/apache/catalina/core/StandardContext.java
java/org/apache/catalina/core/StandardWrapper.java</column><column name="result">3:java/org/apache/catalina/core/StandardContext.java
7:java/org/apache/catalina/core/StandardWrapper.java</column></table><table name="tomcat"><column name="id">566</column><column name="bug_id">50222</column><column name="summary">JreMemoryLeakPreventionListener should speculatively cause memory leaks using the system ClassLoader</column><column name="description">JreMemoryLeakPreventionListener intentionally invokes methods known to pin the context ClassLoader in memory in order to avoid having a WebappClassLoader unintentionally pin itself. This may cause undesirable behavior in embedded environments. Instead, JMLPL could use a security context to temporarily set the current context ClassLoader to be the system ClassLoader and solve the embedded situation without the client having to remember to take this care.</column><column name="report_time">2010-11-05 11:00:08</column><column name="report_timestamp">1288970000</column><column name="status">resolved fixed</column><column name="commit">4ca3db3</column><column name="commit_timestamp">1289390000</column><column name="files">java/org/apache/catalina/core/JreMemoryLeakPreventionListener.java</column><column name="result">1:java/org/apache/catalina/core/JreMemoryLeakPreventionListener.java</column></table><table name="tomcat"><column name="id">567</column><column name="bug_id">50184</column><column name="summary">RpcChannel sends the answer without requesting an ACK</column><column name="description">Created attachment 26229 proposed patch Hi, I'm using apache tribes outside of Tomcat. Although my version is not the latest one, this also applies to trunk. I have a customer that was using Bio senders (a version before to the excecutors refactor see bug 50183), and there were experiencing some weird behavior. (I couldn't reproduce it, but I guess it is related with the platform since they are using solaris) My application uses tribes to create an RPC channel. They also had some network issues. So, in certain occasions, the application invoked a remote method, the remote node processed the invocation and send the answer back (but it is not received in the first node). So, the timeout occurs and eventually a new RPC invocation occurs. But this time, the second node realized that there is a socket issue when trying to send the answer back (it gets a broken pipe exception). Them the connection is re-established and the message is received without any issues. My customer is complaining about the timeout that occurred the first time. To send the message we do the following: BioSender.pushMessage(.....) { ... soOut.write(data); soOut.flush(); ... } But the flush operation does not warranty that the message was successfully sent to the network. It just warranty that the information was passed to the S.O. http://download.oracle.com/javase/6/docs/api/java/io/OutputStream.html#flush() So, in order to avoid this issue I thought that we can modify the RpcChannel to send the reply message using SEND_OPTIONS_USE_ACK option. Setting this, the remote node will be able to detect situations like the one I commented, and recreate the connection. I'm attaching a patch with my proposal. Thanks for your time. Regards, Ariel</column><column name="report_time">2010-10-29 17:12:34</column><column name="report_timestamp">1288390000</column><column name="status">resolved fixed</column><column name="commit">afdc055</column><column name="commit_timestamp">1289320000</column><column name="files">java/org/apache/catalina/tribes/group/RpcChannel.java</column><column name="result">1:java/org/apache/catalina/tribes/group/RpcChannel.java</column></table><table name="tomcat"><column name="id">568</column><column name="bug_id">50232</column><column name="summary">org.apache.catalina.session.StoreBase has a hidden dependency on PersistentManager</column><column name="description">Created attachment 26270 Removes hidden dependency on PersistentStore StoreBase.java depends explicitly on the Manager interface, however, it later casts the manager object to the PersistentManager class with out any check. This removes that dependency, therefore allowing the usage of this store with any manager that does not extend PersistentManager. I will later attach a path that removes the offending isLoaded() method as that may induce the same problem further along...</column><column name="report_time">2010-11-08 05:09:39</column><column name="report_timestamp">1289210000</column><column name="status">resolved fixed</column><column name="commit">b5c24f9</column><column name="commit_timestamp">1289320000</column><column name="files">java/org/apache/catalina/session/StoreBase.java</column><column name="result">1:java/org/apache/catalina/session/StoreBase.java</column></table><table name="tomcat"><column name="id">569</column><column name="bug_id">50168</column><column name="summary">destory method is called twice while the child is destoryed directly</column><column name="description">While calling the method destory() on the StandardContext directly, it seems that the method destoryInternal() is called twice in the LifecycleMBeanBase, the two stacktraces are below : a. LifecycleMBeanBase.unregister(ObjectName) line: 191 LifecycleMBeanBase.destroyInternal() line: 73 ContainerBase.destroyInternal() line: 1109 StandardContext.destroyInternal() line: 5114 LifecycleBase.destroy() line: 271 ContainerBase.removeChild(Container) line: 963 ContainerBase.destroyInternal() line: 1106 StandardContext.destroyInternal() line: 5114 LifecycleBase.destroy() line: 271 ... b. LifecycleMBeanBase.unregister(ObjectName) line: 191 LifecycleMBeanBase.destroyInternal() line: 73 ContainerBase.destroyInternal() line: 1109 StandardContext.destroyInternal() line: 5114 LifecycleBase.destroy() line: 271 ...</column><column name="report_time">2010-10-27 22:47:42</column><column name="report_timestamp">1288230000</column><column name="status">resolved fixed</column><column name="commit">6eae969</column><column name="commit_timestamp">1288910000</column><column name="files">java/org/apache/catalina/Lifecycle.java
java/org/apache/catalina/LifecycleState.java
java/org/apache/catalina/core/AprLifecycleListener.java
java/org/apache/catalina/core/ContainerBase.java
java/org/apache/catalina/startup/ContextConfig.java
java/org/apache/catalina/util/LifecycleBase.java</column><column name="result">1:java/org/apache/catalina/core/ContainerBase.java
3:java/org/apache/catalina/util/LifecycleBase.java
12:java/org/apache/catalina/startup/ContextConfig.java
61:java/org/apache/catalina/core/AprLifecycleListener.java
100:java/org/apache/catalina/Lifecycle.java</column></table><table name="tomcat"><column name="id">570</column><column name="bug_id">50127</column><column name="summary">Possible NPEs in SimpleTCPCluster</column><column name="description">Created attachment 26190 Patch to eliminate potential NPE The code does this in several places: if (object != null) { ... } object.method() If the object can be null, then the method call should be in the conditional block. If not, eliminate the check.</column><column name="report_time">2010-10-20 19:31:02</column><column name="report_timestamp">1287620000</column><column name="status">resolved fixed</column><column name="commit">f77368f</column><column name="commit_timestamp">1288900000</column><column name="files">java/org/apache/catalina/ha/tcp/SimpleTcpCluster.java</column><column name="result">1:java/org/apache/catalina/ha/tcp/SimpleTcpCluster.java</column></table><table name="tomcat"><column name="id">571</column><column name="bug_id">49180</column><column name="summary">Add option to disable log rotation in FileHandler.</column><column name="description">Small enhancement to FileHandler.java which allow susers to disable log rotation by setting the .rotation attribute to "false".</column><column name="report_time">2010-04-24 13:34:58</column><column name="report_timestamp">1272130000</column><column name="status">resolved fixed</column><column name="commit">7184011</column><column name="commit_timestamp">1288630000</column><column name="files">java/org/apache/juli/FileHandler.java</column><column name="result">1:java/org/apache/juli/FileHandler.java</column></table><table name="tomcat"><column name="id">572</column><column name="bug_id">50157</column><column name="summary">a lot of MapperListener is registered as ContainerListener of StandardContext</column><column name="description">Created attachment 26213 patch for MapperListener.java The same five MapperListener is registered as ContainerListener of StandardContext. At first when I add StandardHost by using "Engine addChild operation" via JMX, same MapperListener is registered as ContainerListener of StandardHost. StandardEngine.addChild() -&gt;StandardEngine.addChildInternal() -&gt;StandardEngine.fireContainerEvent() -&gt;MapperListener.containerEvent() line: 133 &lt;-- here ... -&gt;MapperListener.containerEvent() line: 135 -&gt;MapperListener.registerHost() line: 276 &lt;-- here Therefore, StandardHost has the same two MapperListener as ContainerListener. --- Then, starting StandardHost by using "Host start operation", the same five MapperListener is registered as ContainerListener of StandardContext. (1)LifecycleState of StandardHost is changed to STARTING. StandardHost(LifecycleBase).start() line:140 -&gt;StandardHost(ContainerBase).startInternal() ... -&gt;StandardHost(ContainerBase).fireContainerEvent &lt;-- fireContainerEvent fire two times ... -&gt;MapperListener.containerEvent() line:133 &lt;-- here ... -&gt;MapperListener.containerEvent() line:137 -&gt;MapperListener.registerContext() line:339 &lt;-- here (2)LifecycleState of StandardHost is changed to STARTED. StandardHost(LifecycleBase).start() line:156 ... -&gt;MapperListener.registerHost() line:279 -&gt;MapperListener.registerContext() line:339 &lt;-- here --- I think that the memory is wasted a little because of the above issue. On a related issue, MapperListener is not registered as Container/LifecycleListener for StandardContext on starting up Tomcat. I attached the patch for above issues. Best regards.</column><column name="report_time">2010-10-26 03:28:12</column><column name="report_timestamp">1288080000</column><column name="status">resolved fixed</column><column name="commit">53c5d85</column><column name="commit_timestamp">1288130000</column><column name="files">java/org/apache/catalina/connector/MapperListener.java
java/org/apache/catalina/mbeans/ContainerMBean.java</column><column name="result">2:java/org/apache/catalina/connector/MapperListener.java
50:java/org/apache/catalina/mbeans/ContainerMBean.java</column></table><table name="tomcat"><column name="id">573</column><column name="bug_id">50129</column><column name="summary">ContextConfig - unnecessary null checks</column><column name="description">Created attachment 26192 Patch to remove null checks Sample code: urlPatterns = processAnnotationsStringArray(evp.getValue()); urlPatternsSet = urlPatterns != null &amp;&amp; urlPatterns.length &gt; 0; for (String urlPattern : urlPatterns) { The check "urlPatterns != null" is unnecessary as the method call never returns null. If it could return null, then the for loop would cause an NPE.</column><column name="report_time">2010-10-20 19:48:00</column><column name="report_timestamp">1287620000</column><column name="status">resolved fixed</column><column name="commit">509ab5d</column><column name="commit_timestamp">1287930000</column><column name="files">java/org/apache/catalina/startup/ContextConfig.java</column><column name="result">1:java/org/apache/catalina/startup/ContextConfig.java</column></table><table name="tomcat"><column name="id">574</column><column name="bug_id">50138</column><column name="summary">Lack of synchronization in org.apache.catalina.security.SecurityUtil</column><column name="description">Symptom: all processor threads spin madly in: ============== "tomcat-processor-20" daemon prio=10 tid=0x09210800 nid=0x51fb runnable [0x61b76000] java.lang.Thread.State: RUNNABLE 	at java.util.HashMap.getEntry(HashMap.java:347) 	at java.util.HashMap.containsKey(HashMap.java:335) 	at org.apache.catalina.security.SecurityUtil.doAsPrivilege(SecurityUtil.java:227) 	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:230) 	at org.apache.catalina.core.ApplicationFilterChain.access$000(ApplicationFilterChain.java:56) 	at org.apache.catalina.core.ApplicationFilterChain$1.run(ApplicationFilterChain.java:189) 	at java.security.AccessController.doPrivileged(Native Method) 	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:185) ... ============== Cause: org.apache.catalina.security.SecurityUtil.objectCache is a HashMap, but access to it is not synchronized. The javadoc for HashMap says: ============= Note that this implementation is not synchronized. If multiple threads access a hash map concurrently, and at least one of the threads modifies the map structurally, it must be synchronized externally. ============= Proposed solution: change objectCache to ConcurrentHashMap;</column><column name="report_time">2010-10-21 09:22:56</column><column name="report_timestamp">1287670000</column><column name="status">resolved fixed</column><column name="commit">9d955f4</column><column name="commit_timestamp">1287680000</column><column name="files">java/org/apache/catalina/security/SecurityUtil.java</column><column name="result">2:java/org/apache/catalina/security/SecurityUtil.java</column></table><table name="tomcat"><column name="id">575</column><column name="bug_id">50107</column><column name="summary">StandardPipeline is destroyed two times.</column><column name="description">Created attachment 26181 patch for MBeanFactory.java When I call MBeanFactory#removeHost operation via JMX(jconsle), I get the following message. INFO: The destroy() method was called on component [Pipeline[StandardHost[localhost]]] after destroy() had already been called. The second call will be ignored. StandardPipeline is destroyed two times. At first, pipeline is destroyed at ContainerBase.java L.1096: &lt;&lt;ContainerBase.java destroyInternal() L.1094-1097&gt;&gt; 1094 // Stop the Valves in our pipeline (including the basic), if any 1095 if (pipeline instanceof Lifecycle) { 1096 ((Lifecycle) pipeline).destroy(); 1097 } &lt;&lt;ContainerBase.java destroyInternal() L.1104-1107&gt;&gt; 1104 // Required if the child is destroyed directly. 1105 if (parent != null) { 1106 parent.removeChild(this); 1107 } When above-mentioned "parent" is StandardEngine, the parent.removeChild() calls the LifecycleBase#child.destroy(), and child.destroy() calls ContainerBase#destroyInternal(). At this time ContainerBase is StandardHost. &lt;&lt;ContainerBase.java removeChild() L.960-964&gt;&gt; 960 // Set child's parent to null to prevent a loop 961 child.setParent(null); 962 try { 963 child.destroy(); 964 } catch (LifecycleException e) { As a result, pipeline is destroyed again(, and get the above-mentioned info message). In Tomcat 6.0, child.destroy() is not called from ContainerBase#removeChild(). But, as seen above, the removeChild() that is contained in Tomcat7.0 calls the child.destroy(). IMHO, it might not be better to call the child.destroy() from removeHost(). I made the patch that removed host.destroy() from removeHost(). Best regards.</column><column name="report_time">2010-10-18 03:05:40</column><column name="report_timestamp">1287390000</column><column name="status">resolved fixed</column><column name="commit">44f568f</column><column name="commit_timestamp">1287490000</column><column name="files">java/org/apache/catalina/mbeans/MBeanFactory.java</column><column name="result">41:java/org/apache/catalina/mbeans/MBeanFactory.java</column></table><table name="tomcat"><column name="id">576</column><column name="bug_id">50105</column><column name="summary">Violation of JSP-EL spec version 2.1 when coerce Enum to String</column><column name="description">Section 1.18.2 of the 2.1 JSP-EL spec (Coerce A to String) says "if A is Enum, return A.name()". This is not always the case in Tomcat 6.0.29. To demonstrate the bug, I created some custom code (enum, Tag, JSP): Tag: public class MyCustomTag implements Tag { public void setValue(String value) { System.out.println(value); } @Override public void setPageContext(PageContext pc) {} @Override public void setParent(Tag t) {} @Override public Tag getParent() { return null; } @Override public int doStartTag() throws JspException { return SKIP_BODY; } @Override public int doEndTag() throws JspException { return EVAL_PAGE; } @Override public void release() {} } TLD: &lt;?xml version="1.0" encoding="UTF-8" ?&gt; &lt;taglib xsi:schemaLocation="http://java.sun.com/xml/ns/javaeeweb- jsptaglibrary_2_1.xsd" xmlns="http://java.sun.com/xml/ns/javaee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="2.1"&gt; &lt;tlibversion&gt;1.0&lt;/tlibversion&gt; &lt;uri&gt;http://my-domain.org/customLib&lt;/uri&gt; &lt;tag&gt; &lt;name&gt;customTag&lt;/name&gt; &lt;tagclass&gt;mypackage.MyCustomTag&lt;/tagclass&gt; &lt;bodycontent&gt;empty&lt;/bodycontent&gt; &lt;attribute&gt; &lt;name&gt;value&lt;/name&gt; &lt;required&gt;true&lt;/required&gt; &lt;rtexprvalue&gt;true&lt;/rtexprvalue&gt; &lt;/attribute&gt; &lt;/tag&gt; &lt;/taglib&gt; Enum: public enum MyEnum { APPLE, ORANGE; @Override public String toString() { return "this is a " + name(); } } JSP: &lt;%@taglib prefix="myLib" uri="http://my-domain.org/customLib"%&gt; &lt;myLib:customTag value="${myEnum}"/&gt; &lt;myLib:customTag value="foo.${myEnum}.bar"/&gt; Because the value myEnum is was set to MyEnum.ORANGE, i would expect, that this outputs: ORANGE foo.ORANGE.bar But the output in catalina.out instead is: ORANGE foo.this is a ORANGE.bar Which is a violation of the JSP-EL spec (if I understood it right).</column><column name="report_time">2010-10-17 05:26:20</column><column name="report_timestamp">1287310000</column><column name="status">resolved fixed</column><column name="commit">e6c1d55</column><column name="commit_timestamp">1287490000</column><column name="files">java/org/apache/el/parser/AstCompositeExpression.java
test/org/apache/el/TestValueExpressionImpl.java
test/org/apache/el/TesterEnum.java</column><column name="result">1024:java/org/apache/el/parser/AstCompositeExpression.java
1262:test/org/apache/el/TestValueExpressionImpl.java</column></table><table name="tomcat"><column name="id">577</column><column name="bug_id">49426</column><column name="summary">Manager app wrongly localized</column><column name="description">Created attachment 25582 Patch (with unit test) fixing the problem for the ManagerServlet The manager app shows message using the server's default locale whereas it should react on the request Locale. The cause is that the ManagerServlet uses StringManager what is fine for messages that are logged but not for those that are sent as responses. The attached patch fixes the problem for the ManagerServlet but not for the HTMLManagerServlet. It will require a bit more refactoring there because the same messages may be intended for log or for output to the response. I can propose a second patch for it once the problem has been fixed for the ManagerServlet. For info: same problem occurs in Tomcat 6.</column><column name="report_time">2010-06-11 03:26:07</column><column name="report_timestamp">1276240000</column><column name="status">resolved fixed</column><column name="commit">7357867</column><column name="commit_timestamp">1287260000</column><column name="files">java/org/apache/catalina/manager/HTMLManagerServlet.java
java/org/apache/catalina/manager/ManagerServlet.java
java/org/apache/tomcat/util/res/StringManager.java</column><column name="result">3:java/org/apache/catalina/manager/ManagerServlet.java
10:java/org/apache/tomcat/util/res/StringManager.java
11:java/org/apache/catalina/manager/HTMLManagerServlet.java</column></table><table name="tomcat"><column name="id">578</column><column name="bug_id">50087</column><column name="summary">When metadata-complete="false" throw illegal JVM_CONSTANT_Class name</column><column name="description">When metadata-complete="false" and add groovy-all-1.7.2.jar to app lib throw java.lang.reflect.InvocationTargetException 	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) 	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) 	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25) 	at java.lang.reflect.Method.invoke(Method.java:597) 	at org.apache.catalina.startup.Bootstrap.start(Bootstrap.java:290) 	at org.apache.catalina.startup.Bootstrap.main(Bootstrap.java:418) Caused by: java.lang.ClassFormatError: groovy/jmx/builder/package-info : illegal JVM_CONSTANT_Class name: groovy/jmx/builder/package-info 	at java.lang.ClassLoader.defineClass1(Native Method) 	at java.lang.ClassLoader.defineClassCond(ClassLoader.java:632) 	at java.lang.ClassLoader.defineClass(ClassLoader.java:616) 	at java.security.SecureClassLoader.defineClass(SecureClassLoader.java:141) 	at org.apache.catalina.loader.WebappClassLoader.findClassInternal(WebappClassLoader.java:2804) 	at org.apache.catalina.loader.WebappClassLoader.findClass(WebappClassLoader.java:1144) 	at org.apache.catalina.loader.WebappClassLoader.loadClass(WebappClassLoader.java:1639) 	at org.apache.catalina.loader.WebappClassLoader.loadClass(WebappClassLoader.java:1517) 	at org.apache.catalina.startup.ContextConfig.checkHandlesTypes(ContextConfig.java:1952) 	at org.apache.catalina.startup.ContextConfig.processAnnotationsStream(ContextConfig.java:1915) 	at org.apache.catalina.startup.ContextConfig.processAnnotationsJar(ContextConfig.java:1802) 	at org.apache.catalina.startup.ContextConfig.processAnnotationsUrl(ContextConfig.java:1761) 	at org.apache.catalina.startup.ContextConfig.processAnnotations(ContextConfig.java:1747) 	at org.apache.catalina.startup.ContextConfig.webConfig(ContextConfig.java:1252) 	at org.apache.catalina.startup.ContextConfig.configureStart(ContextConfig.java:881) 	at org.apache.catalina.startup.ContextConfig.lifecycleEvent(ContextConfig.java:315) 	at org.apache.catalina.util.LifecycleSupport.fireLifecycleEvent(LifecycleSupport.java:119) 	at org.apache.catalina.util.LifecycleBase.fireLifecycleEvent(LifecycleBase.java:89) 	at org.apache.catalina.core.StandardContext.startInternal(StandardContext.java:4700) 	at org.apache.catalina.util.LifecycleBase.start(LifecycleBase.java:140) 	at org.apache.catalina.core.ContainerBase.startInternal(ContainerBase.java:1028) 	at org.apache.catalina.core.StandardHost.startInternal(StandardHost.java:773) 	at org.apache.catalina.util.LifecycleBase.start(LifecycleBase.java:140) 	at org.apache.catalina.core.ContainerBase.startInternal(ContainerBase.java:1028) 	at org.apache.catalina.core.StandardEngine.startInternal(StandardEngine.java:278) 	at org.apache.catalina.util.LifecycleBase.start(LifecycleBase.java:140) 	at org.apache.catalina.core.StandardService.startInternal(StandardService.java:429) 	at org.apache.catalina.util.LifecycleBase.start(LifecycleBase.java:140) 	at org.apache.catalina.core.StandardServer.startInternal(StandardServer.java:662) 	at org.apache.catalina.util.LifecycleBase.start(LifecycleBase.java:140) 	at org.apache.catalina.startup.Catalina.start(Catalina.java:592) 	... 6 more</column><column name="report_time">2010-10-13 09:36:12</column><column name="report_timestamp">1286980000</column><column name="status">resolved fixed</column><column name="commit">9e7ce59</column><column name="commit_timestamp">1287070000</column><column name="files">java/org/apache/catalina/startup/ContextConfig.java</column><column name="result">1:java/org/apache/catalina/startup/ContextConfig.java</column></table><table name="tomcat"><column name="id">579</column><column name="bug_id">50066</column><column name="summary">Cannot compile recursive tag with ant if it uses a class from the webapp</column><column name="description">The following simple tag file cannot be compiled with the jspc ant task (or the jpsc maven plugin) : &lt;%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %&gt; &lt;%@ taglib prefix="tags" tagdir="/WEB-INF/tags" %&gt; Hello world ! &lt;c:if test="${false}" &gt; &lt;tags:recursive /&gt; &lt;/c:if&gt; The error is org.apache.jasper.JasperException: /WEB-INF/tags/recursive.tag(21,0) Unable to load tag handler class "org.apache.taglibs.standard.tag.rt.core.IfTag" for tag "c:if" It's OK when the compilation is done "online", when the first jsp that uses this tag is called with a http request. The problem is that japer's TagFileProcessor does not set the correct classloader when compiling recursive tags. It works in online mode because the parent classloader of the jsp classloader is the webapp classloader.</column><column name="report_time">2010-10-09 09:49:32</column><column name="report_timestamp">1286630000</column><column name="status">resolved fixed</column><column name="commit">79cf689</column><column name="commit_timestamp">1286730000</column><column name="files">java/org/apache/jasper/compiler/TagFileProcessor.java</column><column name="result">2:java/org/apache/jasper/compiler/TagFileProcessor.java</column></table><table name="tomcat"><column name="id">580</column><column name="bug_id">50063</column><column name="summary">Latest trunck can't configure context when metadata-complete is true and version is 3.0</column><column name="description">patch: ### Eclipse Workspace Patch 1.0 #P tomcat-7.0.x Index: java/org/apache/catalina/startup/ContextConfig.java =================================================================== --- java/org/apache/catalina/startup/ContextConfig.java	(revision 1006105) +++ java/org/apache/catalina/startup/ContextConfig.java	(working copy) @@ -1281,6 +1281,7 @@ } } } else { + 	webXml.configureContext(context); ok = true; }</column><column name="report_time">2010-10-08 22:59:40</column><column name="report_timestamp">1286590000</column><column name="status">resolved fixed</column><column name="commit">4d7f111</column><column name="commit_timestamp">1286700000</column><column name="files">java/org/apache/catalina/startup/ContextConfig.java</column><column name="result">2:java/org/apache/catalina/startup/ContextConfig.java</column></table><table name="tomcat"><column name="id">581</column><column name="bug_id">50027</column><column name="summary">NullPointerException if context.xml is present with &lt;Resource&gt;</column><column name="description">If you deploy a WAR with contex.xml in META-INF and the context.xml has &lt;Resource&gt; tag, Tomcat dont boot and gives this error: java.lang.NullPointerException 	at org.apache.catalina.core.StandardContext.getObjectKeyPropertiesNameOnly(StandardContext.java:5570) 	at org.apache.catalina.core.StandardContext.setNamingResources(StandardContext.java:1757) 	at org.apache.catalina.core.StandardContext.getNamingResources(StandardContext.java:1735) 	at org.apache.catalina.startup.SetNextNamingRule.end(SetNextNamingRule.java:99) 	at org.apache.tomcat.util.digester.Digester.endElement(Digester.java:1058) 	at com.sun.org.apache.xerces.internal.parsers.AbstractSAXParser.endElement(AbstractSAXParser.java:601) 	at com.sun.org.apache.xerces.internal.parsers.AbstractXMLDocumentParser.emptyElement(AbstractXMLDocumentParser.java:180) 	at com.sun.org.apache.xerces.internal.impl.XMLDocumentFragmentScannerImpl.scanStartElement(XMLDocumentFragmentScannerImpl.java:1343) 	at com.sun.org.apache.xerces.internal.impl.XMLDocumentFragmentScannerImpl$FragmentContentDriver.next(XMLDocumentFragmentScannerImpl.java:2755) 	at com.sun.org.apache.xerces.internal.impl.XMLDocumentScannerImpl.next(XMLDocumentScannerImpl.java:648) 	at com.sun.org.apache.xerces.internal.impl.XMLDocumentFragmentScannerImpl.scanDocument(XMLDocumentFragmentScannerImpl.java:511) 	at com.sun.org.apache.xerces.internal.parsers.XML11Configuration.parse(XML11Configuration.java:808) 	at com.sun.org.apache.xerces.internal.parsers.XML11Configuration.parse(XML11Configuration.java:737) 	at com.sun.org.apache.xerces.internal.parsers.XMLParser.parse(XMLParser.java:119) 	at com.sun.org.apache.xerces.internal.parsers.AbstractSAXParser.parse(AbstractSAXParser.java:1205) 	at com.sun.org.apache.xerces.internal.jaxp.SAXParserImpl$JAXPSAXParser.parse(SAXParserImpl.java:522) 	at org.apache.tomcat.util.digester.Digester.parse(Digester.java:1544) 	at org.apache.catalina.startup.Catalina.load(Catalina.java:524) 	at org.apache.catalina.startup.Catalina.load(Catalina.java:560) 	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) 	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) 	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25) 	at java.lang.reflect.Method.invoke(Method.java:597) 	at org.apache.catalina.startup.Bootstrap.load(Bootstrap.java:260) 	at org.apache.catalina.startup.Bootstrap.main(Bootstrap.java:414) 29/09/2010 13:50:37 org.apache.catalina.startup.Catalina load AVISO: Catalina.start using conf/server.xml: java.lang.NullPointerException 	at org.apache.tomcat.util.digester.Digester.createSAXException(Digester.java:2688) 	at org.apache.tomcat.util.digester.Digester.createSAXException(Digester.java:2714) 	at org.apache.tomcat.util.digester.Digester.endElement(Digester.java:1061) 	at com.sun.org.apache.xerces.internal.parsers.AbstractSAXParser.endElement(AbstractSAXParser.java:601) 	at com.sun.org.apache.xerces.internal.parsers.AbstractXMLDocumentParser.emptyElement(AbstractXMLDocumentParser.java:180) 	at com.sun.org.apache.xerces.internal.impl.XMLDocumentFragmentScannerImpl.scanStartElement(XMLDocumentFragmentScannerImpl.java:1343) 	at com.sun.org.apache.xerces.internal.impl.XMLDocumentFragmentScannerImpl$FragmentContentDriver.next(XMLDocumentFragmentScannerImpl.java:2755) 	at com.sun.org.apache.xerces.internal.impl.XMLDocumentScannerImpl.next(XMLDocumentScannerImpl.java:648) 	at com.sun.org.apache.xerces.internal.impl.XMLDocumentFragmentScannerImpl.scanDocument(XMLDocumentFragmentScannerImpl.java:511) 	at com.sun.org.apache.xerces.internal.parsers.XML11Configuration.parse(XML11Configuration.java:808) 	at com.sun.org.apache.xerces.internal.parsers.XML11Configuration.parse(XML11Configuration.java:737) 	at com.sun.org.apache.xerces.internal.parsers.XMLParser.parse(XMLParser.java:119) 	at com.sun.org.apache.xerces.internal.parsers.AbstractSAXParser.parse(AbstractSAXParser.java:1205) 	at com.sun.org.apache.xerces.internal.jaxp.SAXParserImpl$JAXPSAXParser.parse(SAXParserImpl.java:522) 	at org.apache.tomcat.util.digester.Digester.parse(Digester.java:1544) 	at org.apache.catalina.startup.Catalina.load(Catalina.java:524) 	at org.apache.catalina.startup.Catalina.load(Catalina.java:560) 	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) 	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) 	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25) 	at java.lang.reflect.Method.invoke(Method.java:597) 	at org.apache.catalina.startup.Bootstrap.load(Bootstrap.java:260) 	at org.apache.catalina.startup.Bootstrap.main(Bootstrap.java:414) Caused by: java.lang.NullPointerException 	at org.apache.catalina.core.StandardContext.getObjectKeyPropertiesNameOnly(StandardContext.java:5570) 	at org.apache.catalina.core.StandardContext.setNamingResources(StandardContext.java:1757) 	at org.apache.catalina.core.StandardContext.getNamingResources(StandardContext.java:1735) 	at org.apache.catalina.startup.SetNextNamingRule.end(SetNextNamingRule.java:99) 	at org.apache.tomcat.util.digester.Digester.endElement(Digester.java:1058) 	... 20 more 29/09/2010 13:50:37 org.apache.tomcat.util.digester.SetPropertiesRule begin AVISO: [SetPropertiesRule]{Server/Service/Engine/Host/Context} Setting property 'source' to 'org.eclipse.jst.jee.server:bestforkprime' did not find a matching property. 29/09/2010 13:50:37 org.apache.tomcat.util.digester.Digester endElement GRAVE: End event threw exception java.lang.NullPointerException 	at org.apache.catalina.core.StandardContext.getObjectKeyPropertiesNameOnly(StandardContext.java:5570) 	at org.apache.catalina.core.StandardContext.setNamingResources(StandardContext.java:1757) 	at org.apache.catalina.core.StandardContext.getNamingResources(StandardContext.java:1735) 	at org.apache.catalina.startup.SetNextNamingRule.end(SetNextNamingRule.java:99) 	at org.apache.tomcat.util.digester.Digester.endElement(Digester.java:1058) 	at com.sun.org.apache.xerces.internal.parsers.AbstractSAXParser.endElement(AbstractSAXParser.java:601) 	at com.sun.org.apache.xerces.internal.parsers.AbstractXMLDocumentParser.emptyElement(AbstractXMLDocumentParser.java:180) 	at com.sun.org.apache.xerces.internal.impl.XMLDocumentFragmentScannerImpl.scanStartElement(XMLDocumentFragmentScannerImpl.java:1343) 	at com.sun.org.apache.xerces.internal.impl.XMLDocumentFragmentScannerImpl$FragmentContentDriver.next(XMLDocumentFragmentScannerImpl.java:2755) 	at com.sun.org.apache.xerces.internal.impl.XMLDocumentScannerImpl.next(XMLDocumentScannerImpl.java:648) 	at com.sun.org.apache.xerces.internal.impl.XMLDocumentFragmentScannerImpl.scanDocument(XMLDocumentFragmentScannerImpl.java:511) 	at com.sun.org.apache.xerces.internal.parsers.XML11Configuration.parse(XML11Configuration.java:808) 	at com.sun.org.apache.xerces.internal.parsers.XML11Configuration.parse(XML11Configuration.java:737) 	at com.sun.org.apache.xerces.internal.parsers.XMLParser.parse(XMLParser.java:119) 	at com.sun.org.apache.xerces.internal.parsers.AbstractSAXParser.parse(AbstractSAXParser.java:1205) 	at com.sun.org.apache.xerces.internal.jaxp.SAXParserImpl$JAXPSAXParser.parse(SAXParserImpl.java:522) 	at org.apache.tomcat.util.digester.Digester.parse(Digester.java:1544) 	at org.apache.catalina.startup.Catalina.load(Catalina.java:524) 	at org.apache.catalina.startup.Catalina.start(Catalina.java:573) 	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) 	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) 	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25) 	at java.lang.reflect.Method.invoke(Method.java:597) 	at org.apache.catalina.startup.Bootstrap.start(Bootstrap.java:288) 	at org.apache.catalina.startup.Bootstrap.main(Bootstrap.java:415) 29/09/2010 13:50:37 org.apache.catalina.startup.Catalina load AVISO: Catalina.start using conf/server.xml: java.lang.NullPointerException 	at org.apache.tomcat.util.digester.Digester.createSAXException(Digester.java:2688) 	at org.apache.tomcat.util.digester.Digester.createSAXException(Digester.java:2714) 	at org.apache.tomcat.util.digester.Digester.endElement(Digester.java:1061) 	at com.sun.org.apache.xerces.internal.parsers.AbstractSAXParser.endElement(AbstractSAXParser.java:601) 	at com.sun.org.apache.xerces.internal.parsers.AbstractXMLDocumentParser.emptyElement(AbstractXMLDocumentParser.java:180) 	at com.sun.org.apache.xerces.internal.impl.XMLDocumentFragmentScannerImpl.scanStartElement(XMLDocumentFragmentScannerImpl.java:1343) 	at com.sun.org.apache.xerces.internal.impl.XMLDocumentFragmentScannerImpl$FragmentContentDriver.next(XMLDocumentFragmentScannerImpl.java:2755) 	at com.sun.org.apache.xerces.internal.impl.XMLDocumentScannerImpl.next(XMLDocumentScannerImpl.java:648) 	at com.sun.org.apache.xerces.internal.impl.XMLDocumentFragmentScannerImpl.scanDocument(XMLDocumentFragmentScannerImpl.java:511) 	at com.sun.org.apache.xerces.internal.parsers.XML11Configuration.parse(XML11Configuration.java:808) 	at com.sun.org.apache.xerces.internal.parsers.XML11Configuration.parse(XML11Configuration.java:737) 	at com.sun.org.apache.xerces.internal.parsers.XMLParser.parse(XMLParser.java:119) 	at com.sun.org.apache.xerces.internal.parsers.AbstractSAXParser.parse(AbstractSAXParser.java:1205) 	at com.sun.org.apache.xerces.internal.jaxp.SAXParserImpl$JAXPSAXParser.parse(SAXParserImpl.java:522) 	at org.apache.tomcat.util.digester.Digester.parse(Digester.java:1544) 	at org.apache.catalina.startup.Catalina.load(Catalina.java:524) 	at org.apache.catalina.startup.Catalina.start(Catalina.java:573) 	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) 	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) 	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25) 	at java.lang.reflect.Method.invoke(Method.java:597) 	at org.apache.catalina.startup.Bootstrap.start(Bootstrap.java:288) 	at org.apache.catalina.startup.Bootstrap.main(Bootstrap.java:415) Caused by: java.lang.NullPointerException 	at org.apache.catalina.core.StandardContext.getObjectKeyPropertiesNameOnly(StandardContext.java:5570) 	at org.apache.catalina.core.StandardContext.setNamingResources(StandardContext.java:1757) 	at org.apache.catalina.core.StandardContext.getNamingResources(StandardContext.java:1735) 	at org.apache.catalina.startup.SetNextNamingRule.end(SetNextNamingRule.java:99) 	at org.apache.tomcat.util.digester.Digester.endElement(Digester.java:1058) 	... 20 more 29/09/2010 13:50:37 org.apache.catalina.startup.Catalina start GRAVE: Cannot start server. Server instance is not configured. Here is my contex.xml OBS: some values were replaced with XXXX &lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;Context privileged="true" reloadable="true"&gt; 	&lt;WatchedResource&gt;WEB-INF/web.xml&lt;/WatchedResource&gt; 	&lt;WatchedResource&gt;META-INF/context.xml&lt;/WatchedResource&gt; 	 	&lt;Resource name="jdbc/bestfork" auth="Container" 		type="com.mchange.v2.c3p0.ComboPooledDataSource" factory="org.apache.naming.factory.BeanFactory" 		user="xxx" password="xxxx" driverClass="org.postgresql.Driver" 		jdbcUrl="jdbc:postgresql://localhost:5432/xxxxx" minPoolSize="5" 		maxPoolSize="30" acquireIncrement="5" idleConnectionTestPeriod="100" 		maxIdleTime="30"/&gt; 	&lt;Resource name="mail/Session" auth="Container" type="javax.mail.Session" 		mail.smtp.host="xxxx" mail.smtp.auth="true" 		username="xxx" password="xxx" 		mail.user="xxxx" mail.password="xxxx" 		mail.smtp.port="587" mail.transport.protocol="smtp" mail.debug="true" /&gt; 	&lt;Realm className="org.apache.catalina.realm.JDBCRealm" 		driverName="org.postgresql.Driver" connectionURL="jdbc:postgresql://localhost:5432/xxxx" 		connectionName="xxxx" connectionPassword="xxxx" userTable="usuario" 		userNameCol="usuario_cpf" userCredCol="usuario_senha" userRoleTable="usuario_papel" 		roleNameCol="papel_nome" digest="MD5" /&gt; 				 &lt;/Context&gt;</column><column name="report_time">2010-09-29 13:02:53</column><column name="report_timestamp">1285780000</column><column name="status">resolved fixed</column><column name="commit">6ce21f4</column><column name="commit_timestamp">1286570000</column><column name="files">java/org/apache/catalina/core/StandardContext.java</column><column name="result">1:java/org/apache/catalina/core/StandardContext.java</column></table><table name="tomcat"><column name="id">582</column><column name="bug_id">50059</column><column name="summary">Resources are not served from /WEB-INF/lib/{*.jar}/META-INF/resources if metadata-complete="true" is set in web.xml</column><column name="description">To reproduce: 1. Make a Servlet 3.0 webapp (lets name it foo) with metadata-complete="true" attribute set on the web-app element in the /WEB-IBNF/web.xml. 2. Make a jar holding a single /META-INF/resources/index.html file. The jar should be placed in /WEB-INF/lib (lets name it bar.jar). 3. Start the web app in Tomcat 7.0.2 and in browser go to http://localhost:8080/foo/index.html. Expected result: 200 response and index.html served. Actual result: 404 If you modify the web.xml to metadata-complete="false" and restart the app now /foo/index.html will respond as expected. I tried the same webapp with Glassfish v3.0.1 and it works as expected regardless what I set in metadata-complete attribute. I made a quick look in the servlet 3.0 spec and as far as I can see metadata-complete only regulates annotation and web fragment processing. In the example bar.jar has nothing to do with annotations and it is not a web fragment either but it is still handled differently depending on the metadata-complete attribute.</column><column name="report_time">2010-10-08 07:57:25</column><column name="report_timestamp">1286540000</column><column name="status">resolved fixed</column><column name="commit">da36bd1</column><column name="commit_timestamp">1286570000</column><column name="files">java/org/apache/catalina/startup/ContextConfig.java</column><column name="result">2:java/org/apache/catalina/startup/ContextConfig.java</column></table><table name="tomcat"><column name="id">583</column><column name="bug_id">50017</column><column name="summary">Make private immutable fields final</column><column name="description">Created attachment 26090 Patch javax.el package Patches to make immutable private fields final.</column><column name="report_time">2010-09-27 20:27:07</column><column name="report_timestamp">1285630000</column><column name="status">resolved fixed</column><column name="commit">c4a3427</column><column name="commit_timestamp">1286550000</column><column name="files">java/javax/el/ValueReference.java
java/javax/servlet/AsyncEvent.java
java/javax/servlet/HttpConstraintElement.java
java/javax/servlet/HttpMethodConstraintElement.java
java/javax/servlet/MultipartConfigElement.java
java/javax/servlet/ServletContextAttributeEvent.java
java/javax/servlet/ServletRequestAttributeEvent.java
java/javax/servlet/ServletRequestEvent.java
java/javax/servlet/ServletSecurityElement.java
java/javax/servlet/UnavailableException.java
java/javax/servlet/http/HttpSessionBindingEvent.java
java/javax/servlet/jsp/ErrorData.java
java/javax/servlet/jsp/tagext/BodyContent.java
java/javax/servlet/jsp/tagext/FunctionInfo.java
java/javax/servlet/jsp/tagext/TagAttributeInfo.java
java/javax/servlet/jsp/tagext/TagData.java
java/javax/servlet/jsp/tagext/TagExtraInfo.java
java/javax/servlet/jsp/tagext/TagFileInfo.java
java/javax/servlet/jsp/tagext/TagVariableInfo.java
java/javax/servlet/jsp/tagext/ValidationMessage.java
java/javax/servlet/jsp/tagext/VariableInfo.java</column><column name="result">18:java/javax/servlet/jsp/tagext/TagVariableInfo.java
197:java/javax/servlet/UnavailableException.java
276:java/javax/servlet/jsp/tagext/FunctionInfo.java
302:java/javax/servlet/jsp/tagext/TagFileInfo.java
407:java/javax/servlet/jsp/tagext/TagAttributeInfo.java
410:java/javax/servlet/jsp/tagext/BodyContent.java
496:java/javax/servlet/HttpConstraintElement.java
635:java/javax/servlet/jsp/tagext/VariableInfo.java
681:java/javax/el/ValueReference.java
832:java/javax/servlet/jsp/ErrorData.java
866:java/javax/servlet/HttpMethodConstraintElement.java
867:java/javax/servlet/ServletContextAttributeEvent.java
915:java/javax/servlet/jsp/tagext/TagExtraInfo.java
938:java/javax/servlet/jsp/tagext/TagData.java
943:java/javax/servlet/ServletRequestAttributeEvent.java
946:java/javax/servlet/AsyncEvent.java
977:java/javax/servlet/ServletRequestEvent.java
1005:java/javax/servlet/jsp/tagext/ValidationMessage.java
1011:java/javax/servlet/ServletSecurityElement.java
1018:java/javax/servlet/MultipartConfigElement.java
1021:java/javax/servlet/http/HttpSessionBindingEvent.java</column></table><table name="tomcat"><column name="id">584</column><column name="bug_id">50016</column><column name="summary">bad division of responsibility around isUserInRole and new Request login and logout methods</column><column name="description">Created attachment 26089 improve division of responsibility for isUserInRole and login/logout methods There are 2 similar problems that have a bad division of responsibility. 1. Request.isUserInRole tries to prevent jacc implementations and is also wrong. In the current tomcat implementation, role-ref mappings are first applied to the supplied role and then the target role is tested. If the user is not in the mapped role the original role is tested. However, (a). jacc requires that this be implemented by constructing a role-ref permission with the current servlet name and the supplied (not mapped) role. So to be reasonably amenable to a jacc implementation Request.isUserInRole should supply the original role and if possible the servlet name to the wrapper. (b) if there is a mapping, only the mapped role should be checked. Aside from the spec language, consider a web app with two roles A and B and a servlet S that maps A to B and B to A. A user that logs in and is in role A and not B should be able to test in S is in A &gt;&gt; false is in B &gt;&gt; true The current implementation reports true for both A and B. 2. The implementation of the new login and logout methods are excessively intrusive into the internals of the authentication. Both should be delegated directly to the Authenticator. In particular, checking which known Authenticator is installed to see if it supports user/pw login is overly restrictive since other authenticators might be installed. The authenticator also ought to be able to decide if it wants to cache the authentication results.</column><column name="report_time">2010-09-27 16:56:39</column><column name="report_timestamp">1285620000</column><column name="status">resolved fixed</column><column name="commit">469a916</column><column name="commit_timestamp">1286550000</column><column name="files">java/org/apache/catalina/Authenticator.java
java/org/apache/catalina/Realm.java
java/org/apache/catalina/authenticator/AuthenticatorBase.java
java/org/apache/catalina/authenticator/BasicAuthenticator.java
java/org/apache/catalina/authenticator/DigestAuthenticator.java
java/org/apache/catalina/authenticator/FormAuthenticator.java
java/org/apache/catalina/authenticator/NonLoginAuthenticator.java
java/org/apache/catalina/authenticator/SSLAuthenticator.java
java/org/apache/catalina/connector/Request.java
java/org/apache/catalina/realm/RealmBase.java
java/org/apache/catalina/realm/UserDatabaseRealm.java</column><column name="result">4:java/org/apache/catalina/connector/Request.java
10:java/org/apache/catalina/authenticator/AuthenticatorBase.java
11:java/org/apache/catalina/authenticator/FormAuthenticator.java
38:java/org/apache/catalina/Authenticator.java
47:java/org/apache/catalina/realm/RealmBase.java
60:java/org/apache/catalina/Realm.java
62:java/org/apache/catalina/authenticator/SSLAuthenticator.java
71:java/org/apache/catalina/authenticator/DigestAuthenticator.java
81:java/org/apache/catalina/realm/UserDatabaseRealm.java
110:java/org/apache/catalina/authenticator/NonLoginAuthenticator.java
219:java/org/apache/catalina/authenticator/BasicAuthenticator.java</column></table><table name="tomcat"><column name="id">585</column><column name="bug_id">49987</column><column name="summary">Data race in ApplicationContext</column><column name="description">r998053 http://svn.apache.org/repos/asf/tomcat/tc6.0.x/trunk/java/org/apache/catalina/core/ApplicationContext.java Data race on variable private Map parameters In method private void mergeParameters() { if (parameters != null) // concurrent read : 881 return; Map results = new ConcurrentHashMap(); ... parameters = results; // concurrent write : 897 }</column><column name="report_time">2010-09-23 10:16:06</column><column name="report_timestamp">1285250000</column><column name="status">resolved fixed</column><column name="commit">2db864e</column><column name="commit_timestamp">1286490000</column><column name="files">java/org/apache/catalina/core/ApplicationContext.java
java/org/apache/catalina/core/StandardContext.java</column><column name="result">1:java/org/apache/catalina/core/ApplicationContext.java
2:java/org/apache/catalina/core/StandardContext.java</column></table><table name="tomcat"><column name="id">586</column><column name="bug_id">49986</column><column name="summary">Double-check locking. Possible data-race in JspServletWrapper</column><column name="description">r998053 http://svn.apache.org/repos/asf/tomcat/tc6.0.x/trunk/java/org/apache/jasper/servlet/JspServletWrapper.java Common anti-pattern: Double checked locking. I don't know is this race dangerous or no. Race on private boolean reload public Servlet getServlet() throws ServletException, IOException, FileNotFoundException { if (reload) { synchronized (this) { // Synchronizing on jsw enables simultaneous loading // of different pages, but not the same page. if (reload) { // This is to maintain the original protocol. .......... theServlet = servlet; reload = false; } } } return theServlet; }</column><column name="report_time">2010-09-23 09:31:03</column><column name="report_timestamp">1285250000</column><column name="status">resolved fixed</column><column name="commit">2570d6ff</column><column name="commit_timestamp">1286460000</column><column name="files">java/org/apache/jasper/servlet/JspServletWrapper.java</column><column name="result">1:java/org/apache/jasper/servlet/JspServletWrapper.java</column></table><table name="tomcat"><column name="id">587</column><column name="bug_id">49972</column><column name="summary">Double-check idiom. Possible data-race.</column><column name="description">r998053 class org/apache/tomcat/util/http/FastHttpDateFormat http://svn.apache.org/repos/asf/tomcat/tc6.0.x/trunk/java/org/apache/tomcat/util/http/FastHttpDateFormat.java There is double-check anti-pattern in public static final String getCurrentDate() method on protected static long currentDateGenerated variable Concurrent read on line 112 Concurrent write on line 115 P.S.: Maybe I have mistake with determine component</column><column name="report_time">2010-09-22 04:44:02</column><column name="report_timestamp">1285150000</column><column name="status">resolved fixed</column><column name="commit">0ae33cb</column><column name="commit_timestamp">1286460000</column><column name="files">java/org/apache/tomcat/util/http/FastHttpDateFormat.java</column><column name="result" /></table><table name="tomcat"><column name="id">588</column><column name="bug_id">50054</column><column name="summary">When the AJP connector is used, minSpareThreads cannot be used.</column><column name="description">I found following warnning messages. == Oct 7, 2010 2:25:27 PM org.apache.catalina.startup.SetAllPropertiesRule begin WARNING: [SetAllPropertiesRule]{Server/Service/Connector} Setting property 'minSpareThreads' to '31' did not find a matching property. == The AJP connector's configs are the following. &lt;Connector port="8009" protocol="AJP/1.3" redirectPort="8443" minSpareThreads="100"/&gt; When I used the Http connector, minSpareThreads was able to be used. org.apache.coyote.ajp.AjpProtocol doesn't set the minSpareThreads to org.apache.tomcat.util.net.JIoEndpoint. I made a patch. This patch was made based on AbstractHttp11Protocol. Best regards.</column><column name="report_time">2010-10-07 04:22:51</column><column name="report_timestamp">1286440000</column><column name="status">resolved fixed</column><column name="commit">654c964</column><column name="commit_timestamp">1286440000</column><column name="files">java/org/apache/coyote/ajp/AbstractAjpProtocol.java
java/org/apache/coyote/ajp/AjpAprProtocol.java
java/org/apache/coyote/ajp/AjpProtocol.java</column><column name="result">3:java/org/apache/coyote/ajp/AjpProtocol.java
6:java/org/apache/coyote/ajp/AjpAprProtocol.java</column></table><table name="tomcat"><column name="id">589</column><column name="bug_id">49956</column><column name="summary">@Resource(name=) Normalization of JNDI Name</column><column name="description">Created attachment 26048 Resolves issue name attribute of @Resource defines JNDI name of the resource that binds the resource to web component java:comp/env/. java:comp/env/bla..bla.. could be given as a JNDI name. Therefore before using name in DefaultInstanceManager to inject fields &amp; methods, it must be normalized. For example, @Resource(name="java:comp/env/myDataSource") DataSource ds; Before looking up "context.lookup(name)" in DefaultInstanceManager, we have to normalize name to "myDataSource". Patch is attached</column><column name="report_time">2010-09-17 20:15:03</column><column name="report_timestamp">1284770000</column><column name="status">resolved fixed</column><column name="commit">0e71157</column><column name="commit_timestamp">1286400000</column><column name="files">java/org/apache/catalina/core/DefaultInstanceManager.java</column><column name="result">3:java/org/apache/catalina/core/DefaultInstanceManager.java</column></table><table name="tomcat"><column name="id">590</column><column name="bug_id">49952</column><column name="summary">ServletContainerInitializer can't actually add listeners</column><column name="description">Created attachment 26044 Keep the listeners added by ServletContainerInitializer Any listeners added by a ServletContainerInitializer will be wiped out when the listeners from web.xml are sorted and overwrite the arrays that already have the SCI-added listeners in them. I've taken the approach of keeping the single list of listeners from web.xml and keeping the sort into types in listenerStart. I think it might also be possible and more elegant to have the addApplicationListener method be the same code as the ServletContext.addListener(String listenerClassName) method. Patch includes a test demonstrating the problem. The patch to ServletContext may need line number adjustment unless you have applied my patch for supplying the jsp file as a jsp servlet init param.</column><column name="report_time">2010-09-17 13:49:20</column><column name="report_timestamp">1284750000</column><column name="status">resolved fixed</column><column name="commit">937227a</column><column name="commit_timestamp">1286400000</column><column name="files">java/org/apache/catalina/core/StandardContext.java
test/org/apache/catalina/startup/TestListener.java</column><column name="result">1:java/org/apache/catalina/core/StandardContext.java</column></table><table name="tomcat"><column name="id">591</column><column name="bug_id">49937</column><column name="summary">Problems with AsyncListener and resource injection</column><column name="description">Created attachment 26031 propose fix for a couple possible async listener problems I asked about these on the dev list and am proposing some simple fixes in case there's agreement that they are bugs. 1. AsyncListeners are subject to resource injection from annotations, so they should be created using the instance manager. To get the instance manager to the AyncContextImpl I added a getInstanceManager() method to the Context interface. Maybe there's a better way, this interface is currently not very small or simple. 2. various application code can use one of the ServletContext.addListener methods to tell the container to scan for annotations. Just because tomcat doesn't yet actually scan doesn't mean it should throw an exception if you try this. cf servlet 3.0 spec section 15.5 page 179.</column><column name="report_time">2010-09-16 01:49:41</column><column name="report_timestamp">1284620000</column><column name="status">resolved fixed</column><column name="commit">cf4e575</column><column name="commit_timestamp">1286140000</column><column name="files">java/org/apache/catalina/core/AsyncContextImpl.java</column><column name="result">4:java/org/apache/catalina/core/AsyncContextImpl.java</column></table><table name="tomcat"><column name="id">592</column><column name="bug_id">49985</column><column name="summary">Lazy initialization without any synchronization - data race in AstInteger, AstFloatingPoint, AstString</column><column name="description">r998053 http://svn.apache.org/repos/asf/tomcat/tc6.0.x/trunk/java/org/apache/el/parser/AstInteger.java http://svn.apache.org/repos/asf/tomcat/tc6.0.x/trunk/java/org/apache/el/parser/AstFloatingPoint.java http://svn.apache.org/repos/asf/tomcat/tc6.0.x/trunk/java/org/apache/el/parser/AstString.java Use lazy init without any synchronization in methods getInteger(), getFloatingPoint(), getString(), respectively. Consider AstInteger: private Number number; protected Number getInteger() { if (this.number == null) { try { this.number = new Long(this.image); } catch (ArithmeticException e1) { this.number = new BigInteger(this.image); } } return number; } Data races on variable number :37 in method getInteger() :39 concurrent read on line 40 concurrent write on lines 42, 44</column><column name="report_time">2010-09-23 08:55:42</column><column name="report_timestamp">1285250000</column><column name="status">resolved fixed</column><column name="commit">b893eee</column><column name="commit_timestamp">1286050000</column><column name="files">java/org/apache/el/parser/AstFloatingPoint.java
java/org/apache/el/parser/AstInteger.java
java/org/apache/el/parser/AstString.java</column><column name="result">1:java/org/apache/el/parser/AstFloatingPoint.java
2:java/org/apache/el/parser/AstInteger.java
3:java/org/apache/el/parser/AstString.java</column></table><table name="tomcat"><column name="id">593</column><column name="bug_id">49915</column><column name="summary">[Patch] o.a.c.c.StandardServer swallows error on storeConfig.</column><column name="description">When o.a.c.c.StandardServer#storeConfig is called all exceptions were getting swallowed. This lead to the impresssion it was working correctly when saved either through the manager application /manager/save or through jconsole. I've removed the catch throwable block and thrown an exception upon not finding the registerd MBean.</column><column name="report_time">2010-09-10 19:35:43</column><column name="report_timestamp">1284160000</column><column name="status">resolved fixed</column><column name="commit">5eb3851</column><column name="commit_timestamp">1285950000</column><column name="files">java/org/apache/catalina/core/StandardServer.java</column><column name="result">1:java/org/apache/catalina/core/StandardServer.java</column></table><table name="tomcat"><column name="id">594</column><column name="bug_id">49905</column><column name="summary">In cluster, when using DeltaManager memory leak can occur</column><column name="description">Created attachment 26008 Patch to remove context classloader from threads in ThreadPoolExecutor in tribes Tested on apache-tomcat-6.0.29 running under jdk 1.6.0_18. When DeltaManager is instantiated and assigned in StandardContext.start(), is it done AFTER StandardContext.bindThreads(). DeltaManager, in turn, during initalization, asks for sessions in other nodes, and this may result in creating threads in ThreadPoolExecutor in tribes. These threads created with contextClassLoader set to current webapplication WebAppClassLoader. This results in memory leak and error message during redeployment in tomcat log: 09/09/2010 14:46:19 S - - WebappClassLoader.clearReferencesThreads: The web application [/creditdev] appears to have started a thread named [pool-1-thread-1] but has failed to stop it. This is very likely to create a memory leak. Stacktrace: at java.util.concurrent.ThreadPoolExecutor.addThread(Unknown Source) at java.util.concurrent.ThreadPoolExecutor.addIfUnderCorePoolSize(Unknown Source) at java.util.concurrent.ThreadPoolExecutor.execute(Unknown Source) at org.apache.catalina.tribes.group.interceptors.MessageDispatch15Interceptor.addToQueue(MessageDispatch15Interceptor.java:67) at org.apache.catalina.tribes.group.interceptors.MessageDispatchInterceptor.sendMessage(MessageDispatchInterceptor.java:68) at org.apache.catalina.tribes.group.ChannelInterceptorBase.sendMessage(ChannelInterceptorBase.java:75) at org.apache.catalina.tribes.group.interceptors.TcpFailureDetector.sendMessage(TcpFailureDetector.java:87) at org.apache.catalina.tribes.group.ChannelInterceptorBase.sendMessage(ChannelInterceptorBase.java:75) at org.apache.catalina.tribes.group.GroupChannel.send(GroupChannel.java:216) at org.apache.catalina.tribes.group.GroupChannel.send(GroupChannel.java:175) at org.apache.catalina.ha.tcp.SimpleTcpCluster.send(SimpleTcpCluster.java:813) at org.apache.catalina.ha.session.DeltaManager.getAllClusterSessions(DeltaManager.java:959) at org.apache.catalina.ha.session.DeltaManager.start(DeltaManager.java:930) at org.apache.catalina.core.ContainerBase.setManager(ContainerBase.java:438) at org.apache.catalina.core.StandardContext.start(StandardContext.java:4559) at org.apache.catalina.core.ContainerBase.addChildInternal(ContainerBase.java:791) at org.apache.catalina.core.ContainerBase.addChild(ContainerBase.java:771) at org.apache.catalina.core.StandardHost.addChild(StandardHost.java:546) at org.apache.catalina.startup.HostConfig.deployDescriptor(HostConfig.java:637) at org.apache.catalina.startup.HostConfig.deployDescriptors(HostConfig.java:563) at org.apache.catalina.startup.HostConfig.deployApps(HostConfig.java:498) at org.apache.catalina.startup.HostConfig.start(HostConfig.java:1277) at org.apache.catalina.startup.HostConfig.lifecycleEvent(HostConfig.java:321) at org.apache.catalina.util.LifecycleSupport.fireLifecycleEvent(LifecycleSupport.java:119) at org.apache.catalina.core.ContainerBase.start(ContainerBase.java:1053) at org.apache.catalina.core.StandardHost.start(StandardHost.java:785) at org.apache.catalina.core.ContainerBase.start(ContainerBase.java:1045) at org.apache.catalina.core.StandardEngine.start(StandardEngine.java:445) at org.apache.catalina.core.StandardService.start(StandardService.java:519) at org.apache.catalina.core.StandardServer.start(StandardServer.java:710) at org.apache.catalina.startup.Catalina.start(Catalina.java:581) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source) at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source) at java.lang.reflect.Method.invoke(Unknown Source) at org.apache.catalina.startup.Bootstrap.start(Bootstrap.java:289) at org.apache.catalina.startup.Bootstrap.main(Bootstrap.java:414) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source) at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source) at java.lang.reflect.Method.invoke(Unknown Source) at org.tanukisoftware.wrapper.WrapperStartStopApp.run(WrapperStartStopApp.java:243) at java.lang.Thread.run(Unknown Source) Proposed solution - implement java.util.concurrent.ThreadFactory in MessageDispatch15Interceptor and pass instance on ThreadPoolExecutor executor creation. This instance must call setContextClassLoader(null) in newThread() overriden method.</column><column name="report_time">2010-09-09 07:22:00</column><column name="report_timestamp">1284030000</column><column name="status">resolved fixed</column><column name="commit">2c858be</column><column name="commit_timestamp">1285950000</column><column name="files">java/org/apache/catalina/tribes/group/interceptors/MessageDispatch15Interceptor.java
java/org/apache/catalina/tribes/util/TcclThreadFactory.java</column><column name="result">661:java/org/apache/catalina/tribes/group/interceptors/MessageDispatch15Interceptor.java</column></table><table name="tomcat"><column name="id">595</column><column name="bug_id">49890</column><column name="summary">Nio Selector issue on linux platform</column><column name="description">Created attachment 25997 NioEndpoint.java and simple web application sometimes ,server's cpu reaches 100%,and keep 100% all the time,until restart the server. Reproduced with java versions: 1.6.0_07, 1.6.0_18, 1.6.0_21. It is duplicate of issue: Bug 46373. It seams that Jetty guys fixed that problem: http://jira.codehaus.org/browse/JETTY-937?focusedCommentId=168060&amp;page=com.atlassian.jira.plugin.system.issuetabpanels:comment-tabpanel. I added some logging to NioEndpoint.java. With this logging we can see that selector.select(timeout) sometimes return zero keys on linux plutform. And it is never reproduced on windows platform. In the attach: NioEndpoint.7z - patched NioEndpoint.java (with logging) web.7z - simple web application. To reproduce jvm bug we should do several requests(we can just press F5 in browser and hold button) to web application.</column><column name="report_time">2010-09-07 09:17:54</column><column name="report_timestamp">1283870000</column><column name="status">resolved wontfix</column><column name="commit">f4de5ab</column><column name="commit_timestamp">1285940000</column><column name="files">java/org/apache/tomcat/util/net/NioEndpoint.java</column><column name="result">1:java/org/apache/tomcat/util/net/NioEndpoint.java</column></table><table name="tomcat"><column name="id">596</column><column name="bug_id">49861</column><column name="summary">Log format of RMI ports can be improved, remove ","</column><column name="description">I've enabled the fixed JMX port listen capability described in http://tomcat.apache.org/tomcat-6.0-doc/config/listeners.html and found, that fixed ports are logged, but format is not proper imho: Is: INFO: The JMX Remote Listener has configured the registry on port 10,001 and the server on port 10,002 for the Platform server Should: INFO: The JMX Remote Listener has configured the registry on port 10001 and the server on port 10002 for the Platform server Just note that is very uncommon logging TCP/UDP ports with a ","</column><column name="report_time">2010-09-02 04:42:55</column><column name="report_timestamp">1283420000</column><column name="status">resolved fixed</column><column name="commit">00cc8c6</column><column name="commit_timestamp">1285930000</column><column name="files">java/org/apache/catalina/mbeans/JmxRemoteLifecycleListener.java</column><column name="result">1:java/org/apache/catalina/mbeans/JmxRemoteLifecycleListener.java</column></table><table name="tomcat"><column name="id">597</column><column name="bug_id">49667</column><column name="summary">JdbcLeakPrevention class can register unregistered JCBC Driver</column><column name="description">Overview Suppose there is an web application A that uses a database and registers a Driver with the java.sql.DriverManager, and a web application B that doesn't use a database but has a jar file in its WEB-INF/lib directory that contains the same Driver. Suppose you undeploy web application B. Running the org.apache.catalina.loader.JdbcLeakPrevention class will actually register the Driver and leave it loaded! The cause is the way the DriverManager checks whether a ClassLoader has permission to load the Driver. It does that by calling Class.forName with the ClassLoader, which will load the class if the class has not been loaded by that ClassLoader. Loading a Driver class triggers the Driver to register itself. Steps to reproduce Create two web applications: one which registeres a Driver with the java.sql.Drivermanager and one that uses no database. Put the jar containing the Driver class in the WEB-INF/lib directory of both applications. Deploy both in Tomcat. Then undeploy the latter one. Inspect catalina.out, verify that there are no messages about a JDBC Driver being forcibly unregistered. Create a memory dump using jmap and inspect the dump using jhat. Actual results The WebappClassLoader for the latter application is still present. Its "rootset references" page shows two reference chains from class java.sql.DriverManager: Static reference from java.sql.DriverManager.readDrivers (from class java.sql.DriverManager) : --&gt; java.util.Vector@0xeb6eb3f0 (24 bytes) (field elementData:) --&gt; [Ljava.lang.Object;@0xeb6eb408 (20 bytes) (Element 2 of [Ljava.lang.Object;@0xeb6eb408:) --&gt; java.sql.DriverInfo@0xeb6eb420 (20 bytes) (field driverClass:) --&gt; class oracle.jdbc.driver.OracleDriver (84 bytes) (??:) --&gt; org.apache.catalina.loader.WebappClassLoader@0xeb5a84a0 (157 bytes) and a similar one from java.sql.DriverManager.writeDrivers. Expected results The WebappClassLoader is not present in memory anymore. Build date &amp; platform Downloaded Core tar.gz from http://tomcat.apache.org/download-70.cgi</column><column name="report_time">2010-07-29 09:31:33</column><column name="report_timestamp">1280410000</column><column name="status">resolved fixed</column><column name="commit">dc754cc</column><column name="commit_timestamp">1285930000</column><column name="files">java/org/apache/catalina/loader/JdbcLeakPrevention.java</column><column name="result">1:java/org/apache/catalina/loader/JdbcLeakPrevention.java</column></table><table name="tomcat"><column name="id">598</column><column name="bug_id">49856</column><column name="summary">Connector/ThreadPool link to Executor not exposed via JMX</column><column name="description">When viewing either Connector objects or ThreadPool objects via JMX the name of the executor is not shown. It would be helpful if this were exposed via JMX so the links between Connectors/ThreadPools and Executors could be determined.</column><column name="report_time">2010-09-01 03:24:08</column><column name="report_timestamp">1283330000</column><column name="status">resolved fixed</column><column name="commit">167829c</column><column name="commit_timestamp">1285880000</column><column name="files">java/org/apache/catalina/connector/Connector.java</column><column name="result">1:java/org/apache/catalina/connector/Connector.java</column></table><table name="tomcat"><column name="id">599</column><column name="bug_id">49730</column><column name="summary">Race condition in StandardThreadExecutor : requests are sometimes enqueued instead of creating new threads</column><column name="description">In tomcat 6, I often configure an Executor with minSpareThreads=0 to work around memory leak issues upon redeployment. Sometimes (especially in development), when I refresh a page of my webapp with Safari, Chrome or Firefox, some resources of the page take several seconds (&gt;10s) to be served though they are static resources and should come in less than 50ms. For instance, over 15 requests for a page (1 for html, the others for resources like js, css, images...), I sometimes have 1 or 2 that take &gt;10s. After analysis, I found that in org.apache.catalina.core.StandardThreadExecutor.TaskQueue.offer(Runnable) the statement if (parent.getActiveCount()&lt;(parent.getPoolSize())) is sometimes true unexpectedly. Here is the scenario : - ThreadPoolExecutor is empty - the user refreshes the page (or accesses it with an empty cache) in his web browser for a page that uses a more than 10-15 resources - the browser establishes one TCP connection and a new Thread is created - after the browser receives the response, it decides to load as many resources as possible in parallel. For this it establishes up to 6 TCP connections (in my tests) - The Acceptor thread calls StandardThreadExecutor.execute to process each incoming connection. - For each call, StandardThreadExecutor.TaskQueue.offer(Runnable) is being called - if you study the sources of Java 6 ThreadPoolExecutor, you can see that there's a small delay between the time a new Thread is created (thus increasing poolSize) and the time it starts working on its first task (increasing the activeCount) - Since in my case connections are established in a rapid burst, the calls to TaskQueue.offer() are sometimes faster than this small delay, so that we do have parent.getActiveCount()&lt;parent.getPoolSize() and thus the task is enqueued instead of forcing the creation of a thread to serve it. - Since Keep-Alive is enabled and tomcat 6 threads take care of only one TCP connection at a time, the requests in the queue must wait for the keep-alive timeout so that a Thread is returned to the pool to serve pending tasks. - With 25s keepAliveTimeOut, it means that some requests take more than 25s to be served eventhough the pool was never full and the server quite idle!!! Other facts about this issue : - Although my test case starts with an empty pool, it can occur even on a loaded server. The thing that triggers the issue is the burst of new TCP connections. - The problem is less severe with a lower keepAliveTimeout, or if keepalive is disabled. In any case, it also depends on the time taken to serve current requests. - The issue also affects tomcat 7 but is less severe because tc7 threads are returned to the pool after each http request, even if the TCP connection is kept alive. The impact would the same as with tc6 with keepAlive disabled.</column><column name="report_time">2010-08-09 16:16:04</column><column name="report_timestamp">1281380000</column><column name="status">resolved fixed</column><column name="commit">2bfc300</column><column name="commit_timestamp">1285870000</column><column name="files">java/org/apache/tomcat/util/threads/TaskQueue.java
java/org/apache/tomcat/util/threads/ThreadPoolExecutor.java</column><column name="result">2:java/org/apache/tomcat/util/threads/TaskQueue.java
14:java/org/apache/tomcat/util/threads/ThreadPoolExecutor.java</column></table><table name="tomcat"><column name="id">600</column><column name="bug_id">50021</column><column name="summary">ExceptionUtils class missing from bootstrap.jar</column><column name="description">o.a.c.startup.Bootstrap uses o.a.jasper.util.ExceptionUtils, but this class is not placed in bootstrap.jar, causing rather nasty failures if anything goes wrong during initial bootstrapping. This should be a fairly simple matter of updating build.xml to include it, but I wasn't sure whether including Jasper classes in the bootstrap was the done thing. There's an o.a.tomcat.util.ExceptionUtils that is identical, but that too looks like the wrong thing to grab.</column><column name="report_time">2010-09-29 03:43:11</column><column name="report_timestamp">1285750000</column><column name="status">resolved fixed</column><column name="commit">6c22816</column><column name="commit_timestamp">1285760000</column><column name="files">java/org/apache/catalina/startup/Bootstrap.java</column><column name="result">1:java/org/apache/catalina/startup/Bootstrap.java</column></table><table name="tomcat"><column name="id">601</column><column name="bug_id">50018</column><column name="summary">Javadoc corrections</column><column name="description">Created attachment 26092 Javadoc corrections</column><column name="report_time">2010-09-27 20:47:45</column><column name="report_timestamp">1285630000</column><column name="status">resolved fixed</column><column name="commit">2f8a27c</column><column name="commit_timestamp">1285750000</column><column name="files">java/org/apache/jasper/compiler/ParserController.java
java/org/apache/jasper/compiler/TagFileProcessor.java</column><column name="result">126:java/org/apache/jasper/compiler/TagFileProcessor.java
150:java/org/apache/jasper/compiler/ParserController.java</column></table><table name="tomcat"><column name="id">602</column><column name="bug_id">49195</column><column name="summary">Using -1 as shutdown port with Windows service works, but prints error message</column><column name="description">1. Install Tomcat as a service on Windows 2. Specify &lt;Server port="-1" in server.xml 3. Start the service, and then stop the service. 4. The following is printed in the catalina.2010-04-27.log: 27.04.2010 17:49:13 org.apache.catalina.startup.Catalina stopServer SEVERE: No shutdown port configured. Shut down server through OS signal. Server not shut down. It is just a message. Tomcat stops regardless of it: After printing the message Catalina#stopServer() performs System.exit(1) which results in Tomcat shutdown. I think that when service launcher stops Tomcat, Catalina#server is not null. That can be used to differentiate the two use cases. There could be improvements on how to stop Tomcat. E.g., to call Catalina.stop(). If that is the case, it would be better to use wait(10000) instead of sleep(10000) in StandardServer.await(), so that it could be woken by a notifyAll() call, or use interrupt() call to wake it up (if we know the thread). System.exit(0) would work regardless of all that. I suppose that jsvc may show the same behaviour, but I have not tried.</column><column name="report_time">2010-04-27 10:22:54</column><column name="report_timestamp">1272380000</column><column name="status">resolved fixed</column><column name="commit">7c6b1a5</column><column name="commit_timestamp">1285710000</column><column name="files">java/org/apache/catalina/startup/Catalina.java</column><column name="result">1:java/org/apache/catalina/startup/Catalina.java</column></table><table name="tomcat"><column name="id">603</column><column name="bug_id">49665</column><column name="summary">When file not found error occurs it does not tell you which file caused the error.</column><column name="description">Created attachment 25814 Patch to jasper so file not found error while parsing tld's report file and location. When parsing jsp's into java, if a "file not found" occurrs like on a tag file it will not tell you which file caused the error. As an example : ------------------------ [jasper] Jul 29, 2010 7:02:24 PM org.apache.jasper.JspC processFile [jasper] SEVERE: File "/tags/struts-bean" not found [jasper] Jul 29, 2010 7:02:25 PM org.apache.jasper.JspC processFile [jasper] SEVERE: file:/data/cvs/oscar_mcmaster/build/tmp/jspc/web/ticklerPlus/preparedTicklerList.jsp(22,18) Attribute value request.getAttribute("preparedTicklers") is quoted with " which must be escaped when used within the value ------------------------ There are 2 errors showing here, one is from an invalid tag and the other is on an attribute. Note that the attribute works well and tells me which file and location is causing the problem. Note that with the first error it doesn't even tell me which file is causing the error. Attached is a patch which shows the file and location of the error. After the patch file is applied I get a more useful out put ------------------------- [jasper] Jul 29, 2010 6:54:11 PM org.apache.jasper.JspC processFile [jasper] SEVERE: file:/data/cvs/oscar_mcmaster/build/tmp/jspc/web/ticklerPlus/Auth.jsp(1,49) File "/tags/struts-bean" not found [jasper] Jul 29, 2010 6:54:11 PM org.apache.jasper.JspC processFile [jasper] SEVERE: file:/data/cvs/oscar_mcmaster/build/tmp/jspc/web/ticklerPlus/preparedTicklerList.jsp(22,18) Attribute value request.getAttribute("preparedTicklers") is quoted with " which must be escaped when used within the value -------------------------</column><column name="report_time">2010-07-29 05:08:43</column><column name="report_timestamp">1280390000</column><column name="status">resolved fixed</column><column name="commit">7b24ed5</column><column name="commit_timestamp">1285690000</column><column name="files">java/org/apache/jasper/compiler/Generator.java
java/org/apache/jasper/compiler/JspDocumentParser.java
java/org/apache/jasper/compiler/Parser.java
java/org/apache/jasper/compiler/TagLibraryInfoImpl.java</column><column name="result">37:java/org/apache/jasper/compiler/JspDocumentParser.java
44:java/org/apache/jasper/compiler/Parser.java
53:java/org/apache/jasper/compiler/TagLibraryInfoImpl.java
60:java/org/apache/jasper/compiler/Generator.java</column></table><table name="tomcat"><column name="id">604</column><column name="bug_id">49625</column><column name="summary">Tomcat doesn't send Vary consistently when gzip enabled</column><column name="description">HTTP requires that the Vary response header be sent consistently for all responses if they change based upon different aspects of the request. My pages has both compressed and uncompressed variants available, negotiated by the Accept-Encoding request header, but it sends different Vary headers for each; "accept-encoding" when the response is compressed, and "" when it is not. This can cause problems for downstream caches, because they cannot consistently determine what the cache key for a given URI is. My server.xml content: &lt;Service name="Catalina"&gt; &lt;Connector port="8080" proxyPort="80" maxHttpHeaderSize="8192" protocol="org.apache.coyote.http11.Http11Protocol" maxThreads="200" minSpareThreads="25" maxPostSize="8" maxSpareThreads="75" enableLookups="false" keepAliveTimeout="3000" maxKeepAliveRequests="100" redirectPort="8443" acceptCount="100" connectionTimeout="8000" disableUploadTimeout="true" compression="on" compressionMinSize="2048" compressableMimeType="text/html,text/xml,text/javascript,text/css" /&gt; &lt;Engine name="Catalina" defaultHost="localhost"&gt; &lt;Host name="localhost" appBase="webapps" unpackWARs="false" autoDeploy="false" debug="0" xmlValidation="false" xmlNamespaceAware="false"&gt; 	&lt;/Host&gt; &lt;/Engine&gt; &lt;/Service&gt;</column><column name="report_time">2010-07-21 03:11:07</column><column name="report_timestamp">1279700000</column><column name="status">resolved fixed</column><column name="commit">7435fa9</column><column name="commit_timestamp">1285680000</column><column name="files">java/org/apache/coyote/http11/AbstractHttp11Processor.java</column><column name="result">16:java/org/apache/coyote/http11/AbstractHttp11Processor.java</column></table><table name="tomcat"><column name="id">605</column><column name="bug_id">49209</column><column name="summary">AccessControlException when undeploying application</column><column name="description">When running Tomcat with a SecurityManager, an AccessControlException is thrown during undeployment. Stack trace: Caused by: java.security.AccessControlException: access denied (java.lang.RuntimePermission getClassLoader) 	at java.security.AccessControlContext.checkPermission(AccessControlContext.java:323) 	at java.security.AccessController.checkPermission(AccessController.java:546) 	at java.lang.SecurityManager.checkPermission(SecurityManager.java:532) 	at java.lang.Class.getClassLoader(Class.java:594) 	at org.apache.catalina.loader.JdbcLeakPrevention.clearJdbcDriverRegistrations(JdbcLeakPrevention.java:49) I assume the default catalina.policy should be updated, to take this case into account.</column><column name="report_time">2010-04-28 07:30:12</column><column name="report_timestamp">1272450000</column><column name="status">resolved fixed</column><column name="commit">d0d4c75</column><column name="commit_timestamp">1285630000</column><column name="files">java/org/apache/catalina/loader/WebappClassLoader.java</column><column name="result">1:java/org/apache/catalina/loader/WebappClassLoader.java</column></table><table name="tomcat"><column name="id">606</column><column name="bug_id">49102</column><column name="summary">coyote.ajp.Constants - 3 "constant" arrays are mutable</column><column name="description">The class coyote.ajp.Constants contains 3 public static non-empty String[] arrays: methodTransArray responseTransArray headerTransArray responseTransArray only appears to be locally, so could be made private. The others are used in index lookups, so get(index) methods could be used to protect them.</column><column name="report_time">2010-04-12 16:11:37</column><column name="report_timestamp">1271100000</column><column name="status">resolved fixed</column><column name="commit">fb5a3e7</column><column name="commit_timestamp">1285240000</column><column name="files">java/org/apache/coyote/ajp/AjpAprProcessor.java
java/org/apache/coyote/ajp/AjpProcessor.java
java/org/apache/coyote/ajp/Constants.java</column><column name="result">1:java/org/apache/coyote/ajp/AjpProcessor.java
2:java/org/apache/coyote/ajp/AjpAprProcessor.java
3:java/org/apache/coyote/ajp/Constants.java</column></table><table name="tomcat"><column name="id">607</column><column name="bug_id">49909</column><column name="summary">jstl 1.2 not support</column><column name="description">Created attachment 26011 run log I get the R995577 from svn, and complied. Report err when run my webapp that lib include jstl.jar v1.2. But run the examples with jstl.jar v1.1.2 and standard.jar v1.1.2 was work fined. Is the tc7 not support jstal 1.2? The exception stack in the attachment.</column><column name="report_time">2010-09-10 06:20:26</column><column name="report_timestamp">1284110000</column><column name="status">resolved fixed</column><column name="commit">8dc0306</column><column name="commit_timestamp">1284720000</column><column name="files">java/org/apache/catalina/loader/WebappClassLoader.java</column><column name="result">29:java/org/apache/catalina/loader/WebappClassLoader.java</column></table><table name="tomcat"><column name="id">608</column><column name="bug_id">49924</column><column name="summary">When non-primary node changes into a primary node, isPrimarySession is not changed to true.</column><column name="description">If BackupManager is used, when a primary node is switched, DeltaSession#isPrimarySession is not changed to true. Non-primary node changes into a primary node when a primary node is stopped or we get a non-primary session. If a primary node is stopped, a primary node is switched. In AbstractReplicatedMap, when a primary node is switched, MapOwner(BackupManager)#objectMadePrimay is called. However, isPrimarySession does not change to true in this method. =====BackupManager#objectMadePrimay===== public void objectMadePrimay(Object key, Object value) { if (value!=null &amp;&amp; value instanceof DeltaSession) { DeltaSession session = (DeltaSession)value; synchronized (session) { session.access(); session.endAccess(); } } } ===== If we get a non-primary session, a primary node is switched. However, isPrimarySession does not change to true. It is only a change of primary node. I made a patch. It contains the following. isPrimarySession is set to true in BackupManager#objectMadePrimay. When get() is called in non-primary node, MapOwner#objectMadePrimay is called. Best regards.</column><column name="report_time">2010-09-14 03:23:07</column><column name="report_timestamp">1284450000</column><column name="status">resolved fixed</column><column name="commit">b255697</column><column name="commit_timestamp">1284450000</column><column name="files">java/org/apache/catalina/ha/session/BackupManager.java
java/org/apache/catalina/tribes/tipis/AbstractReplicatedMap.java</column><column name="result">1:java/org/apache/catalina/ha/session/BackupManager.java
3:java/org/apache/catalina/tribes/tipis/AbstractReplicatedMap.java</column></table><table name="tomcat"><column name="id">609</column><column name="bug_id">49234</column><column name="summary">JMX Descriptor Modifications</column><column name="description">Created attachment 25378 Descriptor Modification Package: org.apache.catalina I have slightly modified mbeans-descriptor.xml in above package as below. 1. Removed username and password attributes from the User mbean object since it exposes username and the password of the users. 2. Modified some attributes as non writeable according to the context.</column><column name="report_time">2010-04-30 00:17:34</column><column name="report_timestamp">1272600000</column><column name="status">resolved fixed</column><column name="commit">e0182ef</column><column name="commit_timestamp">1284250000</column><column name="files">java/org/apache/catalina/Server.java
java/org/apache/catalina/Service.java
java/org/apache/catalina/core/StandardEngine.java
java/org/apache/catalina/core/StandardServer.java
java/org/apache/catalina/core/StandardService.java
java/org/apache/catalina/mbeans/ContainerMBean.java
java/org/apache/catalina/mbeans/ContextMBean.java
java/org/apache/catalina/mbeans/ServiceMBean.java
java/org/apache/catalina/startup/Catalina.java</column><column name="result">31:java/org/apache/catalina/core/StandardService.java
78:java/org/apache/catalina/core/StandardServer.java
100:java/org/apache/catalina/startup/Catalina.java
205:java/org/apache/catalina/core/StandardEngine.java</column></table><table name="tomcat"><column name="id">610</column><column name="bug_id">49892</column><column name="summary">Wrong JNDI Name for Method Resource Injections</column><column name="description">Method based JNDI env. injections not worked correctly. Patch is attached. See Java EE 6 specification section, EE. 5.2.5 Annotations and Injections. Patch is provided that solves problem.</column><column name="report_time">2010-09-07 10:44:49</column><column name="report_timestamp">1283870000</column><column name="status">resolved fixed</column><column name="commit">94147b2</column><column name="commit_timestamp">1283980000</column><column name="files">java/org/apache/catalina/core/DefaultInstanceManager.java</column><column name="result">12:java/org/apache/catalina/core/DefaultInstanceManager.java</column></table><table name="tomcat"><column name="id">611</column><column name="bug_id">49831</column><column name="summary">Issue with closing XAConnections on MSSQL</column><column name="description">When using XAConnections with MSSQL it has been noticed that the physical connections are not being closed when DataSourceProxy.close(boolean all) is called. This method invokes org.apache.tomcat.jdbc.pool.PooledConnection.disconnent() which calls connection.close(). However, when used with SQLServer, the connection attribute is a proxy object (type com.microsoft.sqlserver.jdbc.SQLServerConnectionPoolProxy) which wraps the physical connection (of type com.microsoft.sqlserver.jdbc.SQLServerConnection). Calling close() on the proxy object only notifies the pool manager that the Connection is released back to the pool; it does not close the underlying physical connection. This is what the PooledConnection.disconnent() implementation currently reads: private void disconnect(boolean finalize) { if (isDiscarded()) { return; } setDiscarded(true); if (connection != null) { try { connection.close(); }catch (Exception ignore) { if (log.isDebugEnabled()) { log.debug("Unable to close underlying SQL connection",ignore); } } } connection = null; xaConnection = null; lastConnected = -1; if (finalize) parent.finalize(this); } If the logic was changed to the following, it would properly closed the XAConnection with the MSSQL. private void disconnect(boolean finalize) { if (isDiscarded()) { return; } setDiscarded(true); if (connection != null) { try { if (xaConnection != null) { xaConnection.close(); } else { connection.close(); } }catch (Exception ignore) { if (log.isDebugEnabled()) { log.debug("Unable to close underlying SQL connection",ignore); } } } connection = null; xaConnection = null; lastConnected = -1; if (finalize) parent.finalize(this); }</column><column name="report_time">2010-08-26 11:08:08</column><column name="report_timestamp">1282840000</column><column name="status">resolved fixed</column><column name="commit">64a8346</column><column name="commit_timestamp">1283960000</column><column name="files">modules/jdbc-pool/java/org/apache/tomcat/jdbc/pool/PooledConnection.java</column><column name="result">1:modules/jdbc-pool/java/org/apache/tomcat/jdbc/pool/PooledConnection.java</column></table><table name="tomcat"><column name="id">612</column><column name="bug_id">49883</column><column name="summary">java.lang.UnsupportedOperationException: The getName() method should never be called</column><column name="description">Hi, I am running Tomcat trunk (revision 992708, 2010-09-03). I added this line to conf/logging.properties: org.apache.catalina.level=FINEST The server fails to start with: Throwable occurred: java.lang.UnsupportedOperationException: The getName() method should never be called 	at org.apache.catalina.realm.CombinedRealm.getName(CombinedRealm.java:268) 	at org.apache.catalina.realm.RealmBase.toString(RealmBase.java:1015) 	at java.text.MessageFormat.subformat(MessageFormat.java:1258) 	at java.text.MessageFormat.format(MessageFormat.java:807) 	at org.apache.tomcat.util.res.StringManager.getString(StringManager.java:152) 	at org.apache.catalina.util.LifecycleBase.setState(LifecycleBase.java:320) 	at org.apache.catalina.util.LifecycleBase.setState(LifecycleBase.java:305) 	at org.apache.catalina.util.LifecycleBase.init(LifecycleBase.java:98) 	at org.apache.catalina.util.LifecycleBase.start(LifecycleBase.java:131) 	at org.apache.catalina.core.ContainerBase.startInternal(ContainerBase.java:1020) 	at org.apache.catalina.core.StandardEngine.startInternal(StandardEngine.java:276) 	at org.apache.catalina.util.LifecycleBase.start(LifecycleBase.java:140) 	at org.apache.catalina.core.StandardService.startInternal(StandardService.java:429) 	at org.apache.catalina.util.LifecycleBase.start(LifecycleBase.java:140) 	at org.apache.catalina.core.StandardServer.startInternal(StandardServer.java:649) 	at org.apache.catalina.util.LifecycleBase.start(LifecycleBase.java:140) 	at org.apache.catalina.startup.Catalina.start(Catalina.java:584) 	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) 	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:48) 	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25) 	at java.lang.reflect.Method.invoke(Method.java:600) 	at org.apache.catalina.startup.Bootstrap.start(Bootstrap.java:289) 	at org.apache.catalina.startup.Bootstrap.main(Bootstrap.java:416) java.lang.reflect.InvocationTargetException 	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) 	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:48) 	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25) 	at java.lang.reflect.Method.invoke(Method.java:600) 	at org.apache.catalina.startup.Bootstrap.start(Bootstrap.java:289) 	at org.apache.catalina.startup.Bootstrap.main(Bootstrap.java:416) Caused by: java.lang.UnsupportedOperationException: The getName() method should never be called 	at org.apache.catalina.realm.CombinedRealm.getName(CombinedRealm.java:268) 	at org.apache.catalina.realm.RealmBase.toString(RealmBase.java:1015) 	at java.text.MessageFormat.subformat(MessageFormat.java:1258) 	at java.text.MessageFormat.format(MessageFormat.java:807) 	at org.apache.tomcat.util.res.StringManager.getString(StringManager.java:152) 	at org.apache.catalina.util.LifecycleBase.setState(LifecycleBase.java:320) 	at org.apache.catalina.util.LifecycleBase.setState(LifecycleBase.java:305) 	at org.apache.catalina.util.LifecycleBase.init(LifecycleBase.java:98) 	at org.apache.catalina.util.LifecycleBase.start(LifecycleBase.java:131) 	at org.apache.catalina.core.ContainerBase.startInternal(ContainerBase.java:1020) 	at org.apache.catalina.core.StandardEngine.startInternal(StandardEngine.java:276) 	at org.apache.catalina.util.LifecycleBase.start(LifecycleBase.java:140) 	at org.apache.catalina.core.StandardService.startInternal(StandardService.java:429) 	at org.apache.catalina.util.LifecycleBase.start(LifecycleBase.java:140) 	at org.apache.catalina.core.StandardServer.startInternal(StandardServer.java:649) 	at org.apache.catalina.util.LifecycleBase.start(LifecycleBase.java:140) 	at org.apache.catalina.startup.Catalina.start(Catalina.java:584) 	... 6 more If I comment out that line in logging.properties, the server starts fine. Looking at the code in LifecycleBase line 320, it is a log.debug call: if (log.isDebugEnabled()) { log.debug(sm.getString("lifecycleBase.setState", this, state)); }</column><column name="report_time">2010-09-04 22:58:52</column><column name="report_timestamp">1283660000</column><column name="status">resolved fixed</column><column name="commit">a9f0fd5</column><column name="commit_timestamp">1283720000</column><column name="files">java/org/apache/catalina/realm/CombinedRealm.java</column><column name="result">9:java/org/apache/catalina/realm/CombinedRealm.java</column></table><table name="tomcat"><column name="id">613</column><column name="bug_id">49802</column><column name="summary">Shutdown of AJP Connector do not work</column><column name="description">Created attachment 25927 Catalina log Hi, when Tomcat is under load from an Apache httpd server (through mod_jk and ajp13) and I shutdown it, I get NullPointerException: ^C 23-ago-2010 11.06.47 org.apache.coyote.http11.AbstractHttp11Protocol pause INFO: Pausing Coyote HTTP/1.1 on http-9080 23-ago-2010 11.06.47 org.apache.coyote.ajp.AjpProtocol pause INFO: Pausing Coyote AJP/1.3 on ajp-9009 23-ago-2010 11.06.48 org.apache.catalina.core.StandardService stopInternal INFO: Stopping service Catalina 23-ago-2010 11.06.48 org.apache.catalina.connector.CoyoteAdapter service GRAVE: An exception or error occurred in the container during the request processing java.lang.NullPointerException at org.apache.catalina.connector.CoyoteAdapter.postParseRequest(CoyoteAdapter.java:638) at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:397) at org.apache.coyote.ajp.AjpProcessor.process(AjpProcessor.java:450) at org.apache.coyote.ajp.AjpProtocol$AjpConnectionHandler.process(AjpProtocol.java:385) ... I think the stopping of the Coyote AJP Connector doesn't work. In fact, if you go with jconsole on MBean Catalina-&gt;Connector-&gt;8009 and do "Stop" on "operation tab", nothing happens. To reproduce this bug: * Download Tomcat 7.0.2 * Confingure an Apache httpd with a JkMount /examples/* * Use ab to generate request (ex: ab -c 3 -n 1000000 "http://localhost/examples/jsp/jsp2/el/basic-arithmetic.jsp") Thank you, Domenico Briganti</column><column name="report_time">2010-08-23 05:59:48</column><column name="report_timestamp">1282560000</column><column name="status">resolved fixed</column><column name="commit">cd7263e</column><column name="commit_timestamp">1283720000</column><column name="files">java/org/apache/catalina/connector/Connector.java
java/org/apache/catalina/core/StandardService.java
java/org/apache/coyote/ProtocolHandler.java
java/org/apache/coyote/ajp/AjpAprProcessor.java
java/org/apache/coyote/ajp/AjpAprProtocol.java
java/org/apache/coyote/ajp/AjpProcessor.java
java/org/apache/coyote/ajp/AjpProtocol.java
java/org/apache/coyote/http11/AbstractHttp11Protocol.java
java/org/apache/coyote/http11/Http11AprProcessor.java
java/org/apache/coyote/http11/Http11NioProcessor.java
java/org/apache/coyote/http11/Http11Processor.java
java/org/apache/tomcat/util/net/AbstractEndpoint.java
java/org/apache/tomcat/util/net/AprEndpoint.java
java/org/apache/tomcat/util/net/JIoEndpoint.java
java/org/apache/tomcat/util/net/NioEndpoint.java</column><column name="result">1:java/org/apache/catalina/connector/Connector.java
5:java/org/apache/coyote/ajp/AjpProtocol.java
7:java/org/apache/coyote/ajp/AjpProcessor.java
12:java/org/apache/coyote/ajp/AjpAprProtocol.java
13:java/org/apache/coyote/ajp/AjpAprProcessor.java
22:java/org/apache/tomcat/util/net/AbstractEndpoint.java
25:java/org/apache/catalina/core/StandardService.java
36:java/org/apache/tomcat/util/net/NioEndpoint.java
38:java/org/apache/coyote/http11/Http11Processor.java
48:java/org/apache/tomcat/util/net/JIoEndpoint.java
59:java/org/apache/coyote/http11/Http11AprProcessor.java
66:java/org/apache/tomcat/util/net/AprEndpoint.java
69:java/org/apache/coyote/ProtocolHandler.java
120:java/org/apache/coyote/http11/Http11NioProcessor.java
286:java/org/apache/coyote/http11/AbstractHttp11Protocol.java</column></table><table name="tomcat"><column name="id">614</column><column name="bug_id">49876</column><column name="summary">correcting generics related compile warning in org/apache/tomcat/util/bcel/classfile files</column><column name="description">Explanation: Several files have compile time generics related warnings displayed for org/apache/tomcat/util/bcel/classfile. This patch cleans up several of those warnings.</column><column name="report_time">2010-09-03 08:17:45</column><column name="report_timestamp">1283520000</column><column name="status">resolved fixed</column><column name="commit">6155a8b</column><column name="commit_timestamp">1283540000</column><column name="files">java/org/apache/tomcat/util/bcel/classfile/AnnotationEntry.java
java/org/apache/tomcat/util/bcel/classfile/Attribute.java
java/org/apache/tomcat/util/bcel/classfile/JavaClass.java
java/org/apache/tomcat/util/bcel/classfile/Unknown.java
java/org/apache/tomcat/util/bcel/classfile/Utility.java</column><column name="result">87:java/org/apache/tomcat/util/bcel/classfile/Unknown.java
387:java/org/apache/tomcat/util/bcel/classfile/Utility.java
550:java/org/apache/tomcat/util/bcel/classfile/JavaClass.java
1158:java/org/apache/tomcat/util/bcel/classfile/Attribute.java
1360:java/org/apache/tomcat/util/bcel/classfile/AnnotationEntry.java</column></table><table name="tomcat"><column name="id">615</column><column name="bug_id">49869</column><column name="summary">Javadoc for WebAppClassLoader constructor has copy/paste error</column><column name="description">The constructor that takes a parent class loader has a copy of the doc string from the constructor that does not take a parent class loader.</column><column name="report_time">2010-09-02 18:26:13</column><column name="report_timestamp">1283470000</column><column name="status">resolved fixed</column><column name="commit">a6620cb</column><column name="commit_timestamp">1283500000</column><column name="files">java/org/apache/catalina/loader/WebappClassLoader.java</column><column name="result">1:java/org/apache/catalina/loader/WebappClassLoader.java</column></table><table name="tomcat"><column name="id">616</column><column name="bug_id">48967</column><column name="summary">Externalize Strings "catalina.base" and "catalina.home"</column><column name="description">Created attachment 25169 Patch externalizing strings Strings "catalina.base" and "catalina.home" are present multiple times in the code base. Most of them should be replaced by a reference to a constant.</column><column name="report_time">2010-03-23 14:19:02</column><column name="report_timestamp">1269370000</column><column name="status">resolved fixed</column><column name="commit">bcb994c</column><column name="commit_timestamp">1283440000</column><column name="files">java/org/apache/catalina/Globals.java
java/org/apache/catalina/connector/Connector.java
java/org/apache/catalina/core/StandardContext.java
java/org/apache/catalina/ha/deploy/FarmWarDeployer.java
java/org/apache/catalina/manager/ManagerServlet.java
java/org/apache/catalina/manager/host/HostManagerServlet.java
java/org/apache/catalina/realm/JAASMemoryLoginModule.java
java/org/apache/catalina/realm/MemoryRealm.java
java/org/apache/catalina/startup/Bootstrap.java
java/org/apache/catalina/startup/Catalina.java
java/org/apache/catalina/startup/CatalinaProperties.java
java/org/apache/catalina/startup/Embedded.java
java/org/apache/catalina/startup/ExpandWar.java
java/org/apache/catalina/startup/HostConfig.java
java/org/apache/catalina/startup/Tomcat.java
java/org/apache/catalina/startup/Tool.java
java/org/apache/catalina/users/MemoryUserDatabase.java
java/org/apache/catalina/valves/AccessLogValve.java
java/org/apache/jasper/compiler/AntCompiler.java
java/org/apache/tomcat/util/net/AbstractEndpoint.java
java/org/apache/tomcat/util/net/jsse/JSSESocketFactory.java</column><column name="result">1:java/org/apache/catalina/startup/Bootstrap.java
2:java/org/apache/catalina/startup/Embedded.java
3:java/org/apache/catalina/startup/CatalinaProperties.java
5:java/org/apache/catalina/startup/Catalina.java
6:java/org/apache/catalina/core/StandardContext.java
15:java/org/apache/catalina/startup/Tomcat.java
25:java/org/apache/catalina/startup/HostConfig.java
35:java/org/apache/catalina/connector/Connector.java
45:java/org/apache/tomcat/util/net/AbstractEndpoint.java
50:java/org/apache/catalina/users/MemoryUserDatabase.java
51:java/org/apache/catalina/startup/Tool.java
68:java/org/apache/catalina/manager/ManagerServlet.java
93:java/org/apache/catalina/ha/deploy/FarmWarDeployer.java
126:java/org/apache/jasper/compiler/AntCompiler.java
153:java/org/apache/catalina/realm/JAASMemoryLoginModule.java
170:java/org/apache/catalina/valves/AccessLogValve.java
208:java/org/apache/catalina/manager/host/HostManagerServlet.java
212:java/org/apache/catalina/realm/MemoryRealm.java
243:java/org/apache/tomcat/util/net/jsse/JSSESocketFactory.java
286:java/org/apache/catalina/Globals.java
329:java/org/apache/catalina/startup/ExpandWar.java</column></table><table name="tomcat"><column name="id">617</column><column name="bug_id">49749</column><column name="summary">SSO cookie should be added as HttpOnly</column><column name="description">SSO cookies should be made HttpOnly by default. In org.apache.catalina.authenticator.AuthenticatorBase#register(), 798- response.addCookie(cookie); 798+ response.addCookieInternal(cookie, true);</column><column name="report_time">2010-08-13 19:18:22</column><column name="report_timestamp">1281740000</column><column name="status">resolved fixed</column><column name="commit">e641f20</column><column name="commit_timestamp">1282740000</column><column name="files">java/org/apache/catalina/authenticator/AuthenticatorBase.java</column><column name="result">1:java/org/apache/catalina/authenticator/AuthenticatorBase.java</column></table><table name="tomcat"><column name="id">618</column><column name="bug_id">48738</column><column name="summary">[PATCH]Allow GzipOutputFilter to send partial result when flushBuffer() is called</column><column name="description">Created attachment 24979 patch for the making GzipOutputFilter work with early flush As part of our site speed optimizations (at Linkedin) we bumped into a problem when trying to do partial flush of compressed content stream from Tomcat to the browser. We discovered the root cause to be a couple of long outstanding JDK bugs: http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=4255743 http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=4813885 Basically, with the GzipOutputFilter turned on, the GZIPOutputStream it uses internally buffers the data that's been sent over, and does not flush to client (browser) when flushBuffer() is invoked. We have produced a patch which we verified internally, that it did work to do a partial flush on the compressed stream. We also have a unit testcase included in the patch to quickly show the problem. Early flush is a quite useful technique that many sites out there can benefit from to speed up the page download/rendering time, and by having it working in tomcat would benefit the existing and new customers. Thanks!</column><column name="report_time">2010-02-13 23:28:26</column><column name="report_timestamp">1266120000</column><column name="status">resolved fixed</column><column name="commit">526f4ac</column><column name="commit_timestamp">1282640000</column><column name="files">java/org/apache/coyote/http11/AbstractOutputBuffer.java
java/org/apache/coyote/http11/filters/FlushableGZIPOutputStream.java
java/org/apache/coyote/http11/filters/GzipOutputFilter.java
test/org/apache/coyote/http11/TestGzipOutputFilter.java</column><column name="result">1:java/org/apache/coyote/http11/filters/GzipOutputFilter.java
22:java/org/apache/coyote/http11/AbstractOutputBuffer.java</column></table><table name="tomcat"><column name="id">619</column><column name="bug_id">49670</column><column name="summary">org.apache.catalina.authenticator.SingleSignOn valve does not function</column><column name="description">I have two web applications; neither declare a realm in the context.xml and both are configured for authentication in the web.xml using standard tomcat authentication methods. I have enabled the tomcat valve in the host and have added a realm to the host as well. &lt;Host name="localhost" appBase="webapps" unpackWARs="true" autoDeploy="true"&gt; 	&lt;Realm className="org.apache.catalina.realm.JAASRealm" appName="SSO" userClassNames="a.b.c" roleClassNames="a.b.c" useContextClassLoader="false"/&gt; &lt;!-- SingleSignOn valve, share authentication between web applications Documentation at: /docs/config/valve.html --&gt; &lt;Valve className="org.apache.catalina.authenticator.SingleSignOn"/&gt; &lt;!-- Access log processes all example. Documentation at: /docs/config/valve.html --&gt; &lt;!-- &lt;Valve className="org.apache.catalina.valves.AccessLogValve" directory="logs" prefix="localhost_access_log." suffix=".txt" pattern="common" resolveHosts="false"/&gt; --&gt; I have added a jaas configuration for the SSO app in the jaas.conf file for the server. I am certain that the realm, jaas.conf are all configured properly as the web applications do require a user to authenticate before accessing the application, but if I have authenticated to one application I still am required to authenticate before accessing the other application. I have this exact same configuration working on a tomcat 6 environment, but an identical configuration will not operate on a tomcat 7 server.</column><column name="report_time">2010-07-29 10:43:35</column><column name="report_timestamp">1280410000</column><column name="status">resolved fixed</column><column name="commit">e2f0b9b</column><column name="commit_timestamp">1282590000</column><column name="files">java/org/apache/catalina/authenticator/AuthenticatorBase.java</column><column name="result">2:java/org/apache/catalina/authenticator/AuthenticatorBase.java</column></table><table name="tomcat"><column name="id">620</column><column name="bug_id">49721</column><column name="summary">Fail to access the resources such as jsp files from a jar file which is supported by servlet 3.0</column><column name="description">I put a jsp file in a jar file and test whether tomcat 7 supports it by viewing it from the browser and failed.</column><column name="report_time">2010-08-06 21:52:37</column><column name="report_timestamp">1281150000</column><column name="status">resolved fixed</column><column name="commit">187eed8</column><column name="commit_timestamp">1282590000</column><column name="files">java/org/apache/catalina/startup/ContextConfig.java</column><column name="result">4:java/org/apache/catalina/startup/ContextConfig.java</column></table><table name="tomcat"><column name="id">621</column><column name="bug_id">49726</column><column name="summary">JSP 2.2 new configuration element &lt;default-content-type&gt; under &lt;jsp-property-group&gt; works incorrectly on tomcat trunk</column><column name="description">Created attachment 25863 There are no java files in this project, so I only uploaded the war file. And its importance is the web.xml file. I wrote a test case which have been attached to test some new configuration elements under &lt;jsp-property-group&gt; which are added in JSP2.2. But it runs incorrectly. The error stack: org.apache.jasper.JasperException: /defaultCtype/page1.jsp(17,1) Page directive: illegal to have multiple occurrences of contentType with different values (old: text/xml, new: text/html) org.apache.jasper.compiler.DefaultErrorHandler.jspError(DefaultErrorHandler.java:40) org.apache.jasper.compiler.ErrorDispatcher.dispatch(ErrorDispatcher.java:407) org.apache.jasper.compiler.ErrorDispatcher.jspError(ErrorDispatcher.java:236) org.apache.jasper.compiler.Validator$DirectiveVisitor.visit(Validator.java:133) org.apache.jasper.compiler.Node$PageDirective.accept(Node.java:590) org.apache.jasper.compiler.Node$Nodes.visit(Node.java:2376) org.apache.jasper.compiler.Node$Visitor.visitBody(Node.java:2428) org.apache.jasper.compiler.Node$Visitor.visit(Node.java:2434) org.apache.jasper.compiler.Node$Root.accept(Node.java:475) org.apache.jasper.compiler.Node$Nodes.visit(Node.java:2376) org.apache.jasper.compiler.Validator.validateDirectives(Validator.java:1733) org.apache.jasper.compiler.Compiler.generateJava(Compiler.java:195) org.apache.jasper.compiler.Compiler.compile(Compiler.java:360) org.apache.jasper.compiler.Compiler.compile(Compiler.java:340) org.apache.jasper.compiler.Compiler.compile(Compiler.java:327) org.apache.jasper.JspCompilationContext.compile(JspCompilationContext.java:594) org.apache.jasper.servlet.JspServletWrapper.service(JspServletWrapper.java:315) org.apache.jasper.servlet.JspServlet.serviceJspFile(JspServlet.java:320) org.apache.jasper.servlet.JspServlet.service(JspServlet.java:265) javax.servlet.http.HttpServlet.service(HttpServlet.java:668)</column><column name="report_time">2010-08-09 02:07:45</column><column name="report_timestamp">1281330000</column><column name="status">resolved fixed</column><column name="commit">42c226f</column><column name="commit_timestamp">1282590000</column><column name="files">java/org/apache/jasper/compiler/Compiler.java
test/org/apache/jasper/compiler/TestCompiler.java</column><column name="result">13:java/org/apache/jasper/compiler/Compiler.java</column></table><table name="tomcat"><column name="id">622</column><column name="bug_id">49750</column><column name="summary">WebappClassLoader.validate(name) does not validate javax.servlet.</column><column name="description">The method does not validate the class name as described in the method documentation. "Validate a classname. As per SRV.9.7.2, we must restrict loading of classes from J2SE (java.*) and classes of the servlet API (javax.servlet.*) "</column><column name="report_time">2010-08-15 11:06:54</column><column name="report_timestamp">1281880000</column><column name="status">resolved fixed</column><column name="commit">6fce7d7</column><column name="commit_timestamp">1282580000</column><column name="files">java/org/apache/catalina/loader/WebappClassLoader.java</column><column name="result">1:java/org/apache/catalina/loader/WebappClassLoader.java</column></table><table name="tomcat"><column name="id">623</column><column name="bug_id">49758</column><column name="summary">[Patch] Generics warnings - rawtypes</column><column name="description">Created attachment 25894 Fix up some raw type warnings</column><column name="report_time">2010-08-16 13:20:09</column><column name="report_timestamp">1281980000</column><column name="status">resolved fixed</column><column name="commit">c05cb94</column><column name="commit_timestamp">1282520000</column><column name="files">java/javax/annotation/Resource.java
java/javax/ejb/EJB.java
java/javax/el/BeanELResolver.java
java/javax/el/ELContext.java
java/javax/el/ResourceBundleELResolver.java
java/javax/servlet/ServletRequestWrapper.java
java/javax/servlet/ServletResponseWrapper.java
java/javax/servlet/annotation/HandlesTypes.java
java/javax/servlet/jsp/el/ExpressionEvaluator.java
java/javax/servlet/jsp/el/ImplicitObjectELResolver.java
java/javax/servlet/jsp/tagext/TagSupport.java
java/javax/xml/ws/WebServiceRef.java
java/org/apache/el/lang/EvaluationContext.java
java/org/apache/el/parser/AstValue.java
java/org/apache/jasper/el/ELContextWrapper.java
java/org/apache/jasper/el/ExpressionEvaluatorImpl.java
java/org/apache/naming/resources/DirContextURLConnection.java</column><column name="result">3:java/javax/el/ELContext.java
7:java/javax/el/ResourceBundleELResolver.java
8:java/javax/el/BeanELResolver.java
10:java/org/apache/jasper/el/ELContextWrapper.java
12:java/org/apache/el/lang/EvaluationContext.java
29:java/javax/servlet/jsp/tagext/TagSupport.java
33:java/org/apache/el/parser/AstValue.java
61:java/org/apache/naming/resources/DirContextURLConnection.java
152:java/javax/servlet/ServletRequestWrapper.java
192:java/javax/servlet/jsp/el/ExpressionEvaluator.java
202:java/javax/servlet/jsp/el/ImplicitObjectELResolver.java
219:java/org/apache/jasper/el/ExpressionEvaluatorImpl.java
227:java/javax/servlet/ServletResponseWrapper.java</column></table><table name="tomcat"><column name="id">624</column><column name="bug_id">49757</column><column name="summary">correcting some generics related warnings</column><column name="description">Patch attached. Thanks</column><column name="report_time">2010-08-16 13:13:12</column><column name="report_timestamp">1281980000</column><column name="status">resolved fixed</column><column name="commit">d446678</column><column name="commit_timestamp">1282490000</column><column name="files">java/org/apache/catalina/manager/JMXProxyServlet.java
java/org/apache/catalina/tribes/tipis/AbstractReplicatedMap.java</column><column name="result">9:java/org/apache/catalina/tribes/tipis/AbstractReplicatedMap.java
617:java/org/apache/catalina/manager/JMXProxyServlet.java</column></table><table name="tomcat"><column name="id">625</column><column name="bug_id">49714</column><column name="summary">The annotation process of Jar should not impact distributable of web.xml.</column><column name="description">Even if &lt; distributable/&gt; is set to web.xml(servlet3.0), distributable is changed from true to false by the annotation process of JAR. ContextConfig#processAnnotations is as follows. ===ContextConfig#processAnnotations protected void processAnnotations(Set&lt;WebXml&gt; fragments) { for(WebXml fragment : fragments) { if (!fragment.isMetadataComplete()) { WebXml annotations = new WebXml(); URL url = fragment.getURL(); processAnnotationsUrl(url, annotations); Set&lt;WebXml&gt; set = new HashSet&lt;WebXml&gt;(); set.add(annotations); // Merge annotations into fragment - fragment takes priority fragment.merge(set); } } } === distributable of "annotations" created by new WebXml() is false (default). If "annotations" is merged with "fragment", distributable of "fragment" becomes false. Because "fragment" is merged with web.xml of the web application, even if &lt; distributable/&gt; is set to web.xml, distributable is changed from true to false. The following are necessary. annotations.setDistributable(true); Best regards.</column><column name="report_time">2010-08-05 22:06:15</column><column name="report_timestamp">1281060000</column><column name="status">resolved fixed</column><column name="commit">f4a10ec</column><column name="commit_timestamp">1281060000</column><column name="files">java/org/apache/catalina/startup/ContextConfig.java</column><column name="result">1:java/org/apache/catalina/startup/ContextConfig.java</column></table><table name="tomcat"><column name="id">626</column><column name="bug_id">49655</column><column name="summary">ExpressionFactoryImpl.createMethodExpression() is not EL 2.2 Spec conform</column><column name="description">org.apache.el.ExpressionFactoryImpl.createMethodExpression(ELContext context, String expression, Class expectedReturnType, Class[] expectedParamTypes) does not correctly impl EL Specification 2.2 (Maintenance Release 2 - December 10, 2009) The spezfication say at site 72 (last paragraph): expectedParamTypes - The expected parameter types for the method to be found. Must be an array with no elements if there are no parameters expected. It is illegal to pass null, unless the method is specified with arugments in the EL expression, in which case these arguments are used for method selection, and this parameter is ignored. The part ", unless the method is specified...." was added in 2.2 and is not implemented. If i call the method with expectedParamTypes == null i get NullPointerException, although expression #{bean.sayHello('World')} has arguments. The Sun 2.2.1-b04 el (com.sun.el.ExpressionFactoryImpl) has the same defect. The code looks identical. JUEL 2.2.1 (http://juel.sourceforge.net/) works fine.</column><column name="report_time">2010-07-27 10:32:48</column><column name="report_timestamp">1280240000</column><column name="status">resolved fixed</column><column name="commit">96a99ce</column><column name="commit_timestamp">1280700000</column><column name="files">test/org/apache/el/TestMethodExpressionImpl.java</column><column name="result">13:test/org/apache/el/TestMethodExpressionImpl.java</column></table><table name="tomcat"><column name="id">627</column><column name="bug_id">49407</column><column name="summary">backup manager reports too few current sessions</column><column name="description">With 100 sessions shared across 4 nodes (i.e. 25 active sessions per node), the delta manager reports 100 current sessions per node (25 active and the copies of the sessions from the other nodes). The back manager reports 25. For consistency it should report 50. The 25 active sessions plus the 25 (or so) that are backed up on that node.</column><column name="report_time">2010-06-08 15:58:58</column><column name="report_timestamp">1276030000</column><column name="status">resolved fixed</column><column name="commit">d21b105</column><column name="commit_timestamp">1280430000</column><column name="files">java/org/apache/catalina/session/ManagerBase.java
java/org/apache/catalina/tribes/tipis/AbstractReplicatedMap.java</column><column name="result">8:java/org/apache/catalina/session/ManagerBase.java
13:java/org/apache/catalina/tribes/tipis/AbstractReplicatedMap.java</column></table><table name="tomcat"><column name="id">628</column><column name="bug_id">49613</column><column name="summary">Request.getAttributeNames() slows down some applications</column><column name="description" /><column name="report_time">2010-07-19 06:23:09</column><column name="report_timestamp">1279530000</column><column name="status">resolved fixed</column><column name="commit">5f1ad13</column><column name="commit_timestamp">1279810000</column><column name="files">java/org/apache/catalina/connector/Request.java</column><column name="result">1:java/org/apache/catalina/connector/Request.java</column></table><table name="tomcat"><column name="id">629</column><column name="bug_id">49567</column><column name="summary">when starting a new thread from a startAsync Runnable, an infinite amount of doPosts is generated</column><column name="description">Created attachment 25728 testcase demonstrating the bug when starting a new thread from a startAsync Runnable, an infinite amount of doPosts is generated. Also, the GET status is: 500 Internal Server Error, however, there is no exception thrown by tomcat. The attached code demonstrates this, by printing "Start async()" an infinite amount of times.</column><column name="report_time">2010-07-07 09:22:22</column><column name="report_timestamp">1278510000</column><column name="status">resolved fixed</column><column name="commit">2357fb5</column><column name="commit_timestamp">1279790000</column><column name="files">java/org/apache/catalina/connector/CoyoteAdapter.java
java/org/apache/catalina/connector/Request.java
java/org/apache/catalina/core/AsyncContextImpl.java
java/org/apache/coyote/http11/Http11Processor.java
test/org/apache/catalina/core/TestAsyncContextImpl.java</column><column name="result">1:java/org/apache/catalina/connector/Request.java
12:java/org/apache/catalina/connector/CoyoteAdapter.java
21:java/org/apache/catalina/core/AsyncContextImpl.java
30:test/org/apache/catalina/core/TestAsyncContextImpl.java
54:java/org/apache/coyote/http11/Http11Processor.java</column></table><table name="tomcat"><column name="id">630</column><column name="bug_id">49617</column><column name="summary">Fix ExpiresFilter docs (remove remaining ExpiresActive reference)</column><column name="description">Remove the last references to the removed configuration parameter ExpiresActive.</column><column name="report_time">2010-07-19 17:44:38</column><column name="report_timestamp">1279580000</column><column name="status">resolved fixed</column><column name="commit">dfbd8aa</column><column name="commit_timestamp">1279730000</column><column name="files">java/org/apache/catalina/filters/ExpiresFilter.java
test/org/apache/catalina/filters/TestExpiresFilter.java</column><column name="result">1:java/org/apache/catalina/filters/ExpiresFilter.java
2:test/org/apache/catalina/filters/TestExpiresFilter.java</column></table><table name="tomcat"><column name="id">631</column><column name="bug_id">48998</column><column name="summary">Proposal : port mod_expires in java as ExpiresFilter Servlet Filter</column><column name="description">Created attachment 25189 Port of mod_expires as ExpiresFilter Here is a proposal to port Apache Httpd mod_expires in java as ExpiresFilter, a standard Servlet Filter. I detailed a standalone version on http://code.google.com/p/xebia-france/wiki/ExpiresFilter . More over, I tried my best to provide very detailed javadocs and docs (in filter.html). The proposed contribution is slightly different because it uses Tomcat logging, few Servlet 3 enhancements and test cases use Tomcat engine. The attached patch contains : * ExpiresFilter.java : the Expires Filter * TestExpiresFilter : detailed test cases * filter.xml : doc updates The filter has been optimized using a profiler and stress tested with Apache Bench under high load.</column><column name="report_time">2010-03-26 16:38:18</column><column name="report_timestamp">1269640000</column><column name="status">resolved fixed</column><column name="commit">7963a16</column><column name="commit_timestamp">1279150000</column><column name="files">java/org/apache/catalina/filters/ExpiresFilter.java
test/org/apache/catalina/filters/TestExpiresFilter.java</column><column name="result" /></table><table name="tomcat"><column name="id">632</column><column name="bug_id">49127</column><column name="summary">SimpleTcpReplicationManager.startInternal() ignores Exception</column><column name="description">ha.session.SimpleTcpReplicationManager.startInternal() ignores Exception when invoking Thread.sleep() - it only needs to ignore InterruptedException.</column><column name="report_time">2010-04-14 19:05:06</column><column name="report_timestamp">1271290000</column><column name="status">resolved fixed</column><column name="commit">eca4ed9</column><column name="commit_timestamp">1279140000</column><column name="files">java/org/apache/catalina/ha/session/SimpleTcpReplicationManager.java</column><column name="result">1:java/org/apache/catalina/ha/session/SimpleTcpReplicationManager.java</column></table><table name="tomcat"><column name="id">633</column><column name="bug_id">49128</column><column name="summary">loader.WebappClassLoader.start() ignores Exception</column><column name="description">catalina.loader.WebappClassLoader.start() ignores Exception. However, it probably only needs to ignore SecurityException</column><column name="report_time">2010-04-14 19:06:21</column><column name="report_timestamp">1271290000</column><column name="status">resolved fixed</column><column name="commit">e8245ef</column><column name="commit_timestamp">1279140000</column><column name="files">java/org/apache/catalina/loader/WebappClassLoader.java</column><column name="result">1:java/org/apache/catalina/loader/WebappClassLoader.java</column></table><table name="tomcat"><column name="id">634</column><column name="bug_id">48960</column><column name="summary">SSI Servlet should support safe configuration</column><column name="description">The current configuration of the SSI module is "All" or "None". The "ALL" option will expose all the legacy Apache SSI directive (echo, printenv, if, exec, ...). As documented, allowing SSI will allow execution of arbitrary programs using the "exec". As a result, there is no safe way to expose sites/projects containing SSI directive, without taking a security risk, or reviewing of every file. The "exec" directive, with the cmd option is a major risk. Even for Apache, you have the option to allowing the "safe" include (includeNoExec). The includeNoExec allow pages to be served, even when the content is not reviewed, or when users are allowed to upload content to the site. I have a big site which need to be converted into JSP. I would like to use the SSI servlet to allow for transition over time. The extra risk from ( from exec cmd) make it impossible to deploy the SSI. My request: Modify the configuration of SSI as follow: By default, it will only allow "safe" directive (no exec cmd=...). This will eliminate the risk from arbitrary execution of commands ("del *.*"). It will also remove many potentail load problems. The cmd= should only be allowed using a directive like "allowUnsafeExec", which will default to false. I think that the change will make it easier to use the SSI feature, without exposing the server to big risk. The risk associated with the "safer" version of SSI is similar to the risk from running JSP pages.</column><column name="report_time">2010-03-22 16:37:48</column><column name="report_timestamp">1269290000</column><column name="status">resolved fixed</column><column name="commit">a36b0c0</column><column name="commit_timestamp">1279060000</column><column name="files">java/org/apache/catalina/ssi/SSIFilter.java
java/org/apache/catalina/ssi/SSIProcessor.java
java/org/apache/catalina/ssi/SSIServlet.java</column><column name="result">1:java/org/apache/catalina/ssi/SSIProcessor.java
54:java/org/apache/catalina/ssi/SSIServlet.java
151:java/org/apache/catalina/ssi/SSIFilter.java</column></table><table name="tomcat"><column name="id">635</column><column name="bug_id">49442</column><column name="summary">Make StringManager fields final</column><column name="description">Created attachment 25592 Patch to make fields final</column><column name="report_time">2010-06-15 05:41:37</column><column name="report_timestamp">1276590000</column><column name="status">resolved fixed</column><column name="commit">4159093</column><column name="commit_timestamp">1278800000</column><column name="files">java/org/apache/tomcat/util/res/StringManager.java</column><column name="result">1:java/org/apache/tomcat/util/res/StringManager.java</column></table><table name="tomcat"><column name="id">636</column><column name="bug_id">49478</column><column name="summary">Add encoding parameter to AddDefaultCharSetFilter</column><column name="description">AddDefaultCharSetFilter adds a default charset to each request. It assumes ISO-8859-1 as the default charset. The attached patch makes it configurable by introducing an "encoding" parameter. This parameter can take one of two special values "default" or "system". Every other value will be interpreted as a name of an character set, e.g "utf-8". The meaning of the two special values are as follows: default: use ISO-8859-1. This value will also be used, if no parameter was specified, or if it is empty system: the jvm will be asked for the default charset. This charset will usually be set by system locale. Together with this functional change, there are two minor changes and one bigger changes hidden. First use of annotation "Override" at overriden methods. Second use of keyword "static" for the ResponseWrapper, since it has no reference to outer class. The third and somewhat bigger change is use of HttpServletResponse#setCharacterEncoding(encoding) instead of manipulating the content-type.</column><column name="report_time">2010-06-21 05:43:57</column><column name="report_timestamp">1277110000</column><column name="status">resolved fixed</column><column name="commit">d6766f1</column><column name="commit_timestamp">1278800000</column><column name="files">java/org/apache/catalina/filters/AddDefaultCharsetFilter.java
test/org/apache/catalina/filters/TestAddCharSetFilter.java</column><column name="result">3:java/org/apache/catalina/filters/AddDefaultCharsetFilter.java</column></table><table name="tomcat"><column name="id">637</column><column name="bug_id">49570</column><column name="summary">The CompressionFilter example should support HTTP proxies to cache gzipped content better by sending Vary: Accept-Encoding header</column><column name="description">At the moment the Compression Filter example doesn't send the header "Vary: Accept-Encoding" with the compressed content (see method writeToGZip(..) in http://svn.apache.org/repos/asf/tomcat/trunk/webapps/examples/WEB-INF/classes/compressionFilters/CompressionResponseStream.java). From many sources like 1. http://httpd.apache.org/docs/2.0/mod/mod_deflate.html#proxies 2. http://developer.yahoo.net/blog/archives/2007/07/high_performanc_3.html it looks like a "Vary: Accept-Encoding" header should be sent with the compressed content to make sure proxy servers can serve gzipped content correctly. To enhance this example, the method writeToGzip(..) should be updated to send Vary: Accept-Encoding header like below: public void writeToGZip(byte b[], int off, int len) throws IOException { ... response.addHeader("Content-Encoding", "gzip"); response.addHeader("Vary", "Accept-Encoding"); gzipstream = new GZIPOutputStream(output); ... }</column><column name="report_time">2010-07-08 02:11:36</column><column name="report_timestamp">1278570000</column><column name="status">resolved fixed</column><column name="commit">c191152</column><column name="commit_timestamp">1278780000</column><column name="files">webapps/examples/WEB-INF/classes/compressionFilters/CompressionResponseStream.java</column><column name="result">9:webapps/examples/WEB-INF/classes/compressionFilters/CompressionResponseStream.java</column></table><table name="tomcat"><column name="id">638</column><column name="bug_id">49503</column><column name="summary">Connectors do not bind to their ports in Catalina.load(), but only later in start()</column><column name="description">Testing with trunk at revision 957942, thus this supposedly affects 7.0.0 as well. In TC6 there is a separate pre-startup phase when starting Tomcat, to allow Connectors to bind to their ports before other parts of Tomcat are started. IIRC, it is implemented by having separate Bootstrap#load(String[]) and Bootstart#start() methods [1]. [1] http://commons.apache.org/daemon/jsvc.html#Downgrading_user When running with jsvc it will mean that Tomcat would not be able to bind to privileged ports (80). I do not use jsvc, but I observe this issue when testing the fix for bug 49030 + bug 48625 that I applied in r957960. Essentially, it breaks the fix for BZ 48625. To reproduce: 1. Add the following line to conf/catalina.properties org.apache.catalina.startup.EXIT_ON_INIT_FAILURE=true 2. Start two Tomcat instances with the same configuration at the same time. The first instance starts successfully. The second instance fails, as expected, but not in the expected way. 3. Expected behaviour: I would expect that in StandardService#initInternal() the connector.init() call fails, because it cannot bind to the port. The exception from connector.init() is caught there and, if EXIT_ON_INIT_FAILURE flag is set, it is rethrown, then caught in Catalina#load() and then rethrown as an Error, which aborts Tomcat startup. 4. Actual behaviour: The exception does not happen, because the connector does not try to bind to the port. It will bind when start() is called. The startup sequence continues and then fails in Server.await().</column><column name="report_time">2010-06-25 11:22:41</column><column name="report_timestamp">1277480000</column><column name="status">resolved fixed</column><column name="commit">a90b576</column><column name="commit_timestamp">1278600000</column><column name="files">java/org/apache/catalina/connector/Connector.java</column><column name="result">1:java/org/apache/catalina/connector/Connector.java</column></table><table name="tomcat"><column name="id">639</column><column name="bug_id">49551</column><column name="summary">When setting absolute path to default context.xml, in ContextConfig.contextConfig() it cannot be found</column><column name="description">Hi, I'm using an Embedded Tomcat. I want to use the Tomcat's functionality - default context.xml. I'm extending the org.apache.catalina.startup.ContextConfig. Sometimes the default context.xml is outside of the "base" directory, because of this I'm using the following method to set the location - in the java doc it is stated that an absolute path is acceptable for method parameter. http://svn.apache.org/repos/asf/tomcat/tc6.0.x/tags/TOMCAT_6_0_26/java/org/apache/catalina/startup/ContextConfig.java 218 /** 219 * Set the location of the default context file 220 * 221 * @param path Absolute/relative path to the default context.xml 222 */ 223 public void setDefaultContextXml(String path) { 224 225 this.defaultContextXml = path; 226 227 } When ContextConfig.contextConfig() method is invoked, a wrong path is generated for the default context.xml i.e. If the base directory is d:/base-dir and the path to the default context.xml is d:/other-dir/configuration/context.xml the following is generated: d:/base-dir/d:/other-dir/configuration/context.xml This happens in ContextConfig.java: 715 /** 716 * Process the default configuration file, if it exists. 717 */ 718 protected void contextConfig() { ... 728 processContextConfig(new File(getBaseDir()), defaultContextXml); ... 734 } 737 /** 738 * Process a context.xml. 739 */ 740 protected void processContextConfig(File baseDir, String resourceName) { ... 749 File file = baseDir; 750 if (resourceName != null) { 751 file = new File(baseDir, resourceName); 752 } ... 819 } Could you please clarify whether it is possible to use this setter method with absolute paths? Thanks in advance Regards</column><column name="report_time">2010-07-05 07:41:23</column><column name="report_timestamp">1278330000</column><column name="status">resolved fixed</column><column name="commit">dca6dd1</column><column name="commit_timestamp">1278360000</column><column name="files">java/org/apache/catalina/startup/ContextConfig.java</column><column name="result">1:java/org/apache/catalina/startup/ContextConfig.java</column></table><table name="tomcat"><column name="id">640</column><column name="bug_id">49550</column><column name="summary">[PATCH] Response class fix isSpace (deprecated) =&gt; isWhiteSpace</column><column name="description">Created attachment 25703 fix isSpace (deprecated) =&gt; isWhiteSpace As the subject says</column><column name="report_time">2010-07-05 07:23:31</column><column name="report_timestamp">1278330000</column><column name="status">resolved fixed</column><column name="commit">7b9630b</column><column name="commit_timestamp">1278360000</column><column name="files">java/org/apache/catalina/connector/Response.java</column><column name="result">2:java/org/apache/catalina/connector/Response.java</column></table><table name="tomcat"><column name="id">641</column><column name="bug_id">49530</column><column name="summary">Context is not correctly stopped at shutdown</column><column name="description">Created attachment 25669 Application that show the behavior Apparently a web application context is not correctly stopped when shutting down Tomcat 7.0.0. I noticed that the destroy() method of a Servlet that's loaded on startup was not called, and put together a test case (see attached files). The test servlet writes to System.out on init() and destroy(), the output on init appears in logs/catalina.out, but no output on destroy. From what I understand of the attached log, the context isn't stopped at all. Steps to reproduce: 1. copy attached startupServlet.war to webapps 2. start Tomcat, then "StartTestServlet.init" appears in catalina.out 3. stop Tomcat Actual Result: no output appears in logs/catalina.out Expected Result: "StartTestServlet.destroy" appears in catalina.out catalina.log shows evidence of context /startupServlet being stopped FWIW: java -version: java version "1.6.0_20" Java(TM) SE Runtime Environment (build 1.6.0_20-b02) Java HotSpot(TM) 64-Bit Server VM (build 16.3-b01, mixed mode) uname -a Linux &lt;hostname&gt; 2.6.32-22-generic #36-Ubuntu SMP Thu Jun 3 19:31:57 UTC 2010 x86_64 GNU/Linux</column><column name="report_time">2010-06-30 10:08:43</column><column name="report_timestamp">1277910000</column><column name="status">resolved fixed</column><column name="commit">3bd4bcb</column><column name="commit_timestamp">1278090000</column><column name="files">java/org/apache/catalina/core/ContainerBase.java</column><column name="result">49:java/org/apache/catalina/core/ContainerBase.java</column></table><table name="tomcat"><column name="id">642</column><column name="bug_id">49536</column><column name="summary">If no webapps deployed, accessing a URL returns 200 OK with no content instead of 404</column><column name="description">Hello I've just downloaded http://mirror.veriportal.com/apache/tomcat/tomcat-7/v7.0.0-beta/bin/apache-tomcat-7.0.0.zip If I start a Tomcat 7 instance with no webapps on it and access a URL, it returns HTTP code 200 OK with no content, instead of an HTTP error 404. Cheers S. Ali Tokmen http://ali.tokmen.com/</column><column name="report_time">2010-07-01 04:07:11</column><column name="report_timestamp">1277970000</column><column name="status">resolved fixed</column><column name="commit">4e34898</column><column name="commit_timestamp">1278020000</column><column name="files">java/org/apache/catalina/connector/CoyoteAdapter.java
java/org/apache/catalina/connector/MapperListener.java
java/org/apache/catalina/connector/Request.java
java/org/apache/tomcat/util/http/mapper/Mapper.java</column><column name="result">7:java/org/apache/catalina/connector/Request.java
59:java/org/apache/catalina/connector/MapperListener.java
79:java/org/apache/catalina/connector/CoyoteAdapter.java
453:java/org/apache/tomcat/util/http/mapper/Mapper.java</column></table><table name="tomcat"><column name="id">643</column><column name="bug_id">49525</column><column name="summary">IE8: Unabled to store data in HttpSession (root context)</column><column name="description">Environment: Tomcat 7.0.0 Beta IE8 A simplest webapp only have a test.jsp below: &lt;%=request.getSession().getId()%&gt; this app installed as root context the test.jsp works fine in firefox but when using IE8 there is always a different session id where refresh the test page. BTW: the test.jsp works find in Tomcat 6.x</column><column name="report_time">2010-06-29 22:22:03</column><column name="report_timestamp">1277860000</column><column name="status">resolved fixed</column><column name="commit">0b8a9a8</column><column name="commit_timestamp">1278010000</column><column name="files">java/org/apache/catalina/core/ApplicationSessionCookieConfig.java</column><column name="result">118:java/org/apache/catalina/core/ApplicationSessionCookieConfig.java</column></table><table name="tomcat"><column name="id">644</column><column name="bug_id">49522</column><column name="summary">Complete Server status (status/all) causes stack trace</column><column name="description">type Exception report message description The server encountered an internal error () that prevented it from fulfilling this request. exception javax.servlet.ServletException: javax.management.AttributeNotFoundException: Cannot find attribute startTime for org.apache.catalina.deploy.NamingResources@d1c778 	org.apache.catalina.manager.StatusManagerServlet.doGet(StatusManagerServlet.java:292) 	javax.servlet.http.HttpServlet.service(HttpServlet.java:621) 	javax.servlet.http.HttpServlet.service(HttpServlet.java:722) root cause javax.management.AttributeNotFoundException: Cannot find attribute startTime for org.apache.catalina.deploy.NamingResources@d1c778 	org.apache.tomcat.util.modeler.ManagedBean.getGetter(ManagedBean.java:493) 	org.apache.tomcat.util.modeler.BaseModelMBean.getAttribute(BaseModelMBean.java:180) 	com.sun.jmx.interceptor.DefaultMBeanServerInterceptor.getAttribute(DefaultMBeanServerInterceptor.java:666) 	com.sun.jmx.mbeanserver.JmxMBeanServer.getAttribute(JmxMBeanServer.java:638) 	org.apache.catalina.manager.StatusTransformer.writeContext(StatusTransformer.java:656) 	org.apache.catalina.manager.StatusTransformer.writeDetailedState(StatusTransformer.java:590) 	org.apache.catalina.manager.StatusManagerServlet.doGet(StatusManagerServlet.java:287) 	javax.servlet.http.HttpServlet.service(HttpServlet.java:621) 	javax.servlet.http.HttpServlet.service(HttpServlet.java:722)</column><column name="report_time">2010-06-29 10:41:51</column><column name="report_timestamp">1277820000</column><column name="status">resolved fixed</column><column name="commit">3c88f07</column><column name="commit_timestamp">1278010000</column><column name="files">java/org/apache/catalina/core/StandardContext.java</column><column name="result">3:java/org/apache/catalina/core/StandardContext.java</column></table><table name="tomcat"><column name="id">645</column><column name="bug_id">49476</column><column name="summary">Cannot expire selected session in Manager webapp</column><column name="description">Running 7.0.0. Steps to reproduce: 1. Login to the Manager webapp. 2. In the "Sessions" column click on the number (1) in the "/manager" row. The Sessions Administration page`[1] is opened. 3. In the sessions list put a checkmark next to any session and press Invalidate selected Sessions button. 4. Actual result: message: FAIL: Nonce mismatch. Command "/sessions" was ignored. and the page displays the list of webapps. Expected result: Invalidating a session and redisplaying the sessions list. [1] http://localhost:8080/manager/html/sessions?path=/manager Suspected cause is that [1] is opened with a GET query that does not include the nonce in its URL.</column><column name="report_time">2010-06-20 11:47:00</column><column name="report_timestamp">1277050000</column><column name="status">resolved fixed</column><column name="commit">a0159a3</column><column name="commit_timestamp">1277370000</column><column name="files">java/org/apache/catalina/filters/CsrfPreventionFilter.java
java/org/apache/catalina/manager/HTMLManagerServlet.java</column><column name="result">6:java/org/apache/catalina/manager/HTMLManagerServlet.java
347:java/org/apache/catalina/filters/CsrfPreventionFilter.java</column></table><table name="tomcat"><column name="id">646</column><column name="bug_id">49443</column><column name="summary">RemoteIpValve : remoteIpHeader vs remoteIPHeader</column><column name="description">In the doc for the RemoteIpValve (http://tomcat.apache.org/tomcat-6.0-doc/config/valve.html), the remoteIPHeader attribute is mentionned, but actually it should be remoteIpHeader (notice the lowercase "p") since the setter method is setRemoteIpHeader(..).</column><column name="report_time">2010-06-15 07:38:37</column><column name="report_timestamp">1276600000</column><column name="status">resolved fixed</column><column name="commit">27091e7</column><column name="commit_timestamp">1276860000</column><column name="files">java/org/apache/catalina/filters/RemoteIpFilter.java
java/org/apache/catalina/valves/RemoteIpValve.java</column><column name="result">1:java/org/apache/catalina/valves/RemoteIpValve.java
2:java/org/apache/catalina/filters/RemoteIpFilter.java</column></table><table name="tomcat"><column name="id">647</column><column name="bug_id">49445</column><column name="summary">After session ID is changed on authentication, the session replication does not work.</column><column name="description">After r889716, session ID is changed on authentication. (default of changeSessionIdOnAuthentication is true. ) But DeltaManager doesn't notify other cluster nodes. Therefore, non-primary node keeps having old session ID. And, can not replicate of change of session attribute notified by new session ID. The workaround is ... override changeSessionId method, and notify to change session ID. BackupManager is OK. This problem is DeltaManager only. Best regards.</column><column name="report_time">2010-06-16 05:08:02</column><column name="report_timestamp">1276680000</column><column name="status">resolved fixed</column><column name="commit">4f990f1</column><column name="commit_timestamp">1276690000</column><column name="files">java/org/apache/catalina/ha/session/DeltaManager.java
java/org/apache/catalina/ha/session/SessionMessage.java
java/org/apache/catalina/ha/session/SessionMessageImpl.java</column><column name="result">1:java/org/apache/catalina/ha/session/DeltaManager.java
81:java/org/apache/catalina/ha/session/SessionMessage.java
104:java/org/apache/catalina/ha/session/SessionMessageImpl.java</column></table><table name="tomcat"><column name="id">648</column><column name="bug_id">49376</column><column name="summary">Minor corrections to info properties.</column><column name="description">The static info properties appear to contain legacy packages.</column><column name="report_time">2010-06-03 07:33:13</column><column name="report_timestamp">1275560000</column><column name="status">resolved fixed</column><column name="commit">e119b5b</column><column name="commit_timestamp">1275860000</column><column name="files">java/org/apache/catalina/ha/authenticator/ClusterSingleSignOn.java
java/org/apache/catalina/ha/authenticator/ClusterSingleSignOnListener.java
java/org/apache/catalina/ha/session/ClusterSessionListener.java</column><column name="result">140:java/org/apache/catalina/ha/authenticator/ClusterSingleSignOn.java
160:java/org/apache/catalina/ha/session/ClusterSessionListener.java
184:java/org/apache/catalina/ha/authenticator/ClusterSingleSignOnListener.java</column></table><table name="tomcat"><column name="id">649</column><column name="bug_id">48971</column><column name="summary">memory leak protection : stopping TimeThreads should be optional and disabled by default</column><column name="description">While investigating to write this wiki page http://wiki.apache.org/tomcat/MemoryLeakProtection , I realized that WebAppClassLoader.clearReferencesStopTimerThread() can have dangerous side effects. Indeed, if the TimerThread was spawned by some library deployed in the common (or even JRE) classpath, then stopping it can impact other webapps still running. It would probably be a bug of that library to have such a thread with such a context classloader, but we have to be realistic, we cannot fix every third-party library (and the JRE). In my opinion, tomcat should better play it safe in such a case, and should not attempt by default to stop TimerThreads : it's safer to have a leak for a stopped webapp than break running apps ! WebAppClassLoader.clearReferencesStopTimerThread() should be conditioned with the existing boolean clearReferencesStopThreads. see attached proposed patch.</column><column name="report_time">2010-03-23 22:56:08</column><column name="report_timestamp">1269400000</column><column name="status">resolved fixed</column><column name="commit">ac8a5ba</column><column name="commit_timestamp">1275410000</column><column name="files">java/org/apache/catalina/core/StandardContext.java
java/org/apache/catalina/loader/WebappClassLoader.java
java/org/apache/catalina/loader/WebappLoader.java</column><column name="result">5:java/org/apache/catalina/core/StandardContext.java
21:java/org/apache/catalina/loader/WebappClassLoader.java
90:java/org/apache/catalina/loader/WebappLoader.java</column></table><table name="tomcat"><column name="id">650</column><column name="bug_id">49360</column><column name="summary">Context class reload fails for PersistentManager</column><column name="description">On context class reload tomcat fails with LifecycleException: An invalid Lifecycle transition was attempted ([before_start]) for component [org.apache.catalina.session.PersistentManager[/xxx]] in state [DESTROYED]</column><column name="report_time">2010-05-29 17:45:06</column><column name="report_timestamp">1275170000</column><column name="status">resolved fixed</column><column name="commit">ac22dd8</column><column name="commit_timestamp">1275330000</column><column name="files">java/org/apache/catalina/ha/session/BackupManager.java
java/org/apache/catalina/ha/session/DeltaManager.java
java/org/apache/catalina/session/PersistentManagerBase.java</column><column name="result">3:java/org/apache/catalina/session/PersistentManagerBase.java
12:java/org/apache/catalina/ha/session/DeltaManager.java
16:java/org/apache/catalina/ha/session/BackupManager.java</column></table><table name="tomcat"><column name="id">651</column><column name="bug_id">49340</column><column name="summary">Webapp unavailable after deploy then stop then start</column><column name="description">Occurs with tomcat 7.0 RC3 but not with 6.0.26 Using the manager/html : - deploy a war - test one of its page, it should be deployed properly - stop the webapp - start the webapp - test one of its page : FAILURE : tomcat returns a 404. Notes : - if using "reload" instead of stop/start it's OK, but it does not fix the unavailability - if the webapp is present when tomcat is started, then the stop/start works normally - The work around is to undeploy the webapp and redeploy it.</column><column name="report_time">2010-05-25 17:45:19</column><column name="report_timestamp">1274820000</column><column name="status">resolved fixed</column><column name="commit">0f669e3</column><column name="commit_timestamp">1275080000</column><column name="files">java/org/apache/catalina/connector/MapperListener.java</column><column name="result">283:java/org/apache/catalina/connector/MapperListener.java</column></table><table name="tomcat"><column name="id">652</column><column name="bug_id">49299</column><column name="summary">Servlet 3.0 ch.7.1.1 says that custom cookie name affects URL rewriting</column><column name="description">Created attachment 25442 cookiename.war In chapter 7.1.1 of servlet-3_0-final-spec.pdf it is said that "If a web application configures a custom name for its session tracking cookies, the same custom name will also be used as the name of the URI parameter if the session id is encoded in the URL (provided that URL rewriting has been enabled)." That is not true for the current trunk: the default "jsessionid" is used instead. I am attaching a war file that reproduces this issue. Steps to reproduce: 1. Deploy it as cookiename.war 2. Access http://localhost:8080/cookiename/ 3. Actual result: The page sends the following cookie: Set-Cookie: MYSESSIONCOOKIE=658C60E714E9C7C833F4FDA366E0477F; Path=/cookiename; HttpOnly but the Reload link on the page uses "jsessionid": http://localhost:8080/cookiename/index.jsp;jsessionid=658C60E714E9C7C833F4FDA366E0477F 4. Expected result: if that phrase in 7.1.1 is to be followed, I would expect the Reload link to be http://localhost:8080/cookiename/index.jsp;MYSESSIONCOOKIE=658C60E714E9C7C833F4FDA366E0477F</column><column name="report_time">2010-05-15 17:38:08</column><column name="report_timestamp">1273960000</column><column name="status">resolved fixed</column><column name="commit">9369636</column><column name="commit_timestamp">1274050000</column><column name="files">java/org/apache/catalina/Globals.java
java/org/apache/catalina/connector/CoyoteAdapter.java
java/org/apache/catalina/connector/Request.java
java/org/apache/catalina/connector/Response.java
java/org/apache/catalina/core/ApplicationSessionCookieConfig.java
java/org/apache/catalina/realm/RealmBase.java
test/org/apache/catalina/connector/TestCoyoteAdaptor.java</column><column name="result">2:java/org/apache/catalina/connector/Request.java
15:java/org/apache/catalina/connector/Response.java
28:java/org/apache/catalina/core/ApplicationSessionCookieConfig.java
60:java/org/apache/catalina/connector/CoyoteAdapter.java
82:java/org/apache/catalina/realm/RealmBase.java
399:java/org/apache/catalina/Globals.java</column></table><table name="tomcat"><column name="id">653</column><column name="bug_id">49290</column><column name="summary">Using a JarScanner with scanAllDirectories=true causes Tomcat 7 not to start</column><column name="description">Created attachment 25437 Possible "starter" patch to make ContextConfig tolerant of file URLs Currently ContextConfig's processServletContainerInitializers() and processResourceJARs() are hard coded to only accept jar URLs. If they encounter a file URL due to a JarScanner with scanAllDirectories=true, they throw a ClassCastException. The attached patch is what I used to update Tomcat 7 so it would start. I've verified that the modified processServletContainerInitializers() picks up the "javax.servlet.ServletContainerInitializer" file from a directory. As for processResourceJARs(), I was lazy and modified it to simply ignore file URLs as BaseDirContext doesn't currently accept non-jar URLs for these "META-INF/resources" locations. The Tomcat 7 support found in the Web Tools Platform would need this fixed (i.e. allow JarScanner with scanAllDirectories=true to be usable) for the feature of serving web application projects directly from the development workspace to work fully. The patch as is would be sufficient. A new feature in WTP 3.2 is multiple web content folders in web application projects. The Tomcat 7 support in WTP has to enable a customized FileDirContext to handle this. It's like VirtualDirContext, but with more hacks. It is able to handle the "META-INF/resources" from directories that processResourceJARs() currently doesn't. However, it may not get the order right. So it would be a benefit if processResourceJARs() could add file URLs to BaseDirContext as well as jar URLs. I'm marking the severity as major mainly be cause I have a bit of a deadline. I likely have a little less than a week to make the WTP change to use a JarScanner. Without it the web-fragment.xml files won't be picked up when serving projects directly from the workspace. However, this is all new "stuff". So there probably won't be a critical need for this feature. If I miss the deadline, I'll be able to fix it in the first WTP maintenance release which would be available in late September. Serving web application projects directly from the workspace on Tomcat 7 wouldn't be fully functional for just a few months. Addressing this later is also fine. Cheers, Larry</column><column name="report_time">2010-05-14 10:26:11</column><column name="report_timestamp">1273850000</column><column name="status">resolved fixed</column><column name="commit">a7b96d0</column><column name="commit_timestamp">1273960000</column><column name="files">java/org/apache/catalina/startup/ContextConfig.java</column><column name="result">6:java/org/apache/catalina/startup/ContextConfig.java</column></table><table name="tomcat"><column name="id">654</column><column name="bug_id">49221</column><column name="summary">javax.servlet.http.Cookie.setDomain uses default charset</column><column name="description">javax.servlet.http.Cookie.setDomain(String pattern) has the following code: domain = pattern.toLowerCase(); The result of this depends on the default Locale; it would be safer to use a fixed locale, e.g. Local.ENGLISH.</column><column name="report_time">2010-04-29 09:40:27</column><column name="report_timestamp">1272550000</column><column name="status">resolved fixed</column><column name="commit">05810ee</column><column name="commit_timestamp">1273660000</column><column name="files">java/javax/servlet/http/Cookie.java</column><column name="result">5:java/javax/servlet/http/Cookie.java</column></table><table name="tomcat"><column name="id">655</column><column name="bug_id">49224</column><column name="summary">NullPointerException in PooledConnection when username or password are null</column><column name="description">I'm using jdbc-pool (version 1.0.8.5) to connect to a DataSource requiring no authentication. Unless I explicitly set the username and password in the PoolProperties object to empty String (as opposed to leaving them null), a NullPointerException is thrown on lines 215 or 216 of PooledConnection.connectUsingDriver().</column><column name="report_time">2010-04-29 11:15:49</column><column name="report_timestamp">1272550000</column><column name="status">resolved fixed</column><column name="commit">4fff6c0</column><column name="commit_timestamp">1273660000</column><column name="files">modules/jdbc-pool/java/org/apache/tomcat/jdbc/pool/PooledConnection.java</column><column name="result">1:modules/jdbc-pool/java/org/apache/tomcat/jdbc/pool/PooledConnection.java</column></table><table name="tomcat"><column name="id">656</column><column name="bug_id">49226</column><column name="summary">toLowerCase()/toUpperCase() may not work OK in all Locales</column><column name="description">Created attachment 25373 Patch to use Locale.ENGLISH for case conversions</column><column name="report_time">2010-04-29 11:29:18</column><column name="report_timestamp">1272560000</column><column name="status">resolved fixed</column><column name="commit">5ad9ecd</column><column name="commit_timestamp">1273610000</column><column name="files">java/org/apache/catalina/core/ApplicationPart.java
java/org/apache/catalina/core/StandardEngine.java
java/org/apache/catalina/core/StandardHost.java
java/org/apache/catalina/deploy/FilterMap.java
java/org/apache/catalina/manager/HTMLManagerServlet.java
java/org/apache/catalina/manager/util/SessionUtils.java
java/org/apache/catalina/servlets/CGIServlet.java
java/org/apache/catalina/servlets/WebdavServlet.java
java/org/apache/catalina/ssi/ResponseIncludeWrapper.java
java/org/apache/catalina/ssi/SSIMediator.java
java/org/apache/catalina/ssi/SSIProcessor.java
java/org/apache/catalina/ssi/SSIServlet.java
java/org/apache/catalina/ssi/SSIServletExternalResolver.java
java/org/apache/catalina/startup/ClassLoaderFactory.java
java/org/apache/catalina/startup/ContextConfig.java
java/org/apache/catalina/startup/HostConfig.java
java/org/apache/catalina/util/ExtensionValidator.java
java/org/apache/catalina/util/MIME2Java.java
java/org/apache/tomcat/util/buf/MessageBytes.java
java/org/apache/tomcat/util/http/AcceptLanguage.java
java/org/apache/tomcat/util/http/fileupload/FileItemHeadersImpl.java
java/org/apache/tomcat/util/http/fileupload/FileUploadBase.java
java/org/apache/tomcat/util/http/fileupload/ParameterParser.java
java/org/apache/tomcat/util/http/fileupload/ServletFileUpload.java
java/org/apache/tomcat/util/modeler/OperationInfo.java
java/org/apache/tomcat/util/net/URL.java
java/org/apache/tomcat/util/net/jsse/JSSESocketFactory.java
webapps/examples/WEB-INF/classes/examples/ShowSource.java
webapps/examples/WEB-INF/classes/jsp2/examples/el/Functions.java</column><column name="result">2:java/org/apache/tomcat/util/buf/MessageBytes.java
7:webapps/examples/WEB-INF/classes/jsp2/examples/el/Functions.java
12:java/org/apache/catalina/ssi/SSIMediator.java
13:java/org/apache/catalina/manager/util/SessionUtils.java
15:java/org/apache/catalina/core/StandardHost.java
16:java/org/apache/catalina/util/ExtensionValidator.java
18:java/org/apache/catalina/startup/HostConfig.java
22:java/org/apache/catalina/startup/ContextConfig.java
26:java/org/apache/tomcat/util/modeler/OperationInfo.java
29:java/org/apache/catalina/manager/HTMLManagerServlet.java
30:java/org/apache/tomcat/util/http/fileupload/ServletFileUpload.java
32:java/org/apache/catalina/deploy/FilterMap.java
33:java/org/apache/catalina/core/StandardEngine.java
34:java/org/apache/catalina/ssi/ResponseIncludeWrapper.java
35:java/org/apache/tomcat/util/http/fileupload/FileItemHeadersImpl.java
36:webapps/examples/WEB-INF/classes/examples/ShowSource.java
41:java/org/apache/catalina/servlets/WebdavServlet.java
46:java/org/apache/catalina/ssi/SSIServlet.java
55:java/org/apache/tomcat/util/http/fileupload/FileUploadBase.java
58:java/org/apache/tomcat/util/http/fileupload/ParameterParser.java
67:java/org/apache/catalina/core/ApplicationPart.java
81:java/org/apache/catalina/startup/ClassLoaderFactory.java
91:java/org/apache/catalina/ssi/SSIServletExternalResolver.java
94:java/org/apache/tomcat/util/net/jsse/JSSESocketFactory.java
96:java/org/apache/catalina/ssi/SSIProcessor.java
120:java/org/apache/tomcat/util/http/AcceptLanguage.java
125:java/org/apache/catalina/servlets/CGIServlet.java
131:java/org/apache/catalina/util/MIME2Java.java
159:java/org/apache/tomcat/util/net/URL.java</column></table><table name="tomcat"><column name="id">657</column><column name="bug_id">49227</column><column name="summary">toLowerCase()/toUpperCase() may not work OK in all Locales</column><column name="description">Created attachment 25374 Patch to use Locale.ENGLISH for case conversions</column><column name="report_time">2010-04-29 11:30:31</column><column name="report_timestamp">1272560000</column><column name="status">resolved fixed</column><column name="commit">09abffb</column><column name="commit_timestamp">1273610000</column><column name="files">java/org/apache/coyote/http11/Http11AprProcessor.java
java/org/apache/coyote/http11/Http11NioProcessor.java
java/org/apache/coyote/http11/Http11Processor.java</column><column name="result">68:java/org/apache/coyote/http11/Http11AprProcessor.java
69:java/org/apache/coyote/http11/Http11Processor.java
80:java/org/apache/coyote/http11/Http11NioProcessor.java</column></table><table name="tomcat"><column name="id">658</column><column name="bug_id">49228</column><column name="summary">toLowerCase()/toUpperCase() may not work OK in all Locales</column><column name="description">Created attachment 25375 Patch to use Locale.ENGLISH for case conversions</column><column name="report_time">2010-04-29 11:31:40</column><column name="report_timestamp">1272560000</column><column name="status">resolved fixed</column><column name="commit">a954806</column><column name="commit_timestamp">1273590000</column><column name="files">java/org/apache/jasper/compiler/Validator.java
java/org/apache/jasper/tagplugins/jstl/Util.java</column><column name="result">4:java/org/apache/jasper/tagplugins/jstl/Util.java
78:java/org/apache/jasper/compiler/Validator.java</column></table><table name="tomcat"><column name="id">659</column><column name="bug_id">49235</column><column name="summary">ServletContainerInitializer onStartup(Set&lt;Class&lt;?&gt;&gt; classSet is not expect class</column><column name="description">I builder tomcat 7.0.0 from svn r939221 below is my code: @MySomeAnn public class MySomeClass{...} @HandlesTypes(MySomeAnn.class) public class ModuleInitializer implements ServletContainerInitializer { @Override public void onStartup(Set&gt; classSet, ServletContext ctx) throws ServletException { for (Class targetClass : classSet) { System.out.println(targetClass.getName()); ... Here output is "MySomeAnn". But I expect output "MySomeClass". It's not yet imp Servlet 3.0 spec. My code work fine on Glassfish 3.0. The output is "MySomeClass".</column><column name="report_time">2010-04-30 03:08:29</column><column name="report_timestamp">1272610000</column><column name="status">resolved fixed</column><column name="commit">4a581aa</column><column name="commit_timestamp">1273590000</column><column name="files">java/org/apache/catalina/startup/ContextConfig.java</column><column name="result">3:java/org/apache/catalina/startup/ContextConfig.java</column></table><table name="tomcat"><column name="id">660</column><column name="bug_id">49240</column><column name="summary">Error thrown during detection of ServletContainerInitializer's</column><column name="description">ContextConfig.checkHandlesTypes() throws a NoClassDefFoundError, which isn't caught, when the class being analysed is initialised if the class, or a class that it references(?), is not present in the classpath. E.g. When a mysql connector/j jar (v5.x) is scanned, an attempt to load the following class occurs: com.mchange.v2.c3p0.QueryConnectionTester java.lang.NoClassDefFoundError: com/mchange/v2/c3p0/QueryConnectionTester 	at java.lang.ClassLoader.defineClass1(Native Method) 	at java.lang.ClassLoader.defineClass(ClassLoader.java:698) 	at java.security.SecureClassLoader.defineClass(SecureClassLoader.java:124) 	at java.net.URLClassLoader.defineClass(URLClassLoader.java:260) 	at java.net.URLClassLoader.access$000(URLClassLoader.java:56) 	at java.net.URLClassLoader$1.run(URLClassLoader.java:195) 	at java.security.AccessController.doPrivileged(Native Method) 	at java.net.URLClassLoader.findClass(URLClassLoader.java:188) 	at java.lang.ClassLoader.loadClass(ClassLoader.java:315) 	at java.lang.ClassLoader.loadClass(ClassLoader.java:250) 	at java.lang.ClassLoader.loadClassInternal(ClassLoader.java:398) 	at java.lang.Class.forName0(Native Method) 	at java.lang.Class.forName(Class.java:247) Also Class.forName is used here, referencing the WebappClassLoader, instead of calling WebappClassLoader.loadClass() directly.</column><column name="report_time">2010-05-01 07:46:16</column><column name="report_timestamp">1272710000</column><column name="status">resolved fixed</column><column name="commit">f24ed2d</column><column name="commit_timestamp">1273570000</column><column name="files">java/org/apache/catalina/startup/ContextConfig.java</column><column name="result">1:java/org/apache/catalina/startup/ContextConfig.java</column></table><table name="tomcat"><column name="id">661</column><column name="bug_id">49269</column><column name="summary">Shouldn't see maxIdle &gt; maxActive message with default props</column><column name="description">In PoolProperties, the default value for maxIdle is Integer.MAX_VALUE and the default for maxActive is 100. This results in a warning message being logged and the value for maxIdle set to match maxActive on lines 393/394 of ConnectionPool. The default for maxIdle should match that of maxActive.</column><column name="report_time">2010-05-10 14:32:07</column><column name="report_timestamp">1273520000</column><column name="status">resolved fixed</column><column name="commit">27a3909</column><column name="commit_timestamp">1273560000</column><column name="files">modules/jdbc-pool/java/org/apache/tomcat/jdbc/pool/PoolProperties.java</column><column name="result">2:modules/jdbc-pool/java/org/apache/tomcat/jdbc/pool/PoolProperties.java</column></table><table name="tomcat"><column name="id">662</column><column name="bug_id">49241</column><column name="summary">DataSourceFactory.parsePoolProperties() doesn't look for "suspectTimeout"</column><column name="description">If you call the DataSourceFactory.parsePoolProperties() method, passing in a Properties object with the "suspectTimeout" property set, that key/value pair is never passed on to the PoolProperties.setSuspectTimeout() method.</column><column name="report_time">2010-05-01 21:01:46</column><column name="report_timestamp">1272760000</column><column name="status">resolved fixed</column><column name="commit">b75b021</column><column name="commit_timestamp">1272910000</column><column name="files">modules/jdbc-pool/java/org/apache/tomcat/jdbc/pool/DataSourceFactory.java</column><column name="result">2:modules/jdbc-pool/java/org/apache/tomcat/jdbc/pool/DataSourceFactory.java</column></table><table name="tomcat"><column name="id">663</column><column name="bug_id">49092</column><column name="summary">util.IntrospectionUtils.PATH_SEPARATOR should be final</column><column name="description">The field org.apache.tomcat.util.IntrospectionUtils.PATH_SEPARATOR should be final.</column><column name="report_time">2010-04-11 22:37:12</column><column name="report_timestamp">1271040000</column><column name="status">resolved fixed</column><column name="commit">616bd68</column><column name="commit_timestamp">1272730000</column><column name="files">test/org/apache/catalina/tribes/demos/IntrospectionUtils.java</column><column name="result">2:test/org/apache/catalina/tribes/demos/IntrospectionUtils.java</column></table><table name="tomcat"><column name="id">664</column><column name="bug_id">49207</column><column name="summary">Filter name not set when dynamically added</column><column name="description">When dynamically adding a Filter the name is not set when calling the method "addMappingForUrlPatterns" in ApplicationFilterRegistration.java. java.lang.IllegalArgumentException: Filter mapping specifies an unknown filter name null 	at org.apache.catalina.core.StandardContext.validateFilterMap(StandardContext.java:2650) 	at org.apache.catalina.core.StandardContext.addFilterMapBefore(StandardContext.java:2622) 	at org.apache.catalina.core.ApplicationFilterRegistration.addMappingForUrlPatterns(ApplicationFilterRegistration.java:102) 	at org.pidster.tomcat.test7.dyn.TestDynamicsListener.contextInitialized(TestDynamicsListener.java:105)</column><column name="report_time">2010-04-28 05:40:52</column><column name="report_timestamp">1272450000</column><column name="status">resolved fixed</column><column name="commit">3396917</column><column name="commit_timestamp">1272470000</column><column name="files">java/org/apache/catalina/core/ApplicationFilterRegistration.java</column><column name="result">2:java/org/apache/catalina/core/ApplicationFilterRegistration.java</column></table><table name="tomcat"><column name="id">665</column><column name="bug_id">49184</column><column name="summary">Index out of bounds exception thrown when dynamically adding Filter</column><column name="description">When dynamically adding a filter to a context an exception is thrown. java.lang.ArrayIndexOutOfBoundsException 	at java.lang.System.arraycopy(Native Method) 	at org.apache.catalina.core.StandardContext.addFilterMapBefore(StandardContext.java:2629) 	at org.apache.catalina.core.ApplicationFilterRegistration.addMappingForServletNames(ApplicationFilterRegistration.java:75)</column><column name="report_time">2010-04-25 08:54:34</column><column name="report_timestamp">1272200000</column><column name="status">resolved fixed</column><column name="commit">3f4a241</column><column name="commit_timestamp">1272270000</column><column name="files">java/org/apache/catalina/core/StandardContext.java</column><column name="result">1:java/org/apache/catalina/core/StandardContext.java</column></table><table name="tomcat"><column name="id">666</column><column name="bug_id">48689</column><column name="summary">Jar abstraction for Jasper</column><column name="description">Jasper can load TLD files through the ServletContext or from a Jar file. To load TLDs from Jar file, an URL to a Jar file must be passed. However, in some environments (e.g. in OSGi) it might not be easy to provide an URL to a jar file. It would be nice to abstract the way Jasper is looking up the embedded TLDs so that different ways of looking up TLDs within Jar files or Bundles or whatever could be used.</column><column name="report_time">2010-02-05 12:30:40</column><column name="report_timestamp">1265390000</column><column name="status">resolved fixed</column><column name="commit">efd418b</column><column name="commit_timestamp">1272200000</column><column name="files">java/org/apache/jasper/JspCompilationContext.java
java/org/apache/jasper/compiler/ImplicitTagLibraryInfo.java
java/org/apache/jasper/compiler/JarResource.java
java/org/apache/jasper/compiler/JarURLResource.java
java/org/apache/jasper/compiler/JspDocumentParser.java
java/org/apache/jasper/compiler/Parser.java
java/org/apache/jasper/compiler/ParserController.java
java/org/apache/jasper/compiler/TagFileProcessor.java
java/org/apache/jasper/compiler/TagLibraryInfoImpl.java
java/org/apache/jasper/compiler/TldLocation.java
java/org/apache/jasper/compiler/TldLocationsCache.java
java/org/apache/jasper/servlet/JspServletWrapper.java</column><column name="result">2:java/org/apache/jasper/compiler/TldLocationsCache.java
5:java/org/apache/jasper/JspCompilationContext.java
11:java/org/apache/jasper/servlet/JspServletWrapper.java
20:java/org/apache/jasper/compiler/TagFileProcessor.java
31:java/org/apache/jasper/compiler/TagLibraryInfoImpl.java
36:java/org/apache/jasper/compiler/ParserController.java
66:java/org/apache/jasper/compiler/Parser.java
112:java/org/apache/jasper/compiler/ImplicitTagLibraryInfo.java
240:java/org/apache/jasper/compiler/JspDocumentParser.java</column></table><table name="tomcat"><column name="id">667</column><column name="bug_id">49140</column><column name="summary">Inefficient use of keySet() iterator in StandardContext.java</column><column name="description">Created attachment 25316 Change keySet() Iterator to values() The loadOnStartup(Container[]) method of StandardContext loops on the keySet() but actually only uses the key to get the values, so it would be more efficient to use the values() Iterator. According to the Javadoc, the keySet() and values() iterators generate the entries in the same order (key ascending). Findbugs detected another 6 such instances for which I can provide patches if required.</column><column name="report_time">2010-04-16 21:14:48</column><column name="report_timestamp">1271470000</column><column name="status">resolved fixed</column><column name="commit">b30fc95</column><column name="commit_timestamp">1272040000</column><column name="files">java/org/apache/catalina/connector/Request.java
java/org/apache/catalina/core/ApplicationHttpRequest.java
java/org/apache/catalina/core/StandardContext.java
java/org/apache/catalina/ha/authenticator/ClusterSingleSignOnListener.java
java/org/apache/catalina/ha/session/ClusterSessionListener.java
java/org/apache/catalina/startup/ContextConfig.java</column><column name="result">1:java/org/apache/catalina/core/StandardContext.java
3:java/org/apache/catalina/connector/Request.java
26:java/org/apache/catalina/startup/ContextConfig.java
32:java/org/apache/catalina/core/ApplicationHttpRequest.java
86:java/org/apache/catalina/ha/authenticator/ClusterSingleSignOnListener.java
106:java/org/apache/catalina/ha/session/ClusterSessionListener.java</column></table><table name="tomcat"><column name="id">668</column><column name="bug_id">49143</column><column name="summary">Possible incorrect lazy initialisations</column><column name="description">Incorrect lazy initialization of static field: org.apache.catalina.realm.RealmBase.md5Helper org.apache.catalina.session.StandardSession.sessionContext org.apache.catalina.startup.TldConfig.noTldJars org.apache.catalina.util.ExtensionValidator.containerAvailableExtensions org.apache.tomcat.util.modeler.modules.MbeansDescriptorsDigesterSource.digester fields should probably all be made volatile</column><column name="report_time">2010-04-16 21:44:52</column><column name="report_timestamp">1271470000</column><column name="status">resolved fixed</column><column name="commit">a6092d7</column><column name="commit_timestamp">1272030000</column><column name="files">java/org/apache/catalina/realm/RealmBase.java
java/org/apache/catalina/session/StandardSession.java
java/org/apache/catalina/startup/TldConfig.java
java/org/apache/catalina/util/ExtensionValidator.java
java/org/apache/tomcat/util/modeler/modules/MbeansDescriptorsDigesterSource.java</column><column name="result">1:java/org/apache/catalina/startup/TldConfig.java
5:java/org/apache/tomcat/util/modeler/modules/MbeansDescriptorsDigesterSource.java
6:java/org/apache/catalina/session/StandardSession.java
7:java/org/apache/catalina/util/ExtensionValidator.java
9:java/org/apache/catalina/realm/RealmBase.java</column></table><table name="tomcat"><column name="id">669</column><column name="bug_id">49144</column><column name="summary">Incorrect lazy initialization and update of static fields?</column><column name="description">Incorrect lazy initialization and update of static fields: org.apache.catalina.startup.Bootstrap.daemon org.apache.catalina.startup.ContextConfig.contextDigester Findbugs says: This method contains an unsynchronized lazy initialization of a static field. After the field is set, the object stored into that location is further updated or accessed. The setting of the field is visible to other threads as soon as it is set. If the futher accesses in the method that set the field serve to initialize the object, then you have a very serious multithreading bug, unless something else prevents any other thread from accessing the stored object until it is fully initialized. Even if you feel confident that the method is never called by multiple threads, it might be better to not set the static field until the value you are setting it to is fully populated/initialized.</column><column name="report_time">2010-04-16 21:47:20</column><column name="report_timestamp">1271470000</column><column name="status">resolved fixed</column><column name="commit">fd7ed83</column><column name="commit_timestamp">1272030000</column><column name="files">java/org/apache/catalina/startup/Bootstrap.java</column><column name="result">1:java/org/apache/catalina/startup/Bootstrap.java</column></table><table name="tomcat"><column name="id">670</column><column name="bug_id">49164</column><column name="summary">junit test ignores failures in threads</column><column name="description">Created attachment 25328 channel exceptions from different threads to main junit thread org.apache.catalina.tribes.test.interceptors.TestOrderInterceptor#testOrder2 starts a few threads to test concurrently sending events to one destination. It tries to make the junit test case fail in case of an exception. Junit will not see those failures, since they are in different threads. Attached patch will channel the exception to main junit thread, which can call fail() if exceptions were catched. It will log only the first exception in the queue.</column><column name="report_time">2010-04-21 14:08:24</column><column name="report_timestamp">1271870000</column><column name="status">resolved fixed</column><column name="commit">aa758d8</column><column name="commit_timestamp">1272030000</column><column name="files">test/org/apache/catalina/tribes/test/interceptors/TestOrderInterceptor.java</column><column name="result">140:test/org/apache/catalina/tribes/test/interceptors/TestOrderInterceptor.java</column></table><table name="tomcat"><column name="id">671</column><column name="bug_id">49171</column><column name="summary">Avoid raw type warning in TagSupport</column><column name="description">Created attachment 25334 Simple fix to suppress raw-type warning (does not affect API!)</column><column name="report_time">2010-04-22 07:10:06</column><column name="report_timestamp">1271930000</column><column name="status">resolved fixed</column><column name="commit">8bd4d7a</column><column name="commit_timestamp">1272030000</column><column name="files">java/javax/servlet/jsp/tagext/TagSupport.java</column><column name="result">1:java/javax/servlet/jsp/tagext/TagSupport.java</column></table><table name="tomcat"><column name="id">672</column><column name="bug_id">49170</column><column name="summary">Transmission of duplicated session in DeltaManager#handleGET_ALL_SESSIONS.</column><column name="description">Created attachment 25333 patch against trunk. Config &lt;Manager className="org.apache.catalina.ha.session.DeltaManager" sendAllSessions="false" sendAllSessionsSize="XXXX" /&gt; DeltaManager#handleGET_ALL_SESSIONS is as follows. ===== ...skip... if (isSendAllSessions()) { sendSessions(sender, currentSessions, findSessionTimestamp); } else { // send session at blocks int len = currentSessions.length &lt; getSendAllSessionsSize() ? currentSessions.length : getSendAllSessionsSize(); Session[] sendSessions = new Session[len]; for (int i = 0; i &lt; currentSessions.length; i += getSendAllSessionsSize()) { len = i + getSendAllSessionsSize() &gt; currentSessions.length ? currentSessions.length - i : getSendAllSessionsSize(); System.arraycopy(currentSessions, i, sendSessions, 0, len); sendSessions(sender, sendSessions,findSessionTimestamp); ...skip... } ...skip... } ===== sendSessions maintains previous Session. For instance, currentSessions=[ssA, ssB, ssC, ssD, ssE] sendAllSessionsSize=3 loop1 : sendSessions=[ssA, ssB, ssC] loop2 : sendSessions=[ssD, ssE, ssC] ssC is transmitted two times. It should be the following. loop1 : sendSessions=[ssA, ssB, ssC] loop2 : sendSessions=[ssD, ssE] This problem exists in TC5.5, TC6.0, and TC7.0. I made a patch against trunk. Best Regards.</column><column name="report_time">2010-04-22 06:54:01</column><column name="report_timestamp">1271930000</column><column name="status">resolved fixed</column><column name="commit">f61100d</column><column name="commit_timestamp">1271930000</column><column name="files">java/org/apache/catalina/ha/session/DeltaManager.java</column><column name="result">1:java/org/apache/catalina/ha/session/DeltaManager.java</column></table><table name="tomcat"><column name="id">673</column><column name="bug_id">43642</column><column name="summary">Add prestartminSpareThreads attribute for Executor</column><column name="description">The attached patch adds the boolean attribute prestartminSpareThreads to the Executor element. This allows the admin to prestart minspareThreads for this Executor during the start of Tomcat. The default value is false which is the old behaviour. A documentation patch for executor.xml can be created if there is interest in committing this patch.</column><column name="report_time">2007-10-17 08:00:46</column><column name="report_timestamp">1192620000</column><column name="status">resolved fixed</column><column name="commit">e7fb8fa</column><column name="commit_timestamp">1271850000</column><column name="files">java/org/apache/catalina/core/StandardThreadExecutor.java</column><column name="result">1:java/org/apache/catalina/core/StandardThreadExecutor.java</column></table><table name="tomcat"><column name="id">674</column><column name="bug_id">49141</column><column name="summary">Impossible cast in naming.factory.SendMailFactory.getObjectInstance</column><column name="description">naming.factory.SendMailFactory.getObjectInstance contains an impossible cast from javax.mail.internet.MimeMessage to javax.mail.internet.MimePart [Findbugs]</column><column name="report_time">2010-04-16 21:21:03</column><column name="report_timestamp">1271470000</column><column name="status">resolved fixed</column><column name="commit">7205c74</column><column name="commit_timestamp">1271790000</column><column name="files">java/javax/mail/internet/MimeMessage.java</column><column name="result">3:java/javax/mail/internet/MimeMessage.java</column></table><table name="tomcat"><column name="id">675</column><column name="bug_id">49151</column><column name="summary">ClassCastException in BackupManager#stopInternal.</column><column name="description">In BackupManager#startInternal, When constructor of LazyReplicatedMap throws exception, sessions is not LazyReplicatedMap. Actually, AbstractReplicatedMap#init has the possibility of throwing RuntimeException. In BackupManager#stopInternal ClassCastException is thrown because AbstractReplicatedMap#breakdown is executed regardless of the type of sessions. should be changed as follows to avoid ClassCastException. === skip. if (sessions instanceof LazyReplicatedMap) { LazyReplicatedMap map = (LazyReplicatedMap)sessions; if ( map!=null ) { map.breakdown(); } } skip. === This problem exists in Tomcat7.0 and 6.0. Best Regards.</column><column name="report_time">2010-04-19 05:02:32</column><column name="report_timestamp">1271670000</column><column name="status">resolved fixed</column><column name="commit">fcb9861</column><column name="commit_timestamp">1271670000</column><column name="files">java/org/apache/catalina/ha/session/BackupManager.java</column><column name="result">1:java/org/apache/catalina/ha/session/BackupManager.java</column></table><table name="tomcat"><column name="id">676</column><column name="bug_id">49150</column><column name="summary">All primary sessions are deleted at BackupManager#stopInternal.</column><column name="description">BackupManager#stopInternal is as follows. ===== protected synchronized void stopInternal() throws LifecycleException { super.stopInternal(); LazyReplicatedMap map = (LazyReplicatedMap)sessions; if ( map!=null ) { map.breakdown(); } cluster.removeManager(this); } ===== In Tomcat 7.0.0 RC1, super#stopInternal() is called first. In StandardManager#stopInternal() of the super class, The session is stored, and expire all active sessions. Storing session is unnecessary in BackupManager. and When the session expired, the session is deleted from all cluster nodes. As a Result, All primary sessions (of own node has) are deleted from all cluster nodes. For instance, Node1 : sessionA(primary), sessionB(proxy), sessionC(backup) Node2 : sessionA(backup), sessionB(primary), sessionC(proxy) Node3 : sessionA(proxy), sessionB(backup), sessionC(primary) If Node1 is stopped, it becomes the following. Node1 : stopped Node2 : sessionB(primary), sessionC(backup) Node3 : sessionB(backup), sessionC(primary) sessionA is expired. It should be the following. Node1 : stopped Node2 : sessionA(primary), sessionB(primary), sessionC(backup) Node3 : sessionA(backup), sessionB(backup), sessionC(primary) There is no problem in Tomcat6.0.x, because it executes super.stop() after LazyReplicatedMap#breakdown() . I made a patch against trunk. Best Regards.</column><column name="report_time">2010-04-19 03:37:08</column><column name="report_timestamp">1271660000</column><column name="status">resolved fixed</column><column name="commit">09f4e25</column><column name="commit_timestamp">1271670000</column><column name="files">java/org/apache/catalina/ha/session/BackupManager.java</column><column name="result">1:java/org/apache/catalina/ha/session/BackupManager.java</column></table><table name="tomcat"><column name="id">677</column><column name="bug_id">49129</column><column name="summary">DigestAuthenticator.md5Helper - possible incorrect lazy initialisation</column><column name="description">Findbugs says: "This method contains an unsynchronized lazy initialization of a non-volatile static field. Because the compiler or processor may reorder instructions, threads are not guaranteed to see a completely initialized object, if the method can be called by multiple threads. You can make the field volatile to correct the problem."</column><column name="report_time">2010-04-14 19:09:31</column><column name="report_timestamp">1271290000</column><column name="status">resolved fixed</column><column name="commit">867605f</column><column name="commit_timestamp">1271290000</column><column name="files">java/org/apache/catalina/authenticator/DigestAuthenticator.java</column><column name="result">1:java/org/apache/catalina/authenticator/DigestAuthenticator.java</column></table><table name="tomcat"><column name="id">678</column><column name="bug_id">49118</column><column name="summary">Inefficient use of String concatenation in loop</column><column name="description">Created attachment 25293 Patch to use StringBuilder instead of +=String HttpServlet toTrace method concatenates Strings in a loop; this is very inefficient.</column><column name="report_time">2010-04-14 05:40:15</column><column name="report_timestamp">1271240000</column><column name="status">resolved fixed</column><column name="commit">95a2eb8</column><column name="commit_timestamp">1271290000</column><column name="files">java/javax/servlet/http/HttpServlet.java</column><column name="result">68:java/javax/servlet/http/HttpServlet.java</column></table><table name="tomcat"><column name="id">679</column><column name="bug_id">49110</column><column name="summary">runtime.JspFactoryImpl$PageContextPool needs to be static</column><column name="description">Findbugs says: Bug: org.apache.jasper.runtime.JspFactoryImpl$PageContextPool needs to be _static_ to avoid a deadly embrace with org.apache.jasper.runtime.JspFactoryImpl.localPool Pattern id: SIC_THREADLOCAL_DEADLY_EMBRACE, type: SIC, category: CORRECTNESS This class is an inner class, but should probably be a static inner class. As it is, there is a serious danger of a deadly embrace between the inner class and the thread local in the outer class. Because the inner class isn't static, it retains a reference to the outer class. If the thread local contains a reference to an instance of the inner class, the inner and outer instance will both be reachable and not eligible for garbage collection.</column><column name="report_time">2010-04-12 19:50:48</column><column name="report_timestamp">1271120000</column><column name="status">resolved fixed</column><column name="commit">b027259</column><column name="commit_timestamp">1271290000</column><column name="files">java/org/apache/jasper/runtime/JspFactoryImpl.java</column><column name="result">1:java/org/apache/jasper/runtime/JspFactoryImpl.java</column></table><table name="tomcat"><column name="id">680</column><column name="bug_id">49109</column><column name="summary">RealmBase.authenticate uses toString on byte array</column><column name="description">catalina.realm.RealmBase.authenticate(String username, byte[] credentials) has the following code: return (authenticate(username, credentials.toString())); This looks wrong, as credentials is a byte array. It should probably be: return (authenticate(username, new String(credentials[,charset])));</column><column name="report_time">2010-04-12 19:36:53</column><column name="report_timestamp">1271120000</column><column name="status">resolved fixed</column><column name="commit">bcf0a01</column><column name="commit_timestamp">1271280000</column><column name="files">java/org/apache/catalina/Realm.java
java/org/apache/catalina/realm/CombinedRealm.java
java/org/apache/catalina/realm/LockOutRealm.java
java/org/apache/catalina/realm/RealmBase.java</column><column name="result">1:java/org/apache/catalina/realm/RealmBase.java
2:java/org/apache/catalina/Realm.java
4:java/org/apache/catalina/realm/CombinedRealm.java
9:java/org/apache/catalina/realm/LockOutRealm.java</column></table><table name="tomcat"><column name="id">681</column><column name="bug_id">49106</column><column name="summary">Unused imports</column><column name="description">Created attachment 25273 Unused imports - patch</column><column name="report_time">2010-04-12 19:01:41</column><column name="report_timestamp">1271110000</column><column name="status">resolved fixed</column><column name="commit">f8d3565</column><column name="commit_timestamp">1271280000</column><column name="files">java/org/apache/catalina/realm/JNDIRealm.java</column><column name="result">116:java/org/apache/catalina/realm/JNDIRealm.java</column></table><table name="tomcat"><column name="id">682</column><column name="bug_id">49105</column><column name="summary">Javadoc corrections</column><column name="description">Created attachment 25272 Javadoc corrections - includes some deletions of misplaced docn</column><column name="report_time">2010-04-12 19:00:58</column><column name="report_timestamp">1271110000</column><column name="status">resolved fixed</column><column name="commit">ead3997</column><column name="commit_timestamp">1271280000</column><column name="files">java/javax/el/ExpressionFactory.java
java/javax/servlet/HttpConstraintElement.java
java/javax/servlet/ServletContext.java
java/org/apache/catalina/Context.java
java/org/apache/catalina/Host.java
java/org/apache/catalina/Lifecycle.java
java/org/apache/catalina/Session.java
java/org/apache/catalina/authenticator/FormAuthenticator.java
java/org/apache/catalina/connector/Request.java
java/org/apache/catalina/core/ApplicationSessionCookieConfig.java
java/org/apache/catalina/core/ContainerBase.java
java/org/apache/catalina/core/StandardContext.java
java/org/apache/catalina/session/StandardSession.java
java/org/apache/catalina/tribes/ChannelListener.java
java/org/apache/catalina/tribes/group/RpcChannel.java
java/org/apache/el/parser/AstValue.java
java/org/apache/jasper/compiler/Node.java
webapps/examples/WEB-INF/classes/chat/ChatServlet.java
webapps/examples/WEB-INF/classes/filters/ExampleFilter.java
webapps/examples/WEB-INF/classes/filters/SetCharacterEncodingFilter.java</column><column name="result">4:java/org/apache/catalina/core/StandardContext.java
28:java/org/apache/catalina/authenticator/FormAuthenticator.java
30:java/javax/servlet/ServletContext.java
61:java/org/apache/catalina/connector/Request.java
63:java/org/apache/catalina/session/StandardSession.java
92:java/org/apache/jasper/compiler/Node.java
134:java/org/apache/el/parser/AstValue.java
151:java/org/apache/catalina/core/ContainerBase.java
347:java/org/apache/catalina/Host.java
363:java/org/apache/catalina/tribes/ChannelListener.java
456:java/org/apache/catalina/tribes/group/RpcChannel.java
515:java/javax/el/ExpressionFactory.java</column></table><table name="tomcat"><column name="id">683</column><column name="bug_id">49104</column><column name="summary">Fix up some raw types</column><column name="description">Created attachment 25271 Fix up some raw types</column><column name="report_time">2010-04-12 18:59:00</column><column name="report_timestamp">1271110000</column><column name="status">resolved fixed</column><column name="commit">5be4f29</column><column name="commit_timestamp">1271280000</column><column name="files">java/org/apache/coyote/ajp/AjpProtocol.java
java/org/apache/coyote/http11/Http11Protocol.java
java/org/apache/tomcat/util/net/JIoEndpoint.java</column><column name="result">142:java/org/apache/coyote/http11/Http11Protocol.java
240:java/org/apache/coyote/ajp/AjpProtocol.java
248:java/org/apache/tomcat/util/net/JIoEndpoint.java</column></table><table name="tomcat"><column name="id">684</column><column name="bug_id">49103</column><column name="summary">Missing annotations</column><column name="description">Created attachment 25270 Add missing annotations</column><column name="report_time">2010-04-12 18:57:56</column><column name="report_timestamp">1271110000</column><column name="status">resolved fixed</column><column name="commit">1018cd7</column><column name="commit_timestamp">1271280000</column><column name="files">java/org/apache/coyote/http11/Http11NioProtocol.java
java/org/apache/coyote/http11/Http11Protocol.java
java/org/apache/tomcat/util/net/AprEndpoint.java
java/org/apache/tomcat/util/net/NioEndpoint.java
java/org/apache/tomcat/util/net/jsse/JSSEImplementation.java</column><column name="result">108:java/org/apache/tomcat/util/net/NioEndpoint.java
109:java/org/apache/coyote/http11/Http11NioProtocol.java
146:java/org/apache/coyote/http11/Http11Protocol.java
426:java/org/apache/tomcat/util/net/jsse/JSSEImplementation.java
523:java/org/apache/tomcat/util/net/AprEndpoint.java</column></table><table name="tomcat"><column name="id">685</column><column name="bug_id">49045</column><column name="summary">JMX Enhancement- Provision of MBeanFactory createStandardService</column><column name="description">Currently MBeanFactory doesn't have a method for creating a new StandardService MBean. This would become an issue for future enhancements of JMX support in Tomcat. As per discussions with Mark, this enhancement is suggested as a starting point for possible future enhancements in JMX support.</column><column name="report_time">2010-04-04 05:40:57</column><column name="report_timestamp">1270370000</column><column name="status">resolved fixed</column><column name="commit">32046eb</column><column name="commit_timestamp">1271250000</column><column name="files">java/org/apache/catalina/mbeans/MBeanFactory.java</column><column name="result">1:java/org/apache/catalina/mbeans/MBeanFactory.java</column></table><table name="tomcat"><column name="id">686</column><column name="bug_id">49089</column><column name="summary">ChannelData.USE_SECURE_RANDOM_FOR_UUID public static mutable field</column><column name="description">catalina.tribes.io.ChannelData.USE_SECURE_RANDOM_FOR_UUID is a mutable public static field. It's only used by an instance method, so there's no need for it to be static. Probably no need for it to be public either; it could be a private field with a setter - or better a final field set by the constructor.</column><column name="report_time">2010-04-11 22:24:38</column><column name="report_timestamp">1271040000</column><column name="status">resolved fixed</column><column name="commit">cb0b029</column><column name="commit_timestamp">1271240000</column><column name="files">java/org/apache/catalina/tribes/io/ChannelData.java</column><column name="result">1:java/org/apache/catalina/tribes/io/ChannelData.java</column></table><table name="tomcat"><column name="id">687</column><column name="bug_id">49116</column><column name="summary">Memory leak by HttpSession.</column><column name="description">When session is stored in StandardManager#doUnload method, an invalid session is stored. For instance, If HttpSession#invalidate is executed while executing StandardManager#doUnload, session of "isValid=false" is stored. The session of isValid=false is restored in StandardManager#doLoad, and it registers in session map (sessions). However, no one can invalidate this session. If isValid is false, StandardSession#invalidate() and StandardSession#isValid() can not expire session. They are throws IllegalStateException or return immediately. Consequently, the session of isValid=false is never deleted from the session map(sessions). I made a patch. If session is already invalid, expire session to prevent memory leak. Best Regards. Keiichi.</column><column name="report_time">2010-04-14 04:43:30</column><column name="report_timestamp">1271230000</column><column name="status">resolved fixed</column><column name="commit">bddfc0a</column><column name="commit_timestamp">1271230000</column><column name="files">java/org/apache/catalina/session/StandardManager.java</column><column name="result">5:java/org/apache/catalina/session/StandardManager.java</column></table><table name="tomcat"><column name="id">688</column><column name="bug_id">49086</column><column name="summary">Addition of Javadoc for Servlet 3.0 annotations</column><column name="description">Created attachment 25252 Javadoc patch for WebServlet annotation Addition of Javadoc for Servlet 3.0 javax.servlet.annotation package. Several patches to follow.</column><column name="report_time">2010-04-11 16:43:49</column><column name="report_timestamp">1271020000</column><column name="status">resolved fixed</column><column name="commit">6fc4360</column><column name="commit_timestamp">1271070000</column><column name="files">java/javax/servlet/annotation/HandlesTypes.java
java/javax/servlet/annotation/HttpConstraint.java
java/javax/servlet/annotation/HttpMethodConstraint.java
java/javax/servlet/annotation/MultipartConfig.java
java/javax/servlet/annotation/ServletSecurity.java
java/javax/servlet/annotation/WebFilter.java
java/javax/servlet/annotation/WebInitParam.java
java/javax/servlet/annotation/WebListener.java
java/javax/servlet/annotation/WebServlet.java</column><column name="result" /></table><table name="tomcat"><column name="id">689</column><column name="bug_id">49091</column><column name="summary">Util.specialCharactersRepresentation should be private</column><column name="description">jasper.tagplugins.jstl.Util.specialCharactersRepresentation is a mutable public static array; it is not used outside the class as far as I can tell and so should be made private</column><column name="report_time">2010-04-11 22:31:35</column><column name="report_timestamp">1271040000</column><column name="status">resolved fixed</column><column name="commit">1ecfaa9</column><column name="commit_timestamp">1271070000</column><column name="files">java/org/apache/jasper/tagplugins/jstl/Util.java</column><column name="result">2:java/org/apache/jasper/tagplugins/jstl/Util.java</column></table><table name="tomcat"><column name="id">690</column><column name="bug_id">49075</column><column name="summary">protected Class User doesn't check argument roles for null</column><column name="description">Created attachment 25246 check for null to guard Collections.unmodifiableList If roles is null, Collections.unmodifiableList will throw a NPE.</column><column name="report_time">2010-04-08 18:15:55</column><column name="report_timestamp">1270760000</column><column name="status">resolved fixed</column><column name="commit">e59ba8f</column><column name="commit_timestamp">1270810000</column><column name="files">java/org/apache/catalina/realm/JNDIRealm.java</column><column name="result">19:java/org/apache/catalina/realm/JNDIRealm.java</column></table><table name="tomcat"><column name="id">691</column><column name="bug_id">49018</column><column name="summary">Timeout argument misprocessed when expiring sessions from Tomcat Manager</column><column name="description">Steps to reproduce: 1. Login to the Tomcat Manager Application 2. Select a web application that has several sessions that are inactive for more than 2 minutes 3. In the text field next to the "Expire sessions" button print "2" 4. Press "Expire sessions" 5. Sample observed result: OK - Session information for application at context path /myapp Default maximum session inactive interval 30 minutes &lt;1 minutes:16 sessions 1 - &lt;2 minutes:2 sessions 2 - &lt;3 minutes:5 sessions 3 - &lt;4 minutes:1 sessions 4 - &lt;5 minutes:2 sessions 5 - &lt;6 minutes:1 sessions 6 - &lt;7 minutes:2 sessions 9 - &lt;10 minutes:1 sessions 8 minutes:expired 0 sessions Actually some sessions were expired (even if the above message prints "0"). Expected result: All sessions with idle time &gt; 2 minutes had to be expired. The bug is in the following lines of ManagerServlet#sessions(PrintWriter, String, int): Lines 1176-1179 if (idle &gt;= 0 &amp;&amp; time &gt;= idle*60) { sessions[i].expire(); idle++; } The patch would be to replace "idle++" with "expired++", because "idle" is the time (in minutes) as submitted from the web form and "expired" is the counter.</column><column name="report_time">2010-03-29 15:18:35</column><column name="report_timestamp">1269890000</column><column name="status">resolved fixed</column><column name="commit">155e3f8</column><column name="commit_timestamp">1270610000</column><column name="files">java/org/apache/catalina/manager/ManagerServlet.java</column><column name="result">3:java/org/apache/catalina/manager/ManagerServlet.java</column></table><table name="tomcat"><column name="id">692</column><column name="bug_id">48648</column><column name="summary">Blank page (dropped connection) when running TC7 with TCnative (APR)</column><column name="description">I encountered this trying to run the current TC trunk with TC-Native 1.1.19 on Windows. The root cause to this behavior occurred to be a wrong value configured by default as a timeout in AprEndpoint.Poller. (Also there might be further issue in how that timeout is applied / how the Poller works, but that is debatable). Current 6.0 and 5.5 (6.0.24, 5.5.28) are unaffected, because the defaults are different there. Though it looks like 6.0 can be configured to misbehave in the same way. More details below. I was accessing Tomcat by HTTP (using Http11AprProtocol), but I think that AJP (AjpAprProtocol) is affected as well. Tomcat was build from trunk (aka future TC7), at revision 904960. ~ Symptoms ~ To reproduce this issue: 1. My environment: - Windows XP 32-bit - java version "1.6.0_17" Java(TM) SE Runtime Environment (build 1.6.0_17-b04) Java HotSpot(TM) Client VM (build 14.3-b01, mixed mode, sharing) - Tomcat trunk, built from revision 904960 - Tomcat Native DLL 1.1.19 2. Place tcnative-1.dll into %CATALINA_HOME%/bin and start Tomcat. I am using an HTTP client, so AJP connector configuration can be removed from server.xml. Tomcat starts: 31.01.2010 18:45:16 org.apache.catalina.core.AprLifecycleListener init INFO: Loaded APR based Apache Tomcat Native library 1.1.19. 31.01.2010 18:45:16 org.apache.catalina.core.AprLifecycleListener init INFO: APR capabilities: IPv6 [true], sendfile [true], accept filters [false], random [true]. 3. Use a web browser (I was using Firefox 3.6) to access some simple JSP page 4. Refresh the page in the browser. The problem is that sometimes the page does not load, (the browser shows a blank page and page info says that response length was 0 bytes) - connection was aborted. The problem was more noticeable when I had a Firewall/Ad blocker running (because they incurred some delay while sending the request?). Turning it off made this error less frequent, but it was still there -- I was able to observe it running wget in a cycle requesting the page. 500 iterations were enough for this error to occur several times, with all firewalls turned off. Here is how this error was displayed by wget: --17:32:51-- http://localhost:8080/test/foo.jsp Resolving localhost... 127.0.0.1 Connecting to localhost|127.0.0.1|:8080... connected. HTTP request sent, awaiting response... Read error (Software caused connection abort) in headers. Retrying. --17:32:51-- (try: 2) http://localhost:8080/test/foo.jsp Connecting to localhost|127.0.0.1|:8080... connected. HTTP request sent, awaiting response... No data received. Retrying. --17:32:51-- (try: 3) http://localhost:8080/test/foo.jsp Connecting to localhost|127.0.0.1|:8080... connected. HTTP request sent, awaiting response... 200 OK Length: 130 [text/html] Saving to: `foo.jsp.98' 0K 100% 3.52M=0s ~ Investigation ~ 1. I enabled FINE, then FINEST logging for all Tomcat components in logging.properties (then selectively disabling those components that I was not interested in). That was futile: the logs showed no trace of those ignored request. 2. I enabled AccessLogValve. It did not help either: The ignored requests were not listed in the access log. 3. I launched jvisualvm tool from Java 6 JDK, connected to running Tomcat to investigate the threads and possible deadlocks there. There was no deadlock, and all threads were running. But I noticed one more thing: on a freshly started Tomcat several first requests, even if those were ignored ones, resulted in creation of a new thread in some thread pool. Here is one of those threads, from a thread dump: "http-8080-exec-9" daemon prio=6 tid=0x0afac800 nid=0xe10 waiting on condition [0x0cc5f000] java.lang.Thread.State: WAITING (parking) 	at sun.misc.Unsafe.park(Native Method) 	- parking to wait for &lt;0x03258e80&gt; (a java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject) 	at java.util.concurrent.locks.LockSupport.park(Unknown Source) 	at java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.await(Unknown Source) 	at java.util.concurrent.LinkedBlockingQueue.take(Unknown Source) 	at java.util.concurrent.ThreadPoolExecutor.getTask(Unknown Source) 	at java.util.concurrent.ThreadPoolExecutor$Worker.run(Unknown Source) 	at java.lang.Thread.run(Unknown Source) Locked ownable synchronizers: 	- None That was the clue: it means that the request has reached Tomcat. Searching by a substring of that thread name I found that getName() + "-exec-" is thread name prefix used by AbstractEndpoint.createExecutor(). Thus I investigated behaviour of AprEndpoint, confirming it by adding with some ad-hoc logging statements. I will not commit them, because this issue is sensitive to timing, so some of them were affecting its reproducibility. ~ Behaviour of AprEndpoint ~ In my configuration I was using Http11AprProtocol and it creates and uses AprEndpoint. Incoming request is processed by an Acceptor thread (AprEndpoint.Acceptor#run()) -&gt; Acceptor#processSocketWithOptions(long) will use getExecutor().execute(new SocketWithOptionsProcessor( )) to pass this newly opened socked further. It is the thread created by this "execute()" call that I spotted in jvisualvm earlier. In SocketWithOptionsProcessor#run() in my configuration deferAccept is false, so we are calling getPoller().add(socket) and pass the socket to a poller. In the AprEndpoint.Poller#add( ) the socket is added to a queue to be processed. The queue array size in my configuration occurred to be 1024, so queue overflow was not an issue. Then AprEndpoint.Poller#run() processes the queue, passes the new sockets from there to TC-Native (Poll.add() call) and then loops over and over polling their status (Poll.poll() call). The problem occurred to be caused by Poll.maintain( ) calls, that are executed every several iterations of the loop. In my case: the recently opened socket remained for several iterations of the Poller loop, but when Poll.maintain() call occurred the socket was returned from the maintain() call as a one to be closed, and was immediately closed, dropping the connection. Thus, Poll.maintain() was misbehaving, closing fresh sockets. Implementation of Poll.maintain() (in poll.c of TC-Native) showed that if (p-&gt;max_ttl == 0) there, the socket is to be closed immediately. p-&gt;max_ttl value is set when configuring a pollset in Poll.create( ), and can be changed later for the pollset as a whole in Poll.setTtl( ) method. In AprEndpoint.Poller the pollset is created in Poller.init(). There, the value for the timeout is determined as int timeout = getKeepAliveTimeout(); if (timeout &lt; 0) { timeout = socketProperties.getSoTimeout(); } where /** * Keepalive timeout, if lesser or equal to 0 then soTimeout will be used. */ private int keepAliveTimeout = 0; so, the timeout actually occurred to be configured as 0. Thus the observed buggy behaviour. In TC 6.0.24 keepAliveTimeout = -1, thus soTimeout will be used. Notes: - The JavaDoc for keepAliveTimeout says that 0 means that soTimepout will be used, but the actual implementation is different. Changing the above cited code to be if (timeout &lt;= 0) { timeout = socketProperties.getSoTimeout(); } would be the most obvious fix for this issue. - A delay longer than soTimeout (60 or 20 seconds? IIRC) will likewise result in closing the socket, with no details mentioned in the logs. - The keepAliveTimeout property name suggests that it is used for sockets where processing already occurred, and we are keeping them alive between requests. (Zero timeout would be okay there). Why was it used for a freshly open sockets? (Zero timeout cannot be used for them) Maybe it is a wrong name for this property? - Is it possible in the Poller to distinguish fresh sockets vs. those in keep-alive state, and configure different timeouts for them? It will require to keep several pollset pools with different TTLs ? - AjpAprProtocol also uses this AjpEndpoint, so I expect it to be affected by this issue as well. - This chain of calls causing this issue occurs only if AprEndpoint.deferAccept field is false. It is true by default but is set to false when the system does not support the requested feature. In my case, in Windows XP SP3, that feature (Socket.APR_TCP_DEFER_ACCEPT) was not supported. A comment in the code says that it is supported in Linux kernel 2.4 and later. Thus, this issue is likely not affect Linux.</column><column name="report_time">2010-01-31 17:58:11</column><column name="report_timestamp">1264980000</column><column name="status">resolved fixed</column><column name="commit">216352a</column><column name="commit_timestamp">1270400000</column><column name="files">java/org/apache/tomcat/util/net/AprEndpoint.java</column><column name="result">40:java/org/apache/tomcat/util/net/AprEndpoint.java</column></table><table name="tomcat"><column name="id">693</column><column name="bug_id">49014</column><column name="summary">Add RemoteIpFilter test case</column><column name="description">Created attachment 25204 TestRemoteIpFilter.java I didn't attach test cases to the RemoteIpFilter when I proposed it because I didn't know how to use the embedded Tomcat. I learned how to use it so here are the test cases.</column><column name="report_time">2010-03-29 00:17:51</column><column name="report_timestamp">1269840000</column><column name="status">resolved fixed</column><column name="commit">d9330a9</column><column name="commit_timestamp">1270380000</column><column name="files">test/org/apache/catalina/filters/TestRemoteIpFilter.java</column><column name="result" /></table><table name="tomcat"><column name="id">694</column><column name="bug_id">48983</column><column name="summary">Enhance RemoteIpValve and RemoteIpFilter logging</column><column name="description">Created attachment 25180 RemoteIpFilter logging enhancement RemoteIpValve and RemoteIpFilter logging can be enhanced to ease understanding why a remote address is not seen as one of the internal proxies ip list. This is particularly useful to troubleshoot unexpected usage of IP-V6 when IP-V4 is expected. Patch is provided in two separated files to ease merge of the RemoteIpValve patch to Tomcat 6.0.x branch. Added log messages : RemoteIpFilter.java : "Skip RemoteIpFilter for request " + request.getRequestURI() + " with originalRemoteAddr '" + request.getRemoteAddr() + "'" RemoteIpValve.java : "Skip RemoteIpValve for request " + request.getRequestURI() + " with originalRemoteAddr '" + request.getRemoteAddr() + "'"</column><column name="report_time">2010-03-24 23:15:14</column><column name="report_timestamp">1269490000</column><column name="status">resolved fixed</column><column name="commit">9a42719</column><column name="commit_timestamp">1270380000</column><column name="files">java/org/apache/catalina/filters/RemoteIpFilter.java
java/org/apache/catalina/valves/RemoteIpValve.java</column><column name="result">1:java/org/apache/catalina/filters/RemoteIpFilter.java
2:java/org/apache/catalina/valves/RemoteIpValve.java</column></table><table name="tomcat"><column name="id">695</column><column name="bug_id">48895</column><column name="summary">WebAppClassLoader.clearThreadLocalMap() concurrency issues</column><column name="description">I think that the memory leak protection of WebAppClassLoader.clearReferencesThreadLocals() which detects and clears ThreadLocals that would prevent GC the WebAppClassLoader instance has issues regarding concurrency : - It enumerates Threads and looks into internal structures of the Thread class, but there are no "memory barrier" that would ensure a consistent state of the ThreadLocalMap being examined. So, it is theoretically possible that a ThreadLocal in Thread A was properly cleaned up by the application, but the current thread B (that is undeploying the application) does not see the up to date state because there's no synchronization between those threads. - Much more severe : after detecting such a leak, it invokes java.lang.ThreadLocal.ThreadLocalMap.remove(ThreadLocal) on Thread A's ThreadLocalMap instance but the invocation is done by Thread B (the thread that undeploys the app). The remove() method is not thread safe at all, and nor is the expungeStaleEntries() method which may also be invoked in clearThreadLocalMap(). So, if a webapp is being undeployed while other applications continue to receive a heavy load of requests, this could corrupt the internal structures of the ThreadLocalMap instance ! I propose to keep the detection of leaks as it is, but to make the actual clearing optional (and disabled by default) to avoid encountering big problems in production. Idea to improve the clearing in a safe way : if the thread that is "provoking" the leak is one of tomcat's worker threads, we could mark it as "dirty", and then have a background task that would end such threads (renew those threads in the pool).</column><column name="report_time">2010-03-11 22:20:01</column><column name="report_timestamp">1268360000</column><column name="status">resolved fixed</column><column name="commit">ae6fcf5</column><column name="commit_timestamp">1269870000</column><column name="files">java/org/apache/catalina/core/StandardContext.java
java/org/apache/catalina/loader/WebappClassLoader.java
java/org/apache/catalina/loader/WebappLoader.java</column><column name="result">1:java/org/apache/catalina/loader/WebappClassLoader.java
2:java/org/apache/catalina/core/StandardContext.java
49:java/org/apache/catalina/loader/WebappLoader.java</column></table><table name="tomcat"><column name="id">696</column><column name="bug_id">48717</column><column name="summary">Session listeners not called on cluster node start</column><column name="description">This appears to be a regression from an earlier bug #35916 which describes the exact same problem, but somewhere along the way, it appears that the bug has come back. Basically, once Tomcat is put in to a cluster and a node joins the cluster, the webapp isn't notified via either HttpSessionActivationListener.didActivate or HttpSessionListener.sessionCreated. Otherwise, all nodes seem to receive these events as expected once in the cluster. This is a problem for an application which needs to track all currently active sessions as it will not know of any existing sessions when joining a cluster. This also appears to affect Tomcat 6.0.24 as well where the symptoms are the same. I actually posted to the users list almost a year ago (totally forgot I did that until I was searching the archives again), but didn't hear any response and worked around the issue temporarily, but it has come up again so I posted to the list again, but no response either time. http://www.mail-archive.com/users@tomcat.apache.org/msg58675.html http://www.mail-archive.com/users@tomcat.apache.org/msg73135.html</column><column name="report_time">2010-02-09 17:43:14</column><column name="report_timestamp">1265760000</column><column name="status">resolved fixed</column><column name="commit">39d3082</column><column name="commit_timestamp">1269800000</column><column name="files">java/org/apache/catalina/ha/session/DeltaManager.java</column><column name="result">9:java/org/apache/catalina/ha/session/DeltaManager.java</column></table><table name="tomcat"><column name="id">697</column><column name="bug_id">48662</column><column name="summary">context.xml expansion on deployment improvements</column><column name="description">Two parts: 1. Log a warning/info message if Tomcat ignores a bundled context.xml in favour of one in CATALINA_BASE/&lt;engine name&gt;/&lt;host name&gt; 2. Make the extraction/copying of context.xml configurable, probably via a new attribute extractXml on the host</column><column name="report_time">2010-02-02 22:44:07</column><column name="report_timestamp">1265170000</column><column name="status">resolved fixed</column><column name="commit">83226d9</column><column name="commit_timestamp">1269780000</column><column name="files">java/org/apache/catalina/Context.java
java/org/apache/catalina/core/StandardContext.java
java/org/apache/catalina/core/StandardHost.java
java/org/apache/catalina/mbeans/MBeanFactory.java
java/org/apache/catalina/startup/ContextConfig.java
java/org/apache/catalina/startup/HostConfig.java</column><column name="result">1:java/org/apache/catalina/core/StandardContext.java
3:java/org/apache/catalina/startup/HostConfig.java
4:java/org/apache/catalina/core/StandardHost.java
17:java/org/apache/catalina/startup/ContextConfig.java
29:java/org/apache/catalina/Context.java
33:java/org/apache/catalina/mbeans/MBeanFactory.java</column></table><table name="tomcat"><column name="id">698</column><column name="bug_id">48934</column><column name="summary">Cluster's regression. When replication fails once, replication can be never done again.</column><column name="description">I found cluster's regression in Tomcat6.0.26. The reproduction is as follows. ===== The cluster is composed of tomcat1 and tomcat2. (Transport className is org.apache.catalina.tribes.transport.nio.PooledParallelSender. Perhaps, I think PooledMultiSender to be the same. ) Tomcat2 is stopped during session replication. As a result, Session replication failed and ChannelException is thrown. Tomcat2 restart. Session replication again. As a result, following exception is thrown. org.apache.catalina.tribes.ChannelException: Sender not connected.; No faulty members identified. ===== The cause is http://svn.apache.org/viewvc?view=revision&amp;revision=908741 When replication fails, sender is disconnected by this fix. The disconnect method is as follows in PooledParallelSender. === public synchronized void disconnect() { this.connected = false; super.disconnect(); } === this.connected is set to false, and super.disconnect() is called. In super.disconnect(), the queue is closed. I think. if connected is set to false once, it never becomes true again. and if queue is closed once, it never opened again. It is only ReplicationTransmitter#start to be able to set connected to true. It is also the same to open the queue. As a result, when replication fails once, replication can be never done again. I do not know the reason why r908741 is applied. However, if ChannelException is thrown once, it becomes impossible to use all Sender. This is not good thing. Can revert r908741 ? If it is not possible, what is the reason for the r908741? Best regards.</column><column name="report_time">2010-03-18 11:09:23</column><column name="report_timestamp">1268920000</column><column name="status">resolved fixed</column><column name="commit">fc66705</column><column name="commit_timestamp">1268920000</column><column name="files">java/org/apache/catalina/tribes/transport/ReplicationTransmitter.java
java/org/apache/catalina/tribes/transport/nio/PooledParallelSender.java</column><column name="result">25:java/org/apache/catalina/tribes/transport/ReplicationTransmitter.java</column></table><table name="tomcat"><column name="id">699</column><column name="bug_id">44265</column><column name="summary">Improve JspWriterImpl performance with "inline" sub method</column><column name="description">As you know, the JspWriterImpl.write method was always invoked in JSP file frequently. But I found its performance is poor because too many sub method were invoked as well. After copying two sub method's code to write method, the performance was improved observably.</column><column name="report_time">2008-01-18 02:51:47</column><column name="report_timestamp">1200640000</column><column name="status">resolved fixed</column><column name="commit">9113574</column><column name="commit_timestamp">1268330000</column><column name="files">java/org/apache/jasper/runtime/JspWriterImpl.java</column><column name="result">1:java/org/apache/jasper/runtime/JspWriterImpl.java</column></table><table name="tomcat"><column name="id">700</column><column name="bug_id">48760</column><column name="summary">Tomcat breaks in serving large files (&gt;=1.8MB) under high load and high threading.</column><column name="description">When serving a 1.8MB file, Tomcat 6.0.16-&gt;6.0.20 (all versions tested), will occasionally throw a BadFileNumber exception and only serve part of the file. The rate of occurrence is roughly a few times a day under high load, but we have stress tools which can reliably reproduce this issue, and multiple continuous wget connections can reproduce the issue, as well. We are serving a large SWF application, although this may affect arbitrary binary data. To reproduce this issue, serve a large file (at least 1.8MB, in our case), and continuously request the file over a period of several hours to a few days; this issue happens intermittently, but it is reproducible. This problem is especially critical to us, as we use apache as a cache in front of tomcat. For whatever reason, apache aggressively caches this bad data and never again requests the file, although this is probably another unrelated problem. In this configuration, however, after the file has gone bad, all users get served corrupt files, causing the application to break entirely. This was reported in 2008 here, but the issue was dismissed: http://mail-archives.apache.org/mod_mbox/tomcat-dev/200808.mbox/%3Cbug-45601-78@https.issues.apache.org/bugzilla/%3E The fix provided here works to resolve the issue, but our IT department cannot support a custom-rolled version of tomcat indefinitely. It's not a sustainable solution, and this issue should affect other users. We are not sure why the fix works, but it does resolve our completely reproducible scenario. Ideally, then, someone with more knowledge of tomcat could understand why this fix works and what, exactly, it's solving, and then integrate this into the main tomcat release line. Here is how the error appears in the logs: Feb 16, 2010 1:25:59 PM org.apache.catalina.core.StandardWrapperValve invoke SEVERE: Servlet.service() for servlet default threw exception java.io.IOException: Bad file number 	at java.io.FileInputStream.readBytes(Native Method) 	at java.io.FileInputStream.read(FileInputStream.java:199) 	at java.io.BufferedInputStream.read1(BufferedInputStream.java:256) 	at java.io.BufferedInputStream.read(BufferedInputStream.java:317) 	at java.io.FilterInputStream.read(FilterInputStream.java:90) 	at org.apache.catalina.servlets.DefaultServlet.copyRange(DefaultServlet.java:1968) 	at org.apache.catalina.servlets.DefaultServlet.copy(DefaultServlet.java:1714) 	at org.apache.catalina.servlets.DefaultServlet.serveResource(DefaultServlet.java:809) 	at org.apache.catalina.servlets.DefaultServlet.doGet(DefaultServlet.java:325) 	at javax.servlet.http.HttpServlet.service(HttpServlet.java:690) 	at javax.servlet.http.HttpServlet.service(HttpServlet.java:803) 	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:290) 	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:206) 	at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:233) 	at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:175) 	at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:128) 	at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:102) 	at org.apache.catalina.valves.AccessLogValve.invoke(AccessLogValve.java:568) 	at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:109) 	at org.apache.catalina.ha.session.JvmRouteBinderValve.invoke(JvmRouteBinderValve.java:209) 	at org.apache.catalina.ha.tcp.ReplicationValve.invoke(ReplicationValve.java:347) 	at org.terracotta.modules.tomcat.tomcat_5_5.SessionValve55.invoke(SessionValve55.java:57) 	at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:286) 	at org.apache.coyote.http11.Http11Processor.process(Http11Processor.java:844) 	at org.apache.coyote.http11.Http11Protocol$Http11ConnectionHandler.process(Http11Protocol.java:583) 	at org.apache.tomcat.util.net.JIoEndpoint$Worker.run(JIoEndpoint.java:447) 	at java.lang.Thread.run(Thread.java:619)</column><column name="report_time">2010-02-17 20:44:37</column><column name="report_timestamp">1266460000</column><column name="status">resolved fixed</column><column name="commit">f1760d8</column><column name="commit_timestamp">1268140000</column><column name="files">java/org/apache/naming/resources/FileDirContext.java
java/org/apache/naming/resources/WARDirContext.java</column><column name="result">184:java/org/apache/naming/resources/FileDirContext.java
302:java/org/apache/naming/resources/WARDirContext.java</column></table><table name="tomcat"><column name="id">701</column><column name="bug_id">48737</column><column name="summary">JspCompilationContext assumes that tagfile with a path starting with META-INF are in jars without checking</column><column name="description">Created attachment 24978 patch to JspCompilationContext This is a pretty special case, since tagfiles in META-INF are usually in jar files... but when using a custom dircontext implementation (usually during development in order to load files from the filesystem without building a full jar) it may happen that the path given to jasper starts with META-INF also if the file is not in a jar. This is what happens using the Eclipse WTP tomcat loader, which loads classes from the workspaces and tld/tagfiles from directories inside your projects. Tagfiles contained in META-INF directories worked properly till tomcat 6.0.17, but the final fix for BUG 43741 broke it (I am still using 6.0.16 and not upgrading due to this problem). Looking at JspCompilationContext.getResource() the patch to solve this problem would be very simple and "safe": if the path starts with META-INF and a jar file containing the tld doesn't exist the resulting URL is simply null. Adding a check for the null jar and setting the URL to the "standard" path inside the context fixes the problem and everything starts working again (note that this doesn't break the previous fix and it can't cause any problem, since the result would have been null anyway). A patch against trunk (2010-02-13) is attached, the following code should easily displays what the patch does: URL result = null; if (res.startsWith("/META-INF/")) { // some lines to get the jar url // ... if (jarUrl != null) { result = new URL(jarUrl.toExternalForm() + res.substring(1)); } + else { + // the path starts with /META-INF but the file is not in a jar + result = context.getResource(canonicalURI(res)); + } }</column><column name="report_time">2010-02-13 18:19:03</column><column name="report_timestamp">1266100000</column><column name="status">resolved fixed</column><column name="commit">6ac5036</column><column name="commit_timestamp">1268140000</column><column name="files">java/org/apache/jasper/JspCompilationContext.java</column><column name="result">1:java/org/apache/jasper/JspCompilationContext.java</column></table><table name="tomcat"><column name="id">702</column><column name="bug_id">48729</column><column name="summary">JNDIRealm.java not parsing roles correctly</column><column name="description">Created attachment 24972 small patch for JNDIRealm.java According to the docs: http://tomcat.apache.org/tomcat-6.0-doc/realm-howto.html it says roles can be specified by both userRoleName, AND roleName mechanisms. But, if both are used then the result is that userRoleName roles are excluded. I believe the correct approach is in the attached patch.</column><column name="report_time">2010-02-11 17:27:55</column><column name="report_timestamp">1265930000</column><column name="status">resolved fixed</column><column name="commit">4cf35b8</column><column name="commit_timestamp">1268140000</column><column name="files">java/org/apache/catalina/realm/JNDIRealm.java</column><column name="result">1:java/org/apache/catalina/realm/JNDIRealm.java</column></table><table name="tomcat"><column name="id">703</column><column name="bug_id">48661</column><column name="summary">inconsistent error page behavior</column><column name="description">There seems to be a bug or at least an inconsistency in how tomcat handles the error page. In Tomcat 6.0.20, if I define my error page like this in web.xml: &lt;error-page&gt; &lt;exception-type&gt;java.lang.Exception&lt;/exception-type&gt; &lt;location&gt;/unexpectedErrors.jsp&lt;/location&gt; &lt;/error-page&gt; Then, if the response has already been committed, Tomcat does this on the system console: Feb 1, 2010 5:59:04 PM org.apache.catalina.core.StandardWrapperValve invoke SEVERE: Servlet.service() for servlet jsp threw exception java.lang.NullPointerException at org.apache.jsp.cpe_jsp._jspService(cpe_jsp.java:693) at org.apache.jasper.runtime.HttpJspBase.service(HttpJspBase.java:70) at javax.servlet.http.HttpServlet.service(HttpServlet.java:717) at org.apache.jasper.servlet.JspServletWrapper.service(JspServletWrapper.java:374) at org.apache.jasper.servlet.JspServlet.serviceJspFile(JspServlet.java:342) at org.apache.jasper.servlet.JspServlet.service(JspServlet.java:267) at javax.servlet.http.HttpServlet.service(HttpServlet.java:717) at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:290) at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:206) at com.eaglecreektech.expedience.provisioning.web.servletFilters.AuthFilter.doFilter(AuthFilter.java:133) at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:235) at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:206) at com.eaglecreektech.expedience.provisioning.web.servletFilters.RequestVolumeFilter.doFilter(RequestVolumeFilter.java:141) at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:235) at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:206) at com.eaglecreektech.expedience.provisioning.web.servletFilters.StartupCheckFilter.doFilter(StartupCheckFilter.java:65) at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:235) at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:206) at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:233) at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:191) at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:128) at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:102) at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:109) at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:293) at org.apache.coyote.http11.Http11Processor.process(Http11Processor.java:849) at org.apache.coyote.http11.Http11Protocol$Http11ConnectionHandler.process(Http11Protocol.java:583) at org.apache.tomcat.util.net.JIoEndpoint$Worker.run(JIoEndpoint.java:454) at java.lang.Thread.run(Thread.java:619) Feb 1, 2010 5:59:04 PM org.apache.catalina.core.StandardHostValve custom SEVERE: Exception Processing ErrorPage[exceptionType=java.lang.Exception, location=/unexpectedErrors.jsp] java.lang.IllegalStateException: Cannot reset buffer after response has been committed at org.apache.catalina.connector.Response.resetBuffer(Response.java:691) at org.apache.catalina.core.StandardHostValve.custom(StandardHostValve.java:409) at org.apache.catalina.core.StandardHostValve.throwable(StandardHostValve.java:271) at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:142) at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:102) at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:109) at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:293) at org.apache.coyote.http11.Http11Processor.process(Http11Processor.java:849) at org.apache.coyote.http11.Http11Protocol$Http11ConnectionHandler.process(Http11Protocol.java:583) at org.apache.tomcat.util.net.JIoEndpoint$Worker.run(JIoEndpoint.java:454) at java.lang.Thread.run(Thread.java:619) And it doesn't put any error text into the broken page - the page just shows how ever far it got before it encountered the error. This behavior doesn't seem correct - it seems like it should at least behave the same way as it does when the error page is defined in a jsp page: &lt;%@ page errorPage="unexpectedErrors.jsp" %&gt; If the response has already been committed, then it just appends the error page onto the end of the response (not ideal, but nothing else can be done, as far as I know) If the response has not been committed, it clears the buffer and writes the error page (which looks nice and pretty , like it should) I'd suggest that the error handling code for the error page as defined in web.xml should check if the response has been committed, and not try to clear the buffer if it is already committed - just append to the end, the same way that the jsp error handler does.</column><column name="report_time">2010-02-02 15:07:25</column><column name="report_timestamp">1265140000</column><column name="status">resolved fixed</column><column name="commit">1ec5ca7</column><column name="commit_timestamp">1268070000</column><column name="files">java/org/apache/catalina/core/StandardHostValve.java</column><column name="result">6:java/org/apache/catalina/core/StandardHostValve.java</column></table><table name="tomcat"><column name="id">704</column><column name="bug_id">48582</column><column name="summary">JspServletWrapper.getServletContext() throws NullPointerException</column><column name="description">We're getting this exception/stack trace in a web application: ''[2010-01-15 17:52:01,381] - ERROR [org.apache.catalina.core.ContainerBase] Exception invoking periodic operation: 'java.lang.NullPointerException at org.apache.jasper.servlet.JspServletWrapper.getServletContext(JspServletWrapper.java:174) at org.apache.jasper.compiler.JspRuntimeContext.checkCompile(JspRuntimeContext.java:304) at org.apache.jasper.servlet.JspServlet.periodicEvent(JspServlet.java:289) at org.apache.catalina.core.StandardWrapper.backgroundProcess(StandardWrapper.java:668) at org.apache.catalina.core.ContainerBase$ContainerBackgroundProcessor.processChildren(ContainerBase.java:1571) at org.apache.catalina.core.ContainerBase$ContainerBackgroundProcessor.processChildren(ContainerBase.java:1580) at org.apache.catalina.core.ContainerBase$ContainerBackgroundProcessor.processChildren(ContainerBase.java:1580) at org.apache.catalina.core.ContainerBase$ContainerBackgroundProcessor.processChildren(ContainerBase.java:1580) at org.apache.catalina.core.ContainerBase$ContainerBackgroundProcessor.run(ContainerBase.java:1560) at java.lang.Thread.run(Thread.java:595) Looking at JspServletWrapper, I see that it has 2 constructors; one for JSP pages, and another for tag files. The one for tag files has a problem in this line: this.config = null; // not used because this.config is indeed used by the public method getServletContext(): public ServletContext getServletContext() { return config.getServletContext(); } and since that method is public, you can't safely say that this.config will not be used. :) So this means that if you create a JspServletWrapper for a JSP tag file, you can never call getServletContext() on it, or you'll generate the NPE above. However, JspRuntimeContext does exactly that in the following block of code, from the checkCompile() method: Object [] wrappers = jsps.values().toArray(); for (int i = 0; i &lt; wrappers.length; i++ ) { JspServletWrapper jsw = (JspServletWrapper)wrappers[i]; JspCompilationContext ctxt = jsw.getJspEngineContext(); // JspServletWrapper also synchronizes on this when // it detects it has to do a reload synchronized(jsw) { try { ctxt.compile(); } catch (FileNotFoundException ex) { ctxt.incrementRemoved(); } catch (Throwable t) { jsw.getServletContext().log("Background compile failed", t); } } } The values in the "jsps" map are both JSP files and tag files, as seen by TagFileProcessor.loadTagFile(), which puts tag files there. So to summarize, any JSP tag file that experiences a compilation failure inside of the checkCompile() method will seem to generate this NullPointerException. A secondary issue here is that if any problem occurs inside of the catch block in the code pasted above (as is currently happening), the original exception is swallowed forever. This is the Throw From Within Finally anti-pattern (http://today.java.net/article/2006/04/04/exception-handling-antipatterns#throwFromWithinFinally) and should be fixed as well.</column><column name="report_time">2010-01-20 13:25:03</column><column name="report_timestamp">1264010000</column><column name="status">resolved fixed</column><column name="commit">7301a10</column><column name="commit_timestamp">1266320000</column><column name="files">java/org/apache/jasper/servlet/JspServletWrapper.java</column><column name="result">1:java/org/apache/jasper/servlet/JspServletWrapper.java</column></table><table name="tomcat"><column name="id">705</column><column name="bug_id">48580</column><column name="summary">6.0.24: AccessControlException in ProtectedFunctionMapper on first access to certain JSP</column><column name="description">Steps to reproduce: 1. Download and install 6.0.24 release candidate 2. Run catalina start -security 3. Access http://localhost:8080/examples/jsp/jsp2/el/implicit-objects.jsp?foo=bar 4. Observe error page, with a stacktrace java.security.AccessControlException: access denied (java.lang.RuntimePermission accessClassInPackage.org.apache.jasper.security) java.security.AccessControlContext.checkPermission(Unknown Source) java.security.AccessController.checkPermission(Unknown Source) java.lang.SecurityManager.checkPermission(Unknown Source) java.lang.SecurityManager.checkPackageAccess(Unknown Source) sun.misc.Launcher$AppClassLoader.loadClass(Unknown Source) java.lang.ClassLoader.loadClass(Unknown Source) java.lang.ClassLoader.loadClass(Unknown Source) java.lang.ClassLoader.loadClassInternal(Unknown Source) org.apache.jasper.runtime.ProtectedFunctionMapper.getMapForFunction(ProtectedFunctionMapper.java:145) org.apache.jsp.jsp.jsp2.el.implicit_002dobjects_jsp.&lt;clinit&gt;(implicit_002dobjects_jsp.java:13) ... This issues does not occur if the following JSP page is accessed before the one where it is observed: http://localhost:8080/examples/jsp/jsp2/el/basic-arithmetic.jsp OS: Windows XP, 32-bit, JRE version: java version "1.6.0_17" Java(TM) SE Runtime Environment (build 1.6.0_17-b04) Java HotSpot(TM) Client VM (build 14.3-b01, mixed mode, sharing)</column><column name="report_time">2010-01-20 11:54:45</column><column name="report_timestamp">1264010000</column><column name="status">resolved fixed</column><column name="commit">9e55819</column><column name="commit_timestamp">1266310000</column><column name="files">java/org/apache/jasper/security/SecurityClassLoad.java</column><column name="result">7:java/org/apache/jasper/security/SecurityClassLoad.java</column></table><table name="tomcat"><column name="id">706</column><column name="bug_id">48498</column><column name="summary">6.0.22RC: ArrayIndexOutOfBoundsException from Jasper when compilation error inside a CDATA block</column><column name="description">Created attachment 24808 /webapps/examples/WEB-INF/tags/panel.tagx Steps to reproduce: 1. Remove /WEB-INF/tags/panel.tag from the Tomcat Examples webapp and replace it with the attached XML Tag file, panel.tagx 2. Visit the following page: http://localhost:8080/examples/jsp/jsp2/tagfiles/panel.jsp 3. The page contains a scriptlet, with a CDATA block that produces a compilatin error. Expected result: Compilation error being reported for line 39, Integer.parseInt(10); Actual result: java.lang.ArrayIndexOutOfBoundsException: 46 	org.apache.jasper.compiler.JavacErrorDetail.&lt;init&gt;(JavacErrorDetail.java:111) 4. If I add sufficient number of empty lines after the CDATA block, ArrayIndexOutOfBoundsException disappears and I can see the compiler error, but the error lines shown are wrong. The shown lines are below the actual location of the error. It looks like this offset in line numbers is due to the size of the CDATA block. ==================================================================== Full stacktrace of the above ArrayIndexOutOfBoundsException exception: java.lang.ArrayIndexOutOfBoundsException: 46 	org.apache.jasper.compiler.JavacErrorDetail.&lt;init&gt;(JavacErrorDetail.java:111) 	org.apache.jasper.compiler.ErrorDispatcher.createJavacError(ErrorDispatcher.java:533) 	org.apache.jasper.compiler.JDTCompiler$2.acceptResult(JDTCompiler.java:377) 	org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:398) 	org.apache.jasper.compiler.JDTCompiler.generateClass(JDTCompiler.java:429) 	org.apache.jasper.compiler.Compiler.compile(Compiler.java:334) 	org.apache.jasper.compiler.Compiler.compile(Compiler.java:312) 	org.apache.jasper.compiler.Compiler.compile(Compiler.java:299) 	org.apache.jasper.JspCompilationContext.compile(JspCompilationContext.java:589) 	org.apache.jasper.servlet.JspServletWrapper.loadTagFile(JspServletWrapper.java:215) 	org.apache.jasper.compiler.TagFileProcessor.loadTagFile(TagFileProcessor.java:625) 	org.apache.jasper.compiler.TagFileProcessor.access$000(TagFileProcessor.java:52) 	org.apache.jasper.compiler.TagFileProcessor$TagFileLoaderVisitor.visit(TagFileProcessor.java:685) 	org.apache.jasper.compiler.Node$CustomTag.accept(Node.java:1530) 	org.apache.jasper.compiler.Node$Nodes.visit(Node.java:2361) 	org.apache.jasper.compiler.Node$Visitor.visitBody(Node.java:2411) 	org.apache.jasper.compiler.Node$Visitor.visit(Node.java:2417) 	org.apache.jasper.compiler.Node$Root.accept(Node.java:495) 	org.apache.jasper.compiler.Node$Nodes.visit(Node.java:2361) 	org.apache.jasper.compiler.TagFileProcessor.loadTagFiles(TagFileProcessor.java:703) 	org.apache.jasper.compiler.Compiler.generateJava(Compiler.java:195) 	org.apache.jasper.compiler.Compiler.compile(Compiler.java:332) 	org.apache.jasper.compiler.Compiler.compile(Compiler.java:312) 	org.apache.jasper.compiler.Compiler.compile(Compiler.java:299) 	org.apache.jasper.JspCompilationContext.compile(JspCompilationContext.java:589) 	org.apache.jasper.servlet.JspServletWrapper.service(JspServletWrapper.java:317) 	org.apache.jasper.servlet.JspServlet.serviceJspFile(JspServlet.java:313) 	org.apache.jasper.servlet.JspServlet.service(JspServlet.java:260) 	javax.servlet.http.HttpServlet.service(HttpServlet.java:717) ====================================================================</column><column name="report_time">2010-01-06 19:40:54</column><column name="report_timestamp">1262820000</column><column name="status">resolved fixed</column><column name="commit">789ac1e</column><column name="commit_timestamp">1266280000</column><column name="files">java/org/apache/jasper/compiler/JavacErrorDetail.java</column><column name="result">143:java/org/apache/jasper/compiler/JavacErrorDetail.java</column></table><table name="tomcat"><column name="id">707</column><column name="bug_id">48384</column><column name="summary">globalXsltFile parameter for the DefaultServlet</column><column name="description">When overriding the DefaultServlet for a given application, the globalXsltFile path need to be relative to Tomcat root. for example: &lt;init-param&gt; &lt;param-name&gt;globalXsltFile&lt;/param-name&gt; &lt;param-value&gt;webapps/quercus/WEB-INF/listing.xsl&lt;/param-value&gt; &lt;/init-param&gt; it would be nice if the path could be relative to the application context.</column><column name="report_time">2009-12-13 16:24:30</column><column name="report_timestamp">1260740000</column><column name="status">resolved fixed</column><column name="commit">0e595cf</column><column name="commit_timestamp">1266090000</column><column name="files">java/org/apache/catalina/servlets/DefaultServlet.java</column><column name="result">1:java/org/apache/catalina/servlets/DefaultServlet.java</column></table><table name="tomcat"><column name="id">708</column><column name="bug_id">48371</column><column name="summary">addWebXmlMappings does not place servlet tags correctly</column><column name="description">If there is a commented-out &lt;security-constraint&gt; or commented-out &lt;servlet&gt; tag and addWebXmlMappings="true", the JSP's servlet and servlet-mapping tags are placed incorrectly and Tomcat will not start due to "--" being inside a comment. Basically, it seems the web.xml is not parsed correctly when using addWebXmlMappings and you cannot have above tags commented out, or new servlet tags will be placed incorrectly and comment tags not respected.</column><column name="report_time">2009-12-10 18:16:34</column><column name="report_timestamp">1260490000</column><column name="status">resolved fixed</column><column name="commit">563e315</column><column name="commit_timestamp">1266090000</column><column name="files">java/org/apache/jasper/JspC.java</column><column name="result">2:java/org/apache/jasper/JspC.java</column></table><table name="tomcat"><column name="id">709</column><column name="bug_id">48318</column><column name="summary">WebDAV servlet returns 500 if files not readable</column><column name="description">If a directory contains a file that is not readable by the Tomcat process (eg file permissions, dangling symlink) then Tomcat throws a NullPointerException and returns a 500 Internal Server Error to the client. Throwing NPE in these circumstances is certainly wrong. Returning 500 with no further information is unhelpful behavior and should be fixed. Generally, interfaces of this type at least list inaccessible files (Windows Explorer, UNIX ls(1), BSD FTP client, ...) and only return an error when one attempts to access such a file. markt suggests an alternative of simply ignoring inaccessible files but notes that "could cause issues if a user tries to upload a file of that name" and suggests better error reporting. Stack: SEVERE: Servlet.service() for servlet webdav threw exception java.lang.NullPointerException at org.apache.catalina.servlets.WebdavServlet.parseProperties(Unknown Source) at org.apache.catalina.servlets.WebdavServlet.doPropfind(Unknown Source) at org.apache.catalina.servlets.WebdavServlet.service(Unknown Source) at javax.servlet.http.HttpServlet.service(Unknown Source) ... Method parseProperties() is in java/org/apache/catalina/servlets/WebdavServlet.java.org and the NPE happens when cacheEntry.attributes is null (case FIND_BY_PROPERTY in my testing and possibly in other cases too). Following the breadcrumbs via: cacheEntry = resources.lookupCache(path); leads eventually to java/org/apache/naming/resources/FileDirContext.java: public Attributes getAttributes(String name, String[] attrIds) throws NamingException { // Building attribute list File file = file(name); if (file == null) throw new NamingException (sm.getString("resources.notFound", name)); ... protected File file(String name) { File file = new File(base, name); if (file.exists() &amp;&amp; file.canRead()) { ... // do useful stuff } else { return null; // ouch }</column><column name="report_time">2009-12-01 07:07:07</column><column name="report_timestamp">1259670000</column><column name="status">resolved fixed</column><column name="commit">da42e44</column><column name="commit_timestamp">1266010000</column><column name="files">java/org/apache/catalina/servlets/WebdavServlet.java</column><column name="result">3:java/org/apache/catalina/servlets/WebdavServlet.java</column></table><table name="tomcat"><column name="id">710</column><column name="bug_id">48726</column><column name="summary">DeployTask throws OutOfMemoryErrors when deploying large WAR files</column><column name="description">Created attachment 24967 patch (diffed from org/apache/catalina/ant) I consistently get OutOfMemory errors when attempting to deploy a 70 mb WAR file to Tomcat using the Deploy ant task: java.lang.OutOfMemoryError: Java heap space at org.apache.catalina.ant.AbstractCatalinaTask.execute(AbstractCatalinaTask.java:262) at org.apache.catalina.ant.DeployTask.execute(DeployTask.java:201) at com.flyer.izpack.webapp.Deploy.run(Deploy.java:68) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source) at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source) at java.lang.reflect.Method.invoke(Unknown Source) at com.izforge.izpack.installer.ProcessPanelWorker$ExecutableClass.run(Unknown Source) at com.izforge.izpack.installer.ProcessPanelWorker$ProcessingJob.run(Unknown Source) at com.izforge.izpack.installer.ProcessPanelWorker.run(Unknown Source) at java.lang.Thread.run(Unknown Source) Caused by: java.lang.OutOfMemoryError: Java heap space at java.util.Arrays.copyOf(Unknown Source) at java.io.ByteArrayOutputStream.write(Unknown Source) at sun.net.www.http.PosterOutputStream.write(Unknown Source) at java.io.BufferedOutputStream.write(Unknown Source) at org.apache.catalina.ant.AbstractCatalinaTask.execute(AbstractCatalinaTask.java:215) ... 10 more --- Nested Exception --- java.lang.OutOfMemoryError: Java heap space at java.util.Arrays.copyOf(Unknown Source) at java.io.ByteArrayOutputStream.write(Unknown Source) at sun.net.www.http.PosterOutputStream.write(Unknown Source) at java.io.BufferedOutputStream.write(Unknown Source) at org.apache.catalina.ant.AbstractCatalinaTask.execute(AbstractCatalinaTask.java:215) at org.apache.catalina.ant.DeployTask.execute(DeployTask.java:201) at com.flyer.izpack.webapp.Deploy.run(Deploy.java:68) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source) at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source) at java.lang.reflect.Method.invoke(Unknown Source) at com.izforge.izpack.installer.ProcessPanelWorker$ExecutableClass.run(Unknown Source) at com.izforge.izpack.installer.ProcessPanelWorker$ProcessingJob.run(Unknown Source) at com.izforge.izpack.installer.ProcessPanelWorker.run(Unknown Source) at java.lang.Thread.run(Unknown Source) I've tracked the issue to the use of java.net.HttpURLConnection without setting the contentLength (in some cases) and not using 'fixed length streaming mode' when contentLength is available. I'm attaching a patch that works for me with the DeployTask. I know that org.apache.catalina.ant.AbstractCatalinaTask is subclassed by many tasks, but I haven't tested all of those. I can probably provide some code to reproduce if needed. See also: https://issues.apache.org/bugzilla/show_bug.cgi?id=47660</column><column name="report_time">2010-02-10 22:46:18</column><column name="report_timestamp">1265860000</column><column name="status">resolved fixed</column><column name="commit">53e0674</column><column name="commit_timestamp">1265850000</column><column name="files">java/org/apache/catalina/ant/AbstractCatalinaTask.java
java/org/apache/catalina/ant/DeployTask.java</column><column name="result">1:java/org/apache/catalina/ant/DeployTask.java
61:java/org/apache/catalina/ant/AbstractCatalinaTask.java</column></table><table name="tomcat"><column name="id">711</column><column name="bug_id">48170</column><column name="summary">Unnecessary synchronization by JspFactory.getDefaultFactory contributes to stability problems</column><column name="description">I have a soak test at constant load that is initially stable. Within the hour, an ever increasing number of blocked threads develops. The vast majority of threads are in JSP rendering, blocked on JspFactory.getDefaultFactory(). The server eventually crashes. We are running Java 6. Upon code inspection, there appears to be no real reason for synchronizing the getDefaultFactory() and setDefaultFactory() as the setter is called only once upon startup when the sub-class loads. Patching the jar, I tried three other experiments: 1) Removing the synchronized keyword entirely. 2) Locking on an inner static class instead of the JspFactory.class. 3) Using volatile for the static member variable. Both experiments #1 and #3 showed vastly better stability. I was able to double the throughput of the server without seeing increasing number of blocked threads. Experiment #2 yielded the same behavior as the original code. Thus, no other code is synchronizing on JspFactory.class. Rather, there seem to be some sort of contention in the java.lang.Class monitor. Using volatile would preserve the multi-threading semantics while avoiding contributing to the instability issue.</column><column name="report_time">2009-11-10 18:04:01</column><column name="report_timestamp">1257890000</column><column name="status">resolved fixed</column><column name="commit">c09753b</column><column name="commit_timestamp">1265670000</column><column name="files">java/javax/servlet/jsp/JspFactory.java</column><column name="result">1:java/javax/servlet/jsp/JspFactory.java</column></table><table name="tomcat"><column name="id">712</column><column name="bug_id">48109</column><column name="summary">Improve binaryStream processing in WebappClassLoader#findResourceInternal</column><column name="description">(based on http://marc.info/?l=tomcat-dev&amp;m=124192105131636&amp;w=2) In WebappClassLoader#findResourceInternal() there is a lot of code between opening the binaryStream and starting to use it. There is a lot of processing, e.g.: if (!openJARs()) { return null; } if (antiJARLocking). If something happens in those steps, it is possible to leak InputStream references. One case is fixed with rev.772872, but it would be better to add a global try/finally block.</column><column name="report_time">2009-11-02 19:49:49</column><column name="report_timestamp">1257210000</column><column name="status">resolved fixed</column><column name="commit">dda2cbc</column><column name="commit_timestamp">1265670000</column><column name="files">java/org/apache/catalina/loader/WebappClassLoader.java</column><column name="result">1:java/org/apache/catalina/loader/WebappClassLoader.java</column></table><table name="tomcat"><column name="id">713</column><column name="bug_id">48665</column><column name="summary">RemoteIpValve examples refer to "connector" package</column><column name="description">Hi, The API doc https://tomcat.apache.org/tomcat-6.0-doc/api/org/apache/catalina/valves/RemoteIpValve.html uses "connector" package in the examples. Took me 10 minutes to figure out :) Best regards, -Bjarni</column><column name="report_time">2010-02-03 03:38:00</column><column name="report_timestamp">1265190000</column><column name="status">resolved fixed</column><column name="commit">9905155</column><column name="commit_timestamp">1265590000</column><column name="files">java/org/apache/catalina/valves/RemoteIpValve.java</column><column name="result">1:java/org/apache/catalina/valves/RemoteIpValve.java</column></table><table name="tomcat"><column name="id">714</column><column name="bug_id">48643</column><column name="summary">catalina.session.FileStore.save() and load() - close() bugs</column><column name="description">The code for the save() method reads: try { fos = new FileOutputStream(file.getAbsolutePath()); oos = new ObjectOutputStream(new BufferedOutputStream(fos)); } catch (IOException e) { if (oos != null) { &lt;== oos can only be null here try { oos.close(); } catch (IOException f) { // Ignore } } throw e; } Presumably the catch statement should try to close fos instead? Similarly for the load() method; at line 280/281 there is the code: } catch (IOException e) { if (ois != null) { However, ois is the last object created by the try clause, so must be null. Probably the code should check and close bis and/or fis. At the end of the load() method, the code says: // Close the input stream if (ois != null) { However, ois cannot be null at that point. Note: these bugs were detected by the Eclipse compiler.</column><column name="report_time">2010-01-30 16:53:02</column><column name="report_timestamp">1264890000</column><column name="status">resolved fixed</column><column name="commit">6f48cde</column><column name="commit_timestamp">1265580000</column><column name="files">java/org/apache/catalina/session/FileStore.java
java/org/apache/catalina/session/StandardManager.java</column><column name="result">1:java/org/apache/catalina/session/FileStore.java
3:java/org/apache/catalina/session/StandardManager.java</column></table><table name="tomcat"><column name="id">715</column><column name="bug_id">48678</column><column name="summary">org.apache.catalina.startup.Catalina incorrectly duplicates super class member</column><column name="description">Catalina declares its own protected member variable "server" and a corresponding "setServer" method, while Catalina's super class Embedded has a private member "server" and a "getServer" method, so that Catalina sets its "service" member, but when asking, will return super.server which is consistently null. This means that Catalina cannot be used as Tomcat embedding directly but at least requires an extension like so: public class MyCatalina extends Catalina { public Server getServer() { return this.server; } } It might have other ramifications though and was most likely not intended. See also: http://marc.info/?l=tomcat-user&amp;m=126502245412565&amp;w=2</column><column name="report_time">2010-02-04 00:09:04</column><column name="report_timestamp">1265260000</column><column name="status">resolved fixed</column><column name="commit">067e0ba</column><column name="commit_timestamp">1265490000</column><column name="files">java/org/apache/catalina/startup/Catalina.java</column><column name="result">2:java/org/apache/catalina/startup/Catalina.java</column></table><table name="tomcat"><column name="id">716</column><column name="bug_id">48551</column><column name="summary">StringCache: Use entrySet() rather than keySet() + get()</column><column name="description">Created attachment 24846 Replace keySet() + get(key) with entrySet() Using entrySet() to iterate over a map is faster than using keySet() followed by get(key). Sample patch attached. There are quite a few other examples elsewhere in the Tomcat code. I can provide patches for those if required.</column><column name="report_time">2010-01-14 19:23:43</column><column name="report_timestamp">1263520000</column><column name="status">resolved fixed</column><column name="commit">c85e791</column><column name="commit_timestamp">1265130000</column><column name="files">java/org/apache/catalina/deploy/WebXml.java
java/org/apache/tomcat/util/buf/StringCache.java</column><column name="result">1:java/org/apache/tomcat/util/buf/StringCache.java
83:java/org/apache/catalina/deploy/WebXml.java</column></table><table name="tomcat"><column name="id">717</column><column name="bug_id">48653</column><column name="summary">RemoteIpValve : request.secure and request.scheme are not forced to "false" and "http" if X-Forwarded-Proto=http</column><column name="description">Created attachment 24915 Tomcat 7 patch with many unit tests, updated docs and few additional jmx attributes fixes When X-Forwarded-Proto="http", the incoming request attributes secure, scheme and serverPort are not overridden as they are with "https". If a request came as unsecured/http but the communication between apache and tomcat is ssl, then request.isSecure(), request.getScheme() and request.getServerPort() are wrong. Proposed patch : * introduce a httpServerPort configuration parameter * modify logic for request.isSecure(), request.getScheme() , and request.getServerPort() : ** if header "x-forwarded-proto" is null then keep incoming values ** else if header "x-forwarded-proto" is equal to "https" then override values to true, https and 443 ** else override values to false, http and 80 Note : * "x-forwarded-proto", 80, 443 and "https" (as the ssl value for x-forwarded-proto header) are configurable ; I use sample values in the bug description to make it easier to understand.</column><column name="report_time">2010-02-01 09:26:02</column><column name="report_timestamp">1265030000</column><column name="status">resolved fixed</column><column name="commit">1789bd8</column><column name="commit_timestamp">1265120000</column><column name="files">java/org/apache/catalina/valves/RemoteIpValve.java
test/org/apache/catalina/valves/TestRemoteIpValve.java</column><column name="result">1:java/org/apache/catalina/valves/RemoteIpValve.java
2:test/org/apache/catalina/valves/TestRemoteIpValve.java</column></table><table name="tomcat"><column name="id">718</column><column name="bug_id">48647</column><column name="summary">RemoteIpFilter : request.secure and request.scheme are not forced to "false" and "http" if X-Forwarded-Proto=http</column><column name="description">Created attachment 24913 Tomcat 7 patch with updated docs When X-Forwarded-Proto="http", the incoming request attributes secure, scheme and serverPort are not overridden as they are with "https". If a request came as unsecured/http but the communication between apache and tomcat is ssl, then request.isSecure(), request.getScheme() and request.getServerPort() are wrong. Proposed patch : * introduce a httpServerPort configuration parameter * modify logic for request.isSecure(), request.getScheme() , and request.getServerPort() : ** if header "x-forwarded-proto" is null then keep incoming values ** else if header "x-forwarded-proto" is equal to "https" then override values to true, https and 443 ** else override values to false, http and 80 Note : * "x-forwarded-proto", 80, 443 and "https" (as the ssl value for x-forwarded-proto header) are configurable ; I use sample values in the bug description to make it easier to understand. * I will soon provide the same fix for RemoteIpValve.</column><column name="report_time">2010-01-31 16:28:21</column><column name="report_timestamp">1264970000</column><column name="status">resolved fixed</column><column name="commit">7aa1206</column><column name="commit_timestamp">1265120000</column><column name="files">java/org/apache/catalina/filters/RemoteIpFilter.java</column><column name="result">1:java/org/apache/catalina/filters/RemoteIpFilter.java</column></table><table name="tomcat"><column name="id">719</column><column name="bug_id">48645</column><column name="summary">RequestUtil.URLDecode(byte[] bytes, String enc)</column><column name="description">the enc is not used in the implementation public static String URLDecode(byte[] bytes, String enc) { return URLDecode(bytes, null, false); }</column><column name="report_time">2010-01-31 04:36:17</column><column name="report_timestamp">1264930000</column><column name="status">resolved fixed</column><column name="commit">d0f9da2</column><column name="commit_timestamp">1264940000</column><column name="files">java/org/apache/catalina/util/RequestUtil.java</column><column name="result">1:java/org/apache/catalina/util/RequestUtil.java</column></table><table name="tomcat"><column name="id">720</column><column name="bug_id">48516</column><column name="summary">NullPointerException in JNDIRealm</column><column name="description">Created attachment 24824 Patch to fix NPE There is a NullPointerException being thrown when the server attempts to look up a non-existent user in JNDIRealm. Specifically, the getUser(DirContext, String) method will return null if the user is not found. However, getPrincipal(DirContext, String) will not check to see if the result from getUser() is null. I'm attaching a patch from the 6.0.20 tag but this should also be backported to the 5.5.x branch as well because the issue exists there.</column><column name="report_time">2010-01-11 05:42:00</column><column name="report_timestamp">1263210000</column><column name="status">resolved fixed</column><column name="commit">62d29b6</column><column name="commit_timestamp">1263340000</column><column name="files">java/org/apache/catalina/realm/JNDIRealm.java</column><column name="result">1:java/org/apache/catalina/realm/JNDIRealm.java</column></table><table name="tomcat"><column name="id">721</column><column name="bug_id">48004</column><column name="summary">setHeader() does not replace the previous value for a "Server"</column><column name="description">Hello, In a servlet or in a filter (before passing the control to doFilter() or after) try the following HttpServletResponse myResponse = ... myResponse.setHeader("Server","My own server name because I do not want to expose the real server name to the public for security reasons"); ... In the headers of the response you will get Server	Apache-Coyote/1.1, My own server name... According to the J2EE API for HttpServletResponse.html.setHeader() http://java.sun.com/j2ee/sdk_1.3/techdocs/api/javax/servlet/http/HttpServletResponse.html#setHeader(java.lang.String,%20java.lang.String) ... Sets a response header with the given name and value. If the header had already been set, the new value overwrites the previous one. The containsHeader method can be used to test for the presence of a header before setting its value. ... In fact if I call myResponse.containsHeader("Server") I even get a false!!! If you look in the IDE at the response object and dig in the responses and wrappers, you will find at the end a buffer with some data already set by Tomcat with this value and other things . As I understand it Tomcat (or Coyote) does not let this header to be changed while nothing in the specification says that it is special. I did not find either a parameter in server.xml or other where the server name is specified to be overiden. So the spec is not implemented properly for this specific header. Some other values are in this buffer, my goal was not to change them but other headers or values could have the same issue. This issue is the same in Tomcat 5.5.28 and Tomcat 6.0.20. Not tested on 7.x. Thanks Olivier</column><column name="report_time">2009-10-15 11:16:16</column><column name="report_timestamp">1255620000</column><column name="status">resolved fixed</column><column name="commit">13daf69</column><column name="commit_timestamp">1263330000</column><column name="files">java/org/apache/coyote/http11/Http11AprProcessor.java
java/org/apache/coyote/http11/Http11NioProcessor.java
java/org/apache/coyote/http11/Http11Processor.java</column><column name="result">16:java/org/apache/coyote/http11/Http11AprProcessor.java
32:java/org/apache/coyote/http11/Http11Processor.java
71:java/org/apache/coyote/http11/Http11NioProcessor.java</column></table><table name="tomcat"><column name="id">722</column><column name="bug_id">48421</column><column name="summary">JULI webapp logging files will not closed when webapp is stopped,reloaded or undeployed</column><column name="description">In Tomcat 6 the JULI logging files which are (can be) declared in webapp/WEB-INF/classes/logging.properties will not closed, when the webapp is reloaded, stopped or even undeployed. The files will at last be closed, when tomcat is shut down or restarted. This is also true for the normally used Handler org.apache.juli.FileHandler, which opens a new File every day and closes the old. On windows this has following effects: A) If the webapp is undeployed the files which are open at this moment are locked and cannot be deleted until tomcat is (someday) stopped or restarted. B) If the webapp is reloaded the file is opened a second time. So the file has two open handles. The next day the FileHandler closes one handle but the file is kept locked through the other handle and cannot be deleted. Every time a webapp is reloaded the associated logfile is opened again (but not closed). This has the consequence that after reloading webapps a few times tomcat must be restarted from time to time. When tomcat is shutdown the unnecessary (and other) open files are closed and will get the shutdown time as modification time. That means any old log files will receive a current modification time, which is irritating. Steps to verify on windows: (for example: undeploy) 1. create in the examples webapp: of tomcat 6.0.20: examples/WEB-INF/classes/logging.properties: handlers = org.apache.juli.FileHandler org.apache.juli.FileHandler.level = FINE org.apache.juli.FileHandler.directory = ${catalina.base}/logs org.apache.juli.FileHandler.prefix = servlet-examples. 2. start tomcat 3. undeploy examples using manager Actual Results: file ${catalina.base}/logs/servlet-examples.&lt;date&gt;.log cannot be deleted (nor at the next day) Expected: file ${catalina.base}/logs/servlet-examples.&lt;date&gt;.log can be deleted very cumbersome Workaround (working for reload): The getHead method of a custom Formatter is extended to track the handlers along with the classloader and webapp. If for a webapp a different (i.e. new) classloader is detected the close method of the handlers assigned to the old classloader is called. So the assigned file is proper closed (and the Formatter.getTail result is appended) I have set severity at minor because tomcat can be used (without webapp logging). But it is a bug because with this logging the same logfile can be useless multiple open (as described above), which should be considered as buggy.</column><column name="report_time">2009-12-20 14:45:51</column><column name="report_timestamp">1261340000</column><column name="status">resolved fixed</column><column name="commit">eeb017a</column><column name="commit_timestamp">1263320000</column><column name="files">java/org/apache/juli/ClassLoaderLogManager.java
java/org/apache/juli/logging/LogFactory.java</column><column name="result">94:java/org/apache/juli/ClassLoaderLogManager.java
261:java/org/apache/juli/logging/LogFactory.java</column></table><table name="tomcat"><column name="id">723</column><column name="bug_id">48523</column><column name="summary">Duplicate property keys in various files</column><column name="description">There are some properties files with non-unique property keys; normally these should be unique. File: java\org\apache\catalina\realm\LocalStrings.properties Duplicate key: 'jaasRealm.userPrincipalSuccess' jaasRealm.userPrincipalSuccess=Principal "{0}" is a valid user class. We will use this as the user Principal. jaasRealm.userPrincipalSuccess=Subject for username "{0}" returned user Principal "{1}" Duplicate key: 'jaasRealm.userPrincipalFailure' jaasRealm.userPrincipalFailure=No valid user Principal found jaasRealm.userPrincipalFailure=Subject for username "{0}" did not return a valid user Principal File: java\org\apache\catalina\realm\LocalStrings_es.properties Duplicate key: 'jaasRealm.userPrincipalSuccess' jaasRealm.userPrincipalSuccess = El Principal "{0}" es una clase v\u00E1lida de usuario. La vamos a usar como usuario Principal. jaasRealm.userPrincipalSuccess = El asunto para el nombre de usuario "{0}" devolvi\u00F3 usuario Principal "{1}" Duplicate key: 'jaasRealm.userPrincipalFailure' jaasRealm.userPrincipalFailure = No se ha hallado usuario Principal jaasRealm.userPrincipalFailure = El asunto para el nombre de usuario "{0}" no devolvi\u00F3 un usuario Principal v\u00E1lido File: java\org\apache\catalina\startup\LocalStrings.properties Duplicate key: 'contextConfig.jndiUrl' contextConfig.jndiUrl=The connection created for URL [{0}] was not a DirContextURLConnection contextConfig.jndiUrl=Unable to process JNDI URL [{0}] for annotations Duplicate key: 'webXml.mergeConflictFilter' webXml.mergeConflictFilter=The Servlet [{0}] was defined inconsistently in multiple fragments including fragment with name [{1}] located at [{2}] webXml.mergeConflictFilter=The Filter [{0}] was defined inconsistently in multiple fragments including fragment with name [{1}] located at [{2}] File: java\org\apache\jasper\resources\LocalStrings.properties Duplicate key: 'jsp.error.page.invalid.buffer' jsp.error.page.invalid.buffer=Page directive: invalid value for buffer jsp.error.page.invalid.buffer=Page directive: invalid buffer size Duplicate key: 'jsp.error.xml.invalidHighSurrogate' jsp.error.xml.invalidHighSurrogate = High surrogate bits in UTF-8 sequence must not exceed 0x10 but found 0x{0}. jsp.error.xml.invalidHighSurrogate = High surrogate bits in UTF-8 sequence must not exceed 0x10 but found 0x{0}. File: java\org\apache\jasper\resources\LocalStrings_es.properties Duplicate key: 'jsp.error.page.invalid.buffer' jsp.error.page.invalid.buffer = Directiva Page\: valor incorrecto para b\u00FAfer jsp.error.page.invalid.buffer = Directiva Page\: valor incorrecto para buffer Duplicate key: 'jsp.error.xml.invalidHighSurrogate' jsp.error.xml.invalidHighSurrogate = Los bits de surrogaci\u00F3n alta en secuencai UTF-8 no deben de exceder 0x10 pero se hall\u00F3 0x{0}. jsp.error.xml.invalidHighSurrogate = Surrogaci\u00F3n Alta de bits en secuencia UTF-8 no debe de exceder 0x10, pero se hall\u00F3 0x{0}. File: java\org\apache\jasper\resources\LocalStrings_ja.properties Duplicate key: 'jsp.error.page.invalid.buffer' jsp.error.page.invalid.buffer=page\u6307\u793a\u5b50: buffer\u5c5e\u6027\u306e\u5024\u304c\u7121\u52b9\u3067\u3059 jsp.error.page.invalid.buffer=page\u6307\u793a\u5b50: \u7121\u52b9\u306a\u30d0\u30c3\u30d5\u30a1\u30b5\u30a4\u30ba\u3067\u3059 Duplicate key: 'jsp.error.xml.invalidHighSurrogate' jsp.error.xml.invalidHighSurrogate = UTF-8\u30b7\u30fc\u30b1\u30f3\u30b9\u306e\u30cf\u30a4\u30b5\u30ed\u30b2\u30fc\u30c8\u30d3\u30c3\u30c8\u306f0x10\u3092\u8d8a\u3048\u3066\u306f\u3044\u3051\u307e\u305b\u3093\u304c\u30010x{0}\u304c\u898b\u3064\u304b\u308a\u307e\u3057\u305f jsp.error.xml.invalidHighSurrogate = UTF-8\u30b7\u30fc\u30b1\u30f3\u30b9\u306e\u30cf\u30a4\u30b5\u30ed\u30b2\u30fc\u30c8\u30d3\u30c3\u30c8\u306f0x10\u3092\u8d8a\u3048\u3066\u306f\u3044\u3051\u307e\u305b\u3093\u304c\u30010x{0}\u304c\u898b\u3064\u304b\u308a\u307e\u3057\u305f File: java\org\apache\tomcat\util\net\res\LocalStrings.properties Duplicate key: 'endpoint.poll.fail' endpoint.poll.fail=Socket [{0}] poll event: [{1}] {2} endpoint.poll.fail=Critical poller failure (restarting poller): [{0}] {1} File: java\org\apache\tomcat\util\net\res\LocalStrings_es.properties Duplicate key: 'endpoint.poll.fail' endpoint.poll.fail = Conector [{0}] evento de encuesta\: [{1}] {2} endpoint.poll.fail = Fallo cr\u00EDtico de encuestador (reiniciando encuestador)\: [{0}] {1} File: java\org\apache\tomcat\util\net\res\LocalStrings.properties Duplicate key: 'endpoint.poll.fail' endpoint.poll.fail=Socket [{0}] poll event: [{1}] {2} endpoint.poll.fail=Critical poller failure (restarting poller): [{0}] {1} File: java\org\apache\tomcat\util\net\res\LocalStrings_es.properties Duplicate key: 'endpoint.poll.fail' endpoint.poll.fail = Conector [{0}] evento de encuesta\: [{1}] {2} endpoint.poll.fail = Fallo cr\u00EDtico de encuestador (reiniciando encuestador)\: [{0}] {1}</column><column name="report_time">2010-01-11 12:45:44</column><column name="report_timestamp">1263230000</column><column name="status">resolved fixed</column><column name="commit">f2eea0c</column><column name="commit_timestamp">1263290000</column><column name="files">java/org/apache/catalina/startup/ContextConfig.java</column><column name="result">4:java/org/apache/catalina/startup/ContextConfig.java</column></table><table name="tomcat"><column name="id">724</column><column name="bug_id">48517</column><column name="summary">@SuppressWarnings("unchecked") - document and reduce scope</column><column name="description">Created attachment 24826 Patch - see description @SuppressWarnings("unchecked") is occasionally necessary to stop the compiler complaining unnecessarily. The attached patch ensures that all the existing tags have comments explaining why they are OK - or necessary (because the API is not generic). It also restricts the scope of the annotation so that it only applies to the specific warning. The intention is to make code maintenance easier and safer.</column><column name="report_time">2010-01-11 07:49:28</column><column name="report_timestamp">1263210000</column><column name="status">resolved fixed</column><column name="commit">4df1957</column><column name="commit_timestamp">1263290000</column><column name="files">java/javax/el/BeanELResolver.java
java/javax/el/ELContext.java
java/javax/el/ResourceBundleELResolver.java
java/org/apache/catalina/loader/WebappClassLoader.java
java/org/apache/el/lang/ELSupport.java
java/org/apache/el/lang/EvaluationContext.java
java/org/apache/el/parser/AstIdentifier.java
java/org/apache/el/parser/AstValue.java
java/org/apache/el/parser/SimpleNode.java
java/org/apache/naming/resources/VirtualDirContext.java</column><column name="result">1:java/javax/el/ELContext.java
2:java/org/apache/el/lang/EvaluationContext.java
4:java/org/apache/el/parser/SimpleNode.java
11:java/org/apache/el/parser/AstIdentifier.java
12:java/org/apache/naming/resources/VirtualDirContext.java
14:java/org/apache/el/parser/AstValue.java
19:java/org/apache/catalina/loader/WebappClassLoader.java
37:java/javax/el/ResourceBundleELResolver.java
44:java/org/apache/el/lang/ELSupport.java
97:java/javax/el/BeanELResolver.java</column></table><table name="tomcat"><column name="id">725</column><column name="bug_id">48112</column><column name="summary">Closing curly brace in literal string incorrectly treated as expression terminator.</column><column name="description">On tomcat 6.0.20 something like the following line in a JSP causes a exception: &lt;c:out value="${fn:trim('{world}')}"/&gt; After removing the closing curly brace from the literal ('{world}' -&gt; '{world') the JSP works. This behaviour seems specific to 6.0.20, as on 6.0.18 and 6.0.16 the line above works fine. Example of exception: ===================== org.apache.jasper.JasperException: An exception occurred processing JSP page /test.jsp at line 11 8: &lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8"&gt; 9: &lt;/head&gt; 10: &lt;body&gt; 11: &lt;c:out value="${fn:trim('{world}')}"/&gt; 12: &lt;/body&gt; 13: &lt;/html&gt; Stacktrace: 	org.apache.jasper.servlet.JspServletWrapper.handleJspException(JspServletWrapper.java:505) 	org.apache.jasper.servlet.JspServletWrapper.service(JspServletWrapper.java:416) 	org.apache.jasper.servlet.JspServlet.serviceJspFile(JspServlet.java:342) 	org.apache.jasper.servlet.JspServlet.service(JspServlet.java:267) 	javax.servlet.http.HttpServlet.service(HttpServlet.java:717) root cause javax.el.ELException: Error Parsing: ${fn:trim('{world} 	org.apache.el.lang.ExpressionBuilder.createNodeInternal(ExpressionBuilder.java:125) 	org.apache.el.lang.ExpressionBuilder.build(ExpressionBuilder.java:150) 	org.apache.el.lang.ExpressionBuilder.createValueExpression(ExpressionBuilder.java:194) 	org.apache.el.ExpressionFactoryImpl.createValueExpression(ExpressionFactoryImpl.java:68) 	org.apache.jasper.runtime.PageContextImpl.proprietaryEvaluate(PageContextImpl.java:934) 	org.apache.jsp.test_jsp._jspx_meth_c_005fout_005f0(test_jsp.java:98) 	org.apache.jsp.test_jsp._jspService(test_jsp.java:72) 	org.apache.jasper.runtime.HttpJspBase.service(HttpJspBase.java:70) 	javax.servlet.http.HttpServlet.service(HttpServlet.java:717) 	org.apache.jasper.servlet.JspServletWrapper.service(JspServletWrapper.java:374) 	org.apache.jasper.servlet.JspServlet.serviceJspFile(JspServlet.java:342) 	org.apache.jasper.servlet.JspServlet.service(JspServlet.java:267) 	javax.servlet.http.HttpServlet.service(HttpServlet.java:717) root cause org.apache.el.parser.ParseException: Encountered " &lt;ILLEGAL_CHARACTER&gt; "\' "" at line 1, column 11. Was expecting one of: &lt;INTEGER_LITERAL&gt; ... &lt;FLOATING_POINT_LITERAL&gt; ... &lt;STRING_LITERAL&gt; ... "true" ... "false" ... "null" ... "(" ... ")" ... "!" ... "not" ... "empty" ... "-" ... &lt;IDENTIFIER&gt; ... 	org.apache.el.parser.ELParser.generateParseException(ELParser.java:2142) 	org.apache.el.parser.ELParser.jj_consume_token(ELParser.java:2024) 	org.apache.el.parser.ELParser.Function(ELParser.java:1207) 	org.apache.el.parser.ELParser.NonLiteral(ELParser.java:1114) 	org.apache.el.parser.ELParser.ValuePrefix(ELParser.java:1016) 	org.apache.el.parser.ELParser.Value(ELParser.java:965) 	org.apache.el.parser.ELParser.Unary(ELParser.java:947) 	org.apache.el.parser.ELParser.Multiplication(ELParser.java:711) 	org.apache.el.parser.ELParser.Math(ELParser.java:631) 	org.apache.el.parser.ELParser.Compare(ELParser.java:443) 	org.apache.el.parser.ELParser.Equality(ELParser.java:337) 	org.apache.el.parser.ELParser.And(ELParser.java:281) 	org.apache.el.parser.ELParser.Or(ELParser.java:225) 	org.apache.el.parser.ELParser.Choice(ELParser.java:182) 	org.apache.el.parser.ELParser.Expression(ELParser.java:174) 	org.apache.el.parser.ELParser.DynamicExpression(ELParser.java:146) 	org.apache.el.parser.ELParser.CompositeExpression(ELParser.java:43) 	org.apache.el.lang.ExpressionBuilder.createNodeInternal(ExpressionBuilder.java:93) 	org.apache.el.lang.ExpressionBuilder.build(ExpressionBuilder.java:150) 	org.apache.el.lang.ExpressionBuilder.createValueExpression(ExpressionBuilder.java:194) 	org.apache.el.ExpressionFactoryImpl.createValueExpression(ExpressionFactoryImpl.java:68) 	org.apache.jasper.runtime.PageContextImpl.proprietaryEvaluate(PageContextImpl.java:934) 	org.apache.jsp.test_jsp._jspx_meth_c_005fout_005f0(test_jsp.java:98) 	org.apache.jsp.test_jsp._jspService(test_jsp.java:72) 	org.apache.jasper.runtime.HttpJspBase.service(HttpJspBase.java:70) 	javax.servlet.http.HttpServlet.service(HttpServlet.java:717) 	org.apache.jasper.servlet.JspServletWrapper.service(JspServletWrapper.java:374) 	org.apache.jasper.servlet.JspServlet.serviceJspFile(JspServlet.java:342) 	org.apache.jasper.servlet.JspServlet.service(JspServlet.java:267) 	javax.servlet.http.HttpServlet.service(HttpServlet.java:717)</column><column name="report_time">2009-11-03 07:09:58</column><column name="report_timestamp">1257250000</column><column name="status">resolved fixed</column><column name="commit">11810fb</column><column name="commit_timestamp">1262800000</column><column name="files">test/org/apache/el/TestELEvaluation.java</column><column name="result">28:test/org/apache/el/TestELEvaluation.java</column></table><table name="tomcat"><column name="id">726</column><column name="bug_id">48424</column><column name="summary">Keep same logic for creating the objectnames for connector mbeans</column><column name="description">Currently, for connector MBeans, they are registered and unregistered by Connector classes themselves. But in the ServerLifecycle and MBeanUtils, there are also codes for unregistering the connector MBeans. Suppose it is used for double check ? The question is that the codes for creating connector object name are not same, in the MBeanUtils, it always assume that address property is of String type, sometimes that a ClassCastException would be thrown.</column><column name="report_time">2009-12-20 23:29:35</column><column name="report_timestamp">1261370000</column><column name="status">resolved fixed</column><column name="commit">da5f249</column><column name="commit_timestamp">1262720000</column><column name="files">java/org/apache/catalina/connector/Connector.java
java/org/apache/catalina/mbeans/MBeanUtils.java</column><column name="result">8:java/org/apache/catalina/mbeans/MBeanUtils.java
9:java/org/apache/catalina/connector/Connector.java</column></table><table name="tomcat"><column name="id">727</column><column name="bug_id">48006</column><column name="summary">Implement the header X-Powered-By suggested by the servlet specification</column><column name="description">Hello, The servlet 2.5 specification at http://jcp.org/aboutJava/communityprocess/mrel/jsr154/index2.html suggests in section "SRV.5.2 Headers" ... It is recommended that containers use the X-Powered-By HTTP header to publish its implementation information. The field value should consist of one or more implementation types, such as "Servlet/2.4". Optionally, the supplementary information of the container and the underlying Java platform can be added after the implementation type within parentheses. The container should be configurable to suppress this header. Heres the examples of this header. X-Powered-By: Servlet/2.4 X-Powered-By: Servlet/2.4 JSP/2.0 (Tomcat/5.0 JRE/1.4.1) ... This behavior is not implemented in Tomcat 6.0.20. To make it totally clear, may I suggest to return the precise Tomcat and JVM version with all the digits and the vendor such as Tomcat/5.5.28 JRE/SUN/1.5.0_12-b04) Having this headers helps a lot the development team to determine what is really running his application in test or production w/o asking to the maintenance guy who is either often unreachable or not able to answer (YES). Provide the option to remove the header through the configuration (file) or through programming (see related bugs 48004 and 48005). The servlet 3.0 specification at http://jcp.org/aboutJava/communityprocess/pfd/jsr315/index.html in the same section "SRV.5.2 Headers" says the same but I did not test for it in Tomcat 7. Thanks Olivier</column><column name="report_time">2009-10-15 11:34:52</column><column name="report_timestamp">1255620000</column><column name="status">resolved fixed</column><column name="commit">3d309a5</column><column name="commit_timestamp">1262260000</column><column name="files">java/org/apache/catalina/connector/CoyoteAdapter.java</column><column name="result">20:java/org/apache/catalina/connector/CoyoteAdapter.java</column></table><table name="tomcat"><column name="id">728</column><column name="bug_id">43819</column><column name="summary">Support latest JSR245 proposal to make EL "self-contained"</column><column name="description">Please add the two static methods ExpressionFactory.newInstance(..) as described in http://jcp.org/aboutJava/communityprocess/maintenance/jsr245/245-MR1.html. These changes make the EL "self-contained" and allow to plug-in third party EL implementations like JUEL (http://juel.sf.net).</column><column name="report_time">2007-11-08 14:48:53</column><column name="report_timestamp">1194550000</column><column name="status">resolved fixed</column><column name="commit">9a2ae02</column><column name="commit_timestamp">1262210000</column><column name="files">java/javax/el/ExpressionFactory.java
java/org/apache/jasper/compiler/JspUtil.java
java/org/apache/jasper/compiler/PageInfo.java
java/org/apache/jasper/compiler/Validator.java
java/org/apache/jasper/runtime/JspApplicationContextImpl.java</column><column name="result">60:java/org/apache/jasper/compiler/Validator.java
86:java/org/apache/jasper/compiler/JspUtil.java
109:java/org/apache/jasper/compiler/PageInfo.java
616:java/org/apache/jasper/runtime/JspApplicationContextImpl.java</column></table><table name="tomcat"><column name="id">729</column><column name="bug_id">48345</column><column name="summary">Session does time-out shorter than setting in web.xml when PersistentManager is used.</column><column name="description">I am encountering the problem that Session does time-out shorter than setting in web.xml. This is a simple scenario where the problem occurs. I am using PersistentManager by the following configuration. &lt;Context&gt; &lt;Manager className="org.apache.catalina.session.PersistentManager" maxIdleSwap="120"&gt; &lt;Store className="org.apache.catalina.session.FileStore"/&gt; &lt;/Manager&gt; &lt;/Context&gt; I am setting the session-timeout at five minutes. &lt;session-config&gt; &lt;session-timeout&gt;5&lt;/session-timeout&gt; &lt;/session-config&gt; [scenario] 1. Create Session. 2. 120 seconds pass. Session does swapOut. 3. In addition, 120 seconds pass. Get Session. Session does swapIn and access time of session in the memory is updated. 4. In addition, 90 seconds pass. Get Session. Because the access time of the session has been updated in (3), The session should be able to be acquired. However, the session can not be acquired. This cause is StoreBase#processExpires invoked between (3) and (4). StoreBase#processExpire deletes the session saved in Store. StoreBase#processExpires is as follows. =====StoreBase#processExpires===== public void processExpires() { ... for (int i = 0; i &lt; keys.length; i++) { try { StandardSession session = (StandardSession) load(keys[i]); if (session == null) { continue; } if (session.isValid()) { continue; } ... if ( ( (PersistentManagerBase) manager).isLoaded( keys[i] )) { // recycle old backup session session.recycle(); } else { // expire swapped out session session.expire(); } remove(session.getIdInternal()); } catch (Exception e) { ... } } } ====== The session saved in Store is loaded, and StandardSession#isValid() is executed. StandardSession#expire(true) is invoked for the session that passes session time-out in "StandardSession#isValid()". StandardSession#expire(true) invokes Manager#remove(Session). As a result, the session is deleted from the session map. In a word, session in memory is deleted by invalidating old session in Store. As a result, session does time-out shorter than setting in web.xml I made a patch against trunk. Best regards.</column><column name="report_time">2009-12-07 02:09:14</column><column name="report_timestamp">1260170000</column><column name="status">resolved fixed</column><column name="commit">d939925</column><column name="commit_timestamp">1262170000</column><column name="files">java/org/apache/catalina/session/StoreBase.java</column><column name="result">1:java/org/apache/catalina/session/StoreBase.java</column></table><table name="tomcat"><column name="id">730</column><column name="bug_id">48454</column><column name="summary">"Bad file descriptor"-IOException in CGIServlet for some programs</column><column name="description">Created attachment 24763 Patch The internal CGIRunner-thread which reads the errorstream logs a "Bad file descriptor"-IOException everytime i called a program (see stacktrace at the end). The program works fine, but the log-messages disturb. I could reproduce the behaviour with Nagiostat as CGI-Program (http://nagiostat.sourceforge.net/). I think the behaviour depends on how fast the cgi-program will return, because I haven't the error with another cgi-program on the same machine. Looking at the code shows that the Process-Object in CGIRunner could be destroyed before the internal Thread has a chance to completely read the errorstream. I fixed the problem in CGIServlet with a errorStreamReaderThread.join(...) before proc.destroy() to allow a clean processing of the errorstream. This is not yet fixed in tomcat trunk / branch tc6.0.x Environment: Linux, Centos5.3 x64, JDK SUN 1.6.0_17, JBoss AS 5.1.0.GA (based on tomcat6.0) Patch: The attached Patch is against source of JBossWeb2.1.3. Improvement: The timeout of the join should be configurable. java.io.IOException: Bad file descriptor at java.io.FileInputStream.readBytes(Native Method) at java.io.FileInputStream.read(FileInputStream.java:199) at sun.nio.cs.StreamDecoder.readBytes(StreamDecoder.java:264) at sun.nio.cs.StreamDecoder.implRead(StreamDecoder.java:306) at sun.nio.cs.StreamDecoder.read(StreamDecoder.java:158) at java.io.InputStreamReader.read(InputStreamReader.java:167) at java.io.BufferedReader.fill(BufferedReader.java:136) at java.io.BufferedReader.readLine(BufferedReader.java:299) at java.io.BufferedReader.readLine(BufferedReader.java:362) at org.apache.catalina.servlets.CGIServlet$CGIRunner.sendToLog(CGIServlet.java:1828) at org.apache.catalina.servlets.CGIServlet$CGIRunner.access$400(CGIServlet.java:1388) at org.apache.catalina.servlets.CGIServlet$CGIRunner$1.run(CGIServlet.java:1663)</column><column name="report_time">2009-12-29 02:46:52</column><column name="report_timestamp">1262070000</column><column name="status">resolved fixed</column><column name="commit">ae6c3c4</column><column name="commit_timestamp">1262170000</column><column name="files">java/org/apache/catalina/servlets/CGIServlet.java</column><column name="result">1:java/org/apache/catalina/servlets/CGIServlet.java</column></table><table name="tomcat"><column name="id">731</column><column name="bug_id">48443</column><column name="summary">when the context path is empty,tomcat will startup with a FileNotFoundException</column><column name="description">Created attachment 24756 fix the resource form when the &lt;contextpath&gt; is empty I deploy my app in tomcat without any context path, i.e. the url of index.jsp of my app is: http://localhost/index.jspbut not http://localhost/myapp/index.jsp. When tomcat startup,there is a FileNotFoundException: The connection created for URL [jndi:/localhost/WEB-INF/classes] was not a DirContextURLConnection java.io.FileNotFoundException 	at org.apache.naming.resources.DirContextURLConnection.list(DirContextURLConnection.java:436) 	at org.apache.catalina.startup.ContextConfig.processAnnotationsJndi(ContextConfig.java:1602) 	at org.apache.catalina.startup.ContextConfig.processAnnotationsUrl(ContextConfig.java:1518) 	at org.apache.catalina.startup.ContextConfig.webConfig(ContextConfig.java:1264) 	at org.apache.catalina.startup.ContextConfig.start(ContextConfig.java:928) because in this condition,the resource form should be /&lt;hostname&gt;/filename instead of /&lt;hostname&gt;/&lt;contextpath&gt;/filename I attachment a patch which can works fine for me.</column><column name="report_time">2009-12-24 22:34:44</column><column name="report_timestamp">1261710000</column><column name="status">resolved fixed</column><column name="commit">ff22e4a</column><column name="commit_timestamp">1262170000</column><column name="files">java/org/apache/naming/resources/DirContextURLConnection.java</column><column name="result">5:java/org/apache/naming/resources/DirContextURLConnection.java</column></table><table name="tomcat"><column name="id">732</column><column name="bug_id">48399</column><column name="summary">Lock fields should be final</column><column name="description">Created attachment 24715 Patch lock field that should be final A field that is used as a lock should be final. org.apache.catalina.ha.session.DeltaSession.diffLock is protected and mutable.</column><column name="report_time">2009-12-16 19:20:55</column><column name="report_timestamp">1261010000</column><column name="status">resolved fixed</column><column name="commit">e1d1476</column><column name="commit_timestamp">1261280000</column><column name="files">java/org/apache/catalina/ha/session/DeltaSession.java
java/org/apache/catalina/tribes/group/interceptors/OrderInterceptor.java
modules/jdbc-pool/java/org/apache/tomcat/jdbc/pool/MultiLockFairBlockingQueue.java</column><column name="result">6:java/org/apache/catalina/ha/session/DeltaSession.java
13:modules/jdbc-pool/java/org/apache/tomcat/jdbc/pool/MultiLockFairBlockingQueue.java
53:java/org/apache/catalina/tribes/group/interceptors/OrderInterceptor.java</column></table><table name="tomcat"><column name="id">733</column><column name="bug_id">47930</column><column name="summary">PersistentManager (using filestore) can return different session objects linked to the same session ID, when Tomcat is restarted</column><column name="description">Created attachment 24333 Sample webapp and scripts to reproduce issue When using PersistentManager with a filestore backing, I've noticed that (near) simultaneous requests with the same session ID, can cause PersistentManager to return two different session objects, shortly after restarting Tomcat. I have included a sample webapp, with a test script to create simultaneous HTTP requests to a servlet, that reproduces this issue. General steps to reproduce: 0. Configure PersistentManager to use FileStore. &lt;Manager className="org.apache.catalina.session.PersistentManager" &gt; &lt;Store className="org.apache.catalina.session.FileStore" directory="/tmp" &gt; &lt;/Store&gt; &lt;/Manager&gt; 1. Make a HTTP request to a servlet, and establish a new session. Note the new session ID created on the server. 2. Restart Tomcat (cleanly shutdown and startup). 3. Shortly after Tomcat starts and initialises, make near simultaneous HTTP requests to a servlet using the previously established session cookie. 4. Output the session IDs and session object hashcodes on the server side, that is associated with each request. 5. Some of the reported session object hashcodes will be different (even though their session IDs are the same). Additionally the HttpSessionListener will report that the additional sessions are created/destroyed. Expected results: Session object hashcodes should be the same for the requests (and have the same session ID). Notes on the included attachment: - sessionTest.zip contains a sample webapp with two servlets. The LoginServlet establishes a new session for a request. The TestServlet will use the session cookie attached to a request, and will retrieve the session object (printing its ID and hex-encoded object hashcode). SessionListener will log each time a session is created or destroyed. - The session_test.sh script will automatically start/shutdown Tomcat, and make HTTP requests using curl. You may have to change the location of TOMCAT_HOME, the URL of the deployed webapp, and the COOKIE path. - Using the sample webapp and script will not always reproduce the issue. It may take a few goes for it to reproduce it. Example output: [tomcat@localhost sessionTest]$ ./session_test.sh Starting Tomcat.. Logging in to init new session.. New sessiond ID: JSESSIONID=09DDD0198C190E3394C19808DD8E074A New session obj hashcode: 3e5e9db7 --- Shutting down Tomcat.. Starting Tomcat.. Session ID: JSESSIONID=09DDD0198C190E3394C19808DD8E074A Session obj hashcode: 46bb05de --- Session ID: JSESSIONID=09DDD0198C190E3394C19808DD8E074A Session obj hashcode: 46bb05de --- Session ID: JSESSIONID=09DDD0198C190E3394C19808DD8E074A Session obj hashcode: 68acbd3a --- Session ID: JSESSIONID=09DDD0198C190E3394C19808DD8E074A Session obj hashcode: 46bb05de --- Session ID: JSESSIONID=09DDD0198C190E3394C19808DD8E074A Session obj hashcode: 24bb6086 --- Session ID: JSESSIONID=09DDD0198C190E3394C19808DD8E074A Session obj hashcode: 24bb6086 --- Removing cookie /tmp/foo.cookie Shutting down Tomcat.. Notice that we have three different session objects tied to the same session ID, after the requests are made (with hashcodes: 46bb05de, 68acbd3a, 24bb6086).</column><column name="report_time">2009-10-01 22:42:57</column><column name="report_timestamp">1254450000</column><column name="status">resolved fixed</column><column name="commit">d9f2c99</column><column name="commit_timestamp">1261160000</column><column name="files">java/org/apache/catalina/session/PersistentManagerBase.java</column><column name="result">6:java/org/apache/catalina/session/PersistentManagerBase.java</column></table><table name="tomcat"><column name="id">734</column><column name="bug_id">48387</column><column name="summary">Make RemoteIpFilter parameters consistent with RemoteIpValve</column><column name="description">Created attachment 24705 Rename RemoteIpFilter#protocolHeaderSslValue into protocolHeaderHttpsValue RemoteIpFilter field 'protocolHeaderSslValue' is not consistent with RemoteIpValve where it is named 'protocolHeaderHttpsValue'. Proposed patch renames 'protocolHeaderSslValue' into 'protocolHeaderHttpsValue' (field + getter and setter) and enhance one javadoc sentence.</column><column name="report_time">2009-12-14 10:28:40</column><column name="report_timestamp">1260800000</column><column name="status">resolved fixed</column><column name="commit">803d64d</column><column name="commit_timestamp">1260830000</column><column name="files">java/org/apache/catalina/filters/RemoteIpFilter.java</column><column name="result">1:java/org/apache/catalina/filters/RemoteIpFilter.java</column></table><table name="tomcat"><column name="id">735</column><column name="bug_id">47744</column><column name="summary">Memory leak when using SSL + Java security manager</column><column name="description">Created attachment 24170 The zip described in the main bug. Contains test client, JSP for the server, and patch. When using SSL + the java security manager, Tomcat leaks memory when servlets access cert path/cipher as request properties. When the servlet/JSP asks for these properties and they are not in the request, they are loaded via the JSSESupport class. The offending method calculates the key size and attempts to cache this in the SSLSession. Without the security manager, this is fine. When the security manager runs, however, the AccessControlContext is different every time. Retrieving from the cache will always return null, and putting into the SSLSession's cache leaks memory. This part is probably a JVM bug and not Tomcat's fault, but Tomcat is exercising it nonetheless. Popular web service tools (such as Apache CXF) retrieve cert properties from the request for every invocation. Depending on the policy file, the leak may be relatively slow, requiring 100s of thousands or millions of requests; or it could be fast (in our case), requiring only ~40k to crash an instance of Tomcat limited to 1 gig of memory. A note here. The SSLSession can be collected once it is not in use, so the memory leak isn't permanent. If you turn down the SSLSession timeout and wait at least that amount of time in between using a specific session, you might never see this bug. You have to continuously use the same session *and* trip JSSESession into attempting to get the keysize. In our particular case, we have long-connected clients that stream information to us, so it is only taking is 10-20 minutes before we are being affected negatively by this. I have attached a zip containing: - A test client - A script (.bat, sorry guys, but easily adapted) to run the test client - A .jsp that trips the JSSESupport to call the affected method. - The simplest possible policy file, to demonstrate it's not a policy file issue. Also attached: a patch that fixes this issue. (It's in the zip for good measure.) I recommend setting the invocation count to at least 100,000 or so on the test client. Use jconsole or a similar tool attached to tomcat to monitor the memory use. You should notice that after the test, a large chunk of memory is not able to be returned by the garbage collector. If you apply the patch, update tomcat-coyote.jar, and re-run the load test, you will notice that memory consumption stays low and you can immediately return to the baseline.</column><column name="report_time">2009-08-26 11:01:57</column><column name="report_timestamp">1251300000</column><column name="status">resolved fixed</column><column name="commit">51d5511</column><column name="commit_timestamp">1260800000</column><column name="files">java/org/apache/tomcat/util/net/jsse/JSSESupport.java</column><column name="result">142:java/org/apache/tomcat/util/net/jsse/JSSESupport.java</column></table><table name="tomcat"><column name="id">736</column><column name="bug_id">47537</column><column name="summary">Empty response when forward to login page fails</column><column name="description">When tomcat receives a POST request on a session that has timedout, it will forward to the form based login page (form-login-page). If this forward fails for some reason (an error in the login page for instance), tomcat will return an empty HTTP response, without any error code. The tomcat log says "Unexpected error forwarding to login page" and contains the detailed stacktrace, but i would expect the error to show up in the browser as well (at least a 500 status)</column><column name="report_time">2009-07-15 10:06:41</column><column name="report_timestamp">1247670000</column><column name="status">resolved fixed</column><column name="commit">88b5d4b</column><column name="commit_timestamp">1260540000</column><column name="files">java/org/apache/catalina/authenticator/FormAuthenticator.java</column><column name="result">2:java/org/apache/catalina/authenticator/FormAuthenticator.java</column></table><table name="tomcat"><column name="id">737</column><column name="bug_id">48373</column><column name="summary">Can not get clients from TomcatBayeux</column><column name="description">When call the getClients method,there will be a Exception: java.lang.ArrayStoreException: java.util.HashMap$Entry maybe this method should be: public List&lt;Client&gt; getClients() { return java.util.Arrays.asList(clients.values().toArray(new Client[0])); } instead of this: public List&lt;Client&gt; getClients() { return java.util.Arrays.asList(clients.entrySet().toArray(new Client[0])); }</column><column name="report_time">2009-12-11 00:22:52</column><column name="report_timestamp">1260510000</column><column name="status">resolved fixed</column><column name="commit">b09d817</column><column name="commit_timestamp">1260530000</column><column name="files">modules/bayeux/java/org/apache/tomcat/bayeux/TomcatBayeux.java</column><column name="result">1:modules/bayeux/java/org/apache/tomcat/bayeux/TomcatBayeux.java</column></table><table name="tomcat"><column name="id">738</column><column name="bug_id">48370</column><column name="summary">PublishRequest.java can not be compiled</column><column name="description">There is a log used in org.apache.tomcat.bayeux.request.PublishRequest,but it was not be defined,so the class can not be complied successfully,there should be something like this? private static final Log log = LogFactory.getLog(PublishRequest.class);</column><column name="report_time">2009-12-10 17:24:23</column><column name="report_timestamp">1260480000</column><column name="status">resolved fixed</column><column name="commit">9be399f</column><column name="commit_timestamp">1260530000</column><column name="files">modules/bayeux/java/org/apache/tomcat/bayeux/request/PublishRequest.java</column><column name="result">1:modules/bayeux/java/org/apache/tomcat/bayeux/request/PublishRequest.java</column></table><table name="tomcat"><column name="id">739</column><column name="bug_id">48324</column><column name="summary">Javadoc fixes for connector.Request.java</column><column name="description">Created attachment 24655 Javadoc fixes for connector.Request.java</column><column name="report_time">2009-12-01 16:02:13</column><column name="report_timestamp">1259700000</column><column name="status">resolved fixed</column><column name="commit">549a5d5</column><column name="commit_timestamp">1260460000</column><column name="files">java/org/apache/catalina/connector/Request.java</column><column name="result">1:java/org/apache/catalina/connector/Request.java</column></table><table name="tomcat"><column name="id">740</column><column name="bug_id">47502</column><column name="summary">clustering fails on serializing javax.security.auth.subject</column><column name="description">Clustering fails on serializing javax.security.auth.subject. See stack below. I looked a little into the Tomcat code. In ./java/org/apache/catalina/connector/Request.java on line 1752 Tomcat puts the 'javax.security.auth.subject' on the session if you use a securitymanager. This is the MemoryUser in my case I think. I must use the securitymanager because I use RMI. Is there a solution possible by making the MemoryUser serializable or by not putting it in the session as an attribute. Mark Thomas &lt;markt_at_apache_dot_org&gt; suggested a note on the session at the Tomcat user-mailinglist. I've never seen notes on sessions. The MemoryUser comes from the security-constraint in my web.xml. Jul 8, 2009 5:53:52 PM org.apache.catalina.ha.session.DeltaSession writeObject SEVERE: Cannot serialize session attribute javax.security.auth.subject for session 9C533E0EB4A79ED5B206B8F5A5DB09AD java.io.NotSerializableException: org.apache.catalina.users.MemoryUser at java.io.ObjectOutputStream.writeObject0(ObjectOutputStream.java:1156) at java.io.ObjectOutputStream.writeObject(ObjectOutputStream.java:326) at java.util.LinkedList.writeObject(LinkedList.java:943) at sun.reflect.GeneratedMethodAccessor216.invoke(Unknown Source) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25) at java.lang.reflect.Method.invoke(Method.java:597) at java.io.ObjectStreamClass.invokeWriteObject(ObjectStreamClass.java:945) at java.io.ObjectOutputStream.writeSerialData(ObjectOutputStream.java:1461) at java.io.ObjectOutputStream.writeOrdinaryObject(ObjectOutputStream.java:1392) at java.io.ObjectOutputStream.writeObject0(ObjectOutputStream.java:1150) at java.io.ObjectOutputStream.access$300(ObjectOutputStream.java:143) at java.io.ObjectOutputStream$PutFieldImpl.writeFields(ObjectOutputStream.java:1668) at java.io.ObjectOutputStream.writeFields(ObjectOutputStream.java:454) at javax.security.auth.Subject$SecureSet.writeObject(Subject.java:1281) at sun.reflect.GeneratedMethodAccessor215.invoke(Unknown Source) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25) at java.lang.reflect.Method.invoke(Method.java:597) at java.io.ObjectStreamClass.invokeWriteObject(ObjectStreamClass.java:945) at java.io.ObjectOutputStream.writeSerialData(ObjectOutputStream.java:1461) at java.io.ObjectOutputStream.writeOrdinaryObject(ObjectOutputStream.java:1392) at java.io.ObjectOutputStream.writeObject0(ObjectOutputStream.java:1150) at java.io.ObjectOutputStream.defaultWriteFields(ObjectOutputStream.java:1509) at java.io.ObjectOutputStream.defaultWriteObject(ObjectOutputStream.java:416) at java.util.Collections$SynchronizedCollection.writeObject(Collections.java:1602) at sun.reflect.GeneratedMethodAccessor214.invoke(Unknown Source) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25) at java.lang.reflect.Method.invoke(Method.java:597) at java.io.ObjectStreamClass.invokeWriteObject(ObjectStreamClass.java:945) at java.io.ObjectOutputStream.writeSerialData(ObjectOutputStream.java:1461) at java.io.ObjectOutputStream.writeOrdinaryObject(ObjectOutputStream.java:1392) at java.io.ObjectOutputStream.writeObject0(ObjectOutputStream.java:1150) at java.io.ObjectOutputStream.defaultWriteFields(ObjectOutputStream.java:1509) at java.io.ObjectOutputStream.defaultWriteObject(ObjectOutputStream.java:416) at javax.security.auth.Subject.writeObject(Subject.java:919) at sun.reflect.GeneratedMethodAccessor213.invoke(Unknown Source) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25) at java.lang.reflect.Method.invoke(Method.java:597) at java.io.ObjectStreamClass.invokeWriteObject(ObjectStreamClass.java:945) at java.io.ObjectOutputStream.writeSerialData(ObjectOutputStream.java:1461) at java.io.ObjectOutputStream.writeOrdinaryObject(ObjectOutputStream.java:1392) at java.io.ObjectOutputStream.writeObject0(ObjectOutputStream.java:1150) at java.io.ObjectOutputStream.writeObject(ObjectOutputStream.java:326) at org.apache.catalina.ha.session.DeltaSession.writeObject(DeltaSession.java:714) at org.apache.catalina.ha.session.DeltaSession.writeObjectData(DeltaSession.java:475) at org.apache.catalina.ha.session.DeltaSession.writeObjectData(DeltaSession.java:472) at org.apache.catalina.ha.session.DeltaManager.serializeSessions(DeltaManager.java:733) at org.apache.catalina.ha.session.DeltaManager.sendSessions(DeltaManager.java:1513) at org.apache.catalina.ha.session.DeltaManager.handleGET_ALL_SESSIONS(DeltaManager.java:1479) at org.apache.catalina.ha.session.DeltaManager.messageReceived(DeltaManager.java:1310) at org.apache.catalina.ha.session.DeltaManager.messageDataReceived(DeltaManager.java:1093) at org.apache.catalina.ha.session.ClusterSessionListener.messageReceived(ClusterSessionListener.java:87) at org.apache.catalina.ha.tcp.SimpleTcpCluster.messageReceived(SimpleTcpCluster.java:901) at org.apache.catalina.ha.tcp.SimpleTcpCluster.messageReceived(SimpleTcpCluster.java:882) at org.apache.catalina.tribes.group.GroupChannel.messageReceived(GroupChannel.java:269) at org.apache.catalina.tribes.group.ChannelInterceptorBase.messageReceived(ChannelInterceptorBase.java:79) at org.apache.catalina.tribes.group.ChannelInterceptorBase.messageReceived(ChannelInterceptorBase.java:79) at org.apache.catalina.tribes.group.interceptors.TcpFailureDetector.messageReceived(TcpFailureDetector.java:110) at org.apache.catalina.tribes.group.ChannelInterceptorBase.messageReceived(ChannelInterceptorBase.java:79) at org.apache.catalina.tribes.group.ChannelCoordinator.messageReceived(ChannelCoordinator.java:241) at org.apache.catalina.tribes.transport.ReceiverBase.messageDataReceived(ReceiverBase.java:225) at org.apache.catalina.tribes.transport.nio.NioReplicationTask.drainChannel(NioReplicationTask.java:188) at org.apache.catalina.tribes.transport.nio.NioReplicationTask.run(NioReplicationTask.java:91) at java.util.concurrent.ThreadPoolExecutor$Worker.runTask(ThreadPoolExecutor.java:886) at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:908) at java.lang.Thread.run(Thread.java:619)</column><column name="report_time">2009-07-09 05:57:29</column><column name="report_timestamp">1247130000</column><column name="status">resolved fixed</column><column name="commit">806200c</column><column name="commit_timestamp">1259710000</column><column name="files">java/org/apache/catalina/ha/session/DeltaSession.java</column><column name="result">1:java/org/apache/catalina/ha/session/DeltaSession.java</column></table><table name="tomcat"><column name="id">741</column><column name="bug_id">48296</column><column name="summary">Generics fixes</column><column name="description">Created attachment 24626 Generics fixes Generics fixes</column><column name="report_time">2009-11-28 07:42:38</column><column name="report_timestamp">1259410000</column><column name="status">resolved fixed</column><column name="commit">ed40c2c</column><column name="commit_timestamp">1259710000</column><column name="files">java/org/apache/catalina/ant/jmx/JMXAccessorTask.java
java/org/apache/catalina/tribes/membership/Membership.java
java/org/apache/naming/resources/DirContextURLConnection.java</column><column name="result">309:java/org/apache/naming/resources/DirContextURLConnection.java
437:java/org/apache/catalina/tribes/membership/Membership.java</column></table><table name="tomcat"><column name="id">742</column><column name="bug_id">47342</column><column name="summary">ReplicatedContext#start throws NullPointerException.</column><column name="description">ReplicatedContext#start throws NullPointerException. context.xml is as follows. &lt;Context className="org.apache.catalina.ha.context.ReplicatedContext" /&gt; When Tomcat is started, the following logs are output. Jun 10, 2009 6:40:57 PM org.apache.catalina.ha.context.ReplicatedContext start SEVERE: Unable to start ReplicatedContext java.lang.NullPointerException at java.io.File.&lt;init&gt;(Unknown Source) at org.apache.catalina.core.StandardContext.getBasePath(StandardContext.java:4840) at org.apache.catalina.ha.context.ReplicatedContext.start(ReplicatedContext.java:63) at org.apache.catalina.core.ContainerBase.addChildInternal(ContainerBase.java:791) at org.apache.catalina.core.ContainerBase.addChild(ContainerBase.java:771) at org.apache.catalina.core.StandardHost.addChild(StandardHost.java:526) at org.apache.catalina.startup.HostConfig.deployDescriptor(HostConfig.java:630) at org.apache.catalina.startup.HostConfig.deployDescriptors(HostConfig.java:556) at org.apache.catalina.startup.HostConfig.deployApps(HostConfig.java:491) at org.apache.catalina.startup.HostConfig.start(HostConfig.java:1206) at org.apache.catalina.startup.HostConfig.lifecycleEvent(HostConfig.java:314) at org.apache.catalina.util.LifecycleSupport.fireLifecycleEvent(LifecycleSupport.java:119) at org.apache.catalina.core.ContainerBase.start(ContainerBase.java:1053) at org.apache.catalina.core.StandardHost.start(StandardHost.java:722) at org.apache.catalina.core.ContainerBase.start(ContainerBase.java:1045) at org.apache.catalina.core.StandardEngine.start(StandardEngine.java:443) at org.apache.catalina.core.StandardService.start(StandardService.java:516) at org.apache.catalina.core.StandardServer.start(StandardServer.java:710) at org.apache.catalina.startup.Catalina.start(Catalina.java:583) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source) at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source) at java.lang.reflect.Method.invoke(Unknown Source) at org.apache.catalina.startup.Bootstrap.start(Bootstrap.java:288) at org.apache.catalina.startup.Bootstrap.main(Bootstrap.java:413) This causes because docBase has not been initialized. I think that this solution for the problem is an addition of initialization to ReplicatedContext#start. I made a patch. Index: java/org/apache/catalina/ha/context/ReplicatedContext.java =================================================================== --- java/org/apache/catalina/ha/context/ReplicatedContext.java (revision 763870) +++ java/org/apache/catalina/ha/context/ReplicatedContext.java (working copy) @@ -51,6 +51,13 @@ @Override public synchronized void start() throws LifecycleException { if ( this.started ) return; + if( !initialized ) { + try { + init(); + } catch( Exception ex ) { + throw new LifecycleException("Error initializaing ", ex); + } + } super.addLifecycleListener(this); try { CatalinaCluster catclust = (CatalinaCluster)this.getCluster(); Regards.</column><column name="report_time">2009-06-10 02:48:24</column><column name="report_timestamp">1244620000</column><column name="status">resolved fixed</column><column name="commit">9afe6ce</column><column name="commit_timestamp">1259360000</column><column name="files">java/org/apache/catalina/ha/context/ReplicatedContext.java</column><column name="result">1:java/org/apache/catalina/ha/context/ReplicatedContext.java</column></table><table name="tomcat"><column name="id">743</column><column name="bug_id">48289</column><column name="summary">ElSupport - Javadoc and generics fixes</column><column name="description">Created attachment 24620 Patch - see description Patch to add some Javadoc and generics fixes to ElSupport. Note that the method coerceToEnum() remains to be fixed. Also adds some basic test cases for the compare() method.</column><column name="report_time">2009-11-25 16:35:49</column><column name="report_timestamp">1259180000</column><column name="status">resolved fixed</column><column name="commit">b8599a3</column><column name="commit_timestamp">1259350000</column><column name="files">java/org/apache/el/lang/ELSupport.java
test/org/apache/el/TestELEvaluation.java</column><column name="result">1:java/org/apache/el/lang/ELSupport.java</column></table><table name="tomcat"><column name="id">744</column><column name="bug_id">48288</column><column name="summary">Patch to fix generics in javax.el package helpers</column><column name="description">Created attachment 24619 Patch It's not possible to fix all the compiler warnings in the javax.el helper classes, because some of the overridden methods in javax.el use raw types in the specification. Patch to follow suppresses these warnings in ELContextWrapper and EvaluationContext</column><column name="report_time">2009-11-25 15:43:06</column><column name="report_timestamp">1259180000</column><column name="status">resolved fixed</column><column name="commit">2ac1900</column><column name="commit_timestamp">1259350000</column><column name="files">java/org/apache/el/lang/EvaluationContext.java
java/org/apache/jasper/el/ELContextWrapper.java</column><column name="result">380:java/org/apache/el/lang/EvaluationContext.java</column></table><table name="tomcat"><column name="id">745</column><column name="bug_id">48287</column><column name="summary">ApplicationContextFacade - generics fixes</column><column name="description">Created attachment 24618 Patch ApplicationContextFacade generates lots of "Type safety: Unchecked cast ..." warnings which are caused by the doPrivileged() method wrapper. These can be suppressed with the patch to follow.</column><column name="report_time">2009-11-25 15:36:20</column><column name="report_timestamp">1259180000</column><column name="status">resolved fixed</column><column name="commit">ce8d1c5</column><column name="commit_timestamp">1259350000</column><column name="files">java/org/apache/catalina/core/ApplicationContextFacade.java</column><column name="result">1:java/org/apache/catalina/core/ApplicationContextFacade.java</column></table><table name="tomcat"><column name="id">746</column><column name="bug_id">48285</column><column name="summary">ApplicationFilterFactory.matchDispatcher() fails to check ASYNC</column><column name="description">catalina.core.ApplicationFilterFactory.matchDispatcher(FilterMap filterMap, DispatcherType type) fails to check for type == ASYNC The extra case ought to be added (but I don't know what it should contain, so cannot provide a patch)</column><column name="report_time">2009-11-25 08:41:12</column><column name="report_timestamp">1259160000</column><column name="status">resolved fixed</column><column name="commit">f0a0aec</column><column name="commit_timestamp">1259340000</column><column name="files">java/org/apache/catalina/core/ApplicationFilterFactory.java
java/org/apache/catalina/deploy/FilterMap.java</column><column name="result">1:java/org/apache/catalina/core/ApplicationFilterFactory.java
13:java/org/apache/catalina/deploy/FilterMap.java</column></table><table name="tomcat"><column name="id">747</column><column name="bug_id">48282</column><column name="summary">Possible NPE in org.apache.tomcat.util.modeler.Registry</column><column name="description">Created attachment 24612 Patch - see description There is a possible NPE in org.apache.tomcat.util.modeler.Registry: if ((group == null) &amp;&amp; (item.getGroup() == null)) { results.add(item.getName()); } else if (group.equals(item.getGroup())) { // group may be null results.add(item.getName()); } The Javadoc implies that the item.getGroup() check should be nested. Patch to follow; also fixes one raw type.</column><column name="report_time">2009-11-25 07:42:40</column><column name="report_timestamp">1259150000</column><column name="status">resolved fixed</column><column name="commit">56897be</column><column name="commit_timestamp">1259340000</column><column name="files">java/org/apache/tomcat/util/modeler/Registry.java</column><column name="result">1:java/org/apache/tomcat/util/modeler/Registry.java</column></table><table name="tomcat"><column name="id">748</column><column name="bug_id">48267</column><column name="summary">Patch to fix generics in javax packages</column><column name="description">Created attachment 24597 Patch to fix generics in javax packages Patch to fix generics in javax packages</column><column name="report_time">2009-11-23 13:22:35</column><column name="report_timestamp">1259000000</column><column name="status">resolved fixed</column><column name="commit">632e68c</column><column name="commit_timestamp">1259340000</column><column name="files">java/javax/annotation/Resource.java
java/javax/ejb/EJB.java
java/javax/el/BeanELResolver.java
java/javax/el/ELContext.java
java/javax/el/ListELResolver.java
java/javax/el/MapELResolver.java
java/javax/el/ResourceBundleELResolver.java
java/javax/xml/ws/WebServiceRef.java</column><column name="result" /></table><table name="tomcat"><column name="id">749</column><column name="bug_id">48266</column><column name="summary">Patch to fix generics in catalina</column><column name="description">Created attachment 24596 Patch to fix generics in catalina As the subject says</column><column name="report_time">2009-11-23 13:21:28</column><column name="report_timestamp">1259000000</column><column name="status">resolved fixed</column><column name="commit">21cd308</column><column name="commit_timestamp">1259110000</column><column name="files">java/org/apache/catalina/ant/jmx/JMXAccessorTask.java
java/org/apache/catalina/connector/Request.java
java/org/apache/catalina/core/StandardPart.java
java/org/apache/catalina/ha/backend/CollectedInfo.java
java/org/apache/catalina/ha/session/BackupManager.java
java/org/apache/catalina/ha/tcp/ReplicationValve.java
java/org/apache/catalina/tribes/tipis/AbstractReplicatedMap.java
java/org/apache/catalina/tribes/transport/bio/MultipointBioSender.java</column><column name="result">20:java/org/apache/catalina/connector/Request.java
66:java/org/apache/catalina/ha/tcp/ReplicationValve.java
69:java/org/apache/catalina/tribes/tipis/AbstractReplicatedMap.java
263:java/org/apache/catalina/ha/session/BackupManager.java</column></table><table name="tomcat"><column name="id">750</column><column name="bug_id">47836</column><column name="summary">TldConfig keeps an internal list of ApplicationListeners</column><column name="description">Created attachment 24258 When the Context is stopped, clears the listeners list When a WebApp is refreshed, the following warning is displayed: "StandardContext.addApplicationListener : The listener "com.sun.faces.config.ConfigureListener" is already configured for this context. The duplicate definition has been ignored." This is because the TldConfig instance does not react to a STOP event of the StandardContext. It should clear the list's content when the WebApp is stopped. We've encountered this bug with tomcat 6.0.20. I've checked the Tomcat7 TldConfig code to see if the issue may still be there, but I'm not sure: there is some code dealing with already registered taglib URI that may prevent the warning. So the provided patch is against tomcat6.0.x branch (but should be easy to port to trunk if there is some interest). BTW, I've checked the TldLocationsCache source code, but it is not implementing the LifecycleListener interface, so that patch cannot be applied on that file ...</column><column name="report_time">2009-09-14 07:03:43</column><column name="report_timestamp">1252930000</column><column name="status">resolved fixed</column><column name="commit">92e53f3</column><column name="commit_timestamp">1259030000</column><column name="files">java/org/apache/catalina/core/StandardContext.java
java/org/apache/catalina/startup/TldConfig.java</column><column name="result">1:java/org/apache/catalina/startup/TldConfig.java
2:java/org/apache/catalina/core/StandardContext.java</column></table><table name="tomcat"><column name="id">751</column><column name="bug_id">48239</column><column name="summary">HexUtils exposes public array</column><column name="description">Created attachment 24567 Patch to replace direct array access with getters HexUtils has two public static arrays which ought to be immutable.</column><column name="report_time">2009-11-19 07:48:12</column><column name="report_timestamp">1258630000</column><column name="status">resolved fixed</column><column name="commit">55e5052</column><column name="commit_timestamp">1258940000</column><column name="files">java/org/apache/coyote/ajp/AjpAprProcessor.java
java/org/apache/coyote/ajp/AjpProcessor.java
java/org/apache/coyote/http11/Http11AprProcessor.java
java/org/apache/coyote/http11/Http11NioProcessor.java
java/org/apache/coyote/http11/Http11Processor.java
java/org/apache/coyote/http11/filters/ChunkedInputFilter.java
java/org/apache/coyote/http11/filters/ChunkedOutputFilter.java
java/org/apache/tomcat/util/buf/HexUtils.java
java/org/apache/tomcat/util/buf/MessageBytes.java</column><column name="result">1:java/org/apache/tomcat/util/buf/HexUtils.java
3:java/org/apache/coyote/http11/Http11Processor.java
5:java/org/apache/coyote/http11/Http11AprProcessor.java
6:java/org/apache/coyote/http11/Http11NioProcessor.java
7:java/org/apache/coyote/http11/filters/ChunkedOutputFilter.java
12:java/org/apache/coyote/http11/filters/ChunkedInputFilter.java
13:java/org/apache/coyote/ajp/AjpAprProcessor.java
14:java/org/apache/tomcat/util/buf/MessageBytes.java
19:java/org/apache/coyote/ajp/AjpProcessor.java</column></table><table name="tomcat"><column name="id">752</column><column name="bug_id">48248</column><column name="summary">tribes.group.interceptors.MessageDispatchInterceptor.run should be volatile</column><column name="description">org.apache.catalina.tribes.group.interceptors.MessageDispatchInterceptor.run should be volatile, as it is used to communicate between running threads.</column><column name="report_time">2009-11-20 04:56:14</column><column name="report_timestamp">1258710000</column><column name="status">resolved fixed</column><column name="commit">a524187</column><column name="commit_timestamp">1258940000</column><column name="files">java/org/apache/catalina/tribes/group/GroupChannel.java
java/org/apache/catalina/tribes/group/interceptors/MessageDispatchInterceptor.java
java/org/apache/catalina/tribes/group/interceptors/TcpPingInterceptor.java
java/org/apache/catalina/tribes/membership/McastServiceImpl.java</column><column name="result">1:java/org/apache/catalina/tribes/group/interceptors/MessageDispatchInterceptor.java
2:java/org/apache/catalina/tribes/group/GroupChannel.java
19:java/org/apache/catalina/tribes/membership/McastServiceImpl.java
41:java/org/apache/catalina/tribes/group/interceptors/TcpPingInterceptor.java</column></table><table name="tomcat"><column name="id">753</column><column name="bug_id">48249</column><column name="summary">org.apache.tomcat.util.net.NioBlockingSelector.BlockPoller.run &lt;= volatile</column><column name="description">org.apache.tomcat.util.net.NioBlockingSelector.BlockPoller.run should be volatile, as it is used to communicate between running threads.</column><column name="report_time">2009-11-20 05:06:47</column><column name="report_timestamp">1258710000</column><column name="status">resolved fixed</column><column name="commit">c7d7ba2</column><column name="commit_timestamp">1258940000</column><column name="files">java/org/apache/tomcat/util/net/NioBlockingSelector.java</column><column name="result">1:java/org/apache/tomcat/util/net/NioBlockingSelector.java</column></table><table name="tomcat"><column name="id">754</column><column name="bug_id">48049</column><column name="summary">org.apache.naming.NamingContext's destroySubcontext() method doesn't  invoke itself recursively, but invoke unbind() method</column><column name="description">Below is the original implementation of destroySubcontext(Name name) method: public void destroySubcontext(Name name) throws NamingException { checkWritable(); while ((!name.isEmpty()) &amp;&amp; (name.get(0).length() == 0)) name = name.getSuffix(1); if (name.isEmpty()) throw new NamingException (sm.getString("namingContext.invalidName")); NamingEntry entry = (NamingEntry) bindings.get(name.get(0)); if (entry == null) { throw new NameNotFoundException (sm.getString("namingContext.nameNotBound", name.get(0))); } if (name.size() &gt; 1) { if (entry.type == NamingEntry.CONTEXT) { ((Context) entry.value).unbind(name.getSuffix(1)); } else { throw new NamingException (sm.getString("namingContext.contextExpected")); } } else { if (entry.type == NamingEntry.CONTEXT) { ((Context) entry.value).close(); bindings.remove(name.get(0)); } else { throw new NotContextException (sm.getString("namingContext.contextExpected")); } } } However, the method invokes 'unbind' method rather than invokes itself recursively. if (name.size() &gt; 1) { if (entry.type == NamingEntry.CONTEXT) { ((Context) entry.value).unbind(name.getSuffix(1)); } else { throw new NamingException (sm.getString("namingContext.contextExpected")); } should be: if (name.size() &gt; 1) { if (entry.type == NamingEntry.CONTEXT) { ((Context) entry.value).destroySubcontext(name.getSuffix(1)); } else { throw new NamingException (sm.getString("namingContext.contextExpected")); }</column><column name="report_time">2009-10-25 07:24:55</column><column name="report_timestamp">1256470000</column><column name="status">resolved fixed</column><column name="commit">af8a612</column><column name="commit_timestamp">1258930000</column><column name="files">java/org/apache/naming/NamingContext.java</column><column name="result">1:java/org/apache/naming/NamingContext.java</column></table><table name="tomcat"><column name="id">755</column><column name="bug_id">47799</column><column name="summary">Domain does not work in Membership and DomainFilterInterceptor.</column><column name="description">I used domain ="{1,2,3,4}" as follows by the Cluster configuration. &lt;Cluster className="org.apache.catalina.ha.tcp.SimpleTcpCluster" channelSendOptions="6"&gt; ... &lt;Membership className="org.apache.catalina.tribes.membership.McastService" address="228.0.0.4" port="45564" frequency="500" dropTime="3000" domain="{1,2,3,4}"/&gt; ... &lt;Interceptor className="org.apache.catalina.tribes.group.interceptors.DomainFilterInterceptor" domain="{1,2,3,4}"/&gt; ... &lt;/Cluster&gt; However, domain does not work in Membership and DomainFilterInterceptor. The type of instance variable domain of org.apache.catalina.tribes.membership.McastService and org.apache.catalina.tribes.group.interceptors.DomainFilterInterceptor is byte array. org.apache.tomcat.util.IntrospectionUtils#setProperty is invoked in org.apache.tomcat.util.digester.SetPropertyRule#begin. However, Because byte array property is not supported in org.apache.tomcat.util.IntrospectionUtils#setProperty, McastService#setDomain(byte array) and DomainFilterInterceptor#setDomain(byte array) is never invoked. As a result, domain can not set, and domain is always null. There are two workarounds as follows. 1:org.apache.tomcat.util.IntrospectionUtils#setProperty supports byte array property. 2:Prepares setDomain(String) method for McastService and DomainFilterInterceptor. Invoke setDomain(byte array) from setDomain(String). This is the same way as org.apache.catalina.tribes.membership.StaticMember. I think that it is easy to prepare setDomain(String) method. I made the patch. McastService's patch against tomcat_trunk. [start.] Index: java/org/apache/catalina/tribes/membership/McastService.java =================================================================== --- java/org/apache/catalina/tribes/membership/McastService.java	(revision 787304) +++ java/org/apache/catalina/tribes/membership/McastService.java	(working copy) @@ -30,6 +30,7 @@ import org.apache.catalina.tribes.MessageListener; import org.apache.catalina.tribes.io.ChannelData; import org.apache.catalina.tribes.io.XByteBuffer; +import org.apache.catalina.tribes.util.Arrays; import org.apache.catalina.tribes.util.StringManager; import org.apache.catalina.tribes.util.UUIDGenerator; @@ -607,6 +608,12 @@ } } + public void setDomain(String domain) { + if ( domain == null ) return; + if ( domain.startsWith("{") ) setDomain(Arrays.fromString(domain)); + else setDomain(Arrays.convert(domain)); + } + /** * Simple test program * @param args Command-line arguments [end.] DomainFilterInterceptor's patch against tomcat_trunk. [start.] Index: java/org/apache/catalina/tribes/group/interceptors/DomainFilterInterceptor.java =================================================================== --- java/org/apache/catalina/tribes/group/interceptors/DomainFilterInterceptor.java	(revision 763870) +++ java/org/apache/catalina/tribes/group/interceptors/DomainFilterInterceptor.java	(working copy) @@ -97,4 +97,13 @@ public void setDomain(byte[] domain) { this.domain = domain; } + + public void setDomain(String domain) { + if ( domain == null ) return; + if (domain.startsWith("{")) + setDomain(org.apache.catalina.tribes.util.Arrays.fromString(domain)); +	 else + setDomain(org.apache.catalina.tribes.util.Arrays.convert(domain)); + } + } [end.] Best regards.</column><column name="report_time">2009-09-08 02:39:42</column><column name="report_timestamp">1252390000</column><column name="status">resolved fixed</column><column name="commit">94c643b</column><column name="commit_timestamp">1258930000</column><column name="files">java/org/apache/catalina/tribes/group/interceptors/DomainFilterInterceptor.java
java/org/apache/catalina/tribes/membership/McastService.java</column><column name="result">1:java/org/apache/catalina/tribes/group/interceptors/DomainFilterInterceptor.java
24:java/org/apache/catalina/tribes/membership/McastService.java</column></table><table name="tomcat"><column name="id">756</column><column name="bug_id">47462</column><column name="summary">The annotation doesn't become effective.(metadata-complete="false" is not effective.)</column><column name="description">Even if "false" is set to metadata-complete, the annotation doesn't become effective. To invalidate the annotation by all the Web applications of Tomcat, metadata-complete of conf/web.xml is set to "true". [conf/web.xml] &lt;web-app xmlns="http://java.sun.com/xml/ns/javaee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd" version="2.5" metadata-complete="true" &gt; ..... &lt;/web-app&gt; To make the annotation of Web application (testWebApp) effective, metadata-complete of webapps/testWebApp/WEB-INF/web.xml is set to "false". [webapps/testWebApp/WEB-INF/web.xml] &lt;web-app xmlns="http://java.sun.com/xml/ns/javaee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd" version="2.5" metadata-complete="false"&gt; .... &lt;/web-app&gt; However, testWebApp doesn't make the annotation effective. Because WebRuleSet#IgnoreAnnotationsRule#begin is as follows. When metadata-complete is "false", context.setIgnoreAnnotations(false) is not invoked. [WebRuleSet#IgnoreAnnotationsRule#begin] final class IgnoreAnnotationsRule extends Rule { public IgnoreAnnotationsRule() { } public void begin(String namespace, String name, Attributes attributes) throws Exception { Context context = (Context) digester.peek(digester.getCount() - 1); String value = attributes.getValue("metadata-complete"); if ("true".equals(value)) { context.setIgnoreAnnotations(true); } if (digester.getLogger().isDebugEnabled()) { digester.getLogger().debug (context.getClass().getName() + ".setIgnoreAnnotations( " + context.getIgnoreAnnotations() + ")"); } } } I think that the following patches are necessary. Index: java/org/apache/catalina/startup/WebRuleSet.java =================================================================== --- java/org/apache/catalina/startup/WebRuleSet.java	(revision 763870) +++ java/org/apache/catalina/startup/WebRuleSet.java	(working copy) @@ -848,6 +848,8 @@ String value = attributes.getValue("metadata-complete"); if ("true".equals(value)) { context.setIgnoreAnnotations(true); + } else if ("false".equals(value)) { + context.setIgnoreAnnotations(false); } if (digester.getLogger().isDebugEnabled()) { digester.getLogger().debug Best regards.</column><column name="report_time">2009-07-01 02:51:39</column><column name="report_timestamp">1246430000</column><column name="status">resolved fixed</column><column name="commit">04b0838</column><column name="commit_timestamp">1258920000</column><column name="files">java/org/apache/catalina/startup/WebRuleSet.java</column><column name="result">46:java/org/apache/catalina/startup/WebRuleSet.java</column></table><table name="tomcat"><column name="id">757</column><column name="bug_id">47997</column><column name="summary">NamingContextListener fails to add itself as a PropertyChangeListener to all namingResources</column><column name="description">Created attachment 24378 proposed fix In the NamingContextListener.lifecycleEvent(LifecycleEvent) method, the NamingContextListener object fails to add itself as a PropertyChangeListener to namingResources whose context is not a Server, e.g. a Context instance. This prevents the NamingResourcesMBean from working with non-Server contexts.</column><column name="report_time">2009-10-14 17:45:53</column><column name="report_timestamp">1255560000</column><column name="status">resolved fixed</column><column name="commit">58162ed</column><column name="commit_timestamp">1258920000</column><column name="files">java/org/apache/catalina/core/NamingContextListener.java</column><column name="result">1:java/org/apache/catalina/core/NamingContextListener.java</column></table><table name="tomcat"><column name="id">758</column><column name="bug_id">47718</column><column name="summary">ManagerBase leaks fd to /dev/urandom when context stopped</column><column name="description">On operating systems where /dev/urandom exists, org.apache.catalina.session.ManagerBase will use it as a source of data for getRandomBytes(). If you stop a context or undeploy a host, the number of file descriptors that have /dev/urandom open tomcat remains constant. For example, if you use the manager application to stop or undeploy a context, the number of file descriptors to /dev/urandom is the same as before the stop. File descriptor use is determined by using lsof or examining the /proc/&lt;pid&gt;/fd directory on Linux. The same issue is seen if you undeploy a virtual host. If you undeploy/deploy a context, or remove/add a virtual host, the # of file descriptors to /dev/urandom will increase each time. This is because ManagerBase does not close the DataInputStream it holds to /dev/urandom. The patch shown below resolves this issue. Stopping a context, or undeploying a virtual host will close the session manager's reference to /dev/urandom. --- apache-tomcat-5.5.28-src/container/catalina/src/share/org/apache/catalina/session/ManagerBase.java	2009-07-24 13:35:00.000000000 -0600 +++ apache-tomcat-5.5.28-gls/container/catalina/src/share/org/apache/catalina/session/ManagerBase.java	2009-08-20 13:38:03.000000000 -0600 @@ -688,10 +688,17 @@ } public void destroy() { if( oname != null ) Registry.getRegistry(null, null).unregisterComponent(oname); + if (randomIS!=null) { + try { + randomIS.close(); + } catch (IOException ioe) { + } + randomIS=null; + } initialized=false; oname = null; // Don't clear log since it is required in case attributes are changed // (eg via JMX) whilst the manager is stopped. }</column><column name="report_time">2009-08-20 14:48:26</column><column name="report_timestamp">1250790000</column><column name="status">resolved fixed</column><column name="commit">ae5c640</column><column name="commit_timestamp">1258920000</column><column name="files">java/org/apache/catalina/session/ManagerBase.java</column><column name="result">1:java/org/apache/catalina/session/ManagerBase.java</column></table><table name="tomcat"><column name="id">759</column><column name="bug_id">48252</column><column name="summary">StackOverflowError in NioEndpoint.setProperty when setting jkHome</column><column name="description">- Noticed only when running in debugger with breakpoint set for StackOverflowError. - The error is translated by Java's reflection mechanism to an InvocationTargetException, which is caught and silently ignored by IntrospectionUtils. - Connector.initialize() sets jkHome property on Http11NioProtocol. - Http11NioProtocol sets jkHome property on NioEndpoint. - NioEndpoint recursively invokes its own setProperty method via IntrospectionUtils.setProperty, causing the stack overflow. - Using embedded Tomcat. - Using Nio connector. Does not happen for standard connector. - Happens in 6.0.18 and 6.0.20; haven't tested with earlier versions.</column><column name="report_time">2009-11-20 08:25:45</column><column name="report_timestamp">1258720000</column><column name="status">resolved fixed</column><column name="commit">c0cb61b</column><column name="commit_timestamp">1258740000</column><column name="files">java/org/apache/tomcat/util/IntrospectionUtils.java
java/org/apache/tomcat/util/net/AbstractEndpoint.java</column><column name="result">4:java/org/apache/tomcat/util/net/AbstractEndpoint.java
64:java/org/apache/tomcat/util/IntrospectionUtils.java</column></table><table name="tomcat"><column name="id">760</column><column name="bug_id">48234</column><column name="summary">org.apache.catalina.core.ContainerBase.getLogger() not thread-safe?</column><column name="description">org.apache.catalina.core.ContainerBase.getLogger() is not synchronised, yet all the other methods which access org.apache.catalina.core.ContainerBase.logger are synch. This seems wrong. org.apache.catalina.core.ContainerBase.logger should probably be private to prevent unsynch. access by subclasses. Similar considerations apply to logName and logName() The Javadoc for getLogger() states that it can return null - that does not appear to be possible. [Not sure if the method ever returns the parent logger either.]</column><column name="report_time">2009-11-18 17:41:42</column><column name="report_timestamp">1258580000</column><column name="status">resolved fixed</column><column name="commit">c53173b</column><column name="commit_timestamp">1258600000</column><column name="files">java/org/apache/catalina/core/ContainerBase.java</column><column name="result">1:java/org/apache/catalina/core/ContainerBase.java</column></table><table name="tomcat"><column name="id">761</column><column name="bug_id">48172</column><column name="summary">JspRuntimeContext synch. problems.</column><column name="description">JspRuntimeContext.jspReloadCount is synchronised when updated, but not when read by getJspReloadCount(). If the instance is accessed from multiple threads, then the returned value may not be the current value, it could be arbitrarily stale. If this is acceptable, then the Javadoc should say so; otherwise the getter needs to be synch. (or the field needs to be volatile) Or just use AtomicInteger. == Various other fields are neither final nor synchronized, e.g. classpath codeSource etc. As far as I can tell, these could easily be made final as they are only written by the constructor.</column><column name="report_time">2009-11-11 03:23:50</column><column name="report_timestamp">1257930000</column><column name="status">resolved fixed</column><column name="commit">242b6a3</column><column name="commit_timestamp">1258590000</column><column name="files">java/org/apache/jasper/compiler/JspRuntimeContext.java</column><column name="result">1:java/org/apache/jasper/compiler/JspRuntimeContext.java</column></table><table name="tomcat"><column name="id">762</column><column name="bug_id">48197</column><column name="summary">XByteBuffer: privatize public fields; fix Javadoc</column><column name="description">Created attachment 24536 Patch to fix various problems in XByteBuffer. Patch to fix various problems in XByteBuffer.</column><column name="report_time">2009-11-14 06:29:45</column><column name="report_timestamp">1258200000</column><column name="status">resolved fixed</column><column name="commit">a1cb0c3</column><column name="commit_timestamp">1258590000</column><column name="files">java/org/apache/catalina/tribes/io/XByteBuffer.java</column><column name="result">1:java/org/apache/catalina/tribes/io/XByteBuffer.java</column></table><table name="tomcat"><column name="id">763</column><column name="bug_id">48230</column><column name="summary">Unused imports</column><column name="description">Created attachment 24559 Unused imports - patch</column><column name="report_time">2009-11-18 14:00:17</column><column name="report_timestamp">1258570000</column><column name="status">resolved fixed</column><column name="commit">84d49a0</column><column name="commit_timestamp">1258590000</column><column name="files">java/org/apache/catalina/Authenticator.java
java/org/apache/catalina/authenticator/FormAuthenticator.java
java/org/apache/tomcat/util/net/NioEndpoint.java
modules/jdbc-pool/test/org/apache/tomcat/jdbc/test/TestSuspectTimeout.java</column><column name="result">104:java/org/apache/catalina/authenticator/FormAuthenticator.java</column></table><table name="tomcat"><column name="id">764</column><column name="bug_id">48217</column><column name="summary">Loggers should be final</column><column name="description">Created attachment 24554 Make logs final and private; add missing @Override markers</column><column name="report_time">2009-11-17 16:30:07</column><column name="report_timestamp">1258490000</column><column name="status">resolved fixed</column><column name="commit">0d7263a</column><column name="commit_timestamp">1258550000</column><column name="files">java/org/apache/coyote/http11/AbstractHttp11Protocol.java
java/org/apache/coyote/http11/Http11NioProtocol.java
java/org/apache/coyote/http11/Http11Protocol.java</column><column name="result">605:java/org/apache/coyote/http11/AbstractHttp11Protocol.java</column></table><table name="tomcat"><column name="id">765</column><column name="bug_id">48196</column><column name="summary">Public arrays that should be private</column><column name="description">Created attachment 24535 Patch fixes some public arrays that aren't currently accessed outside their class. Arrays should never be public unless they have zero elements. Patch fixes some public arrays that aren't currently accessed outside their class.</column><column name="report_time">2009-11-14 06:28:06</column><column name="report_timestamp">1258200000</column><column name="status">resolved fixed</column><column name="commit">38f52b5</column><column name="commit_timestamp">1258500000</column><column name="files">java/org/apache/catalina/startup/Tomcat.java
java/org/apache/catalina/tribes/group/interceptors/TwoPhaseCommitInterceptor.java
java/org/apache/catalina/util/HexUtils.java</column><column name="result">212:java/org/apache/catalina/startup/Tomcat.java
225:java/org/apache/catalina/util/HexUtils.java
342:java/org/apache/catalina/tribes/group/interceptors/TwoPhaseCommitInterceptor.java</column></table><table name="tomcat"><column name="id">766</column><column name="bug_id">48176</column><column name="summary">Fields that should be final</column><column name="description">Created attachment 24517 Patch fields that should be final</column><column name="report_time">2009-11-11 08:01:28</column><column name="report_timestamp">1257940000</column><column name="status">resolved fixed</column><column name="commit">16c4534</column><column name="commit_timestamp">1258500000</column><column name="files">java/org/apache/catalina/tribes/io/BufferPool.java
java/org/apache/jasper/compiler/ServletWriter.java
modules/tomcat-lite/java/org/apache/tomcat/util/http/MimeMap.java</column><column name="result">656:java/org/apache/catalina/tribes/io/BufferPool.java</column></table><table name="tomcat"><column name="id">767</column><column name="bug_id">48175</column><column name="summary">Loggers should be final</column><column name="description">Created attachment 24516 Patch to make log fields final where possible Log fields should be final (see r834226)</column><column name="report_time">2009-11-11 07:37:28</column><column name="report_timestamp">1257940000</column><column name="status">resolved fixed</column><column name="commit">799b934</column><column name="commit_timestamp">1258500000</column><column name="files">java/org/apache/catalina/core/ApplicationFilterConfig.java
java/org/apache/catalina/core/ContainerBase.java
java/org/apache/catalina/core/StandardHost.java
java/org/apache/catalina/core/StandardWrapper.java
java/org/apache/catalina/ha/ClusterListener.java
java/org/apache/catalina/ha/context/ReplicatedContext.java
java/org/apache/catalina/ha/deploy/FarmWarDeployer.java
java/org/apache/catalina/ha/deploy/FileMessageFactory.java
java/org/apache/catalina/ha/deploy/WarWatcher.java
java/org/apache/catalina/ha/session/BackupManager.java
java/org/apache/catalina/ha/session/DeltaManager.java
java/org/apache/catalina/ha/session/DeltaRequest.java
java/org/apache/catalina/ha/session/DeltaSession.java
java/org/apache/catalina/ha/session/JvmRouteBinderValve.java
java/org/apache/catalina/ha/session/SerializablePrincipal.java
java/org/apache/catalina/ha/session/SimpleTcpReplicationManager.java
java/org/apache/catalina/ha/tcp/ReplicationValve.java
java/org/apache/catalina/loader/WebappClassLoader.java
java/org/apache/catalina/loader/WebappLoader.java
java/org/apache/catalina/mbeans/MBeanFactory.java
java/org/apache/catalina/security/SecurityConfig.java
java/org/apache/catalina/security/SecurityUtil.java
java/org/apache/catalina/startup/Catalina.java
java/org/apache/catalina/startup/CatalinaProperties.java
java/org/apache/catalina/startup/ContextConfig.java
java/org/apache/catalina/startup/DefaultJarScanner.java
java/org/apache/catalina/startup/DigesterFactory.java
java/org/apache/catalina/startup/EngineConfig.java
java/org/apache/catalina/startup/HostConfig.java
java/org/apache/catalina/startup/TldConfig.java
java/org/apache/catalina/startup/UserConfig.java
java/org/apache/catalina/startup/WebXml.java
java/org/apache/catalina/tribes/group/ChannelInterceptorBase.java
java/org/apache/catalina/tribes/group/GroupChannel.java
java/org/apache/catalina/tribes/group/RpcChannel.java
java/org/apache/catalina/tribes/group/interceptors/FragmentationInterceptor.java
java/org/apache/catalina/tribes/group/interceptors/MessageDispatchInterceptor.java
java/org/apache/catalina/tribes/group/interceptors/TcpFailureDetector.java
java/org/apache/catalina/tribes/group/interceptors/TcpPingInterceptor.java
java/org/apache/catalina/tribes/group/interceptors/ThroughputInterceptor.java
java/org/apache/catalina/tribes/group/interceptors/TwoPhaseCommitInterceptor.java
java/org/apache/catalina/tribes/io/ObjectReader.java
java/org/apache/catalina/tribes/io/XByteBuffer.java
java/org/apache/catalina/tribes/membership/McastService.java
java/org/apache/catalina/tribes/membership/McastServiceImpl.java
java/org/apache/catalina/tribes/tipis/LazyReplicatedMap.java
java/org/apache/catalina/tribes/tipis/ReplicatedMap.java
java/org/apache/catalina/tribes/transport/bio/BioReceiver.java
java/org/apache/catalina/tribes/transport/bio/BioReplicationTask.java
java/org/apache/catalina/tribes/transport/bio/BioSender.java
java/org/apache/catalina/tribes/transport/bio/util/FastQueue.java
java/org/apache/catalina/tribes/transport/nio/NioReceiver.java
java/org/apache/catalina/tribes/transport/nio/NioReplicationTask.java
java/org/apache/catalina/tribes/transport/nio/NioSender.java
java/org/apache/catalina/tribes/transport/nio/ParallelNioSender.java
java/org/apache/catalina/tribes/util/Logs.java
java/org/apache/catalina/util/ExtensionValidator.java
java/org/apache/coyote/ajp/AjpAprProcessor.java
java/org/apache/coyote/ajp/AjpAprProtocol.java
java/org/apache/coyote/ajp/AjpMessage.java
java/org/apache/coyote/ajp/AjpProcessor.java
java/org/apache/coyote/ajp/AjpProtocol.java
java/org/apache/coyote/http11/AbstractHttp11Processor.java
java/org/apache/coyote/http11/Http11AprProcessor.java
java/org/apache/coyote/http11/Http11AprProtocol.java
java/org/apache/coyote/http11/Http11NioProtocol.java
java/org/apache/coyote/http11/Http11Protocol.java
java/org/apache/jasper/JspCompilationContext.java
java/org/apache/jasper/compiler/SmapUtil.java
java/org/apache/jasper/security/SecurityClassLoad.java
java/org/apache/jasper/xmlparser/UCSReader.java
java/org/apache/jasper/xmlparser/UTF8Reader.java
java/org/apache/naming/NamingContext.java
java/org/apache/naming/SelectorContext.java
java/org/apache/naming/resources/FileDirContext.java
java/org/apache/naming/resources/WARDirContext.java
java/org/apache/tomcat/util/DomUtil.java
java/org/apache/tomcat/util/IntrospectionUtils.java
java/org/apache/tomcat/util/buf/B2CConverter.java
java/org/apache/tomcat/util/buf/C2BConverter.java
java/org/apache/tomcat/util/buf/StringCache.java
java/org/apache/tomcat/util/buf/UEncoder.java
java/org/apache/tomcat/util/http/Cookies.java
java/org/apache/tomcat/util/http/Parameters.java
java/org/apache/tomcat/util/http/mapper/Mapper.java
java/org/apache/tomcat/util/net/SSLImplementation.java
java/org/apache/tomcat/util/net/jsse/JSSEImplementation.java
java/org/apache/tomcat/util/net/jsse/JSSESocketFactory.java
java/org/apache/tomcat/util/net/jsse/JSSESupport.java
modules/tomcat-lite/java/org/apache/tomcat/util/http/mapper/BaseMapper.java
test/org/apache/catalina/tribes/demos/IntrospectionUtils.java</column><column name="result">4:java/org/apache/catalina/core/ContainerBase.java
10:java/org/apache/catalina/loader/WebappLoader.java
13:java/org/apache/catalina/tribes/util/Logs.java
15:java/org/apache/catalina/startup/UserConfig.java
16:java/org/apache/catalina/startup/EngineConfig.java
19:java/org/apache/tomcat/util/net/SSLImplementation.java
28:java/org/apache/tomcat/util/http/mapper/Mapper.java
35:java/org/apache/catalina/mbeans/MBeanFactory.java
37:java/org/apache/catalina/core/ApplicationFilterConfig.java
42:java/org/apache/catalina/core/StandardWrapper.java
48:modules/tomcat-lite/java/org/apache/tomcat/util/http/mapper/BaseMapper.java
70:java/org/apache/tomcat/util/net/jsse/JSSEImplementation.java
72:java/org/apache/coyote/http11/Http11AprProcessor.java
75:java/org/apache/catalina/startup/HostConfig.java
97:java/org/apache/catalina/security/SecurityUtil.java
108:java/org/apache/coyote/http11/Http11AprProtocol.java
122:java/org/apache/jasper/JspCompilationContext.java
130:java/org/apache/coyote/ajp/AjpAprProcessor.java
132:java/org/apache/catalina/tribes/membership/McastServiceImpl.java
134:java/org/apache/catalina/tribes/transport/nio/NioReplicationTask.java
135:java/org/apache/catalina/loader/WebappClassLoader.java
137:java/org/apache/catalina/ha/session/DeltaManager.java
141:java/org/apache/catalina/startup/TldConfig.java
154:java/org/apache/coyote/http11/Http11NioProtocol.java
156:java/org/apache/jasper/compiler/SmapUtil.java
165:java/org/apache/coyote/http11/AbstractHttp11Processor.java
185:java/org/apache/catalina/ha/session/DeltaSession.java
187:java/org/apache/coyote/ajp/AjpProcessor.java
202:java/org/apache/tomcat/util/buf/StringCache.java
229:java/org/apache/catalina/ha/context/ReplicatedContext.java
251:java/org/apache/naming/resources/FileDirContext.java
260:java/org/apache/catalina/startup/WebXml.java
262:java/org/apache/tomcat/util/net/jsse/JSSESocketFactory.java
264:java/org/apache/catalina/startup/ContextConfig.java
267:java/org/apache/coyote/ajp/AjpMessage.java
270:java/org/apache/catalina/util/ExtensionValidator.java
271:java/org/apache/catalina/ha/deploy/FarmWarDeployer.java
277:java/org/apache/tomcat/util/http/Parameters.java
353:java/org/apache/catalina/tribes/transport/nio/ParallelNioSender.java
361:java/org/apache/coyote/http11/Http11Protocol.java
366:java/org/apache/catalina/startup/Catalina.java
430:java/org/apache/catalina/tribes/group/ChannelInterceptorBase.java
431:java/org/apache/catalina/tribes/group/RpcChannel.java
435:java/org/apache/catalina/ha/ClusterListener.java
437:java/org/apache/tomcat/util/buf/C2BConverter.java
492:java/org/apache/tomcat/util/http/Cookies.java
499:java/org/apache/jasper/xmlparser/UTF8Reader.java
522:java/org/apache/tomcat/util/IntrospectionUtils.java
523:test/org/apache/catalina/tribes/demos/IntrospectionUtils.java
550:java/org/apache/catalina/security/SecurityConfig.java
551:java/org/apache/catalina/tribes/group/interceptors/TwoPhaseCommitInterceptor.java
554:java/org/apache/catalina/tribes/transport/nio/NioReceiver.java
577:java/org/apache/catalina/ha/session/BackupManager.java
579:java/org/apache/catalina/tribes/group/interceptors/TcpFailureDetector.java
588:java/org/apache/tomcat/util/buf/B2CConverter.java
629:java/org/apache/catalina/tribes/group/interceptors/MessageDispatchInterceptor.java
714:java/org/apache/catalina/ha/session/SerializablePrincipal.java
723:java/org/apache/jasper/security/SecurityClassLoad.java
742:java/org/apache/catalina/tribes/tipis/ReplicatedMap.java
765:java/org/apache/tomcat/util/buf/UEncoder.java
773:java/org/apache/catalina/startup/DefaultJarScanner.java
776:java/org/apache/jasper/xmlparser/UCSReader.java
779:java/org/apache/catalina/tribes/tipis/LazyReplicatedMap.java
785:java/org/apache/naming/SelectorContext.java
792:java/org/apache/naming/NamingContext.java
797:java/org/apache/coyote/ajp/AjpProtocol.java
799:java/org/apache/coyote/ajp/AjpAprProtocol.java</column></table><table name="tomcat"><column name="id">768</column><column name="bug_id">48174</column><column name="summary">org.apache.tomcat.jni.Address.APR_ANYADDR should be final</column><column name="description">org.apache.tomcat.jni.Address.APR_ANYADDR should be final</column><column name="report_time">2009-11-11 07:14:34</column><column name="report_timestamp">1257940000</column><column name="status">resolved fixed</column><column name="commit">57571a7</column><column name="commit_timestamp">1258500000</column><column name="files">java/org/apache/tomcat/jni/Address.java</column><column name="result">1:java/org/apache/tomcat/jni/Address.java</column></table><table name="tomcat"><column name="id">769</column><column name="bug_id">48173</column><column name="summary">org.apache.catalina.tribes.io.ChannelData.EMPTY_DATA_ARRAY should be final</column><column name="description">org.apache.catalina.tribes.io.ChannelData.EMPTY_DATA_ARRAY should be final</column><column name="report_time">2009-11-11 06:59:39</column><column name="report_timestamp">1257940000</column><column name="status">resolved fixed</column><column name="commit">e5ae1bc</column><column name="commit_timestamp">1258500000</column><column name="files">java/org/apache/catalina/tribes/io/ChannelData.java</column><column name="result">1:java/org/apache/catalina/tribes/io/ChannelData.java</column></table><table name="tomcat"><column name="id">770</column><column name="bug_id">48151</column><column name="summary">Java files that don't have AL headers</column><column name="description">Created attachment 24498 List of .java files with no AL headers Attached is a list of Java files that don't have AL headers.</column><column name="report_time">2009-11-06 03:06:03</column><column name="report_timestamp">1257490000</column><column name="status">resolved fixed</column><column name="commit">5447621</column><column name="commit_timestamp">1258500000</column><column name="files">java/org/apache/catalina/startup/DefaultJarScanner.java
java/org/apache/tomcat/JarScannerCallback.java
modules/jdbc-pool/test/org/apache/tomcat/jdbc/test/TestConcurrency.java
modules/jdbc-pool/test/org/apache/tomcat/jdbc/test/TestException.java
modules/jdbc-pool/test/org/apache/tomcat/jdbc/test/driver/ResultSet.java
modules/tomcat-lite/examples/spring/TomcatSpring.java
modules/tomcat-lite/java/org/apache/tomcat/addons/Filesystem.java
modules/tomcat-lite/java/org/apache/tomcat/addons/UserAuthentication.java
modules/tomcat-lite/java/org/apache/tomcat/addons/UserSessionManager.java
modules/tomcat-lite/java/org/apache/tomcat/addons/UserTemplateClassMapper.java
modules/tomcat-lite/java/org/apache/tomcat/integration/ObjectManager.java
modules/tomcat-lite/java/org/apache/tomcat/integration/jmx/JmxObjectManagerSpi.java
modules/tomcat-lite/java/org/apache/tomcat/integration/simple/LocalFilesystem.java
modules/tomcat-lite/java/org/apache/tomcat/integration/simple/Main.java
modules/tomcat-lite/java/org/apache/tomcat/integration/simple/ServletHelper.java
modules/tomcat-lite/java/org/apache/tomcat/integration/simple/SimpleObjectManager.java
modules/tomcat-lite/java/org/apache/tomcat/lite/BodyWriter.java
modules/tomcat-lite/java/org/apache/tomcat/lite/Connector.java
modules/tomcat-lite/java/org/apache/tomcat/lite/ContextPreinitListener.java
modules/tomcat-lite/java/org/apache/tomcat/lite/WebappContextMapper.java
modules/tomcat-lite/java/org/apache/tomcat/lite/coyote/CoyoteConnector.java
modules/tomcat-lite/java/org/apache/tomcat/lite/webxml/ServletContextConfig.java
modules/tomcat-lite/java/org/apache/tomcat/lite/webxml/TomcatLiteWebXmlConfig.java
modules/tomcat-lite/java/org/apache/tomcat/lite/webxml/WebXml.java
modules/tomcat-lite/java/org/apache/tomcat/servlets/file/CopyUtils.java
modules/tomcat-lite/java/org/apache/tomcat/servlets/file/FileCopyUtils.java
modules/tomcat-lite/java/org/apache/tomcat/servlets/jsp/PreCompileFilter.java
modules/tomcat-lite/java/org/apache/tomcat/servlets/jsp/SingleThreadedProxyServlet.java
modules/tomcat-lite/java/org/apache/tomcat/servlets/sec/UserDB.java
modules/tomcat-lite/java/org/apache/tomcat/servlets/session/RandomGenerator.java
modules/tomcat-lite/java/org/apache/tomcat/servlets/util/Range.java
modules/tomcat-lite/java/org/apache/tomcat/servlets/util/UrlUtils.java
modules/tomcat-lite/java/org/apache/tomcat/util/http/HttpRequest.java
modules/tomcat-lite/java/org/apache/tomcat/util/http/HttpResponse.java
modules/tomcat-lite/test/org/apache/tomcat/lite/LiteTestHelper.java
modules/tomcat-lite/test/org/apache/tomcat/lite/PropertiesSpiTest.java
modules/tomcat-lite/test/org/apache/tomcat/lite/SimpleServlet.java
modules/tomcat-lite/test/org/apache/tomcat/test/watchdog/WatchdogTest.java
modules/tomcat-lite/test/org/apache/tomcat/util/buf/UEncoderTest.java
test/org/apache/TestAll.java
test/org/apache/catalina/startup/SimpleHttpClient.java
test/org/apache/catalina/startup/TestWebXml.java</column><column name="result">4:modules/tomcat-lite/java/org/apache/tomcat/util/http/HttpRequest.java
11:modules/tomcat-lite/java/org/apache/tomcat/util/http/HttpResponse.java
36:modules/tomcat-lite/java/org/apache/tomcat/lite/Connector.java
60:test/org/apache/catalina/startup/SimpleHttpClient.java
85:modules/tomcat-lite/test/org/apache/tomcat/lite/SimpleServlet.java
102:modules/tomcat-lite/java/org/apache/tomcat/lite/coyote/CoyoteConnector.java
108:modules/tomcat-lite/java/org/apache/tomcat/servlets/util/Range.java
122:modules/tomcat-lite/java/org/apache/tomcat/lite/BodyWriter.java
127:modules/tomcat-lite/java/org/apache/tomcat/addons/UserAuthentication.java
296:modules/tomcat-lite/java/org/apache/tomcat/lite/webxml/TomcatLiteWebXmlConfig.java
299:modules/tomcat-lite/java/org/apache/tomcat/lite/WebappContextMapper.java
303:modules/tomcat-lite/java/org/apache/tomcat/integration/simple/ServletHelper.java
304:modules/tomcat-lite/java/org/apache/tomcat/lite/ContextPreinitListener.java
305:modules/tomcat-lite/java/org/apache/tomcat/addons/UserSessionManager.java
352:java/org/apache/catalina/startup/DefaultJarScanner.java
410:modules/tomcat-lite/test/org/apache/tomcat/lite/LiteTestHelper.java
417:modules/tomcat-lite/java/org/apache/tomcat/addons/UserTemplateClassMapper.java
436:modules/tomcat-lite/java/org/apache/tomcat/servlets/jsp/SingleThreadedProxyServlet.java
524:modules/tomcat-lite/java/org/apache/tomcat/servlets/session/RandomGenerator.java
585:modules/tomcat-lite/java/org/apache/tomcat/servlets/file/FileCopyUtils.java
586:modules/tomcat-lite/java/org/apache/tomcat/servlets/file/CopyUtils.java
706:modules/jdbc-pool/test/org/apache/tomcat/jdbc/test/driver/ResultSet.java
730:modules/jdbc-pool/test/org/apache/tomcat/jdbc/test/TestConcurrency.java
764:java/org/apache/tomcat/JarScannerCallback.java
772:modules/tomcat-lite/java/org/apache/tomcat/addons/Filesystem.java
778:modules/tomcat-lite/java/org/apache/tomcat/lite/webxml/WebXml.java
824:modules/tomcat-lite/java/org/apache/tomcat/integration/simple/LocalFilesystem.java
868:modules/tomcat-lite/java/org/apache/tomcat/servlets/jsp/PreCompileFilter.java
928:modules/tomcat-lite/java/org/apache/tomcat/integration/simple/SimpleObjectManager.java
955:modules/tomcat-lite/java/org/apache/tomcat/integration/simple/Main.java
1049:modules/tomcat-lite/test/org/apache/tomcat/test/watchdog/WatchdogTest.java
1201:modules/tomcat-lite/java/org/apache/tomcat/lite/webxml/ServletContextConfig.java
1223:modules/tomcat-lite/java/org/apache/tomcat/integration/ObjectManager.java</column></table><table name="tomcat"><column name="id">771</column><column name="bug_id">48150</column><column name="summary">some misspellings I found in the "javax.servlet" package</column><column name="description">Created attachment 24497 svn patch file for the javax.servlet package see atached svn patch file</column><column name="report_time">2009-11-06 01:46:29</column><column name="report_timestamp">1257490000</column><column name="status">resolved fixed</column><column name="commit">7849435</column><column name="commit_timestamp">1258500000</column><column name="files">java/javax/servlet/GenericServlet.java
java/javax/servlet/http/HttpServlet.java
java/javax/servlet/jsp/JspWriter.java
java/javax/servlet/jsp/PageContext.java
java/javax/servlet/jsp/SkipPageException.java
java/javax/servlet/jsp/tagext/JspFragment.java
java/javax/servlet/jsp/tagext/PageData.java
java/javax/servlet/jsp/tagext/SimpleTagSupport.java
java/javax/servlet/jsp/tagext/TagLibraryInfo.java
java/javax/servlet/jsp/tagext/TagLibraryValidator.java
java/javax/servlet/jsp/tagext/TagSupport.java</column><column name="result">6:java/javax/servlet/jsp/PageContext.java
11:java/javax/servlet/http/HttpServlet.java
29:java/javax/servlet/jsp/tagext/TagLibraryInfo.java
72:java/javax/servlet/jsp/tagext/JspFragment.java
79:java/javax/servlet/GenericServlet.java
94:java/javax/servlet/jsp/tagext/SimpleTagSupport.java
130:java/javax/servlet/jsp/SkipPageException.java
506:java/javax/servlet/jsp/JspWriter.java</column></table><table name="tomcat"><column name="id">772</column><column name="bug_id">48149</column><column name="summary">some misspellings I  found in the "org.apache.coyote" package and "org.apache.el" package</column><column name="description">Created attachment 24496 svn patch for "org.apache.coyote" and "org.apache.el" package see the attached svn patch file</column><column name="report_time">2009-11-06 01:14:34</column><column name="report_timestamp">1257490000</column><column name="status">resolved fixed</column><column name="commit">39a78f4</column><column name="commit_timestamp">1258500000</column><column name="files">java/org/apache/coyote/ActionCode.java
java/org/apache/coyote/ProtocolHandler.java
java/org/apache/coyote/Request.java
java/org/apache/coyote/RequestGroupInfo.java
java/org/apache/coyote/RequestInfo.java
java/org/apache/coyote/Response.java
java/org/apache/coyote/ajp/AjpAprProcessor.java
java/org/apache/coyote/ajp/AjpAprProtocol.java
java/org/apache/coyote/ajp/AjpProcessor.java
java/org/apache/coyote/ajp/AjpProtocol.java
java/org/apache/coyote/http11/AbstractHttp11Processor.java
java/org/apache/coyote/http11/AbstractInputBuffer.java
java/org/apache/coyote/http11/AbstractOutputBuffer.java
java/org/apache/coyote/http11/Http11AprProcessor.java
java/org/apache/coyote/http11/Http11NioProcessor.java
java/org/apache/coyote/http11/Http11Processor.java
java/org/apache/coyote/http11/InternalAprInputBuffer.java
java/org/apache/coyote/http11/InternalAprOutputBuffer.java
java/org/apache/coyote/http11/InternalInputBuffer.java
java/org/apache/coyote/http11/InternalNioInputBuffer.java
java/org/apache/coyote/http11/InternalNioOutputBuffer.java
java/org/apache/coyote/http11/InternalOutputBuffer.java
java/org/apache/coyote/http11/filters/VoidInputFilter.java
java/org/apache/el/parser/AstValue.java
java/org/apache/el/parser/ParseException.java</column><column name="result">36:java/org/apache/coyote/Request.java
37:java/org/apache/coyote/RequestInfo.java
44:java/org/apache/coyote/http11/Http11AprProcessor.java
49:java/org/apache/coyote/ProtocolHandler.java
54:java/org/apache/coyote/http11/AbstractOutputBuffer.java
56:java/org/apache/coyote/http11/InternalAprOutputBuffer.java
63:java/org/apache/coyote/ajp/AjpAprProcessor.java
66:java/org/apache/coyote/ajp/AjpProcessor.java
75:java/org/apache/coyote/http11/AbstractInputBuffer.java
78:java/org/apache/coyote/http11/Http11NioProcessor.java
79:java/org/apache/coyote/http11/Http11Processor.java
92:java/org/apache/coyote/http11/AbstractHttp11Processor.java
116:java/org/apache/coyote/http11/InternalAprInputBuffer.java
132:java/org/apache/coyote/ActionCode.java
214:java/org/apache/coyote/ajp/AjpProtocol.java
219:java/org/apache/coyote/ajp/AjpAprProtocol.java
288:java/org/apache/el/parser/AstValue.java
378:java/org/apache/coyote/http11/InternalNioInputBuffer.java
397:java/org/apache/coyote/Response.java
427:java/org/apache/coyote/http11/InternalInputBuffer.java
475:java/org/apache/coyote/http11/filters/VoidInputFilter.java
1053:java/org/apache/coyote/http11/InternalOutputBuffer.java
1119:java/org/apache/coyote/RequestGroupInfo.java
1134:java/org/apache/coyote/http11/InternalNioOutputBuffer.java</column></table><table name="tomcat"><column name="id">773</column><column name="bug_id">48148</column><column name="summary">some misspellings I  found in the "org.apache.jasper" package and "org.apache.juli" package</column><column name="description">Created attachment 24495 svn patch for "org.apache.jasper" and "org.apache.juli" package see attached svn patch file</column><column name="report_time">2009-11-06 00:32:48</column><column name="report_timestamp">1257490000</column><column name="status">resolved fixed</column><column name="commit">6ce7032</column><column name="commit_timestamp">1258500000</column><column name="files">java/org/apache/jasper/Constants.java
java/org/apache/jasper/EmbeddedServletOptions.java
java/org/apache/jasper/JasperException.java
java/org/apache/jasper/JspC.java
java/org/apache/jasper/JspCompilationContext.java
java/org/apache/jasper/Options.java
java/org/apache/jasper/compiler/Collector.java
java/org/apache/jasper/compiler/Compiler.java
java/org/apache/jasper/compiler/ELFunctionMapper.java
java/org/apache/jasper/compiler/Generator.java
java/org/apache/jasper/compiler/JarScannerFactory.java
java/org/apache/jasper/compiler/JspConfig.java
java/org/apache/jasper/compiler/JspDocumentParser.java
java/org/apache/jasper/compiler/JspReader.java
java/org/apache/jasper/compiler/JspRuntimeContext.java
java/org/apache/jasper/compiler/JspUtil.java
java/org/apache/jasper/compiler/Node.java
java/org/apache/jasper/compiler/TagFileProcessor.java
java/org/apache/jasper/compiler/TagLibraryInfoImpl.java
java/org/apache/jasper/compiler/TextOptimizer.java
java/org/apache/jasper/compiler/TldLocationsCache.java
java/org/apache/jasper/compiler/Validator.java
java/org/apache/jasper/compiler/tagplugin/TagPluginContext.java
java/org/apache/jasper/runtime/BodyContentImpl.java
java/org/apache/jasper/runtime/JspContextWrapper.java
java/org/apache/jasper/servlet/JspServlet.java
java/org/apache/jasper/servlet/JspServletWrapper.java
java/org/apache/jasper/tagplugins/jstl/core/Import.java
java/org/apache/jasper/util/Enumerator.java
java/org/apache/jasper/xmlparser/UTF8Reader.java
java/org/apache/jasper/xmlparser/XMLEncodingDetector.java
java/org/apache/juli/ClassLoaderLogManager.java
java/org/apache/juli/OneLineFormatter.java
java/org/apache/juli/logging/DirectJDKLog.java
java/org/apache/juli/logging/Log.java
java/org/apache/juli/logging/LogFactory.java</column><column name="result">2:java/org/apache/jasper/JasperException.java
3:java/org/apache/jasper/compiler/Compiler.java
12:java/org/apache/jasper/JspCompilationContext.java
13:java/org/apache/jasper/Options.java
16:java/org/apache/jasper/compiler/Node.java
17:java/org/apache/jasper/JspC.java
28:java/org/apache/jasper/compiler/TldLocationsCache.java
29:java/org/apache/jasper/servlet/JspServletWrapper.java
34:java/org/apache/jasper/EmbeddedServletOptions.java
35:java/org/apache/jasper/compiler/JspUtil.java
36:java/org/apache/jasper/compiler/JspReader.java
40:java/org/apache/jasper/compiler/Generator.java
44:java/org/apache/jasper/Constants.java
48:java/org/apache/jasper/compiler/tagplugin/TagPluginContext.java
58:java/org/apache/jasper/compiler/Validator.java
59:java/org/apache/jasper/compiler/TagFileProcessor.java
67:java/org/apache/jasper/servlet/JspServlet.java
68:java/org/apache/jasper/compiler/JspRuntimeContext.java
73:java/org/apache/jasper/xmlparser/XMLEncodingDetector.java
77:java/org/apache/jasper/compiler/JarScannerFactory.java
78:java/org/apache/jasper/compiler/ELFunctionMapper.java
80:java/org/apache/jasper/compiler/TagLibraryInfoImpl.java
81:java/org/apache/jasper/compiler/Collector.java
82:java/org/apache/jasper/compiler/TextOptimizer.java
86:java/org/apache/jasper/compiler/JspDocumentParser.java
105:java/org/apache/jasper/compiler/JspConfig.java
176:java/org/apache/jasper/tagplugins/jstl/core/Import.java
185:java/org/apache/juli/ClassLoaderLogManager.java
261:java/org/apache/juli/logging/LogFactory.java
281:java/org/apache/jasper/runtime/BodyContentImpl.java
389:java/org/apache/jasper/xmlparser/UTF8Reader.java
510:java/org/apache/jasper/runtime/JspContextWrapper.java
814:java/org/apache/jasper/util/Enumerator.java
1016:java/org/apache/juli/logging/Log.java
1096:java/org/apache/juli/logging/DirectJDKLog.java
1115:java/org/apache/juli/OneLineFormatter.java</column></table><table name="tomcat"><column name="id">774</column><column name="bug_id">48147</column><column name="summary">some misspellings I can find in the "org.apache.naming" package</column><column name="description">Created attachment 24494 svn patch file for the org.apache.naming package see the attached svn patch file</column><column name="report_time">2009-11-05 23:26:42</column><column name="report_timestamp">1257480000</column><column name="status">resolved fixed</column><column name="commit">21e86e6</column><column name="commit_timestamp">1258500000</column><column name="files">java/org/apache/naming/NamingEntry.java
java/org/apache/naming/NamingService.java
java/org/apache/naming/NamingServiceMBean.java
java/org/apache/naming/ResourceRef.java
java/org/apache/naming/factory/EjbFactory.java
java/org/apache/naming/factory/OpenEjbFactory.java
java/org/apache/naming/factory/ResourceEnvFactory.java
java/org/apache/naming/factory/TransactionFactory.java
java/org/apache/naming/resources/BaseDirContext.java
java/org/apache/naming/resources/DirContextURLConnection.java
java/org/apache/naming/resources/FileDirContext.java
java/org/apache/naming/resources/ProxyDirContext.java
java/org/apache/naming/resources/Resource.java
java/org/apache/naming/resources/ResourceCache.java
java/org/apache/naming/resources/WARDirContext.java</column><column name="result">137:java/org/apache/naming/resources/ResourceCache.java
190:java/org/apache/naming/resources/BaseDirContext.java
256:java/org/apache/naming/NamingService.java
293:java/org/apache/naming/NamingEntry.java
314:java/org/apache/naming/resources/FileDirContext.java
334:java/org/apache/naming/resources/WARDirContext.java
397:java/org/apache/naming/resources/ProxyDirContext.java
476:java/org/apache/naming/NamingServiceMBean.java
506:java/org/apache/naming/resources/DirContextURLConnection.java
545:java/org/apache/naming/ResourceRef.java
645:java/org/apache/naming/factory/ResourceEnvFactory.java
647:java/org/apache/naming/factory/TransactionFactory.java
668:java/org/apache/naming/factory/EjbFactory.java
795:java/org/apache/naming/factory/OpenEjbFactory.java
1061:java/org/apache/naming/resources/Resource.java</column></table><table name="tomcat"><column name="id">775</column><column name="bug_id">48146</column><column name="summary">some misspellings I can find in the "org.apache.tomcat" package</column><column name="description">Created attachment 24493 svn patch for the various classes in the org.apache.tomcat package see the attached svn patch file</column><column name="report_time">2009-11-05 23:05:31</column><column name="report_timestamp">1257480000</column><column name="status">resolved fixed</column><column name="commit">ed97da7</column><column name="commit_timestamp">1258500000</column><column name="files">java/org/apache/tomcat/jni/BIOCallback.java
java/org/apache/tomcat/jni/Directory.java
java/org/apache/tomcat/jni/File.java
java/org/apache/tomcat/jni/Local.java
java/org/apache/tomcat/jni/OS.java
java/org/apache/tomcat/jni/Poll.java
java/org/apache/tomcat/jni/Pool.java
java/org/apache/tomcat/jni/Proc.java
java/org/apache/tomcat/jni/SSL.java
java/org/apache/tomcat/jni/SSLContext.java
java/org/apache/tomcat/jni/Shm.java
java/org/apache/tomcat/jni/Socket.java
java/org/apache/tomcat/jni/Time.java
java/org/apache/tomcat/jni/User.java
java/org/apache/tomcat/util/DomUtil.java
java/org/apache/tomcat/util/IntrospectionUtils.java
java/org/apache/tomcat/util/buf/B2CConverter.java
java/org/apache/tomcat/util/buf/ByteChunk.java
java/org/apache/tomcat/util/buf/C2BConverter.java
java/org/apache/tomcat/util/buf/CharChunk.java
java/org/apache/tomcat/util/buf/MessageBytes.java
java/org/apache/tomcat/util/buf/StringCache.java
java/org/apache/tomcat/util/buf/UDecoder.java
java/org/apache/tomcat/util/buf/UEncoder.java
java/org/apache/tomcat/util/collections/MultiMap.java
java/org/apache/tomcat/util/collections/MultiMapNamesEnumeration.java
java/org/apache/tomcat/util/digester/AbstractRulesImpl.java
java/org/apache/tomcat/util/digester/CallMethodRule.java
java/org/apache/tomcat/util/digester/Digester.java
java/org/apache/tomcat/util/digester/FactoryCreateRule.java
java/org/apache/tomcat/util/digester/GenericParser.java
java/org/apache/tomcat/util/digester/NodeCreateRule.java
java/org/apache/tomcat/util/digester/RuleSet.java
java/org/apache/tomcat/util/digester/RulesBase.java
java/org/apache/tomcat/util/digester/SetNextRule.java
java/org/apache/tomcat/util/digester/SetPropertiesRule.java
java/org/apache/tomcat/util/digester/SetPropertyRule.java
java/org/apache/tomcat/util/digester/SetRootRule.java
java/org/apache/tomcat/util/digester/SetTopRule.java
java/org/apache/tomcat/util/digester/WithDefaultsRulesWrapper.java
java/org/apache/tomcat/util/http/ContentType.java
java/org/apache/tomcat/util/http/Cookies.java
java/org/apache/tomcat/util/http/MimeHeaders.java
java/org/apache/tomcat/util/http/fileupload/FileItem.java
java/org/apache/tomcat/util/http/fileupload/MultipartStream.java
java/org/apache/tomcat/util/http/mapper/Mapper.java
java/org/apache/tomcat/util/modeler/AttributeInfo.java
java/org/apache/tomcat/util/modeler/BaseModelMBean.java
java/org/apache/tomcat/util/modeler/Registry.java
java/org/apache/tomcat/util/modeler/modules/MbeansDescriptorsIntrospectionSource.java
java/org/apache/tomcat/util/net/AprEndpoint.java
java/org/apache/tomcat/util/net/DefaultServerSocketFactory.java
java/org/apache/tomcat/util/net/NioEndpoint.java
java/org/apache/tomcat/util/net/ServerSocketFactory.java
java/org/apache/tomcat/util/net/jsse/JSSESocketFactory.java</column><column name="result">54:java/org/apache/tomcat/util/buf/StringCache.java
79:java/org/apache/tomcat/util/buf/ByteChunk.java
87:java/org/apache/tomcat/util/modeler/Registry.java
96:java/org/apache/tomcat/util/http/mapper/Mapper.java
109:java/org/apache/tomcat/util/collections/MultiMap.java
114:java/org/apache/tomcat/util/digester/Digester.java
119:java/org/apache/tomcat/util/collections/MultiMapNamesEnumeration.java
121:java/org/apache/tomcat/jni/Local.java
125:java/org/apache/tomcat/jni/Socket.java
128:java/org/apache/tomcat/util/IntrospectionUtils.java
136:java/org/apache/tomcat/util/http/MimeHeaders.java
138:java/org/apache/tomcat/util/http/fileupload/MultipartStream.java
155:java/org/apache/tomcat/util/http/Cookies.java
304:java/org/apache/tomcat/util/modeler/BaseModelMBean.java
305:java/org/apache/tomcat/jni/Directory.java
311:java/org/apache/tomcat/util/net/jsse/JSSESocketFactory.java
372:java/org/apache/tomcat/util/DomUtil.java
376:java/org/apache/tomcat/util/net/AprEndpoint.java
379:java/org/apache/tomcat/util/digester/RulesBase.java
396:java/org/apache/tomcat/util/net/NioEndpoint.java
458:java/org/apache/tomcat/util/modeler/modules/MbeansDescriptorsIntrospectionSource.java
477:java/org/apache/tomcat/util/buf/UDecoder.java
480:java/org/apache/tomcat/jni/Proc.java
523:java/org/apache/tomcat/util/http/ContentType.java
669:java/org/apache/tomcat/jni/BIOCallback.java
793:java/org/apache/tomcat/util/digester/RuleSet.java
908:java/org/apache/tomcat/util/digester/GenericParser.java
909:java/org/apache/tomcat/util/net/DefaultServerSocketFactory.java
934:java/org/apache/tomcat/jni/Time.java
963:java/org/apache/tomcat/util/digester/AbstractRulesImpl.java
1016:java/org/apache/tomcat/util/buf/B2CConverter.java
1027:java/org/apache/tomcat/jni/User.java
1050:java/org/apache/tomcat/util/digester/WithDefaultsRulesWrapper.java
1063:java/org/apache/tomcat/util/modeler/AttributeInfo.java
1078:java/org/apache/tomcat/util/http/fileupload/FileItem.java
1081:java/org/apache/tomcat/jni/Shm.java
1098:java/org/apache/tomcat/jni/OS.java
1100:java/org/apache/tomcat/util/digester/FactoryCreateRule.java
1108:java/org/apache/tomcat/util/buf/UEncoder.java
1126:java/org/apache/tomcat/jni/Pool.java
1132:java/org/apache/tomcat/util/buf/C2BConverter.java
1133:java/org/apache/tomcat/util/net/ServerSocketFactory.java
1134:java/org/apache/tomcat/jni/Poll.java
1160:java/org/apache/tomcat/util/digester/CallMethodRule.java
1180:java/org/apache/tomcat/util/buf/MessageBytes.java
1181:java/org/apache/tomcat/util/digester/NodeCreateRule.java
1188:java/org/apache/tomcat/util/buf/CharChunk.java
1192:java/org/apache/tomcat/jni/SSLContext.java
1203:java/org/apache/tomcat/jni/SSL.java
1205:java/org/apache/tomcat/jni/File.java</column></table><table name="tomcat"><column name="id">776</column><column name="bug_id">48143</column><column name="summary">Javadoc fixes</column><column name="description">Created attachment 24491 Patch for Javadoc Lots of Javadoc fixes. Mainly misspelt parameter names or non-existent parameters. A few descriptions have been left as TBA. Large sections of Javadoc have been commented out in BaseModelMBean because the corresponding methods were already commented out.</column><column name="report_time">2009-11-05 13:04:26</column><column name="report_timestamp">1257440000</column><column name="status">resolved fixed</column><column name="commit">c52b1ba</column><column name="commit_timestamp">1258500000</column><column name="files">java/javax/servlet/SessionCookieConfig.java
java/org/apache/catalina/ant/jmx/JMXAccessorCreateTask.java
java/org/apache/catalina/core/ApplicationFilterChain.java
java/org/apache/catalina/core/StandardContextValve.java
java/org/apache/catalina/core/StandardEngineValve.java
java/org/apache/catalina/core/StandardHostValve.java
java/org/apache/catalina/core/StandardWrapperValve.java
java/org/apache/catalina/ha/ClusterManager.java
java/org/apache/catalina/ha/session/DeltaSession.java
java/org/apache/catalina/ha/tcp/SimpleTcpCluster.java
java/org/apache/catalina/manager/StatusTransformer.java
java/org/apache/catalina/realm/CombinedRealm.java
java/org/apache/catalina/realm/LockOutRealm.java
java/org/apache/catalina/startup/Embedded.java
java/org/apache/catalina/startup/WebRuleSet.java
java/org/apache/catalina/tribes/group/ChannelCoordinator.java
java/org/apache/catalina/tribes/io/ChannelData.java
java/org/apache/catalina/tribes/io/ObjectReader.java
java/org/apache/catalina/tribes/io/ReplicationStream.java
java/org/apache/catalina/tribes/io/XByteBuffer.java
java/org/apache/catalina/tribes/membership/McastServiceImpl.java
java/org/apache/catalina/tribes/membership/MemberImpl.java
java/org/apache/catalina/tribes/membership/Membership.java
java/org/apache/catalina/tribes/transport/bio/util/LinkObject.java
java/org/apache/catalina/tribes/transport/nio/NioReceiver.java
java/org/apache/catalina/users/MemoryUserDatabase.java
java/org/apache/catalina/valves/RemoteIpValve.java
java/org/apache/coyote/http11/Http11Processor.java
java/org/apache/jasper/compiler/ParserController.java
java/org/apache/jasper/compiler/TagFileProcessor.java
java/org/apache/jasper/compiler/TldLocationsCache.java
java/org/apache/naming/HandlerRef.java
java/org/apache/naming/ServiceRef.java
java/org/apache/naming/resources/BaseDirContext.java
java/org/apache/tomcat/buildutil/Txt2Html.java
java/org/apache/tomcat/util/digester/SetPropertiesRule.java
java/org/apache/tomcat/util/digester/SetPropertyRule.java
java/org/apache/tomcat/util/modeler/BaseModelMBean.java
java/org/apache/tomcat/util/net/NioBlockingSelector.java
java/org/apache/tomcat/util/net/SSLSessionManager.java</column><column name="result">30:java/org/apache/jasper/compiler/TldLocationsCache.java
36:java/org/apache/tomcat/util/modeler/BaseModelMBean.java
60:java/org/apache/catalina/tribes/transport/nio/NioReceiver.java
64:java/org/apache/catalina/tribes/group/ChannelCoordinator.java
66:java/org/apache/coyote/http11/Http11Processor.java
68:java/org/apache/jasper/compiler/TagFileProcessor.java
89:java/org/apache/catalina/core/ApplicationFilterChain.java
90:java/org/apache/jasper/compiler/ParserController.java
101:java/org/apache/catalina/core/StandardHostValve.java
104:java/org/apache/catalina/core/StandardContextValve.java</column></table><table name="tomcat"><column name="id">777</column><column name="bug_id">48139</column><column name="summary">Tomcat Javadoc and unthrown exception fixes</column><column name="description">Created attachment 24489 Patch As the subject says...</column><column name="report_time">2009-11-05 08:10:54</column><column name="report_timestamp">1257430000</column><column name="status">resolved fixed</column><column name="commit">ab3620c</column><column name="commit_timestamp">1257450000</column><column name="files">java/org/apache/catalina/startup/Tomcat.java</column><column name="result">1:java/org/apache/catalina/startup/Tomcat.java</column></table><table name="tomcat"><column name="id">778</column><column name="bug_id">48137</column><column name="summary">some misspellings I can find in the "org.apache.catalina" package</column><column name="description">Created attachment 24488 svn patch for the various classes in the org.apache.catalina package please see the attached svn patch file</column><column name="report_time">2009-11-05 06:13:59</column><column name="report_timestamp">1257420000</column><column name="status">resolved fixed</column><column name="commit">18c0edc</column><column name="commit_timestamp">1257450000</column><column name="files">java/org/apache/catalina/Cluster.java
java/org/apache/catalina/CometEvent.java
java/org/apache/catalina/CometProcessor.java
java/org/apache/catalina/Context.java
java/org/apache/catalina/Host.java
java/org/apache/catalina/Pipeline.java
java/org/apache/catalina/ant/BaseRedirectorHelperTask.java
java/org/apache/catalina/ant/JKStatusUpdateTask.java
java/org/apache/catalina/ant/jmx/JMXAccessorQueryTask.java
java/org/apache/catalina/ant/jmx/JMXAccessorSetTask.java
java/org/apache/catalina/ant/jmx/JMXAccessorTask.java
java/org/apache/catalina/authenticator/AuthenticatorBase.java
java/org/apache/catalina/authenticator/FormAuthenticator.java
java/org/apache/catalina/authenticator/SingleSignOn.java
java/org/apache/catalina/connector/Connector.java
java/org/apache/catalina/connector/CoyoteAdapter.java
java/org/apache/catalina/connector/CoyoteInputStream.java
java/org/apache/catalina/connector/CoyoteReader.java
java/org/apache/catalina/connector/OutputBuffer.java
java/org/apache/catalina/connector/Request.java
java/org/apache/catalina/connector/RequestFacade.java
java/org/apache/catalina/connector/Response.java
java/org/apache/catalina/deploy/ContextService.java
java/org/apache/catalina/filters/WebdavFixFilter.java
java/org/apache/catalina/ha/authenticator/ClusterSingleSignOn.java
java/org/apache/catalina/ha/backend/CollectedInfo.java
java/org/apache/catalina/ha/backend/HeartbeatListener.java
java/org/apache/catalina/ha/deploy/FarmWarDeployer.java
java/org/apache/catalina/ha/deploy/FileMessageFactory.java
java/org/apache/catalina/ha/deploy/WarWatcher.java
java/org/apache/catalina/ha/session/DeltaManager.java
java/org/apache/catalina/ha/session/DeltaRequest.java
java/org/apache/catalina/ha/session/DeltaSession.java
java/org/apache/catalina/ha/session/JvmRouteBinderValve.java
java/org/apache/catalina/ha/session/SessionMessageImpl.java
java/org/apache/catalina/ha/tcp/ReplicationValve.java
java/org/apache/catalina/ha/tcp/SimpleTcpCluster.java
java/org/apache/catalina/loader/WebappClassLoader.java
java/org/apache/catalina/manager/HTMLManagerServlet.java
java/org/apache/catalina/manager/JMXProxyServlet.java
java/org/apache/catalina/manager/ManagerServlet.java
java/org/apache/catalina/manager/host/HTMLHostManagerServlet.java
java/org/apache/catalina/manager/util/SessionUtils.java
java/org/apache/catalina/mbeans/ContextEnvironmentMBean.java
java/org/apache/catalina/mbeans/ContextResourceLinkMBean.java
java/org/apache/catalina/mbeans/ContextResourceMBean.java
java/org/apache/catalina/mbeans/MBeanFactory.java
java/org/apache/catalina/mbeans/ServerLifecycleListener.java
java/org/apache/catalina/realm/DataSourceRealm.java
java/org/apache/catalina/realm/JAASCallbackHandler.java
java/org/apache/catalina/realm/JAASMemoryLoginModule.java
java/org/apache/catalina/realm/JAASRealm.java
java/org/apache/catalina/realm/JDBCRealm.java
java/org/apache/catalina/realm/JNDIRealm.java
java/org/apache/catalina/realm/LockOutRealm.java
java/org/apache/catalina/realm/RealmBase.java
java/org/apache/catalina/security/SecurityUtil.java
java/org/apache/catalina/servlets/CGIServlet.java
java/org/apache/catalina/servlets/DefaultServlet.java
java/org/apache/catalina/servlets/WebdavServlet.java
java/org/apache/catalina/session/JDBCStore.java
java/org/apache/catalina/session/PersistentManagerBase.java
java/org/apache/catalina/session/StandardManager.java
java/org/apache/catalina/ssi/ExpressionParseTree.java
java/org/apache/catalina/ssi/SSIFsize.java
java/org/apache/catalina/ssi/SSIServletExternalResolver.java
java/org/apache/catalina/ssi/SSIStopProcessingException.java
java/org/apache/catalina/tribes/Channel.java
java/org/apache/catalina/tribes/ChannelListener.java
java/org/apache/catalina/tribes/Heartbeat.java
java/org/apache/catalina/tribes/Member.java
java/org/apache/catalina/tribes/UniqueId.java
java/org/apache/catalina/tribes/group/GroupChannel.java
java/org/apache/catalina/tribes/group/interceptors/MessageDispatch15Interceptor.java
java/org/apache/catalina/tribes/io/ObjectReader.java
java/org/apache/catalina/tribes/membership/McastServiceImpl.java
java/org/apache/catalina/tribes/transport/PooledSender.java
java/org/apache/catalina/tribes/transport/bio/BioReplicationTask.java
java/org/apache/catalina/tribes/transport/bio/BioSender.java
java/org/apache/catalina/tribes/transport/bio/util/FastQueue.java
java/org/apache/catalina/tribes/transport/nio/NioSender.java
java/org/apache/catalina/tribes/transport/nio/ParallelNioSender.java
java/org/apache/catalina/users/MemoryUserDatabase.java
java/org/apache/catalina/util/Base64.java
java/org/apache/catalina/util/DateTool.java
java/org/apache/catalina/util/ExtensionValidator.java
java/org/apache/catalina/util/IOTools.java
java/org/apache/catalina/util/ManifestResource.java
java/org/apache/catalina/util/ParameterMap.java
java/org/apache/catalina/util/RequestUtil.java
java/org/apache/catalina/util/SchemaResolver.java
java/org/apache/catalina/util/Strftime.java
java/org/apache/catalina/valves/AccessLogValve.java
java/org/apache/catalina/valves/CometConnectionManagerValve.java</column><column name="result">21:java/org/apache/catalina/tribes/io/ObjectReader.java
27:java/org/apache/catalina/Context.java
29:java/org/apache/catalina/mbeans/MBeanFactory.java
31:java/org/apache/catalina/loader/WebappClassLoader.java
34:java/org/apache/catalina/valves/AccessLogValve.java
35:java/org/apache/catalina/connector/Request.java
42:java/org/apache/catalina/realm/RealmBase.java
45:java/org/apache/catalina/security/SecurityUtil.java
46:java/org/apache/catalina/session/StandardManager.java
47:java/org/apache/catalina/authenticator/AuthenticatorBase.java
48:java/org/apache/catalina/ha/session/DeltaManager.java
49:java/org/apache/catalina/connector/Connector.java
55:java/org/apache/catalina/Host.java
56:java/org/apache/catalina/connector/Response.java
57:java/org/apache/catalina/authenticator/SingleSignOn.java
64:java/org/apache/catalina/session/PersistentManagerBase.java
65:java/org/apache/catalina/valves/CometConnectionManagerValve.java
73:java/org/apache/catalina/users/MemoryUserDatabase.java
78:java/org/apache/catalina/tribes/membership/McastServiceImpl.java
104:java/org/apache/catalina/tribes/UniqueId.java
116:java/org/apache/catalina/ha/session/JvmRouteBinderValve.java
117:java/org/apache/catalina/ha/tcp/ReplicationValve.java
118:java/org/apache/catalina/servlets/DefaultServlet.java
120:java/org/apache/catalina/ha/deploy/FarmWarDeployer.java
127:java/org/apache/catalina/ha/authenticator/ClusterSingleSignOn.java
130:java/org/apache/catalina/mbeans/ServerLifecycleListener.java
149:java/org/apache/catalina/realm/JAASMemoryLoginModule.java
152:java/org/apache/catalina/tribes/transport/nio/NioSender.java
158:java/org/apache/catalina/manager/ManagerServlet.java
162:java/org/apache/catalina/servlets/CGIServlet.java
192:java/org/apache/catalina/connector/RequestFacade.java
199:java/org/apache/catalina/tribes/group/GroupChannel.java
219:java/org/apache/catalina/connector/CoyoteInputStream.java
223:java/org/apache/catalina/manager/HTMLManagerServlet.java
224:java/org/apache/catalina/tribes/transport/bio/BioSender.java
229:java/org/apache/catalina/mbeans/ContextResourceMBean.java
237:java/org/apache/catalina/manager/util/SessionUtils.java
243:java/org/apache/catalina/realm/JDBCRealm.java
246:java/org/apache/catalina/ha/tcp/SimpleTcpCluster.java
253:java/org/apache/catalina/util/ExtensionValidator.java
256:java/org/apache/catalina/tribes/transport/nio/ParallelNioSender.java
258:java/org/apache/catalina/tribes/transport/bio/util/FastQueue.java
291:java/org/apache/catalina/realm/DataSourceRealm.java
299:java/org/apache/catalina/ssi/SSIServletExternalResolver.java
303:java/org/apache/catalina/servlets/WebdavServlet.java
305:java/org/apache/catalina/realm/JNDIRealm.java
310:java/org/apache/catalina/connector/CoyoteReader.java
318:java/org/apache/catalina/realm/JAASCallbackHandler.java
331:java/org/apache/catalina/ant/BaseRedirectorHelperTask.java
336:java/org/apache/catalina/util/Strftime.java
347:java/org/apache/catalina/manager/host/HTMLHostManagerServlet.java
353:java/org/apache/catalina/authenticator/FormAuthenticator.java
358:java/org/apache/catalina/util/ParameterMap.java
368:java/org/apache/catalina/realm/JAASRealm.java
376:java/org/apache/catalina/ha/backend/CollectedInfo.java
379:java/org/apache/catalina/mbeans/ContextEnvironmentMBean.java
382:java/org/apache/catalina/mbeans/ContextResourceLinkMBean.java
386:java/org/apache/catalina/util/ManifestResource.java
395:java/org/apache/catalina/connector/CoyoteAdapter.java
416:java/org/apache/catalina/ha/session/DeltaRequest.java
421:java/org/apache/catalina/ant/jmx/JMXAccessorSetTask.java
425:java/org/apache/catalina/tribes/transport/bio/BioReplicationTask.java
435:java/org/apache/catalina/ant/jmx/JMXAccessorQueryTask.java
450:java/org/apache/catalina/tribes/Channel.java
452:java/org/apache/catalina/ant/JKStatusUpdateTask.java
462:java/org/apache/catalina/session/JDBCStore.java
499:java/org/apache/catalina/util/RequestUtil.java
520:java/org/apache/catalina/ha/backend/HeartbeatListener.java
534:java/org/apache/catalina/ha/deploy/FileMessageFactory.java
597:java/org/apache/catalina/tribes/Heartbeat.java
623:java/org/apache/catalina/ssi/SSIStopProcessingException.java
641:java/org/apache/catalina/CometProcessor.java
772:java/org/apache/catalina/tribes/ChannelListener.java
857:java/org/apache/catalina/util/IOTools.java
942:java/org/apache/catalina/Pipeline.java
1010:java/org/apache/catalina/util/SchemaResolver.java
1011:java/org/apache/catalina/manager/JMXProxyServlet.java
1043:java/org/apache/catalina/tribes/Member.java
1054:java/org/apache/catalina/ha/session/SessionMessageImpl.java
1064:java/org/apache/catalina/CometEvent.java
1073:java/org/apache/catalina/tribes/group/interceptors/MessageDispatch15Interceptor.java
1077:java/org/apache/catalina/ssi/SSIFsize.java
1085:java/org/apache/catalina/ha/deploy/WarWatcher.java
1088:java/org/apache/catalina/util/DateTool.java
1090:java/org/apache/catalina/tribes/transport/PooledSender.java
1123:java/org/apache/catalina/deploy/ContextService.java
1131:java/org/apache/catalina/connector/OutputBuffer.java
1140:java/org/apache/catalina/filters/WebdavFixFilter.java
1159:java/org/apache/catalina/ssi/ExpressionParseTree.java
1164:java/org/apache/catalina/realm/LockOutRealm.java
1167:java/org/apache/catalina/util/Base64.java</column></table><table name="tomcat"><column name="id">779</column><column name="bug_id">48135</column><column name="summary">ServiceRefFactory: impossible null check of serviceInterfaceClass</column><column name="description">The ServiceRefFactory class performs an impossible null check of serviceInterfaceClass at line 238: 237: Class[] serviceInterfaces = serviceInterfaceClass.getInterfaces(); 238: if (serviceInterfaceClass != null) { If it were null, line 237 would generate an NPE.</column><column name="report_time">2009-11-05 03:34:18</column><column name="report_timestamp">1257410000</column><column name="status">resolved fixed</column><column name="commit">97ccffd</column><column name="commit_timestamp">1257450000</column><column name="files">java/org/apache/naming/factory/webservices/ServiceProxy.java
java/org/apache/naming/factory/webservices/ServiceRefFactory.java</column><column name="result">1:java/org/apache/naming/factory/webservices/ServiceRefFactory.java
20:java/org/apache/naming/factory/webservices/ServiceProxy.java</column></table><table name="tomcat"><column name="id">780</column><column name="bug_id">48133</column><column name="summary">misspellings in the javadoc and comment of the various classes in the package of "org.apache.core"</column><column name="description">Created attachment 24486 the svn patch file Please see the attached file, which is a svn patch file of the he various classes in the package of "org.apache.core"</column><column name="report_time">2009-11-04 19:05:17</column><column name="report_timestamp">1257380000</column><column name="status">resolved fixed</column><column name="commit">9204e4d</column><column name="commit_timestamp">1257450000</column><column name="files">java/org/apache/catalina/core/ApplicationDispatcher.java
java/org/apache/catalina/core/ApplicationFilterFactory.java
java/org/apache/catalina/core/ApplicationHttpRequest.java
java/org/apache/catalina/core/ContainerBase.java
java/org/apache/catalina/core/StandardContext.java
java/org/apache/catalina/core/StandardEngine.java
java/org/apache/catalina/core/StandardHost.java
java/org/apache/catalina/core/StandardPipeline.java
java/org/apache/catalina/core/StandardService.java
java/org/apache/catalina/core/StandardWrapperFacade.java
java/org/apache/catalina/core/StandardWrapperValve.java</column><column name="result">14:java/org/apache/catalina/core/StandardContext.java
107:java/org/apache/catalina/core/ApplicationDispatcher.java
111:java/org/apache/catalina/core/StandardPipeline.java
141:java/org/apache/catalina/core/StandardService.java
144:java/org/apache/catalina/core/ApplicationHttpRequest.java
200:java/org/apache/catalina/core/StandardWrapperValve.java
206:java/org/apache/catalina/core/ContainerBase.java
213:java/org/apache/catalina/core/StandardEngine.java
221:java/org/apache/catalina/core/StandardHost.java
285:java/org/apache/catalina/core/ApplicationFilterFactory.java
827:java/org/apache/catalina/core/StandardWrapperFacade.java</column></table><table name="tomcat"><column name="id">781</column><column name="bug_id">48131</column><column name="summary">Add @deprecated annotations to deprecated elements</column><column name="description">Created attachment 24475 Patch to add @deprecated annotations to deprecated elements Patch to add @deprecated annotations to deprecated elements</column><column name="report_time">2009-11-04 13:30:07</column><column name="report_timestamp">1257360000</column><column name="status">resolved fixed</column><column name="commit">a3fa5d3</column><column name="commit_timestamp">1257380000</column><column name="files">java/javax/servlet/ServletContext.java
java/javax/servlet/ServletRequest.java
java/javax/servlet/ServletRequestWrapper.java
java/javax/servlet/SingleThreadModel.java
java/javax/servlet/UnavailableException.java
java/javax/servlet/http/HttpServletRequest.java
java/javax/servlet/http/HttpServletRequestWrapper.java
java/javax/servlet/http/HttpServletResponse.java
java/javax/servlet/http/HttpServletResponseWrapper.java
java/javax/servlet/http/HttpSession.java
java/javax/servlet/http/HttpSessionContext.java
java/javax/servlet/http/HttpUtils.java
java/javax/servlet/jsp/JspException.java
java/javax/servlet/jsp/el/ELException.java
java/javax/servlet/jsp/el/ELParseException.java
java/javax/servlet/jsp/el/Expression.java
java/javax/servlet/jsp/el/ExpressionEvaluator.java
java/javax/servlet/jsp/el/FunctionMapper.java
java/javax/servlet/jsp/el/VariableResolver.java
java/javax/servlet/jsp/tagext/BodyTag.java
java/org/apache/catalina/Cluster.java
java/org/apache/catalina/Manager.java
java/org/apache/catalina/connector/Request.java
java/org/apache/catalina/connector/Response.java
java/org/apache/catalina/core/ApplicationContext.java
java/org/apache/catalina/core/ApplicationContextFacade.java
java/org/apache/catalina/core/ApplicationHttpResponse.java
java/org/apache/catalina/core/DummyRequest.java
java/org/apache/catalina/core/DummyResponse.java
java/org/apache/catalina/ha/session/DeltaSession.java
java/org/apache/catalina/ha/tcp/SimpleTcpCluster.java
java/org/apache/catalina/realm/JAASRealm.java
java/org/apache/catalina/session/ManagerBase.java
java/org/apache/catalina/session/StandardSession.java
java/org/apache/catalina/session/StandardSessionFacade.java
java/org/apache/catalina/startup/Catalina.java
java/org/apache/catalina/tribes/io/XByteBuffer.java
java/org/apache/catalina/tribes/membership/McastService.java
java/org/apache/catalina/tribes/transport/ReceiverBase.java
java/org/apache/el/parser/SimpleCharStream.java
java/org/apache/jasper/servlet/JspCServletContext.java
java/org/apache/naming/resources/ResourceAttributes.java
java/org/apache/tomcat/util/digester/Rule.java
java/org/apache/tomcat/util/digester/SetNextRule.java
java/org/apache/tomcat/util/digester/SetPropertiesRule.java
java/org/apache/tomcat/util/digester/SetPropertyRule.java
java/org/apache/tomcat/util/digester/SetRootRule.java
java/org/apache/tomcat/util/digester/SetTopRule.java</column><column name="result">5:java/org/apache/jasper/servlet/JspCServletContext.java
8:java/org/apache/tomcat/util/digester/Rule.java
9:java/org/apache/catalina/Cluster.java
11:java/org/apache/catalina/core/ApplicationContext.java
12:java/javax/servlet/http/HttpSession.java
14:java/org/apache/catalina/session/StandardSession.java
15:java/org/apache/catalina/core/DummyRequest.java
16:java/org/apache/catalina/session/StandardSessionFacade.java
17:java/javax/servlet/ServletRequest.java
18:java/org/apache/catalina/core/DummyResponse.java
19:java/javax/servlet/http/HttpServletResponse.java
20:java/javax/servlet/ServletContext.java
21:java/javax/servlet/http/HttpServletRequest.java
22:java/javax/servlet/http/HttpSessionContext.java
23:java/javax/servlet/UnavailableException.java
24:java/javax/servlet/ServletRequestWrapper.java
26:java/javax/servlet/jsp/JspException.java
27:java/org/apache/catalina/ha/tcp/SimpleTcpCluster.java
28:java/org/apache/catalina/tribes/io/XByteBuffer.java
29:java/org/apache/catalina/core/ApplicationContextFacade.java
30:java/org/apache/catalina/tribes/transport/ReceiverBase.java
31:java/org/apache/catalina/Manager.java
35:java/javax/servlet/http/HttpServletResponseWrapper.java
36:java/org/apache/tomcat/util/digester/SetPropertiesRule.java
37:java/org/apache/tomcat/util/digester/SetPropertyRule.java
38:java/org/apache/catalina/session/ManagerBase.java
39:java/javax/servlet/http/HttpServletRequestWrapper.java
40:java/org/apache/catalina/realm/JAASRealm.java
41:java/org/apache/naming/resources/ResourceAttributes.java
43:java/org/apache/catalina/tribes/membership/McastService.java
44:java/org/apache/tomcat/util/digester/SetNextRule.java
45:java/org/apache/catalina/core/ApplicationHttpResponse.java
46:java/org/apache/tomcat/util/digester/SetRootRule.java
47:java/javax/servlet/jsp/el/ELParseException.java
48:java/org/apache/tomcat/util/digester/SetTopRule.java
49:java/org/apache/catalina/connector/Response.java
50:java/javax/servlet/jsp/el/FunctionMapper.java
52:java/org/apache/el/parser/SimpleCharStream.java
53:java/org/apache/catalina/connector/Request.java
54:java/org/apache/catalina/startup/Catalina.java
55:java/javax/servlet/jsp/el/VariableResolver.java
56:java/javax/servlet/SingleThreadModel.java
59:java/javax/servlet/jsp/el/ELException.java
60:java/javax/servlet/jsp/el/Expression.java
80:java/javax/servlet/jsp/tagext/BodyTag.java
86:java/javax/servlet/jsp/el/ExpressionEvaluator.java
126:java/javax/servlet/http/HttpUtils.java
157:java/org/apache/catalina/ha/session/DeltaSession.java</column></table><table name="tomcat"><column name="id">782</column><column name="bug_id">48123</column><column name="summary">4 misspellings in the javadoc of class "org.apache.catalina.startup.WebRuleSet"</column><column name="description">No.1 Line: 99 /** * Construct an instance of this &lt;code&gt;RuleSet&lt;/code&gt; with the default * matching pattern prefix and default fargment setting. */ public WebRuleSet() { 'fragment' was misspelled as 'fargment' No.2 Line: 614 /** * Rule to check that the &lt;code&gt;login-config&lt;/code&gt; is occuring * only 1 time within the web.xml */ final class SetLoginConfig extends Rule { 'occurring' was misspelled as 'occuring' No.3 Line 635 /** * Rule to check that the &lt;code&gt;jsp-config&lt;/code&gt; is occuring * only 1 time within the web.xml */ final class SetJspConfig extends Rule { 'occurring' was misspelled as 'occuring' No.4 Line 656 /** * Rule to check that the &lt;code&gt;session-config&lt;/code&gt; is occuring * only 1 time within the web.xml */ final class SetSessionConfig extends Rule { 'occurring' was misspelled as 'occuring'</column><column name="report_time">2009-11-04 02:02:40</column><column name="report_timestamp">1257320000</column><column name="status">resolved fixed</column><column name="commit">363b79a</column><column name="commit_timestamp">1257380000</column><column name="files">java/org/apache/catalina/startup/WebRuleSet.java</column><column name="result">1:java/org/apache/catalina/startup/WebRuleSet.java</column></table><table name="tomcat"><column name="id">783</column><column name="bug_id">48121</column><column name="summary">2 misspellings in the javadoc of class "org.apache.catalina.startup.TldConfig"</column><column name="description">No.1 Line 194: /** * Attribute value used to turn on/off TLD namespace awarenes. */ private boolean tldNamespaceAware = false; 'awareness' was misspelled as 'awarenes' No.2 Line 261 /** * Get the server.xml &amp;lt;host&amp;gt; attribute's xmlNamespaceAware. * @return true if namespace awarenes is enabled. * */ public boolean getTldNamespaceAware(){ return this.tldNamespaceAware; } 'awareness' was misspelled as 'awarenes'</column><column name="report_time">2009-11-04 01:48:39</column><column name="report_timestamp">1257320000</column><column name="status">resolved fixed</column><column name="commit">5d9f68b</column><column name="commit_timestamp">1257380000</column><column name="files">java/org/apache/catalina/startup/TldConfig.java</column><column name="result">1:java/org/apache/catalina/startup/TldConfig.java</column></table><table name="tomcat"><column name="id">784</column><column name="bug_id">48120</column><column name="summary">one misspelling in the javadoc of class "org.apache.catalina.startup.SetNextNamingRule"</column><column name="description">Line 50: /** * Construct a "set next" rule with the specified method name. * * @param methodName Method name of the parent method to call * @param paramType Java class of the parent method's argument * (if you wish to use a primitive type, specify the corresonding * Java wrapper class instead, such as &lt;code&gt;java.lang.Boolean&lt;/code&gt; * for a &lt;code&gt;boolean&lt;/code&gt; parameter) */ public SetNextNamingRule(String methodName, String paramType) { 'corresponding' was misspelled as 'corresonding'</column><column name="report_time">2009-11-04 01:45:46</column><column name="report_timestamp">1257320000</column><column name="status">resolved fixed</column><column name="commit">7508847</column><column name="commit_timestamp">1257380000</column><column name="files">java/org/apache/catalina/startup/SetNextNamingRule.java</column><column name="result">1:java/org/apache/catalina/startup/SetNextNamingRule.java</column></table><table name="tomcat"><column name="id">785</column><column name="bug_id">48117</column><column name="summary">two misspellings in the javadoc of class "org.apache.catalina.startup.ContextConfig"</column><column name="description">in protected synchronized void stop(): (Line: 1059) // Removing sercurity role 'security' is misspelled to 'sercurity' in protected InputSource getWebXmlSource(String filename, String path): (Line: 1354) /** * * @param filename Name of the file (possibly with one or more leading path * segemnts) to read * @param path Location that filename is relative to * @return */ 'segments' is misspelled to 'segemnts'.</column><column name="report_time">2009-11-04 01:26:19</column><column name="report_timestamp">1257320000</column><column name="status">resolved fixed</column><column name="commit">b6df018</column><column name="commit_timestamp">1257380000</column><column name="files">java/org/apache/catalina/startup/ContextConfig.java</column><column name="result">1:java/org/apache/catalina/startup/ContextConfig.java</column></table><table name="tomcat"><column name="id">786</column><column name="bug_id">48119</column><column name="summary">5 misspellings in the javadoc of class "org.apache.catalina.startup.HostConfig'</column><column name="description">No.1 Line 146: /** * Attribute value used to turn on/off XML namespace awarenes. */ protected boolean xmlNamespaceAware = false; 'awareness' was misspelled as 'awarenes' No.2 Line 268: /** * Get the server.xml &amp;lt;host&amp;gt; attribute's xmlNamespaceAware. * @return true if namespace awarenes is enabled. * */ public boolean getXmlNamespaceAware(){ return xmlNamespaceAware; } 'awareness' was misspelled as 'awarenes' No.3 Line 366: /** * Has the specified application been deployed? Note applications defined * in server.xml will not have been deployed. * @return &lt;code&gt;true&lt;/code&gt; if the application has been deployed and * &lt;code&gt;false&lt;/code&gt; if the applciation has not been deployed or does not * exist */ public boolean isDeployed(String name) { 'application' was misspelled as 'applciation' No.4 Line 1328: /** * Add a new Context to be managed by us. * Entry point for the admin webapp, and other JMX Context controlers. */ public void manageApp(Context context) { 'controllers' was misspelled as 'controlers' Line 1382: /** * Remove a webapp from our control. * Entry point for the admin webapp, and other JMX Context controlers. */ public void unmanageApp(String contextPath) { 'controllers' was misspelled as 'controlers'</column><column name="report_time">2009-11-04 01:42:30</column><column name="report_timestamp">1257320000</column><column name="status">resolved fixed</column><column name="commit">07e5982</column><column name="commit_timestamp">1257340000</column><column name="files">java/org/apache/catalina/startup/HostConfig.java</column><column name="result">1:java/org/apache/catalina/startup/HostConfig.java</column></table><table name="tomcat"><column name="id">787</column><column name="bug_id">48118</column><column name="summary">two misspellings in the javadoc of class "org.apache.catalina.startup.Embeded"</column><column name="description">Line: 230 /** * Return true if redirction of standard streams is enabled. */ public boolean isRedirectStreams() { return (this.redirectStreams); } 'redirection' was misspelled to 'redirction' Line: 875 /** Initialize naming - this should only enable java:env and root naming. * If tomcat is embeded in an application that already defines those - * it shouldn't do it. * * XXX The 2 should be separated, you may want to enable java: but not * the initial context and the reverse * XXX Can we "guess" - i.e. lookup java: and if something is returned assume * false ? * XXX We have a major problem with the current setting for java: url */ protected void initNaming() { 'embedded' was mispelled to 'embeded'</column><column name="report_time">2009-11-04 01:33:03</column><column name="report_timestamp">1257320000</column><column name="status">resolved fixed</column><column name="commit">ae16eb2</column><column name="commit_timestamp">1257340000</column><column name="files">java/org/apache/catalina/startup/Embedded.java</column><column name="result">1:java/org/apache/catalina/startup/Embedded.java</column></table><table name="tomcat"><column name="id">788</column><column name="bug_id">46947</column><column name="summary">Code cleanup patch that removes some obsolete null checks</column><column name="description">Created attachment 23432 Patch against trunk As discussed at ApacheCon with Mark and Peter, here is a patch against trunk that removes obsolete null checks where the variable has already been dereferenced earlier. The patch doesn't fix all issues that Findbugs reports in the "RCN" category. I was not able to confirm the remaining ones and I suspect some false alarms. Note to reviewer: The diffs for Generator.java are quite hard to follow in the patch file, maybe it's easier for you to just remove the "if (attrInfos != null)" check yourself in the original code.</column><column name="report_time">2009-03-31 13:00:32</column><column name="report_timestamp">1238520000</column><column name="status">resolved fixed</column><column name="commit">6908b18</column><column name="commit_timestamp">1257300000</column><column name="files">java/org/apache/catalina/ant/jmx/JMXAccessorTask.java
java/org/apache/catalina/tribes/transport/bio/BioReceiver.java
java/org/apache/catalina/valves/JDBCAccessLogValve.java
java/org/apache/tomcat/util/net/NioBlockingSelector.java</column><column name="result">134:java/org/apache/catalina/valves/JDBCAccessLogValve.java
508:java/org/apache/catalina/ant/jmx/JMXAccessorTask.java
579:java/org/apache/tomcat/util/net/NioBlockingSelector.java
1012:java/org/apache/catalina/tribes/transport/bio/BioReceiver.java</column></table><table name="tomcat"><column name="id">789</column><column name="bug_id">48102</column><column name="summary">'Bootstrap' is misspelled as 'Boostrap' in the javadoc of the class of 'org.apache.catalina.startup.Bootstrap'</column><column name="description">Below is the javadoc of the class of 'org.apache.catalina.startup.Bootstrap': /** * Boostrap loader for Catalina. This application constructs a class loader * for use in loading the Catalina internal classes (by accumulating all of the * JAR files found in the "server" directory under "catalina.home"), and * starts the regular execution of the container. The purpose of this * roundabout approach is to keep the Catalina internal classes (and any * other classes they depend on, such as an XML parser) out of the system * class path and therefore not visible to application level classes. * * @author Craig R. McClanahan * @author Remy Maucherat * @version $Revision: 831860 $ $Date: 2009-11-02 19:00:01 +0800 (Mon, 02 Nov 2009) $ */ the first word ommits a 't' letter. It sould be 'Bootstrap', not 'Boostrap'.</column><column name="report_time">2009-11-02 03:11:25</column><column name="report_timestamp">1257150000</column><column name="status">resolved fixed</column><column name="commit">c060034</column><column name="commit_timestamp">1257210000</column><column name="files">java/org/apache/catalina/startup/Bootstrap.java</column><column name="result">1:java/org/apache/catalina/startup/Bootstrap.java</column></table><table name="tomcat"><column name="id">790</column><column name="bug_id">48104</column><column name="summary">the javadoc of class 'org.apache.catalina.startup.Catalina' is not complete, as in the usage() method</column><column name="description">Below is the javadoc of class 'org.apache.catalina.startup.Catalina': /** * Startup/Shutdown shell program for Catalina. The following command line * options are recognized: * &lt;ul&gt; * &lt;li&gt;&lt;b&gt;-config {pathname}&lt;/b&gt; - Set the pathname of the configuration file * to be processed. If a relative path is specified, it will be * interpreted as relative to the directory pathname specified by the * "catalina.base" system property. [conf/server.xml] * &lt;li&gt;&lt;b&gt;-help&lt;/b&gt; - Display usage information. * &lt;li&gt;&lt;b&gt;-stop&lt;/b&gt; - Stop the currently running instance of Catalina. * &lt;/u&gt; * * Should do the same thing as Embedded, but using a server.xml file. * * @author Craig R. McClanahan * @author Remy Maucherat * @version $Revision: 752323 $ $Date: 2009-03-11 08:46:54 +0800 (Wed, 11 Mar 2009) $ */ However, it doesn't allude the '-nonmaing' option, and 'start' option. Below is the usage() method of the same class: /** * Print usage information for this application. */ protected void usage() { System.out.println ("usage: java org.apache.catalina.startup.Catalina" + " [ -config {pathname} ]" + " [ -nonaming ] { start | stop }"); } It is not complete either. It lacks the '-help' option.</column><column name="report_time">2009-11-02 03:20:57</column><column name="report_timestamp">1257150000</column><column name="status">resolved fixed</column><column name="commit">481cfe9</column><column name="commit_timestamp">1257210000</column><column name="files">java/org/apache/catalina/startup/Catalina.java</column><column name="result">1:java/org/apache/catalina/startup/Catalina.java</column></table><table name="tomcat"><column name="id">791</column><column name="bug_id">47881</column><column name="summary">org.apache.catalina.startup.Bootstrap's main method handles 'startd' or 'stopd' wrongly</column><column name="description">String command = "start"; if (args.length &gt; 0) { command = args[args.length - 1]; } if (command.equals("startd")) { args[0] = "start"; daemon.load(args); daemon.start(); } else if (command.equals("stopd")) { args[0] = "stop"; daemon.stop(); } ... ... should be: String command = "start"; if (args.length &gt; 0) { command = args[args.length - 1]; } if (command.equals("startd")) { args[args.length - 1] = "start"; daemon.load(args); daemon.start(); } else if (command.equals("stopd")) { args[args.length - 1] = "stop"; daemon.stop(); } ... ... Please refer to the following usage method of org.apache.catalina.startup.Catalina: protected void usage() { System.out.println ("usage: java org.apache.catalina.startup.Catalina" + " [ -config {pathname} ]" + " [ -nonaming ] { start | stop }"); }</column><column name="report_time">2009-09-20 19:14:04</column><column name="report_timestamp">1253490000</column><column name="status">resolved fixed</column><column name="commit">3ef0f21</column><column name="commit_timestamp">1257160000</column><column name="files">java/org/apache/catalina/startup/Bootstrap.java</column><column name="result">1:java/org/apache/catalina/startup/Bootstrap.java</column></table><table name="tomcat"><column name="id">792</column><column name="bug_id">47331</column><column name="summary">No translation error messag when using #{...} in template text</column><column name="description">JSP.2.2 requires a translation error when an #{...} EL expression is used in templated text. (See also the Section 1.2.4 of "JavaServer Pages 2.1 Expression Language Specification".) Tomcat 6.0.18 *erronously* parse the expression. Tomcat 6.0.20 *rightly* does not but it also does not issue any error like the JSP specs requires. An example might clarify. Given the following JSP snip: --- [snip] --- &lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;jsp:root version="2.1" xmlns:jsp="http://java.sun.com/JSP/Page" xmlns:c="http://java.sun.com/jsp/jstl/core" xmlns:f="http://java.sun.com/jsf/core" xmlns:h="http://java.sun.com/jsf/html"&gt; &lt;jsp:directive.page contentType="text/html;charset=UTF-8" pageEncoding="UTF-8"/&gt; &lt;jsp:output omit-xml-declaration="no" doctype-root-element="html" doctype-public="-//W3C//DTD XHTML 1.0 Transitional//EN" doctype-system="http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"/&gt; &lt;f:view&gt; &lt;html xmlns="http://www.w3.org/1999/xhtml"&gt; &lt;head&gt; &lt;link rel="stylesheet" href="#{facesContext.externalContext.requestContextPath}/resources/theme/current/css/screen.css" type="text/css" /&gt; &lt;link rel="shortcut icon" href="#{facesContext.externalContext.requestContextPath}/resources/theme/current/img/favicon.ico" type="image/x-icon"/&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- ... --&gt; &lt;/body&gt; &lt;/html&gt; &lt;/f:view&gt; &lt;/jsp:root&gt; --- [/snip] --- With Tomcat 6.0.18 I get: --- [snip] --- &lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt; &lt;html xmlns="http://www.w3.org/1999/xhtml"&gt; &lt;head&gt; &lt;!-- ... --&gt; &lt;link rel="stylesheet" href="/my-web-app/resources/theme/current/css/screen.css" type="text/css" /&gt; &lt;link rel="shortcut icon" href="/my-web-app/resources/theme/current/img/favicon.ico" type="image/x-icon"/&gt; &lt;/head&gt; &lt;!-- ... --&gt; &lt;/html&gt;. --- [/snip] --- Instead with Tomcat 6.0.20: --- [snip] --- &lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt; &lt;html xmlns="http://www.w3.org/1999/xhtml"&gt; &lt;head&gt; &lt;!-- ... --&gt; &lt;link rel="stylesheet" href="#{facesContext.externalContext.requestContextPath}/resources/theme/current/css/screen.css" type="text/css" /&gt; &lt;link rel="shortcut icon" href="#{facesContext.externalContext.requestContextPath}/resources/theme/current/img/favicon.ico" type="image/x-icon"/&gt; &lt;/head&gt; &lt;!-- ... --&gt; &lt;/html&gt;. --- [/snip] --- But neither an error nor a warning message appear in the log. For a discussion about this see the following post on the tomcat-user ML: http://mail-archives.apache.org/mod_mbox/tomcat-users/200906.mbox/%3ca764c6280906070128j2bfdc49fvf6a0fb31d3165cc1@mail.gmail.com%3e and the subsequent replies.</column><column name="report_time">2009-06-08 02:22:52</column><column name="report_timestamp">1244440000</column><column name="status">resolved fixed</column><column name="commit">f3b04b4</column><column name="commit_timestamp">1257120000</column><column name="files">java/org/apache/jasper/compiler/Validator.java</column><column name="result">69:java/org/apache/jasper/compiler/Validator.java</column></table><table name="tomcat"><column name="id">793</column><column name="bug_id">47451</column><column name="summary">NPE if response contains null content-encoding header</column><column name="description">I've been getting a NullPointerException when using the JnlpDownloadServlet from JDK 1.6.0_14 with Tomcat 6.0.20: Jun 29, 2009 3:35:03 PM org.apache.coyote.http11.Http11Processor process SEVERE: Error finishing response java.lang.NullPointerException 	at org.apache.tomcat.util.buf.MessageBytes.indexOf(MessageBytes.java:479) 	at org.apache.tomcat.util.buf.MessageBytes.indexOf(MessageBytes.java:485) 	at org.apache.coyote.http11.Http11Processor.isCompressable(Http11Processor.java:1441) 	at org.apache.coyote.http11.Http11Processor.prepareResponse(Http11Processor.java:1517) 	at org.apache.coyote.http11.Http11Processor.action(Http11Processor.java:944) 	at org.apache.coyote.Response.action(Response.java:181) 	at org.apache.coyote.http11.InternalOutputBuffer.endRequest(InternalOutputBuffer.java:379) 	at org.apache.coyote.http11.Http11Processor.process(Http11Processor.java:889) 	at org.apache.coyote.http11.Http11Protocol$Http11ConnectionHandler.process(Http11Protocol.java:583) 	at org.apache.tomcat.util.net.JIoEndpoint$Worker.run(JIoEndpoint.java:454) 	at java.lang.Thread.run(Thread.java:619) A brief analysis of the JnlpDownloadServlet code shows that the content-encoding header on the response is being set to null in DownloadResponse$FileDownloadResponse. The Tomcat code tries to guard against a null header in Http11Process.isCompressable: if ((contentEncodingMB != null) &amp;&amp; (contentEncodingMB.indexOf("gzip") != -1)) return false; However, it appears that it's possible for contentEncodingMB, which is an instance of MessageBytes, to be non-null, while the value encapsulated by the MessageBytes IS null, resulting in an NPE in MessageBytes.indexOf(). Since this occurs with the JnlpDownloadServlet provided by Sun (see http://java.sun.com/j2se/1.5.0/docs/guide/javaws/developersguide/downloadservletguide.html), I imagine more people might be running into this problem.</column><column name="report_time">2009-06-29 14:53:48</column><column name="report_timestamp">1246300000</column><column name="status">resolved fixed</column><column name="commit">14084ac</column><column name="commit_timestamp">1257120000</column><column name="files">java/org/apache/catalina/connector/Response.java</column><column name="result">6:java/org/apache/catalina/connector/Response.java</column></table><table name="tomcat"><column name="id">794</column><column name="bug_id">47364</column><column name="summary">HttpServletRequest.getAttributeNames() does not return the names of all attributes</column><column name="description">In an email exchange that involved Ranier (see attachment), he suggested I log this in Bugzilla, so I am. I was using Tomcat 6.0.20 on Windows XP SP3 with the latest Java 6 JVM. In the doGet method of a servlet, I was trying to see all request attributes to see if the "sendfile supported" attribute was set (specifically the request attribute org.apache.tomcat.sendfile.support). On my first pass at this I just used HttpServletRequest.getAttributeNames() to dump all the names of the attributes expecting to see this one listed, but I got no attributes listed at all. Then I actually got the attribute via getAttribute("org.apache.tomcat.sendfile.support") which worked. So getAttributeNames is not returning the names of all attributes. So either: 1. getAttributeNames needs to be fixed to return the names of all attributes (i.e., a code change); or 2. The Tomcat doc needs to be updated in some way as to say thatgetAttributeNames only returns certain attributes and blah blah (i.e., a doc change). Again my original email and Ranier's reply is attached. Thanks!</column><column name="report_time">2009-06-12 13:44:21</column><column name="report_timestamp">1244830000</column><column name="status">resolved fixed</column><column name="commit">7fc56b4</column><column name="commit_timestamp">1257100000</column><column name="files">java/org/apache/catalina/connector/Request.java</column><column name="result">6:java/org/apache/catalina/connector/Request.java</column></table><table name="tomcat"><column name="id">795</column><column name="bug_id">48009</column><column name="summary">Editing context.xml may cause unwanted undeploy of a webapp</column><column name="description">Tomcat polls context.xml files for changes. If a previously-existing context.xml is missing at the instant Tomcat polls, then the application is undeployed. Some text editors (notably vi and its derivatives) create backup files by: 1) Renaming the original file, then 2) creating a new file and writing the edited contents to that file. Therefore there is a race condition. There is a small but non-zero probability that a user editing and saving context.xml using such an editor will see their webapp undeployed. Messages on tomcat-users indicate that such a situation has occurred on a production server at least once. It's undoubtedly rare. Suggested fixes: - Examine the directory for the presence of backup files for context.xml, and do not undeploy if one is found even if context.xml is missing. This is horribly ugly and makes the semantics of "a backup file" very peculiar, but is actually the only way to *prevent* the race - anything else only makes it less likely, as on a heavily loaded system (or one where context.xml is being edited via a network file share) the interval between the old context.xml being renamed and the new one being created may be arbitrarily long. - Only undeploy if the file is missing for a period of time. The discussion is then around that period. On tomcat-users, Mark Thomas suggested polling again after 500ms; I suggested remembering the state between polls and only undeploying if the file was missing for two successive polls. This is a cleaner fix to explain, but is not a complete solution as it does not remove the possibility of such a race. --- As an aside, there may well be a similar issue where Tomcat polls for context.xml as it is being written, finds it has changed, and reads a part-written version. In mitigation, the files involved are typically small and may well be written in one or very few operations; however, Tomcat should probably not assume that any file change is atomic.</column><column name="report_time">2009-10-16 01:52:21</column><column name="report_timestamp">1255670000</column><column name="status">resolved fixed</column><column name="commit">d55f1d9</column><column name="commit_timestamp">1256160000</column><column name="files">java/org/apache/catalina/startup/HostConfig.java</column><column name="result">2:java/org/apache/catalina/startup/HostConfig.java</column></table><table name="tomcat"><column name="id">796</column><column name="bug_id">48019</column><column name="summary">StackOverflowError on "include"</column><column name="description">JSP file name: /common/headers.jsp It's cotent: &lt;% // example: &lt;%@ include file="/common/headers.jsp" % &gt; %&gt; &lt;meta http-equiv="Content-Type" content="text/html;charset=utf-8" /&gt; &lt;meta http-equiv="Cache-Control" content="no-store" /&gt; &lt;meta http-equiv="Pragma" content="no-cache" /&gt; &lt;meta http-equiv="Expires" content="0" /&gt; &lt;link href="../css/css.css" rel="stylesheet" type="text/css"&gt; Console output: java.lang.StackOverflowError 	at java.text.DateFormat.format(DateFormat.java:275) 	at java.text.Format.format(Format.java:140) 	at java.text.MessageFormat.subformat(MessageFormat.java:1288) 	at java.text.MessageFormat.format(MessageFormat.java:795) 	at java.util.logging.SimpleFormatter.format(SimpleFormatter.java:50) 	at java.util.logging.StreamHandler.publish(StreamHandler.java:179) 	at java.util.logging.ConsoleHandler.publish(ConsoleHandler.java:88) 	at java.util.logging.Logger.log(Logger.java:458) 	at java.util.logging.Logger.doLog(Logger.java:480) 	at java.util.logging.Logger.logp(Logger.java:680) 	at org.apache.juli.logging.DirectJDKLog.log(DirectJDKLog.java:167) 	at org.apache.juli.logging.DirectJDKLog.error(DirectJDKLog.java:135) 	at org.apache.jasper.compiler.JspReader.pushFile(JspReader.java:606) 	at org.apache.jasper.compiler.JspReader.&lt;init&gt;(JspReader.java:141) 	at org.apache.jasper.compiler.JspReader.&lt;init&gt;(JspReader.java:119) 	at org.apache.jasper.compiler.ParserController.determineSyntaxAndEncoding(ParserController.java:399) 	at org.apache.jasper.compiler.ParserController.doParse(ParserController.java:207) 	at org.apache.jasper.compiler.ParserController.parse(ParserController.java:137) 	at org.apache.jasper.compiler.Parser.processIncludeDirective(Parser.java:339) 	at org.apache.jasper.compiler.Parser.parseIncludeDirective(Parser.java:376) 	at org.apache.jasper.compiler.Parser.parseDirective(Parser.java:484) 	at org.apache.jasper.compiler.Parser.parseTagFileDirectives(Parser.java:1784) 	at org.apache.jasper.compiler.Parser.parse(Parser.java:127) This not exist in "6.0.18".</column><column name="report_time">2009-10-17 07:18:47</column><column name="report_timestamp">1255780000</column><column name="status">resolved fixed</column><column name="commit">deac657</column><column name="commit_timestamp">1256160000</column><column name="files">java/org/apache/jasper/compiler/Parser.java</column><column name="result">2:java/org/apache/jasper/compiler/Parser.java</column></table><table name="tomcat"><column name="id">797</column><column name="bug_id">40001</column><column name="summary">HTML pages should not use GET to restart web-apps.</column><column name="description"> </column><column name="report_time">2006-07-10 14:32:20</column><column name="report_timestamp">1152560000</column><column name="status">resolved fixed</column><column name="commit">99f01fd</column><column name="commit_timestamp">1255210000</column><column name="files">java/org/apache/catalina/manager/Constants.java
java/org/apache/catalina/manager/HTMLManagerServlet.java</column><column name="result">3:java/org/apache/catalina/manager/HTMLManagerServlet.java
245:java/org/apache/catalina/manager/Constants.java</column></table><table name="tomcat"><column name="id">798</column><column name="bug_id">47320</column><column name="summary">Decoding jsessionid bug on z/os</column><column name="description">If you receive a rewritten URL on z/os with uss (unix on a mainframe), Tomcat does not properly decode the jsessionid portion of the URL. The problem is in org.apache.catalina.connector.CoyoteAdapter in the parseSessionId method. The two instantiations of a String object do not specify the encdoding to use. e.g. String sid = new String(uriBC.getBuffer(), start + sessionIdStart, semicolon2 - sessionIdStart); ...as well as the second String instantiation in this method. Consequently z/os uses its default encoding which (I think) is EBCDIC. If I recompile with a hardcoded "UTF-8" for the encoding then the jsessionid decodes properly. Not that I am suggesting this literally for the official fix. e.g. String sid = new String(uriBC.getBuffer(), start + sessionIdStart, semicolon2 - sessionIdStart, "UTF-8");</column><column name="report_time">2009-06-05 08:37:24</column><column name="report_timestamp">1244210000</column><column name="status">resolved fixed</column><column name="commit">0f99904</column><column name="commit_timestamp">1254070000</column><column name="files">java/org/apache/catalina/connector/CoyoteAdapter.java</column><column name="result">1:java/org/apache/catalina/connector/CoyoteAdapter.java</column></table><table name="tomcat"><column name="id">799</column><column name="bug_id">47499</column><column name="summary">provide better insight on BindException: Cannot assign requested address</column><column name="description">1) cite the address you attempt to listen (not just the port) 2) proper exception chaining the following info is currently lost: &lt;&lt;java.net.BindException: Cannot assign requested address 	at java.net.PlainSocketImpl.socketBind(Native Method) 	at java.net.PlainSocketImpl.bind(PlainSocketImpl.java:359) 	at java.net.ServerSocket.bind(ServerSocket.java:319) 	at java.net.ServerSocket.&lt;init&gt;(ServerSocket.java:185) 	at javax.net.ssl.SSLServerSocket.&lt;init&gt;(SSLServerSocket.java:106) 	at com.privasphere.net.ssl.SSLServerSocketImpl.&lt;init&gt;(SSLServerSocketImpl.java:106) 	at com.privasphere.net.ssl.SSLServerSocketFactoryImpl.createServerSocket(SSLServerSocketFactoryImpl.java:71) 	at org.apache.tomcat.util.net.jsse.JSSESocketFactory.createSocket(JSSESocketFactory.java:100) 	at org.apache.tomcat.util.net.PoolTcpEndpoint.initEndpoint(PoolTcpEndpoint.java:295) 	at org.apache.coyote.http11.Http11BaseProtocol.init(Http11BaseProtocol.java:139) 	at org.apache.catalina.connector.Connector.initialize(Connector.java:1017) 	at org.apache.catalina.core.StandardService.initialize(StandardService.java:578)&gt;&gt;</column><column name="report_time">2009-07-08 22:05:03</column><column name="report_timestamp">1247110000</column><column name="status">resolved fixed</column><column name="commit">73bb9e4</column><column name="commit_timestamp">1253650000</column><column name="files">java/org/apache/tomcat/util/net/JIoEndpoint.java</column><column name="result">2:java/org/apache/tomcat/util/net/JIoEndpoint.java</column></table><table name="tomcat"><column name="id">800</column><column name="bug_id">47866</column><column name="summary">NullPointerException in embedded tomcat</column><column name="description">It seems that the WebappClassLoader was stopped? {noformat} Caused by: java.lang.NullPointerException 	at org.apache.catalina.loader.WebappClassLoader.findResources(WebappClassLoader.java:994) 	at java.lang.ClassLoader.getResources(ClassLoader.java:1016) {noformat} All I did was launch a server add a context and then ask it to load a resource from its classpath. It's a bit more complicated than that, so I'll try and narrow it down if needed.</column><column name="report_time">2009-09-18 00:23:03</column><column name="report_timestamp">1253250000</column><column name="status">resolved wontfix</column><column name="commit">189181a</column><column name="commit_timestamp">1253530000</column><column name="files">test/org/apache/catalina/startup/TestTomcat.java</column><column name="result">27:test/org/apache/catalina/startup/TestTomcat.java</column></table><table name="tomcat"><column name="id">801</column><column name="bug_id">47225</column><column name="summary">Wrong argument in redirectPath.setChars in Mapper.internalMapWrapper()</column><column name="description">Found in current trunk and tc6.0.x, and tc5.5.x: http://svn.apache.org/viewvc/tomcat/trunk/java/org/apache/tomcat/util/http/mapper/Mapper.java?annotate=734728&amp;pathrev=770809 730 : 	 	 	 if(mappingData.wrapper == null &amp;&amp; noServletPath) { 731 : 	 	 	// The path is empty, redirect to "/" 732 : 	 	 	mappingData.redirectPath.setChars 733 : 	 	 	(path.getBuffer(), pathOffset, pathEnd); 734 : 	 	 	path.setEnd(pathEnd - 1); 735 : 	 	 	return; 736 : 	 	 	} On line 733 the pathEnd argument is wrong: it should be length, not an index. It should be mappingData.redirectPath.setChars(path.getBuffer(), pathOffset, pathEnd-pathOffset); Do not know, why there are no complaints. May be pathOffset is always zero?</column><column name="report_time">2009-05-19 21:52:39</column><column name="report_timestamp">1242780000</column><column name="status">resolved fixed</column><column name="commit">a31d52f</column><column name="commit_timestamp">1253140000</column><column name="files">java/org/apache/tomcat/util/http/mapper/Mapper.java</column><column name="result">5:java/org/apache/tomcat/util/http/mapper/Mapper.java</column></table><table name="tomcat"><column name="id">802</column><column name="bug_id">47161</column><column name="summary">Manager ignores executors on status pages</column><column name="description">When displaying the thread pools, the StatusManagerServlet ignores executors and uses the 'standard' ThreadPool information for each connector. This causes incorrect information to be displayed when a connector is configured to use an executor. On a related topic, it appears that the connector&lt;-&gt;executor link is not exposed via JMX (which it will need to be to fix this).</column><column name="report_time">2009-05-06 07:20:31</column><column name="report_timestamp">1241610000</column><column name="status">resolved fixed</column><column name="commit">aaf7b5d</column><column name="commit_timestamp">1253050000</column><column name="files">java/org/apache/tomcat/util/net/AbstractEndpoint.java
java/org/apache/tomcat/util/threads/ResizableExecutor.java</column><column name="result">10:java/org/apache/tomcat/util/net/AbstractEndpoint.java
16:java/org/apache/tomcat/util/threads/ResizableExecutor.java</column></table><table name="tomcat"><column name="id">803</column><column name="bug_id">46950</column><column name="summary">SSL renegotiation does not occur when resource with CLIENT-CERT auth is requested</column><column name="description">When a part of a webapp requires an SSL connection with a client certificate there should be an SSL renegotiation to request a client certificate from the browser. This is the configuration I added to an webapp that already uses an SSL connector: &lt;login-config id="LoginConfig_1"&gt; &lt;auth-method&gt;CLIENT-CERT&lt;/auth-method&gt; &lt;realm-name&gt;WPS&lt;/realm-name&gt; &lt;/login-config&gt; &lt;security-constraint id="SecurityConstraint_1"&gt; &lt;web-resource-collection id="WebResourceCollection_1"&gt; &lt;web-resource-name/&gt; &lt;url-pattern&gt;/LoginWithCert.do&lt;/url-pattern&gt; &lt;http-method&gt;DELETE&lt;/http-method&gt; &lt;http-method&gt;GET&lt;/http-method&gt; &lt;http-method&gt;POST&lt;/http-method&gt; &lt;http-method&gt;PUT&lt;/http-method&gt; &lt;http-method&gt;HEAD&lt;/http-method&gt; &lt;/web-resource-collection&gt; &lt;user-data-constraint id="UserDataConstraint_4"&gt; &lt;transport-guarantee&gt;CONFIDENTIAL&lt;/transport-guarantee&gt; &lt;/user-data-constraint&gt; &lt;/security-constraint&gt; Requests to /LoginWithCert.do require an SSL connection, if there isn't one, but no client certificate is requested.</column><column name="report_time">2009-04-01 06:33:02</column><column name="report_timestamp">1238580000</column><column name="status">resolved fixed</column><column name="commit">e9248d7</column><column name="commit_timestamp">1253040000</column><column name="files">java/org/apache/catalina/core/AprLifecycleListener.java
java/org/apache/coyote/http11/Http11AprProcessor.java
java/org/apache/tomcat/jni/SSLSocket.java</column><column name="result">23:java/org/apache/coyote/http11/Http11AprProcessor.java
40:java/org/apache/tomcat/jni/SSLSocket.java
409:java/org/apache/catalina/core/AprLifecycleListener.java</column></table><table name="tomcat"><column name="id">804</column><column name="bug_id">47828</column><column name="summary">Change Tomcat.setSilent() to setSilent(boolean)</column><column name="description">Change Tomcat.setSilent() to setSilent(boolean). It's nicer for clients to have a JavaBean type setter, and it doesn't seem to make sense that you can set something but not unset it.</column><column name="report_time">2009-09-12 00:37:54</column><column name="report_timestamp">1252730000</column><column name="status">resolved fixed</column><column name="commit">59e88f1</column><column name="commit_timestamp">1253010000</column><column name="files">java/org/apache/catalina/startup/Tomcat.java</column><column name="result">1:java/org/apache/catalina/startup/Tomcat.java</column></table><table name="tomcat"><column name="id">805</column><column name="bug_id">47820</column><column name="summary">Static utility methods in Tomcat should be instance methods</column><column name="description">Why are the static addServlet() methods in Tomcat static? I can see they don't use any state from the instance, but isn't it cleaner to use an instance method, so that the API is uniform (everything I want to do to a tomcat instance goes through the instance)? It would be more consistent to follow the pattern of addServlet(String,String,String), and search for the context by name instead of requiring the instance to be passed in to a static method.</column><column name="report_time">2009-09-11 02:09:00</column><column name="report_timestamp">1252650000</column><column name="status">resolved fixed</column><column name="commit">6cce550</column><column name="commit_timestamp">1253010000</column><column name="files">java/org/apache/catalina/startup/Tomcat.java</column><column name="result">4:java/org/apache/catalina/startup/Tomcat.java</column></table><table name="tomcat"><column name="id">806</column><column name="bug_id">47826</column><column name="summary">a logging statement error in org.apache.catalina.startup.Bootstrap.java</column><column name="description">// Local repository boolean replace = false; String before = repository; while ((i=repository.indexOf(CATALINA_HOME_TOKEN))&gt;=0) { replace=true; if (i&gt;0) { repository = repository.substring(0,i) + getCatalinaHome() + repository.substring(i+CATALINA_HOME_TOKEN.length()); } else { repository = getCatalinaHome() + repository.substring(CATALINA_HOME_TOKEN.length()); } } while ((i=repository.indexOf(CATALINA_BASE_TOKEN))&gt;=0) { replace=true; if (i&gt;0) { repository = repository.substring(0,i) + getCatalinaBase() + repository.substring(i+CATALINA_BASE_TOKEN.length()); } else { repository = getCatalinaBase() + repository.substring(CATALINA_BASE_TOKEN.length()); } } if (replace &amp;&amp; log.isDebugEnabled()) log.debug("Expanded " + before + " to " + replace); The last line should be: "log.debug("Expanded " + before + " to " + repository);"</column><column name="report_time">2009-09-11 17:39:34</column><column name="report_timestamp">1252710000</column><column name="status">resolved fixed</column><column name="commit">720de5e</column><column name="commit_timestamp">1252770000</column><column name="files">java/org/apache/catalina/startup/Bootstrap.java</column><column name="result">1:java/org/apache/catalina/startup/Bootstrap.java</column></table><table name="tomcat"><column name="id">807</column><column name="bug_id">47705</column><column name="summary">ArithmeticException: / by zero when expiring sessions via manager</column><column name="description">Received ArithmeticException: / by zero when expiring sessions via Tomcat manager webapp. This exception was thrown only if session-timeout is set as -1 on webapp web.xml. Moreover, the exception was also thrown regardless of the idle parameter value (/expire?path=/xxx&amp;idle=mm) as long as session-timeout = -1. Result: Exception stacktrace: ERROR: 19/08/2009 00:18:22 [http-80-exec-33] (org.apache.catalina.core.ApplicationContext:669) HTMLManager: ManagerServlet.sessions[/contextpath] java.lang.ArithmeticException: / by zero at org.apache.catalina.manager.ManagerServlet.sessions(ManagerServlet.java:1133) at org.apache.catalina.manager.HTMLManagerServlet.sessions(HTMLManagerServlet.java:573) at org.apache.catalina.manager.HTMLManagerServlet.expireSessions(HTMLManagerServlet.java:660) at org.apache.catalina.manager.HTMLManagerServlet.doGet(HTMLManagerServlet.java:118) at org.apache.catalina.manager.HTMLManagerServlet.doPost(HTMLManagerServlet.java:157) at javax.servlet.http.HttpServlet.service(HttpServlet.java:637) at javax.servlet.http.HttpServlet.service(HttpServlet.java:717) at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:290) at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:206) at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:233) at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:191) at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:525) at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:128) at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:102) at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:109) at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:286) at org.apache.coyote.http11.Http11NioProcessor.process(Http11NioProcessor.java:880) at org.apache.coyote.http11.Http11NioProtocol$Http11ConnectionHandler.process(Http11NioProtocol.java:719) at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.run(NioEndpoint.java:2081) at java.util.concurrent.ThreadPoolExecutor$Worker.runTask(ThreadPoolExecutor.java:886) at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:908) at java.lang.Thread.run(Thread.java:619)</column><column name="report_time">2009-08-19 00:12:52</column><column name="report_timestamp">1250660000</column><column name="status">resolved fixed</column><column name="commit">6ab874a</column><column name="commit_timestamp">1251730000</column><column name="files">java/org/apache/catalina/manager/ManagerServlet.java</column><column name="result">8:java/org/apache/catalina/manager/ManagerServlet.java</column></table><table name="tomcat"><column name="id">808</column><column name="bug_id">47378</column><column name="summary">welcome-file ignores servlet mapping</column><column name="description">Web applications that use a servlet mapping for their welcome-file are ignored and the server returns either a directory listing or a 404 if the listing is disabled. I have JSF servlet defined and a servlet-mapping for *.jsf to go to the FacesServlet. I have "index.jsf" listed as by welcome-file and I get a 404 with directory listing disabled. I also have a custom servlet defined with its mapping and set the welcome-file to its mapping and get a 404 as well.</column><column name="report_time">2009-06-16 12:52:31</column><column name="report_timestamp">1245170000</column><column name="status">resolved fixed</column><column name="commit">fe53ca9</column><column name="commit_timestamp">1251730000</column><column name="files">java/org/apache/tomcat/util/http/mapper/Mapper.java</column><column name="result">3:java/org/apache/tomcat/util/http/mapper/Mapper.java</column></table><table name="tomcat"><column name="id">809</column><column name="bug_id">47612</column><column name="summary">[PATCH] fix unsafe public string array in AbstractCreateStatementInterceptor</column><column name="description">Created attachment 24070 Protect array against changes; remove "magic" numbers As previously mentioned on the Tomcat-dev list, the AbstractCreateStatementInterceptor class has two public static String arrays. These can easily be changed accidentally or deliberately. There subclasses which use the arrays also depend on the order of the entries in the arrays. The patch makes the arrays private, and makes the array order explicit, eliminating the "magic" numbers currently used to access the array entries.</column><column name="report_time">2009-07-30 18:21:37</column><column name="report_timestamp">1248990000</column><column name="status">resolved fixed</column><column name="commit">4f5a5e4</column><column name="commit_timestamp">1249490000</column><column name="files">modules/jdbc-pool/java/org/apache/tomcat/jdbc/pool/interceptor/AbstractCreateStatementInterceptor.java
modules/jdbc-pool/java/org/apache/tomcat/jdbc/pool/interceptor/AbstractQueryReport.java</column><column name="result">1:modules/jdbc-pool/java/org/apache/tomcat/jdbc/pool/interceptor/AbstractCreateStatementInterceptor.java
3:modules/jdbc-pool/java/org/apache/tomcat/jdbc/pool/interceptor/AbstractQueryReport.java</column></table><table name="tomcat"><column name="id">810</column><column name="bug_id">47583</column><column name="summary">Fix occasional test failure in TestConcurrency</column><column name="description">Created attachment 24039 Sample test run showing failures TestConcurrency exhibits occasional failures - about 10% in my tests - which appear to be due to a startup timing issue. This can be fixed by replacing: assertEquals("Size comparison:",10, ds.getPool().getSize()); by assertTrue("Size comparison(less than 11):",ds.getPool().getSize()&lt;=10); in the testSimple() method (as has been done for the other test methods in the class). See attached files for some sample failures. N.B. the test output indicates either no failures or two failures. This suggests that the failure in testSimple() may be affecting a subsequent test, i.e. there may be a problem with the test cleanup. Perhaps Driver.reset(); should be done after ds.close() - or even after super.tearDown()?</column><column name="report_time">2009-07-26 06:43:28</column><column name="report_timestamp">1248610000</column><column name="status">resolved fixed</column><column name="commit">278dedc</column><column name="commit_timestamp">1248980000</column><column name="files">modules/jdbc-pool/test/org/apache/tomcat/jdbc/test/TestConcurrency.java</column><column name="result">1:modules/jdbc-pool/test/org/apache/tomcat/jdbc/test/TestConcurrency.java</column></table><table name="tomcat"><column name="id">811</column><column name="bug_id">47576</column><column name="summary">Javadoc errors - Exception name misspelt</column><column name="description">The files FairBlockingQueue.java MultiLockFairBlockingQueue.java use * @throws UnsupportedOperation This should be * @throws UnsupportedOperationException</column><column name="report_time">2009-07-24 17:27:54</column><column name="report_timestamp">1248470000</column><column name="status">resolved fixed</column><column name="commit">abbb922</column><column name="commit_timestamp">1248980000</column><column name="files">modules/jdbc-pool/java/org/apache/tomcat/jdbc/pool/FairBlockingQueue.java
modules/jdbc-pool/java/org/apache/tomcat/jdbc/pool/MultiLockFairBlockingQueue.java</column><column name="result">1:modules/jdbc-pool/java/org/apache/tomcat/jdbc/pool/MultiLockFairBlockingQueue.java
2:modules/jdbc-pool/java/org/apache/tomcat/jdbc/pool/FairBlockingQueue.java</column></table><table name="tomcat"><column name="id">812</column><column name="bug_id">47569</column><column name="summary">Test cases do not clear up afterwards</column><column name="description">Some of the test cases (e.g. TestTomcat) start a Tomcat server, This creates the directory tree tomcat.8080/work... which is not deleted when the test finishes.</column><column name="report_time">2009-07-23 13:08:38</column><column name="report_timestamp">1248370000</column><column name="status">resolved fixed</column><column name="commit">a9e00d5</column><column name="commit_timestamp">1248980000</column><column name="files">test/org/apache/catalina/connector/TestRequest.java
test/org/apache/catalina/startup/TestTomcat.java</column><column name="result">1:test/org/apache/catalina/startup/TestTomcat.java
420:test/org/apache/catalina/connector/TestRequest.java</column></table><table name="tomcat"><column name="id">813</column><column name="bug_id">47568</column><column name="summary">TestTomcat fails to delete work directory</column><column name="description">TestTomcat.setUp() creates a work directory, but does not delete it in tearDown()</column><column name="report_time">2009-07-23 12:56:58</column><column name="report_timestamp">1248370000</column><column name="status">resolved fixed</column><column name="commit">cfb18a0</column><column name="commit_timestamp">1248940000</column><column name="files">test/org/apache/catalina/startup/TestTomcat.java</column><column name="result">1:test/org/apache/catalina/startup/TestTomcat.java</column></table><table name="tomcat"><column name="id">814</column><column name="bug_id">41824</column><column name="summary">Unable to use nested type in TLD</column><column name="description">I wish to pass instances of a nested type to a JSP tag. My nested type is edu.ucsf.library.ltdl2.history.SearchHistory.Item (static inner class). I wrote my TLD like so: &lt;tag&gt;		 ... &lt;attribute&gt; &lt;name&gt;historyItem&lt;/name&gt; &lt;required&gt;no&lt;/required&gt; &lt;rtexprvalue&gt;true&lt;/rtexprvalue&gt; &lt;type&gt;edu.ucsf.library.ltdl2.history.SearchHistory.Item&lt;/type&gt; &lt;/attribute&gt; &lt;/tag&gt; Tomcat (Jasper) 5.5.20 then fails with: org.apache.jasper.JasperException: /WEB-INF/jsp/history/view.jsp(88,14) Unknown attribute type (edu.ucsf.library.ltdl2.history.SearchHistory.Item) for attribute historyItem. 	at org.apache.jasper.compiler.DefaultErrorHandler.jspError (DefaultErrorHandler.java:39) 	at org.apache.jasper.compiler.ErrorDispatcher.dispatch (ErrorDispatcher.java:405) 	at org.apache.jasper.compiler.ErrorDispatcher.jspError (ErrorDispatcher.java:234) 	at org.apache.jasper.compiler.Validator$ValidateVisitor.checkXmlAttributes (Validator.java:946) 	at org.apache.jasper.compiler.Validator$ValidateVisitor.visit (Validator.java:710) 	at org.apache.jasper.compiler.Node$CustomTag.accept(Node.java:1441) 	at org.apache.jasper.compiler.Node$Nodes.visit(Node.java:2163) 	at org.apache.jasper.compiler.Node$Visitor.visitBody(Node.java:2213) 	at org.apache.jasper.compiler.Validator$ValidateVisitor.visit (Validator.java:730) 	at org.apache.jasper.compiler.Node$CustomTag.accept(Node.java:1441) 	at org.apache.jasper.compiler.Node$Nodes.visit(Node.java:2163) 	at org.apache.jasper.compiler.Node$Visitor.visitBody(Node.java:2213) 	at org.apache.jasper.compiler.Node$Visitor.visit(Node.java:2219) 	at org.apache.jasper.compiler.Node$Root.accept(Node.java:456) 	at org.apache.jasper.compiler.Node$Nodes.visit(Node.java:2163) 	at org.apache.jasper.compiler.Validator.validate(Validator.java:1489) 	at org.apache.jasper.compiler.Compiler.generateJava(Compiler.java:166) 	at org.apache.jasper.compiler.Compiler.compile(Compiler.java:295) 	at org.apache.jasper.compiler.Compiler.compile(Compiler.java:276) 	at org.apache.jasper.compiler.Compiler.compile(Compiler.java:264) 	at org.apache.jasper.JspCompilationContext.compile (JspCompilationContext.java:563) 	at org.apache.jasper.servlet.JspServletWrapper.service (JspServletWrapper.java:305) 	at org.apache.jasper.servlet.JspServlet.serviceJspFile (JspServlet.java:314) 	at org.apache.jasper.servlet.JspServlet.service(JspServlet.java:264) 	at javax.servlet.http.HttpServlet.service(HttpServlet.java:802) If I use the name "edu.ucsf.library.ltdl2.history.SearchHistory$Item" instead, I get: org.apache.jasper.JasperException: Unable to compile class for JSP An error occurred at line: 88 in the jsp file: /WEB-INF/jsp/history/view.jsp Generated servlet error: The nested type edu.ucsf.library.ltdl2.history.SearchHistory$Item cannot be referenced using its binary name An error occurred at line: 88 in the jsp file: /WEB-INF/jsp/history/view.jsp Generated servlet error: The nested type edu.ucsf.library.ltdl2.history.SearchHistory$Item cannot be referenced using its binary name 	at org.apache.jasper.compiler.DefaultErrorHandler.javacError (DefaultErrorHandler.java:84) 	at org.apache.jasper.compiler.ErrorDispatcher.javacError (ErrorDispatcher.java:328) 	at org.apache.jasper.compiler.JDTCompiler.generateClass (JDTCompiler.java:414) 	at org.apache.jasper.compiler.Compiler.compile(Compiler.java:297) 	at org.apache.jasper.compiler.Compiler.compile(Compiler.java:276) 	at org.apache.jasper.compiler.Compiler.compile(Compiler.java:264) 	at org.apache.jasper.JspCompilationContext.compile (JspCompilationContext.java:563) 	at org.apache.jasper.servlet.JspServletWrapper.service (JspServletWrapper.java:305) 	at org.apache.jasper.servlet.JspServlet.serviceJspFile (JspServlet.java:314) 	at org.apache.jasper.servlet.JspServlet.service(JspServlet.java:264) 	at javax.servlet.http.HttpServlet.service(HttpServlet.java:802) This appears to be related to bug 35351, where the nested type is used in &lt;jsp:useBean&gt; constructs. Thanks for your help.</column><column name="report_time">2007-03-12 10:40:25</column><column name="report_timestamp">1173710000</column><column name="status">resolved fixed</column><column name="commit">768af9f</column><column name="commit_timestamp">1248460000</column><column name="files">java/org/apache/jasper/compiler/JspUtil.java</column><column name="result">6:java/org/apache/jasper/compiler/JspUtil.java</column></table><table name="tomcat"><column name="id">815</column><column name="bug_id">46907</column><column name="summary">Jasper with log4j in web-app classpath and debug level enabled prevents reading HTTP POST stream from JSP</column><column name="description">This is on Tomcat 5.5.x (don't remember the last rev. number, not my current machine). When log4j is in the classpath of the web-app and is configured to log at debug level, Jasper dumps the whole HTTP POST request body as debug traces. This consumes the HttpServletRequest input stream which then arrives unusable for the user at the beginning of the JSP code (using HttpServletRequest.getInputStream(), the stream is already at its end). A workaround is to disable debug traces for Japser class in log4j.properties, but Jasper should not consume the HttpServletRequest input stream whatever mode it runs into.</column><column name="report_time">2009-03-24 15:20:17</column><column name="report_timestamp">1237920000</column><column name="status">resolved fixed</column><column name="commit">50d0e6e</column><column name="commit_timestamp">1248370000</column><column name="files">java/org/apache/jasper/servlet/JspServlet.java</column><column name="result">40:java/org/apache/jasper/servlet/JspServlet.java</column></table><table name="tomcat"><column name="id">816</column><column name="bug_id">47518</column><column name="summary">Valve Interface Javadocs for invoke method references non-existent method</column><column name="description">It appears that the Valve interface javadoc hasn't been updated since around TC 5.5. Here is a snip of what it currently available from TC's website (6.0.20 I would guess): " # If the corresponding Response was not generated (and control was not returned, call the next Valve in the pipeline (if there is one) by executing context.invokeNext(). . . . # Modify the HTTP headers included with the Response after the invokeNext() method has returned. # Perform any actions on the output stream associated with the specified Response after the invokeNext() method has returned. " The invokeNext method has not existed in the Valve interface in many versions. I believe the replacement is: this.getNext().invoke(request, response) I'm happy to provide a doc patch if getNext().invoke(request, response) is the expected replacement for invokeNext(request, response). Note that the docs for 5.5 also have the same problem. Please let me know if I should log that separately.</column><column name="report_time">2009-07-13 06:40:01</column><column name="report_timestamp">1247480000</column><column name="status">resolved fixed</column><column name="commit">9dc93f5</column><column name="commit_timestamp">1248160000</column><column name="files">java/org/apache/catalina/Valve.java</column><column name="result">1:java/org/apache/catalina/Valve.java</column></table><table name="tomcat"><column name="id">817</column><column name="bug_id">41059</column><column name="summary">WebAppClassLoader clearReferences code break running threads</column><column name="description">When the WebAppClassLoader stops it manually sets all static and final variables to null in the clearReferences method. This results in NPEs for any thread that was not stopped and not expecting its final or static variables to be null. This is particularly a problem with hot deploys since the unload fails and terminating the deploy.</column><column name="report_time">2006-11-28 11:53:02</column><column name="report_timestamp">1164730000</column><column name="status">resolved fixed</column><column name="commit">a9f0239</column><column name="commit_timestamp">1247850000</column><column name="files">java/org/apache/catalina/loader/WebappClassLoader.java</column><column name="result">1:java/org/apache/catalina/loader/WebappClassLoader.java</column></table><table name="tomcat"><column name="id">818</column><column name="bug_id">40551</column><column name="summary">Sticky sessions using PersistentManager enter indeterminate state on node failover</column><column name="description">If a cluster of nodes is being load balanced with sticky sessions, and a particular node becomes unavailable, any sessions bound to that node must be redistributed. Particularly in the case of mod_jk these sessions will not be bound to whichever node the failover occurred on because the jessionid will still contain the JVM route of the original failed node, thus placing the session in an indeterminate state and losing sticky properties. I am attaching a patch that will trigger a session to rebind itself to a new node if the jvmroutes don't match and replace the jessionid in the browser's cookie.</column><column name="report_time">2006-09-20 01:33:41</column><column name="report_timestamp">1158730000</column><column name="status">resolved fixed</column><column name="commit">f0d447d</column><column name="commit_timestamp">1247770000</column><column name="files">java/org/apache/catalina/ha/session/JvmRouteBinderValve.java</column><column name="result">1:java/org/apache/catalina/ha/session/JvmRouteBinderValve.java</column></table><table name="tomcat"><column name="id">819</column><column name="bug_id">47515</column><column name="summary">Tomcat can't replicate session when it is started.</column><column name="description">System two Tomcat Server(AP1,AP2) Tomcat's version is 6.0.18. Replication method is Delta Manager I stopped Tomcat of AP1. Then, I restarted Tomcat of AP1. Then, for AP1, Tomcat's log is as follows. Jul 2, 2009 4:51:04 PM org.apache.catalina.ha.session.DeltaManager getAllClusterSessions WARNING: Manager [/tpcw]: Drop message SESSION-DELTA inside GET_ALL_SESSIONS sync phase start date 7/2/09 4:51 PM message date 1/1/70 9:00 AM Jul 2, 2009 4:51:04 PM org.apache.catalina.ha.session.DeltaManager getAllClusterSessions WARNING: Manager [/tpcw]: Drop message SESSION-ACCESSED inside GET_ALL_SESSIONS sync phase start date 7/2/09 4:51 PM message date 1/1/70 9:00 AM TimeStamp is incorrect when SESSION-DELTA or SESSION-ACCESSED because "1/1/70 9:00 AM" isn't created time of session. In this case, AP1's Tomcat may drop all session data. As a result, AP1's Tomcat can't replicate session. If TimeStamp is updated when update last replicated time, it goes well. I made patch. DeltaManager's patch. Index: java/org/apache/catalina/ha/session/DeltaManager.java =================================================================== --- java/org/apache/catalina/ha/session/DeltaManager.java	(revision 792004) +++ java/org/apache/catalina/ha/session/DeltaManager.java	(working copy) @@ -1162,7 +1162,10 @@ } //update last replicated time - if (msg != null) session.setLastTimeReplicated(System.currentTimeMillis()); + if (msg != null){ + 	session.setLastTimeReplicated(System.currentTimeMillis()); + 	msg.setTimestamp(session.getLastTimeReplicated()); + } return msg; } catch (IOException x) { log.error(sm.getString("deltaManager.createMessage.unableCreateDeltaRequest",sessionId), x);</column><column name="report_time">2009-07-12 23:08:36</column><column name="report_timestamp">1247450000</column><column name="status">resolved fixed</column><column name="commit">83e98da</column><column name="commit_timestamp">1247750000</column><column name="files">java/org/apache/catalina/ha/session/DeltaManager.java</column><column name="result">5:java/org/apache/catalina/ha/session/DeltaManager.java</column></table><table name="tomcat"><column name="id">820</column><column name="bug_id">40380</column><column name="summary">Potential syncro problem in StandardSession.expire(boolean)</column><column name="description">public void expire(boolean notify) { // Mark this session as "being expired" if needed if (expiring) return; // No man's land here synchronized (this) { if (manager == null) return; expiring = true;</column><column name="report_time">2006-08-31 18:57:30</column><column name="report_timestamp">1157070000</column><column name="status">resolved fixed</column><column name="commit">6f3e56e</column><column name="commit_timestamp">1247590000</column><column name="files">java/org/apache/catalina/session/StandardSession.java</column><column name="result">1:java/org/apache/catalina/session/StandardSession.java</column></table><table name="tomcat"><column name="id">821</column><column name="bug_id">47524</column><column name="summary">McastServiceImpl executor is not dispatching events.</column><column name="description">Created attachment 23977 Fix proposal The class McastServiceImpl does not dispatch events, because the the executor is not creating threads. The class ReceiverBase has its own queue to address this issue. I have refactored the code a little to reuse the class. (attaching the diff file) I'm not sure if filing a bug in Bugzilla is the right procedure for Trunk branch. If not, could you please tell me how should I proceed? Regards, Ariel</column><column name="report_time">2009-07-14 06:20:02</column><column name="report_timestamp">1247570000</column><column name="status">resolved fixed</column><column name="commit">aa8a2d3</column><column name="commit_timestamp">1247580000</column><column name="files">java/org/apache/catalina/tribes/membership/McastServiceImpl.java
java/org/apache/catalina/tribes/transport/ReceiverBase.java
java/org/apache/catalina/tribes/util/ExecutorFactory.java</column><column name="result">1:java/org/apache/catalina/tribes/membership/McastServiceImpl.java
7:java/org/apache/catalina/tribes/transport/ReceiverBase.java</column></table><table name="tomcat"><column name="id">822</column><column name="bug_id">39231</column><column name="summary">The JAAS contract for LoginModule is broken</column><column name="description">The issue is that the custom JAAS's LoginModule.logout() method is never called. I guess this has been never implemented correctly (at least since Tomcat 5.5.9). The thing is that according to the JAAS spec, the LoginContext.logout() is supposed to invoke the logout method for each LoginModule configured for this LoginContext. So, somebody should be sure to call LoginContext.logout() method. The caller for this method could be either a server or a client. So, either Tomcat should provide some means to access the LoginContext to the clients, or Tomcat should take the responsibility to call this method by itself. I guess the solution could be for Tomcat to associate the instance of LoginContext with the user's session, and then Tomcat could invoke LoginContext.logout() when the session is being invalidated (both when the session times out or invalidated explicitely). I hope that I am correctly interpreting the JAAS spec.</column><column name="report_time">2006-04-06 21:19:49</column><column name="report_timestamp">1144370000</column><column name="status">resolved fixed</column><column name="commit">80f8ec6</column><column name="commit_timestamp">1246980000</column><column name="files">java/org/apache/catalina/realm/GenericPrincipal.java
java/org/apache/catalina/realm/JAASRealm.java
java/org/apache/catalina/session/StandardSession.java</column><column name="result">2:java/org/apache/catalina/realm/JAASRealm.java
40:java/org/apache/catalina/session/StandardSession.java
372:java/org/apache/catalina/realm/GenericPrincipal.java</column></table><table name="tomcat"><column name="id">823</column><column name="bug_id">47478</column><column name="summary">DeltaSession ignores notifyListenersOnReplication when BackupManager is used.</column><column name="description">When BackupManager is used, DeltaSession notifies session listener even if notifyListenersOnReplication is set to false. The cause is in the following o.a.c.h.s.DeltaSession#applyDiff's codes. public void applyDiff(byte[] diff, int offset, int length) throws IOException, ClassNotFoundException { try { ... getDeltaRequest().execute(this); } finally { Thread.currentThread().setContextClassLoader(contextLoader); } }finally { unlock(); } } DeltaSession always notifies the session listener regardless of the value of notifyListenersOnReplication. Do not notify the session listener when notifyListenersOnReplication is set to false. I think that I should add notifyListenersOnReplication to the second parameter when o.a.c.h.s.DeltaRequest#execute is invoked. For instance, as follows. [start.] Index: java/org/apache/catalina/ha/session/DeltaSession.java =================================================================== --- java/org/apache/catalina/ha/session/DeltaSession.java	(revision 763870) +++ java/org/apache/catalina/ha/session/DeltaSession.java	(working copy) @@ -175,7 +175,7 @@ ClassLoader[] loaders = getClassLoaders(); if (loaders != null &amp;&amp; loaders.length &gt; 0) Thread.currentThread().setContextClassLoader(loaders[0]); - getDeltaRequest().execute(this); + getDeltaRequest().execute(this, ((ClusterManager) getManager()).isNotifyListenersOnReplication()); } finally { Thread.currentThread().setContextClassLoader(contextLoader); } [end.] Best regards</column><column name="report_time">2009-07-06 03:05:17</column><column name="report_timestamp">1246860000</column><column name="status">resolved fixed</column><column name="commit">c1099f7</column><column name="commit_timestamp">1246900000</column><column name="files">java/org/apache/catalina/ha/session/DeltaSession.java</column><column name="result">3:java/org/apache/catalina/ha/session/DeltaSession.java</column></table><table name="tomcat"><column name="id">824</column><column name="bug_id">37933</column><column name="summary">Bugs in Tomcat</column><column name="description">Hi, I am manokaran.I wrote a program in tomcat using eclipse IDE. The code is as follows: 1.&gt;This is a Bean: package MMM; public class Bean { 	private String name; 	public void SetName(String s) 	{this.name=s; 	} 	public String getName() 	{ 		return name; 	} } 2.&gt;This is a Servlet class: package MMM; import java.io.IOException; import javax.servlet.RequestDispatcher; import javax.servlet.ServletException; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; public class Serv extends HttpServlet{ 	public void doGet(HttpServletRequest request,HttpServletResponse response) throws ServletException,IOException 	{ 		Bean bean=new Bean(); 		bean.SetName("manokaran"); 		request.setAttribute("mano",bean); 		RequestDispatcher rd=request.getRequestDispatcher("india.jsp"); 		rd.forward(request,response); 	} } 3.This is web.xml file: &lt;?xml version="1.0" encoding="ISO-8859-1"?&gt; &lt;!DOCTYPE web-app PUBLIC "-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN" "http://java.sun.com/dtd/web-app_2_3.dtd"&gt; &lt;web-app&gt; &lt;servlet&gt; &lt;servlet-name&gt;mano&lt;/servlet-name&gt; &lt;servlet-class&gt;MMM.Serv&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;mano&lt;/servlet-name&gt; &lt;url-pattern&gt;/manokara.do&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;/web-app&gt; 4.&gt;This is Index.html file: &lt;html&gt; &lt;form action=manokara.do&gt; &lt;input type=submit&gt; &lt;/form&gt; &lt;/html&gt; 5.&gt;This is a JSP file: &lt;jsp:useBean id="mano1" class="MMM.Bean" scope="request" /&gt; &lt;jsp:getProperty name="mano" property="name"/&gt; Report: The setAttribute, Jsp UseBean ID and getProperty name must be same. this is the correct procedure. this format was working well in tomcat and all web,application servers. But the values set by me were : setAttribute("mano",ss),getProperty name="mano" useBean id="mano1". Observe that the useBean id is set different. Hence logically, this must not work. But in my case it is working in TOMCAT. The same code is not working in WEBLOGIC.</column><column name="report_time">2005-12-16 07:00:20</column><column name="report_timestamp">1134730000</column><column name="status">resolved fixed</column><column name="commit">202a33e</column><column name="commit_timestamp">1246790000</column><column name="files">java/org/apache/jasper/compiler/Generator.java
java/org/apache/jasper/compiler/PageInfo.java</column><column name="result">19:java/org/apache/jasper/compiler/Generator.java</column></table><table name="tomcat"><column name="id">825</column><column name="bug_id">37984</column><column name="summary">JNDIRealm.java not able to handle MD5 password</column><column name="description">I'm using JNDIRealm to authenticate to OpenLDAP 2.2.28. Within OpenLDAP I've configured the userPassword attribute for each user to contain the MD5 digest, and each is prefixed with the string "{MD5}". I am not an LDAP expert by any means but I believe this prefix is a standard convention. Anyway assuming this is a convention then JNDIRealm needs to strip off the "{MD5}" portion much like it does with "{SHA1}". See attached patch which accomplishes this and I verified it works in my environment.</column><column name="report_time">2005-12-21 05:51:20</column><column name="report_timestamp">1135160000</column><column name="status">resolved fixed</column><column name="commit">c6818a0</column><column name="commit_timestamp">1246490000</column><column name="files">java/org/apache/catalina/realm/JNDIRealm.java</column><column name="result">1:java/org/apache/catalina/realm/JNDIRealm.java</column></table><table name="tomcat"><column name="id">826</column><column name="bug_id">47440</column><column name="summary">Remove DB-specific SQL statements from test cases (SELECT 1)</column><column name="description">Some of the test cases assume that the JDBC provider supports "SELECT 1" as a valid SQL statement; however this is not always the case, e.g. Derby requires a table name to select from. The solution provided in the patches is to use the validation query defined in the properties set up for the test, rather than always using "SELECT 1".</column><column name="report_time">2009-06-27 05:17:55</column><column name="report_timestamp">1246090000</column><column name="status">resolved fixed</column><column name="commit">d92da6e</column><column name="commit_timestamp">1246290000</column><column name="files">modules/jdbc-pool/test/org/apache/tomcat/jdbc/test/CheckOutThreadTest.java
modules/jdbc-pool/test/org/apache/tomcat/jdbc/test/DefaultProperties.java
modules/jdbc-pool/test/org/apache/tomcat/jdbc/test/TestSlowQueryReport.java</column><column name="result">7:modules/jdbc-pool/test/org/apache/tomcat/jdbc/test/TestSlowQueryReport.java
51:modules/jdbc-pool/test/org/apache/tomcat/jdbc/test/DefaultProperties.java
109:modules/jdbc-pool/test/org/apache/tomcat/jdbc/test/CheckOutThreadTest.java</column></table><table name="tomcat"><column name="id">827</column><column name="bug_id">47439</column><column name="summary">PooledConnection.connect() fails to check for null connection</column><column name="description">PooledConnection.connect() fails to check for null return from java.sql.Driver.connect() method. This can result in an NPE when the connection is used later.</column><column name="report_time">2009-06-27 05:01:35</column><column name="report_timestamp">1246090000</column><column name="status">resolved fixed</column><column name="commit">ef96fa2</column><column name="commit_timestamp">1246200000</column><column name="files">modules/jdbc-pool/java/org/apache/tomcat/jdbc/pool/PooledConnection.java</column><column name="result">1:modules/jdbc-pool/java/org/apache/tomcat/jdbc/pool/PooledConnection.java</column></table><table name="tomcat"><column name="id">828</column><column name="bug_id">38352</column><column name="summary">Additional Entries for Default catalina.policy file.</column><column name="description">This patch adds additional entries to the catalina.policy file. Specifically: The catalina.base/shared directory is added and given equal permissions to catalina.home/common java.io.tmpdir is now readable. javax.servlet.context.tempdir is now readable. I think to be compliant with the spec, this must be allowed. Directory specified by java.io.tmpdir (which is what tomcat points javax.servlet.context.tempdir to) is now read, write, delete. Again, I think the spec requires this.</column><column name="report_time">2006-01-22 20:27:46</column><column name="report_timestamp">1137980000</column><column name="status">resolved fixed</column><column name="commit">76a4eb3</column><column name="commit_timestamp">1245420000</column><column name="files">java/org/apache/jasper/compiler/JspRuntimeContext.java</column><column name="result">33:java/org/apache/jasper/compiler/JspRuntimeContext.java</column></table><table name="tomcat"><column name="id">829</column><column name="bug_id">47308</column><column name="summary">Cannot join in the cluster membership.</column><column name="description">I use Tomcat6.0.20. The fix of Revision 757582(http://svn.apache.org/viewvc?view=rev&amp;revision=757582) is applied to Tomcat6.0.20. This fix means that Tomcat6.0.20 always disabled LoopbackMode. Therefore, it is not possible to join in the membership when the cluster is composed of two or more Tomcat on the same machine. I think that options for loopbackMode is better. I made patch. McastService's patch. Index: java/org/apache/catalina/tribes/membership/McastService.java =================================================================== --- java/org/apache/catalina/tribes/membership/McastService.java	(revision 763870) +++ java/org/apache/catalina/tribes/membership/McastService.java	(working copy) @@ -230,6 +230,9 @@ properties.setProperty("recoverySleepTime", String.valueOf(recoverySleepTime)); } + public void setLocalLoopbackDisabled(boolean localLoopbackDisabled) { + properties.setProperty("localLoopbackDisabled", String.valueOf(localLoopbackDisabled)); + } /** * @deprecated use getPort() @@ -360,7 +363,8 @@ java.net.InetAddress.getByName(properties.getProperty("mcastAddress")), ttl, soTimeout, - this); + this, + Boolean.valueOf(properties.getProperty("localLoopbackDisabled","true")).booleanValue()); String value = properties.getProperty("recoveryEnabled","true"); boolean recEnabled = Boolean.valueOf(value).booleanValue() ; impl.setRecoveryEnabled(recEnabled); McastServiceImpl's patch. Index: java/org/apache/catalina/tribes/membership/McastServiceImpl.java =================================================================== --- java/org/apache/catalina/tribes/membership/McastServiceImpl.java	(revision 763870) +++ java/org/apache/catalina/tribes/membership/McastServiceImpl.java	(working copy) @@ -135,7 +135,13 @@ * Add the ability to turn on/off recovery */ protected boolean recoveryEnabled = true; + /** + * disable/enable local loopback message + */ + protected boolean localLoopbackDisabled = true; + + /** * Create a new mcast service impl * @param member - the local member * @param sendFrequency - the time (ms) in between pings sent out @@ -144,6 +150,7 @@ * @param bind - the bind address (not sure this is used yet) * @param mcastAddress - the mcast address * @param service - the callback service + * @param disableLoopbackMode - disable loopbackMode * @throws IOException */ public McastServiceImpl( @@ -155,7 +162,8 @@ InetAddress mcastAddress, int ttl, int soTimeout, - MembershipListener service) + MembershipListener service, + boolean localLoopbackDisabled) throws IOException { this.member = member; this.address = mcastAddress; @@ -166,6 +174,7 @@ this.timeToExpiration = expireTime; this.service = service; this.sendFrequency = sendFrequency; + this.localLoopbackDisabled = localLoopbackDisabled; init(); } @@ -199,7 +208,7 @@ } else { socket = new MulticastSocket(port); } - socket.setLoopbackMode(true); //hint that we don't need loop back messages + socket.setLoopbackMode(localLoopbackDisabled); //hint that we don't need loop back messages if (mcastBindAddress != null) { And the localLoopbackDisabled attribute is specified for &lt; Membership &gt; of server.xml. example. &lt;Membership className="org.apache.catalina.tribes.membership.McastService" --another attribute-- localLoopbackDisabled="false" /&gt; Regards.</column><column name="report_time">2009-06-03 03:39:06</column><column name="report_timestamp">1244010000</column><column name="status">resolved fixed</column><column name="commit">51fd68b</column><column name="commit_timestamp">1245340000</column><column name="files">java/org/apache/catalina/tribes/membership/McastService.java
java/org/apache/catalina/tribes/membership/McastServiceImpl.java</column><column name="result">21:java/org/apache/catalina/tribes/membership/McastService.java
53:java/org/apache/catalina/tribes/membership/McastServiceImpl.java</column></table><table name="tomcat"><column name="id">830</column><column name="bug_id">47389</column><column name="summary">DeltaManager doesn't do the session replication. (notifySessionListenersOnReplication=false)</column><column name="description">DeltaManager is used. When notifySessionListenersOnReplication is set to false, session replication is not done. This cause is in the following DeltaManager#handleSESSION_CREATED's codes. protected void handleSESSION_CREATED(SessionMessage msg,Member sender) { ... if(notifySessionListenersOnReplication) session.setId(msg.getSessionID()); else session.setIdInternal(msg.getSessionID()); session.resetDeltaRequest(); session.endAccess(); } When notifySessionListenersOnReplication is false, only session.setIdInternal is executed. Session is not added to session map of DeltaManager in session.setIdInternal method. As a result, session replication is not done. When notifySessionListenersOnReplication is false, I think that I should add session to session map of DeltaManager. For instance, as follows. [start.] Index: java/org/apache/catalina/ha/session/DeltaManager.java =================================================================== --- java/org/apache/catalina/ha/session/DeltaManager.java	(revision 763870) +++ java/org/apache/catalina/ha/session/DeltaManager.java	(working copy) @@ -1435,10 +1435,12 @@ // use container maxInactiveInterval so that session will expire correctly in case of primary transfer session.setMaxInactiveInterval(getMaxInactiveInterval()); session.access(); - if(notifySessionListenersOnReplication) + if(notifySessionListenersOnReplication) { session.setId(msg.getSessionID()); - else + } else { session.setIdInternal(msg.getSessionID()); + add(session); + } session.resetDeltaRequest(); session.endAccess(); [end.] Best regards.</column><column name="report_time">2009-06-18 03:39:55</column><column name="report_timestamp">1245310000</column><column name="status">resolved fixed</column><column name="commit">c768090</column><column name="commit_timestamp">1245340000</column><column name="files">java/org/apache/catalina/ha/session/DeltaManager.java</column><column name="result">1:java/org/apache/catalina/ha/session/DeltaManager.java</column></table><table name="tomcat"><column name="id">831</column><column name="bug_id">47369</column><column name="summary">DeltaRequest is never reset. (use BackupManager)</column><column name="description">DeltaRequest is never reset after the session replication when BackupManager is used. This means information on the previous session replication replicate again. actions.size() of DeltaRequest increases until the session becomes invalid. I think that I should reset DeltaRequest in each session replication. For instance, as follows. [start.] Index: java/org/apache/catalina/tribes/tipis/AbstractReplicatedMap.java =================================================================== --- java/org/apache/catalina/tribes/tipis/AbstractReplicatedMap.java	(revision 763870) +++ java/org/apache/catalina/tribes/tipis/AbstractReplicatedMap.java	(working copy) @@ -401,6 +401,7 @@ rentry.getDiff(), entry.getPrimary(), entry.getBackupNodes()); + rentry.resetDiff(); } catch (IOException x) { log.error("Unable to diff object. Will replicate the entire object instead.", x); } finally { [end.] Best regards</column><column name="report_time">2009-06-15 03:34:59</column><column name="report_timestamp">1245050000</column><column name="status">resolved fixed</column><column name="commit">b3e2be4</column><column name="commit_timestamp">1245090000</column><column name="files">java/org/apache/catalina/tribes/tipis/AbstractReplicatedMap.java</column><column name="result">8:java/org/apache/catalina/tribes/tipis/AbstractReplicatedMap.java</column></table><table name="tomcat"><column name="id">832</column><column name="bug_id">47343</column><column name="summary">Fails re-deploying, when we update context.xml.</column><column name="description">When context.xml of the conf/&lt;engine&gt;/&lt;host&gt;directory is updated, docBase directory is deleted and fails re-deploying. Reproduction. (The context name is assumed to be testWebapp. ) 1.&lt;&lt;Tomcat_home&gt;&gt;/webapps/testWebapp/META-INF/context.xml is prepared. 2.Context.xml is not put under the conf/&lt;engine&gt;/&lt;host&gt; directory. (means first deployed) 3.Tomcat is started. (testWebapp.xml is created to the conf/&lt;engine&gt;/&lt;host&gt; directory. ) 4.testWebapp.xml of conf/&lt;engine&gt;/&lt;host &gt; is updated. Result. &lt;&lt;Tomcat_home&gt;&gt;/webapps/testWebapp directory is deleted. The cause is in the fixed of "http://svn.apache.org/viewvc?view=rev&amp;revision=712464". The order of the resource added to HostConfig$DeployedApplication#redeployResources was changed by this fix. order of the redploy resources is as follows. [before fix] Case of Deploy war. war -&gt; context.xml(conf/&lt;engine&gt;/&lt;host&gt;) -&gt; doceBase directory Case of Deploy directory. doceBase directory -&gt; context.xml(META-INF/context.xml) [after fix] Case of Deploy war. context.xml(conf/&lt;engine&gt;/&lt;host&gt;) -&gt; war -&gt; doceBase directory Case of Deploy directory. context.xml(META-INF/context.xml) -&gt; doceBase directory HostConfig#checkResources is as follows. for (int i = 0; i &lt; resources.length; i++) { ...omits if ((!resource.isDirectory()) &amp;&amp; resource.lastModified() &gt; lastModified) { ...omits // Delete other redeploy resources for (int j = i + 1; j &lt; resources.length; j++) { try { File current = new File(resources[j]); ...omits ExpandWar.delete(current); } } catch (IOException e) { log.warn(sm.getString ("hostConfig.canonicalizing", app.name), e); } } ...omits After all, When testWebapp.xml of conf/&lt;engine&gt;/&lt;host &gt; is updated, directory is deleted or war and the directory are deleted. As a result, It fails in deploying because it tries to deploy it only with context.xml (docBase direcotry doesn't exist). Regards.</column><column name="report_time">2009-06-10 03:54:19</column><column name="report_timestamp">1244620000</column><column name="status">resolved fixed</column><column name="commit">cc1f0dd</column><column name="commit_timestamp">1244730000</column><column name="files">java/org/apache/catalina/startup/HostConfig.java</column><column name="result">2:java/org/apache/catalina/startup/HostConfig.java</column></table><table name="tomcat"><column name="id">833</column><column name="bug_id">47299</column><column name="summary">Cannot override StandardContext in embedding case because of StandardSession.fireContainerEvent</column><column name="description">StandardSession.fireContainerEvent checks for the String class name! Why not just use an instanceof check here?</column><column name="report_time">2009-06-02 07:19:36</column><column name="report_timestamp">1243940000</column><column name="status">resolved fixed</column><column name="commit">468f370</column><column name="commit_timestamp">1244240000</column><column name="files">java/org/apache/catalina/session/StandardSession.java</column><column name="result">2:java/org/apache/catalina/session/StandardSession.java</column></table><table name="tomcat"><column name="id">834</column><column name="bug_id">47158</column><column name="summary">I think AccessLogValve has race condition problem</column><column name="description">"Double-Checked Locking" pattern is heavily used in this class, but the usage of it in AccessLogValve has some issues of race condition judging by this article: http://www.cs.umd.edu/~pugh/java/memoryModel/DoubleCheckedLocking.html Based by this article, I think these variables in this class should be declared as volatile to get rid of race condition: private volatile long currentMillis; private volatile Date currentDate;</column><column name="report_time">2009-05-05 15:12:45</column><column name="report_timestamp">1241550000</column><column name="status">resolved fixed</column><column name="commit">f00029e</column><column name="commit_timestamp">1244130000</column><column name="files">java/org/apache/catalina/valves/AccessLogValve.java</column><column name="result">1:java/org/apache/catalina/valves/AccessLogValve.java</column></table><table name="tomcat"><column name="id">835</column><column name="bug_id">47216</column><column name="summary">Possible NPE in Http11Processor.action()</column><column name="description">The code at around line 1075: } else if (actionCode == ActionCode.ACTION_REQ_LOCAL_ADDR_ATTRIBUTE) { if (localAddr == null) localAddr = socket.getLocalAddress().getHostAddress(); fails to check if "socket != null". Since this is checked everywhere else in the method this is probably a bug. The method Http11Processor.parseHost() also references "socket" without checking for null. Within the class, it is only called by process(Socket), which guarantees that it won't be null. However once process() returns normally, socket will be set to null. The parseHost() method is public, so it may be called when socket == null. Perhaps the parseHost() method should be private?</column><column name="report_time">2009-05-18 18:13:50</column><column name="report_timestamp">1242680000</column><column name="status">resolved wontfix</column><column name="commit">36feee0</column><column name="commit_timestamp">1243250000</column><column name="files">java/org/apache/coyote/http11/Http11Processor.java</column><column name="result">1:java/org/apache/coyote/http11/Http11Processor.java</column></table><table name="tomcat"><column name="id">836</column><column name="bug_id">47234</column><column name="summary">serviceStartTime is different in MemberImpl from McastServiceImpl</column><column name="description">Hi, I'm using the tribes cluster module in my own application (which has nothing to do with tomcat) and I'm using the member alive time value to sort all the cluster members. This bug produces the following: I have 2 nodes that were started almost at the same time and both nodes claim that the other node was started before them NODE1: Remote members: (-52.63.57.110:4001 ready=true suspect=false failing=false aliveTime=1526) Local member: (-52.63.57.109:4000 ready=true suspect=false failing=false aliveTime=1236) NODE2: Remote members: (-52.63.57.109:4000 ready=true suspect=false failing=false aliveTime=2021) Local member: (-52.63.57.110:4001 ready=true suspect=false failing=false aliveTime=1069) My code do the following: Member[] members = groupChannel.getMembers(); printRemote(members); Member localMember = groupChannel.getLocalMember(true); printLocal(localMember); In that code (due to timing issues) it should possible the other way around (that every node claim to be started before the other) but not that case. The issue occurs because when the McastService is started, it assigns a start time to the local member. public class McastService .... { public void start(int level) { .... localMember.setServiceStartTime(System.currentTimeMillis()); .... impl = new McastServiceImpl(localMember, ....); impl.start(level); } } But, then it creates and starts a McastServiceImpl which also stores a new serviceStartTime :-( public class McastServiceImpl { protected long serviceStartTime; public void start(int level) { .... serviceStartTime = System.currentTimeMillis(); .... } } So, we have 2 different start times. Unfortunately both times are used: To get the local member, the impl.getServiceStartTime() is used: public class McastService .... { public Member getLocalMember(boolean alive) { if ( alive &amp;&amp; localMember != null &amp;&amp; impl != null) localMember.setMemberAliveTime(System.currentTimeMillis()-impl.getServiceStartTime()); return localMember; } } But, when the member is transmited throw the network, the MemberImpl.getServiceStartTime() is used. public class MemberImpl .... { public byte[] getData(boolean getalive, boolean reset) { if ( reset ) dataPkg = null; //look in cache first if ( dataPkg!=null ) { if ( getalive ) { //you'd be surprised, but System.currentTimeMillis //shows up on the profiler long alive=System.currentTimeMillis()-getServiceStartTime(); XByteBuffer.toBytes( (long) alive, dataPkg, TRIBES_MBR_BEGIN.length+4); } return dataPkg; } ...... } That produces that weird behaviour. IMHO, the fix should be setting the same "serviceStartTime" to both components. This issue is affecting seriously my code. I would appreciate if you could fix it asap. I've verified that the same code is present in trunk repository. Regards, Ariel</column><column name="report_time">2009-05-21 07:32:52</column><column name="report_timestamp">1242910000</column><column name="status">resolved fixed</column><column name="commit">9fa7640</column><column name="commit_timestamp">1242930000</column><column name="files">java/org/apache/catalina/tribes/membership/McastServiceImpl.java</column><column name="result">2:java/org/apache/catalina/tribes/membership/McastServiceImpl.java</column></table><table name="tomcat"><column name="id">837</column><column name="bug_id">47111</column><column name="summary">do caching the resources like the docu say it (StringManager)</column><column name="description">Created attachment 23559 do caching the resources like the docu say it do caching the resources like the docu say it see https://issues.apache.org/bugzilla/show_bug.cgi?id=46933</column><column name="report_time">2009-04-28 08:54:49</column><column name="report_timestamp">1240920000</column><column name="status">resolved wontfix</column><column name="commit">96167ed</column><column name="commit_timestamp">1241310000</column><column name="files">java/org/apache/tomcat/util/res/StringManager.java</column><column name="result">1:java/org/apache/tomcat/util/res/StringManager.java</column></table><table name="tomcat"><column name="id">838</column><column name="bug_id">47050</column><column name="summary">StandardHostValve.status unnecessarily HTML-escapes the error message</column><column name="description">I have written a JSP page that prints all request attributes verbatimly to the output. When I access it as http://localhost:8100/roland/404&amp;amp; it outputs the following HTML code: &lt;body&gt; javax.servlet.error.message=/roland/404&amp;amp;amp;&lt;br&gt; javax.servlet.error.request_uri=/roland/404&amp;amp;&lt;br&gt; ... &lt;/body&gt; I was surprised that the error.message has been HTML-escaped, but the error.request hasn't. What's the intention of this escaping? It feels like Catalina is imitating PHP's magic-quotes here, which it shouldn't. In my opinion, the error message should be copied to the request attribute as-is and not being passed through RequestUtil.filter, so the programmer can write it to log files or a text/plain error page without unfiltering it first.</column><column name="report_time">2009-04-19 01:59:15</column><column name="report_timestamp">1240120000</column><column name="status">resolved fixed</column><column name="commit">1ad0501</column><column name="commit_timestamp">1241190000</column><column name="files">java/org/apache/catalina/core/StandardHostValve.java</column><column name="result">1:java/org/apache/catalina/core/StandardHostValve.java</column></table><table name="tomcat"><column name="id">839</column><column name="bug_id">47046</column><column name="summary">Shutdown does not unregister all MBeans</column><column name="description">Created attachment 23505 Simple driver to highlight problem If I start and stop Tomcat in a VM using the Catalina class then it does not unregister all its MBeans. The list left over is: Catalina:type=RequestProcessor,worker=http-8080,name=HttpRequest1 true Catalina:type=MBeanFactory true Catalina:type=Engine true Catalina:type=JkWorkerEnv true Catalina:type=StringCache true Catalina:type=Host,host=localhost true Catalina:type=JkMain true Catalina:type=JkHandler,name=channelSocket true Catalina:type=Server true Catalina:type=JkHandler,name=request true Catalina:type=Connector,port=8080 true Catalina:type=Connector,port=8009 true I've attached a simple class that can be used to reproduce this list.</column><column name="report_time">2009-04-17 07:59:51</column><column name="report_timestamp">1239970000</column><column name="status">resolved fixed</column><column name="commit">54b9da9</column><column name="commit_timestamp">1241050000</column><column name="files">java/org/apache/catalina/connector/MapperListener.java
java/org/apache/catalina/mbeans/MBeanUtils.java
java/org/apache/catalina/mbeans/ServerLifecycleListener.java</column><column name="result">6:java/org/apache/catalina/mbeans/ServerLifecycleListener.java
14:java/org/apache/catalina/mbeans/MBeanUtils.java
21:java/org/apache/catalina/connector/MapperListener.java</column></table><table name="tomcat"><column name="id">840</column><column name="bug_id">46925</column><column name="summary">Nested groups in JNDI realm with non-recursive implementation</column><column name="description">Created attachment 23420 Patch which replaced the recursive method with a while loop ("memberOf Algorithm") I have modified the method getRoles in org.apache.catalina.realm.JNDIRealm in the trunk in order to use a while loop to detect nested groups (instead of the recursive method currently implemented there). The algorithm is inspired by the article "Practices in Directory Groups" found here: http://middleware.internet2.edu/dir/groups/internet2-mace-dir-groups-best-practices-200210.htm It avoids group slurping and handles cyclic group memberships as well. Find a patch attached. Greetings from Amsterdam, Stefan</column><column name="report_time">2009-03-27 03:58:28</column><column name="report_timestamp">1238140000</column><column name="status">resolved fixed</column><column name="commit">d04dd88</column><column name="commit_timestamp">1240860000</column><column name="files">java/org/apache/catalina/realm/JNDIRealm.java</column><column name="result">2:java/org/apache/catalina/realm/JNDIRealm.java</column></table><table name="tomcat"><column name="id">841</column><column name="bug_id">37929</column><column name="summary">invalidated session causes pageContext methods to fail</column><column name="description">javax.servlet.http.HttpSession methods such as getAttribute(), getValue(), getAttributeNames(), getValueNames(), etc, throw an IllegalStateException if called on a session that has been invalidated. So, with the following code in a JSP page: &lt;% session.invalidate(); Object obj = pageContext.findAttribute("foo"); %&gt; An IllegalStateException is thrown because pageContext.findAttribute() eventually calls session.getAttribute() on a session that has been invalidated. The session that has been invalidated should simply be ignored when a method needs to process the various scopes (page, request, session, application). This impacts the following methods in PageContextImpl: public int getAttributesScope(final String name) which calls -&gt; private int doGetAttributeScope(String name); public Object findAttribute(final String name) which calls -&gt; private Object doFindAttribute(String name); public void removeAttribute(final String name) which calls -&gt; private void doRemoveAttribute(String name); The fix is to catch IllegalStateException and ignore it when processing the attribute in session scope. The code then simply follows through to process application scope. No need to worry about setAttribute() because it is always invoked on a specific scope, and the spec already states that java.lang.IllegalStateException must be thrown when called on an invalidated session. pageContext.setAttribute("foo", "value of foo", PageContext.SESSION_SCOPE); java.lang.IllegalStateException - if the scope is PageContext.SESSION_SCOPE but the page that was requested does not participate in a session or the session has been invalidated. --------------------------------------------------------------------------- At the same time, a fix should be done to method "doRemoveAttribute(String name)" where a try/catch block for Exception appears unnecessary. private void doRemoveAttribute(String name){ try { removeAttribute(name, PAGE_SCOPE); removeAttribute(name, REQUEST_SCOPE); if( session != null ) { try { removeAttribute(name, SESSION_SCOPE); } catch (IllegalStateException ex) { // Session has been invalidated. // Ignore and fall through to application scope. } } removeAttribute(name, APPLICATION_SCOPE); } catch (Exception ex) { // we remove as much as we can, and // simply ignore possible exceptions } } Here is a full analysis: Starting with 'removeAttribute(final String name)' - we check for null and throw NPE if necessary - we call doRemoveAttribute(name) doRemoveAttribute(name) - we call removeAttribute(name, scope) for each scope removeAttribute(final String name, final int scope) - this calls doRemoveAttribute(name, scope) doRemoveAttribute(name, scope) - page scope: attributes.remove -&gt; won't throw an Exception - request scope: request.removeAttribute -&gt; no documented Exception thrown - session scope: throws IllegalStateException if session is null - app scope: context.removeAttribute -&gt; no documented Exception thrown A null value for name is already checked in removeAttribute(final String name) and we throw NPE. So this situation (removing an attr from page or request scope throwing an NPE) won't happen. In doRemoveAttribute(name), we already check on session != null before calling removeAttribute(name, SESSION_SCOPE). So there normally is no IllegalStateException thrown (except for the invalidated case). When removing an attribute from application (i.e., ServletContext) scope, any registered listeners will be notified, but the code that does that (see appserv-webtier/src/java/org/apache/catalina/core/ApplicationContext. removeAttribute()) already catches any Throwable that a listener may throw. The try/catch block is therefore unnecessary. Moreover, if any of the removal actions from the different scopes could have thrown an exception, each of them would have needed to be wrapped inside their own try/catch, so as to ensure that an exception in one scope does not cause any of the subsequent removals to be bypassed. doRemoveAttribute(String name) has therefore been modified as follows: private void doRemoveAttribute(String name){ removeAttribute(name, PAGE_SCOPE); removeAttribute(name, REQUEST_SCOPE); if( session != null ) { try { removeAttribute(name, SESSION_SCOPE); } catch (IllegalStateException ex) { // Session has been invalidated. // Ignore and fall through to application scope. } } removeAttribute(name, APPLICATION_SCOPE); } -------------------------- Changes done on glassfish. ymmv on jasper for the diffs. --- PageContextImpl.java	9 Dec 2005 18:54:30 -0000	1.7 +++ PageContextImpl.java	16 Dec 2005 00:11:21 -0000	1.8 @@ -452,8 +452,13 @@ return REQUEST_SCOPE; if (session != null) { + try { if (session.getAttribute(name) != null) return SESSION_SCOPE; + } catch (IllegalStateException ex) { + 	 // Session has been invalidated. + // Ignore and fall through to application scope. + } } if (context.getAttribute(name) != null) @@ -495,9 +500,14 @@ return o; if (session != null) { +	 try { o = session.getAttribute(name); - if (o != null) - return o; + 	 } catch (IllegalStateException ex) { + 	 // Session has been invalidated. + // Ignore and fall through to application scope. + 	 } + + 	 if (o != null) return o; } return context.getAttribute(name); @@ -559,19 +569,18 @@ } } - private void doRemoveAttribute(String name){ - try { removeAttribute(name, PAGE_SCOPE); removeAttribute(name, REQUEST_SCOPE); if( session != null ) { + try { removeAttribute(name, SESSION_SCOPE); + } catch (IllegalStateException ex) { + // Session has been invalidated. + // Ignore and fall through to application scope. } - removeAttribute(name, APPLICATION_SCOPE); - } catch (Exception ex) { - // we remove as much as we can, and - // simply ignore possible exceptions } + removeAttribute(name, APPLICATION_SCOPE); } public JspWriter getOut() {</column><column name="report_time">2005-12-16 01:58:15</column><column name="report_timestamp">1134720000</column><column name="status">resolved fixed</column><column name="commit">04cacaf</column><column name="commit_timestamp">1239900000</column><column name="files">java/org/apache/jasper/runtime/PageContextImpl.java</column><column name="result">1:java/org/apache/jasper/runtime/PageContextImpl.java</column></table><table name="tomcat"><column name="id">842</column><column name="bug_id">47013</column><column name="summary">JSP not compiled at startup when used as a servlet</column><column name="description">I created a servlet with a jsp and the following web.xml entry: 	&lt;servlet&gt; 		&lt;servlet-name&gt;Repository&lt;/servlet-name&gt; 		&lt;jsp-file&gt;/Repository.jsp&lt;/jsp-file&gt; 		&lt;load-on-startup&gt;1&lt;/load-on-startup&gt; 	&lt;/servlet&gt; 	&lt;servlet-mapping&gt; 		&lt;servlet-name&gt;Repository&lt;/servlet-name&gt; 		&lt;url-pattern&gt;/Repository&lt;/url-pattern&gt; 	&lt;/servlet-mapping&gt; I altered the JSP and started Tomcat. The initial startup invokes the JSP with the following call stack: 	org.apache.jsp.Repository_jsp.jspInit(Repository_jsp.java:42) 	org.apache.jasper.runtime.HttpJspBase.init(HttpJspBase.java:51) 	org.apache.jasper.servlet.JspServletWrapper.getServlet(JspServletWrapper.java:159) 	org.apache.jasper.servlet.JspServletWrapper.service(JspServletWrapper.java:329) 	org.apache.jasper.servlet.JspServlet.serviceJspFile(JspServlet.java:342) 	org.apache.jasper.servlet.JspServlet.service(JspServlet.java:267) 	javax.servlet.http.HttpServlet.service(HttpServlet.java:717) 	org.apache.catalina.core.StandardWrapper.loadServlet(StandardWrapper.java:1191) 	org.apache.catalina.core.StandardWrapper.load(StandardWrapper.java:992) 	org.apache.catalina.core.StandardContext.loadOnStartup(StandardContext.java:4058) 	org.apache.catalina.core.StandardContext.start(StandardContext.java:4371) 	org.apache.catalina.core.ContainerBase.start(ContainerBase.java:1045) 	org.apache.catalina.core.StandardHost.start(StandardHost.java:719) 	org.apache.catalina.core.ContainerBase.start(ContainerBase.java:1045) 	org.apache.catalina.core.StandardEngine.start(StandardEngine.java:443) 	org.apache.catalina.core.StandardService.start(StandardService.java:516) 	org.apache.catalina.core.StandardServer.start(StandardServer.java:710) 	org.apache.catalina.startup.Catalina.start(Catalina.java:578) 	sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) 	sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) 	sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25) 	java.lang.reflect.Method.invoke(Method.java:597) 	org.apache.catalina.startup.Bootstrap.start(Bootstrap.java:288) 	org.apache.catalina.startup.Bootstrap.main(Bootstrap.java:413) Then I hit the servlet with a normal request with http://localhost:8080/context/Repository which yields this call stack: 	org.apache.jsp.Repository_jsp.jspInit(Repository_jsp.java:42) 	org.apache.jasper.runtime.HttpJspBase.init(HttpJspBase.java:51) 	org.apache.jasper.servlet.JspServletWrapper.getServlet(JspServletWrapper.java:159) 	org.apache.jasper.servlet.JspServletWrapper.getDependants(JspServletWrapper.java:263) 	org.apache.jasper.compiler.Compiler.isOutDated(Compiler.java:430) 	org.apache.jasper.compiler.Compiler.isOutDated(Compiler.java:351) 	org.apache.jasper.JspCompilationContext.compile(JspCompilationContext.java:582) 	org.apache.jasper.servlet.JspServletWrapper.service(JspServletWrapper.java:317) 	org.apache.jasper.servlet.JspServlet.serviceJspFile(JspServlet.java:342) 	org.apache.jasper.servlet.JspServlet.service(JspServlet.java:267) 	javax.servlet.http.HttpServlet.service(HttpServlet.java:717) 	org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:290) 	org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:206) 	org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:233) 	org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:191) 	org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:128) 	org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:102) 	org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:109) 	org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:286) 	org.apache.coyote.http11.Http11Processor.process(Http11Processor.java:845) 	org.apache.coyote.http11.Http11Protocol$Http11ConnectionHandler.process(Http11Protocol.java:583) 	org.apache.tomcat.util.net.JIoEndpoint$Worker.run(JIoEndpoint.java:447) 	java.lang.Thread.run(Thread.java:619) The JSP gets compiled on the request, but not at startup. I backtracked a little and found StandardWrapper is doing: 	req.setQueryString("jsp_precompile=true"); which is unsafe b/c the precompile param can be specified as system property org.apache.jasper.Constants.PRECOMPILE. Instead it should be: 	req.setQueryString(Constants.PRECOMPILE + "=true"); Anyway, I wasn't overriding it so that didn't help.</column><column name="report_time">2009-04-10 09:26:22</column><column name="report_timestamp">1239370000</column><column name="status">resolved fixed</column><column name="commit">c8cbc28</column><column name="commit_timestamp">1239750000</column><column name="files">java/org/apache/catalina/core/Constants.java
java/org/apache/catalina/core/StandardWrapper.java</column><column name="result">13:java/org/apache/catalina/core/StandardWrapper.java
57:java/org/apache/catalina/core/Constants.java</column></table><table name="tomcat"><column name="id">843</column><column name="bug_id">42579</column><column name="summary">[Patch] JNDIRealm fails to parse absolute names</column><column name="description">Active Directory can respond to a query with SearchResult's that are not relative. We discovered this happening with a directory hosted across many servers when the userBase was not sufficient to identify a single server. In getUserBySearch, JNDIRealm assumes that the SearchResult is relative and goes about creating a DN for the user by appending together the various bits of names it gets back. This is definitely wrong for absolute names which are URL's of the form: ldap://server/encoded_user_dn I discovered this issue in Tomcat 5.5 and a cursory look at the SVN repo for Tomcat 6.0 reveals that this bug is also present there. I have a patch for this issue which I will attach.</column><column name="report_time">2007-06-04 14:13:14</column><column name="report_timestamp">1180980000</column><column name="status">resolved fixed</column><column name="commit">90e8d0d</column><column name="commit_timestamp">1239290000</column><column name="files">java/org/apache/catalina/realm/JNDIRealm.java</column><column name="result">1:java/org/apache/catalina/realm/JNDIRealm.java</column></table><table name="tomcat"><column name="id">844</column><column name="bug_id">46354</column><column name="summary">LIMIT_BUFFER setting causes arraycopy errors</column><column name="description">Per the advice in this issue: http://issues.apache.org/bugzilla/show_bug.cgi?id=37793 We just tried to apply the following setting to our Tomcat instances -Dorg.apache.jasper.runtime.BodyContentImpl.LIMIT_BUFFER=true A short time after applying this setting, we would start seeing the following stack traces on various random requests. SEVERE: Servlet.service() for servlet jsp threw exception java.lang.ArrayIndexOutOfBoundsException at java.lang.System.arraycopy(System.java) at java.lang.String.getChars(String.java:855) at org.apache.jasper.runtime.BodyContentImpl.write(BodyContentImpl.java:146) at org.apache.jasper.runtime.BodyContentImpl.write(BodyContentImpl.java:159) at org.apache.jsp.tag.web.arch.patterns.DetailInspector.list_tag._jspx_meth_c_005fif_005f3(list_tag.java:683) at org.apache.jsp.tag.web.arch.patterns.DetailInspector.list_tag._jspx_meth_c_005fforEach_005f0(list_tag.java:630) at org.apache.jsp.tag.web.arch.patterns.DetailInspector.list_tag.doTag(list_tag.java:302) at org.apache.jsp.WEB_002dINF.pages.registrar.academic.Student.inspect.pgmstudy_002dtab_jsp._jspx_meth_detail_005flist_005f0(pgmstudy_002dtab_jsp.java:224) at org.apache.jsp.WEB_002dINF.pages.registrar.academic.Student.inspect.pgmstudy_002dtab_jsp.access$0(pgmstudy_002dtab_jsp.java:214) at org.apache.jsp.WEB_002dINF.pages.registrar.academic.Student.inspect.pgmstudy_002dtab_jsp$pgmstudy_002dtab_jspHelper.invoke0(pgmstudy_002dtab_jsp.java:492) at org.apache.jsp.WEB_002dINF.pages.registrar.academic.Student.inspect.pgmstudy_002dtab_jsp$pgmstudy_002dtab_jspHelper.invoke(pgmstudy_002dtab_jsp.java:571) at org.apache.jsp.tag.web.arch.patterns.DetailInspector.inspector_tag.doTag(inspector_tag.java:163) at org.apache.jsp.WEB_002dINF.pages.registrar.academic.Student.inspect.pgmstudy_002dtab_jsp._jspService(pgmstudy_002dtab_jsp.java:151) at org.apache.jasper.runtime.HttpJspBase.service(HttpJspBase.java:98) at javax.servlet.http.HttpServlet.service(HttpServlet.java:803) at org.apache.jasper.servlet.JspServletWrapper.service(JspServletWrapper.java:328) at org.apache.jasper.servlet.JspServlet.serviceJspFile(JspServlet.java:315) at org.apache.jasper.servlet.JspServlet.service(JspServlet.java:265) at javax.servlet.http.HttpServlet.service(HttpServlet.java:803) ... If we remove the setting, then things behave normally (albeit with the memory issues discussed in the linked issue). We are running on top of java version 1.6.0.</column><column name="report_time">2008-12-05 09:01:51</column><column name="report_timestamp">1228490000</column><column name="status">resolved fixed</column><column name="commit">78a994a</column><column name="commit_timestamp">1239290000</column><column name="files">java/org/apache/jasper/runtime/BodyContentImpl.java</column><column name="result">54:java/org/apache/jasper/runtime/BodyContentImpl.java</column></table><table name="tomcat"><column name="id">845</column><column name="bug_id">46984</column><column name="summary">Server incorrectly reports a 501 error on bad method name.  Should report 400 error.</column><column name="description">I managed to send a corrupt data stream to Tomcat. The result was that the method name turned out to be '0\n\n0\n\n0\n\nPOST'. This was actually the method name that was returned to the servlet's .service(request, response) method by Tomcat. The error message returned back to the client was: java.io.IOException: Server returned HTTP response code: 501 for URL: http://localhost/method-bug/bug 	at sun.net.www.protocol.http.HttpURLConnection.getInputStream(HttpURLConnection.java:1305) 	at sun.net.www.protocol.http.HttpURLConnection.getHeaderFields(HttpURLConnection.java:2187) The 501 error indicates that the method is not implemented or not supported. While this is somewhat true, there is a more applicable error message. The 501 error is confusing, in that it indicates a valid method name was received. In this case, the method name was formed with invalid characters (numbers and carriage returns). The correct behavior is that Tomcat should detect the bad/invalid/malformed method name and throw a 400 error, bad request. The offending code is in org.apache.coyote.http11.InternalInputBuffer. The parseRequestLine code is naive. It starts by skipping blank lines, then puts EVERYTHING up until the next 'space' character into the method name, including carriage returns, special characters, numbers, etc. Correct behavior is that it should detect an invalid method name (according to the spec) at this point, and throw error 400 (I think 400 is correct). public void parseRequestLine() throws IOException { int start = 0; // // Skipping blank lines // byte chr = 0; do { // Read new bytes if needed if (pos &gt;= lastValid) { if (!fill()) throw new EOFException(sm.getString("iib.eof.error")); } chr = buf[pos++]; } while ((chr == Constants.CR) || (chr == Constants.LF)); pos--; // Mark the current buffer position start = pos; // // Reading the method name // Method name is always US-ASCII // boolean space = false; while (!space) { // Read new bytes if needed if (pos &gt;= lastValid) { if (!fill()) throw new EOFException(sm.getString("iib.eof.error")); } ascbuf[pos] = (char) buf[pos]; // Spec says single SP but it also says be tolerant of HT if (buf[pos] == Constants.SP || buf[pos] == Constants.HT) { space = true; request.method().setChars(ascbuf, start, pos - start); } pos++; }</column><column name="report_time">2009-04-07 07:44:46</column><column name="report_timestamp">1239100000</column><column name="status">resolved fixed</column><column name="commit">42a093b</column><column name="commit_timestamp">1239290000</column><column name="files">java/org/apache/coyote/http11/Http11AprProcessor.java
java/org/apache/coyote/http11/Http11NioProcessor.java
java/org/apache/coyote/http11/Http11Processor.java
java/org/apache/coyote/http11/InternalAprInputBuffer.java
java/org/apache/coyote/http11/InternalInputBuffer.java
java/org/apache/coyote/http11/InternalNioInputBuffer.java</column><column name="result">30:java/org/apache/coyote/http11/Http11AprProcessor.java
31:java/org/apache/coyote/http11/Http11NioProcessor.java
47:java/org/apache/coyote/http11/Http11Processor.java
307:java/org/apache/coyote/http11/InternalNioInputBuffer.java
434:java/org/apache/coyote/http11/InternalInputBuffer.java
441:java/org/apache/coyote/http11/InternalAprInputBuffer.java</column></table><table name="tomcat"><column name="id">846</column><column name="bug_id">46961</column><column name="summary">org.apache.catalina.loader.WebappClassLoader throws exception related to Java 6 Bug 6434149</column><column name="description">Our application uses JSF. Upon defining navigation with NavigationRuleRule, we get the exception WARN NavigationRuleRule - [NavigationRuleRule]{faces-config/navigation-rule} Me rge(*) java.lang.ClassNotFoundException: [Ljava.lang.String; at org.apache.catalina.loader.WebappClassLoader.loadClass(WebappClassLoa der.java:1352) at org.apache.catalina.loader.WebappClassLoader.loadClass(WebappClassLoa der.java:1198) at com.sun.faces.config.ConfigureListener.configure(ConfigureListener.ja va:615) at com.sun.faces.config.ConfigureListener.configure(ConfigureListener.ja va:402) at com.sun.faces.config.ConfigureListener.contextInitialized(ConfigureLi stener.java:328) at org.apache.catalina.core.StandardContext.listenerStart(StandardContex t.java:3729) at org.apache.catalina.core.StandardContext.start(StandardContext.java:4 187) at org.apache.catalina.core.ContainerBase.start(ContainerBase.java:1013) at org.apache.catalina.core.StandardHost.start(StandardHost.java:718) at org.apache.catalina.core.ContainerBase.start(ContainerBase.java:1013) at org.apache.catalina.core.StandardEngine.start(StandardEngine.java:442 ) at org.apache.catalina.startup.Embedded.start(Embedded.java:821) This is due to Java 6 Bug 6434149 (http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6434149) This link recommends the following actions to solve this bug: 1) Add -Dsun.lang.ClassLoader.allowArraySyntax=true if you want to use a library for which you don't have the source with JDK6 2) Change loader.loadClass( name ) to Class.forName( name, false, loader ) if you own the code. class org.apache.catalina.loader.WebAppClassLoader uses this code to load classes: clazz = loader.loadClass(name); Can you please change the sections of code where this line is used (1352 and others) to clazz = Class.forName( name, false, loader); so this problem is solved? Thanks</column><column name="report_time">2009-04-03 07:15:39</column><column name="report_timestamp">1238760000</column><column name="status">resolved fixed</column><column name="commit">f109fb9</column><column name="commit_timestamp">1239280000</column><column name="files">java/org/apache/catalina/loader/WebappClassLoader.java</column><column name="result">1:java/org/apache/catalina/loader/WebappClassLoader.java</column></table><table name="tomcat"><column name="id">847</column><column name="bug_id">46909</column><column name="summary">&lt;jsp:plugin&gt; error</column><column name="description">&lt;jsp:plugin type="applet"&gt; generates type="application/x-java-applet;" instead of type = "application/x-java-applet". Firefox with Java-plugin cannot display Java applets because ";" is added.</column><column name="report_time">2009-03-25 03:07:44</column><column name="report_timestamp">1237960000</column><column name="status">resolved fixed</column><column name="commit">80b90ee</column><column name="commit_timestamp">1239280000</column><column name="files">java/org/apache/jasper/compiler/Generator.java</column><column name="result">9:java/org/apache/jasper/compiler/Generator.java</column></table><table name="tomcat"><column name="id">848</column><column name="bug_id">46562</column><column name="summary">Reader not closed</column><column name="description">SHTML files are locked when using windows. Closing the reader solves the problem.</column><column name="report_time">2009-01-19 08:17:14</column><column name="report_timestamp">1232370000</column><column name="status">resolved fixed</column><column name="commit">6ecc35d</column><column name="commit_timestamp">1239280000</column><column name="files">java/org/apache/catalina/ssi/SSIServlet.java</column><column name="result">60:java/org/apache/catalina/ssi/SSIServlet.java</column></table><table name="tomcat"><column name="id">849</column><column name="bug_id">46998</column><column name="summary">small fix to TaskThreadFactory</column><column name="description">Created attachment 23466 change scope change scope</column><column name="report_time">2009-04-08 11:35:20</column><column name="report_timestamp">1239200000</column><column name="status">resolved fixed</column><column name="commit">0c48c98</column><column name="commit_timestamp">1239270000</column><column name="files">java/org/apache/tomcat/util/threads/TaskThreadFactory.java</column><column name="result">1:java/org/apache/tomcat/util/threads/TaskThreadFactory.java</column></table><table name="tomcat"><column name="id">850</column><column name="bug_id">46997</column><column name="summary">small fix to TaskQueue</column><column name="description">Created attachment 23465 small fixes the offer method should do the same just with less checks</column><column name="report_time">2009-04-08 11:30:59</column><column name="report_timestamp">1239200000</column><column name="status">resolved fixed</column><column name="commit">4e1c4b2</column><column name="commit_timestamp">1239270000</column><column name="files">java/org/apache/tomcat/util/threads/TaskQueue.java</column><column name="result">1:java/org/apache/tomcat/util/threads/TaskQueue.java</column></table><table name="tomcat"><column name="id">851</column><column name="bug_id">46991</column><column name="summary">"Bytes received "  problem</column><column name="description">use jk module submit some data with post method ,but "Bytes received" always show zero see source file ,JkCoyoteHandler.java ,in "inovke" method public int invoke( Msg msg, MsgContext ep ) throws IOException { if( ep.isLogTimeEnabled() ) ep.setLong( MsgContext.TIMER_PRE_REQUEST, System.currentTimeMillis()); Request req=ep.getRequest(); Response res=req.getResponse(); if( log.isDebugEnabled() ) log.debug( "Invoke " + req + " " + res + " " + req.requestURI().toString()); res.setNote( epNote, ep ); ep.setStatus( MsgContext.JK_STATUS_HEAD ); RequestInfo rp = req.getRequestProcessor(); rp.setStage(Constants.STAGE_SERVICE); try { adapter.service( req, res ); } catch( Exception ex ) { log.info("Error servicing request " + req,ex); } if(ep.getStatus() != MsgContext.JK_STATUS_CLOSED) { res.finish(); } req.recycle(); req.updateCounters(); //see this line res.recycle(); ep.recycle(); if( ep.getStatus() == MsgContext.JK_STATUS_ERROR ) { return ERROR; } ep.setStatus( MsgContext.JK_STATUS_NEW ); rp.setStage(Constants.STAGE_KEEPALIVE); return OK; } the request object recycled,the "byteRead" property must be set to zero ,but at the next line ,begin to "updateCounters",this may be a bug</column><column name="report_time">2009-04-08 01:37:54</column><column name="report_timestamp">1239170000</column><column name="status">resolved fixed</column><column name="commit">a228c06</column><column name="commit_timestamp">1239210000</column><column name="files">java/org/apache/jk/server/JkCoyoteHandler.java</column><column name="result">1:java/org/apache/jk/server/JkCoyoteHandler.java</column></table><table name="tomcat"><column name="id">852</column><column name="bug_id">46990</column><column name="summary">Synchronize target can be changed midway</column><column name="description">Created attachment 23455 Fix broken synchronization Various classes synchronize on a variable which is then changed. This will not have the desired effect, as all accesses must use the same lock in order for the synchronisation to work correctly. The patch adds new final lock objects (which cannot be changed midway). It also adds some additional synchronization to various get() methods to ensure that reader threads get the correct updates.</column><column name="report_time">2009-04-07 18:52:10</column><column name="report_timestamp">1239140000</column><column name="status">resolved fixed</column><column name="commit">f1fd999</column><column name="commit_timestamp">1239210000</column><column name="files">java/org/apache/catalina/core/StandardContext.java
java/org/apache/catalina/core/StandardHost.java
java/org/apache/catalina/tribes/membership/Membership.java
java/org/apache/catalina/util/InstanceSupport.java
java/org/apache/catalina/util/LifecycleSupport.java</column><column name="result">14:java/org/apache/catalina/core/StandardContext.java
69:java/org/apache/catalina/util/LifecycleSupport.java
114:java/org/apache/catalina/tribes/membership/Membership.java
119:java/org/apache/catalina/util/InstanceSupport.java
177:java/org/apache/catalina/core/StandardHost.java</column></table><table name="tomcat"><column name="id">853</column><column name="bug_id">46988</column><column name="summary">JMXAccessorTask String constants should be final</column><column name="description">Created attachment 23452 Patch to make fields final JMXAccessorTask String constants should be final</column><column name="report_time">2009-04-07 17:18:48</column><column name="report_timestamp">1239140000</column><column name="status">resolved fixed</column><column name="commit">81ebe8f</column><column name="commit_timestamp">1239200000</column><column name="files">java/org/apache/catalina/ant/jmx/JMXAccessorTask.java</column><column name="result">1:java/org/apache/catalina/ant/jmx/JMXAccessorTask.java</column></table><table name="tomcat"><column name="id">854</column><column name="bug_id">46986</column><column name="summary">org.apache.jasper.Constants public arrays are mutable</column><column name="description">There are various public String arrays in org.apache.jasper.Constants. Although the array variables are final, any code can change any of the array constants.</column><column name="report_time">2009-04-07 17:14:51</column><column name="report_timestamp">1239140000</column><column name="status">resolved fixed</column><column name="commit">f497f12</column><column name="commit_timestamp">1239200000</column><column name="files">java/org/apache/jasper/Constants.java
java/org/apache/jasper/compiler/PageInfo.java
java/org/apache/jasper/xmlparser/ParserUtils.java</column><column name="result">30:java/org/apache/jasper/xmlparser/ParserUtils.java
31:java/org/apache/jasper/compiler/PageInfo.java
127:java/org/apache/jasper/Constants.java</column></table><table name="tomcat"><column name="id">855</column><column name="bug_id">46967</column><column name="summary">ManagerBase.setRandomFile error handling fix</column><column name="description">On some platforms (z/OS for sure), the device file /dev/urandom can pass the "f.exists()" test, but throws an IOException of some kind when trying to open it. The current code in ManagerBase.setRandomFile() doesn't handle this, which results in EVERY call to getRandom() to try again and log the error "Failed to close randomIS". The following changes to the method will add proper error handling to correct this (my changes marked "// kjw") public void setRandomFile( String s ) { // as a hack, you can use a static file - and genarate the same // session ids ( good for strange debugging ) if (Globals.IS_SECURITY_ENABLED){ randomIS = (DataInputStream)AccessController.doPrivileged(new PrivilegedSetRandomFile()); } else { try{ devRandomSource=s; File f=new File( devRandomSource ); if( ! f.exists() ) return; randomIS= new DataInputStream( new FileInputStream(f)); randomIS.readLong(); if( log.isDebugEnabled() ) log.debug( "Opening " + devRandomSource ); } catch( IOException ex ) { 	log.debug("Error reading " + devRandomSource, ex); //kjw 	if (randomIS != null) { // kjw: if opened 	 try { 	 randomIS.close(); 	 } catch (Exception e) { 	 log.warn("Failed to close randomIS."); 	 } 	} // kjw 	devRandomSource = null; // kjw: don't try again automatically randomIS=null; } } }</column><column name="report_time">2009-04-03 18:57:28</column><column name="report_timestamp">1238800000</column><column name="status">resolved fixed</column><column name="commit">243aa86</column><column name="commit_timestamp">1239200000</column><column name="files">java/org/apache/catalina/session/ManagerBase.java</column><column name="result">1:java/org/apache/catalina/session/ManagerBase.java</column></table><table name="tomcat"><column name="id">856</column><column name="bug_id">46958</column><column name="summary">manager XML interface hard-coded path in XSL transformation</column><column name="description">The manager XML-interface cannot be used if it's installed under any other path than /manager, failing to find the xform.xsl file needed for XSL transformation. Fails: http://example.com/mymanager/status?XML=true Works: http://example.com/manager/status?XML=true Reason for error, in Tomcat sources org.apache.catalina.manager.Constants XML_STYLE returns the constant value "&lt;?xml-stylesheet type=\"text/xsl\" href=\"/manager/xform.xsl\" ?&gt;"; The /manager part needs to be modified to match webapp path. Caller: org.apache.catalina.util.RequestUtil.StatusTransformer public static void writeHeader(PrintWriter writer, final String contextPath, int mode) { //... // TODO needs current virtual webapp path as parameter writer.write(Constants.XML_STYLE); } On a sidenote, in org.apache.catalina.manager.host.Constants there is a similar hard-coded value, which might cause similar problems in the future. It seems to be unreferenced in the current sources right now (unused value).</column><column name="report_time">2009-04-02 16:55:36</column><column name="report_timestamp">1238710000</column><column name="status">resolved fixed</column><column name="commit">a9a58fb</column><column name="commit_timestamp">1239190000</column><column name="files">java/org/apache/catalina/manager/Constants.java</column><column name="result">58:java/org/apache/catalina/manager/Constants.java</column></table><table name="tomcat"><column name="id">857</column><column name="bug_id">46933</column><column name="summary">Using Java 1.5 in StringManager</column><column name="description">Created attachment 23424 update method to java 1.5 Using Java 1.5 in StringManager</column><column name="report_time">2009-03-27 15:34:14</column><column name="report_timestamp">1238180000</column><column name="status">resolved fixed</column><column name="commit">23c47da</column><column name="commit_timestamp">1239190000</column><column name="files">java/org/apache/tomcat/util/res/StringManager.java
test/org/apache/tomcat/util/res/TestStringManager.java</column><column name="result">1:java/org/apache/tomcat/util/res/StringManager.java</column></table><table name="tomcat"><column name="id">858</column><column name="bug_id">46982</column><column name="summary">AccessLogValve reports correct time but incorrect offset following Spring DST transition.</column><column name="description">This is a problem with AccessLogValve for tc5.5 as well as tc6.0 on all platforms. With the system clock on my linux machine (Ubuntu in my case) to just before the US time change on March 8, I started Tomcat 5.5 and see the following messages in my Tomcat access log after accessing Tomcat JSP example pages at the time of DST transition: -: - [08/Mar/2009:01:56:20 -0700] GET /jsp-examples/jsp2/simpletag/book.jsp HTTP/1.1 200 1738 1 - {http-8080-Processor24} -: - [08/Mar/2009:03:01:22 -0700] GET /jsp-examples/jsp2/tagfiles/hello.jsp HTTP/1.1 200 2213 68 - {http-8080-Processor25} Note the offset of "-0700" both before and after DST transition. Following a Tomcat restart the offset is correct: -: - [08/Mar/2009:03:19:42 -0600] GET /jsp-examples/jsp2/jspx/basic.jspx HTTP/1.1 200 1919 780 - {http-8080-Processor25} -: - [08/Mar/2009:03:19:59 -0600] GET /jsp-examples/jsp2/jspx/svgexample.html HTTP/1.1 200 2239 4 - {http-8080-Processor25} -: - [08/Mar/2009:03:19:59 -0600] GET /jsp-examples/jsp2/jspx/textRotate.jpg HTTP/1.1 200 26729 3 - {http-8080-Processor25} BTW, I ran the tzupdater before my tests: linwin01-512&gt; java -jar tzupdater.jar -V tzupdater version 1.3.12-b01 JRE time zone data version: tzdata2009a Embedded time zone data version: tzdata2009a The problem is in the org.apache.catalina.valves.AccessLogValve which contains the following in its start method: // Initialize the timeZone, Date formatters, and currentDate timezone = TimeZone.getDefault(); timeZoneNoDST = calculateTimeZoneOffset(timezone.getRawOffset()); Calendar calendar = Calendar.getInstance(timezone); int offset = calendar.get(Calendar.DST_OFFSET); timeZoneDST = calculateTimeZoneOffset(timezone.getRawOffset()+offset); Based on what Ive seen, int offset = calendar.get(Calendar.DST_OFFSET); returns 0 when the current time is not in Daylight savings time and (for my timezone) 3600000 (60 * 60 * 1000) when the current time is in Daylight Savings. It looks like the code assumes this is always the offset for Daylight Savings for the current timezone. I have no idea if there are some locations/timezones where Daylight Savings Time does not have a 1 hour offset. Because of this, if in a non-DST time period, timeZoneDST and timeZoneNoDST are set to the same value. If in a DST time period, I believe they are set correctly so that the transition in Autumn works correctly. I think the only problem is when moving ahead in Springtime (unless the software has been running for 6 months or so which caused the offset to be set correctly).</column><column name="report_time">2009-04-07 07:32:55</column><column name="report_timestamp">1239100000</column><column name="status">resolved fixed</column><column name="commit">360f8eb</column><column name="commit_timestamp">1239190000</column><column name="files">java/org/apache/catalina/valves/AccessLogValve.java</column><column name="result">1:java/org/apache/catalina/valves/AccessLogValve.java</column></table><table name="tomcat"><column name="id">859</column><column name="bug_id">41606</column><column name="summary">The jspInit method is called twice.</column><column name="description">The problem is: The jspInit method is called twice. The definition is: -The JSP background compilations are enable. (In default web.xml, define checkInterval and define development false.) -Define the JSP with &lt;servlet&gt; and &lt;load-on-startup&gt; tag in web.xml. The proposing: org/apache/jasper/compiler/Compiler.java ---- public void compile(boolean compileClass, boolean jspcMode) throws FileNotFoundException, JasperException, Exception { .... if( compileClass ) { File targetFile = new File(ctxt.getClassFileName()); if (targetFile.exists()) { long targetLastModified = targetFile.lastModified(); if (jsw != null) { jsw.setServletClassLastModifiedTime(targetLastModified); } } } }// last of the method. ---- Regards, Yuichiro</column><column name="report_time">2007-02-13 20:46:54</column><column name="report_timestamp">1171420000</column><column name="status">resolved fixed</column><column name="commit">f36a2c4</column><column name="commit_timestamp">1238150000</column><column name="files">java/org/apache/jasper/compiler/Compiler.java</column><column name="result">1:java/org/apache/jasper/compiler/Compiler.java</column></table><table name="tomcat"><column name="id">860</column><column name="bug_id">46822</column><column name="summary">Avoid redundant instantiations in StandardContext</column><column name="description">Created attachment 23358 Patch file to replace new Booleans with primitive version While reviewing the source code, I noticed that java\org\apache\catalina\core\StandardContext.java code is creating Boolean objects unnecessarily. For example: support.firePropertyChange("antiJARLocking", new Boolean(oldAntiJARLocking), new Boolean(this.antiJARLocking)); is instantiating Boolean objects when there is already a version of firePropertyChange that accepts boolean primitives. So, the above can be rewritten to avoid instantiating new objects like: support.firePropertyChange("antiJARLocking", oldAntiJARLocking, this.antiJARLocking); This pattern was repeated for numerous properties. I took the liberty of creating a patch.</column><column name="report_time">2009-03-08 22:56:01</column><column name="report_timestamp">1236570000</column><column name="status">resolved fixed</column><column name="commit">b10d9da</column><column name="commit_timestamp">1238070000</column><column name="files">java/org/apache/catalina/core/StandardContext.java</column><column name="result">1:java/org/apache/catalina/core/StandardContext.java</column></table><table name="tomcat"><column name="id">861</column><column name="bug_id">46866</column><column name="summary">Seed from current time is useless</column><column name="description">fgrep -r 'new Random(System.currentTimeMillis())' . Gives 7 places where Random initialized with seed = currentTimeMillis. This is unnecessary, because better seed initialization happens in the default Random constructor.</column><column name="report_time">2009-03-16 21:34:33</column><column name="report_timestamp">1237250000</column><column name="status">resolved fixed</column><column name="commit">fae26ce</column><column name="commit_timestamp">1238070000</column><column name="files">java/org/apache/catalina/core/StandardServer.java
java/org/apache/catalina/tribes/util/UUIDGenerator.java
test/org/apache/catalina/tribes/demos/LoadTest.java
test/org/apache/catalina/tribes/demos/MapDemo.java
test/org/apache/catalina/tribes/test/channel/TestDataIntegrity.java
test/org/apache/catalina/tribes/test/channel/TestMulticastPackages.java
test/org/apache/catalina/tribes/test/channel/TestRemoteProcessException.java
test/org/apache/catalina/tribes/test/channel/TestUdpPackages.java
test/org/apache/catalina/tribes/test/io/TestSenderConnections.java</column><column name="result">6:java/org/apache/catalina/tribes/util/UUIDGenerator.java
16:test/org/apache/catalina/tribes/test/channel/TestDataIntegrity.java
17:test/org/apache/catalina/tribes/test/channel/TestUdpPackages.java
18:test/org/apache/catalina/tribes/test/channel/TestMulticastPackages.java
30:java/org/apache/catalina/core/StandardServer.java
47:test/org/apache/catalina/tribes/demos/LoadTest.java
61:test/org/apache/catalina/tribes/test/channel/TestRemoteProcessException.java
63:test/org/apache/catalina/tribes/test/io/TestSenderConnections.java
92:test/org/apache/catalina/tribes/demos/MapDemo.java</column></table><table name="tomcat"><column name="id">862</column><column name="bug_id">46875</column><column name="summary">CometConnectionManagerValve: concurrent access on session object when calling HttpSession.invalidate()</column><column name="description">When calling invalidate() on an valid HttpSession object CometConnectionManagerValve methods sessionDestroy(HttpSessionEvent se) and event(Request request, Response response, CometEvent event) are called concurrently. So either a CometEvent with EventType.END and EventSubType.SESSION_END is never signaled via sessionDestroyed(...) or the HttpSession object has become invalid and the attribute holding comet requests can not be set or removed via event(...). I have configured CometConnectionManagerValve as a Valve element in context.xml and also as a Listener element in my applications web.xml. see this stacktrace 'sessionDestroy() was a bit faster': An exception or error occurred in the container during the request processing java.lang.IllegalStateException: removeAttribute: Session already invalidated 	at org.apache.catalina.session.StandardSession.removeAttribute(StandardSession.java:1206) 	at org.apache.catalina.session.StandardSession.removeAttribute(StandardSession.java:1181) 	at org.apache.catalina.session.StandardSessionFacade.removeAttribute(StandardSessionFacade.java:140) 	at org.apache.catalina.valves.CometConnectionManagerValve.event(CometConnectionManagerValve.java:335) 	at org.apache.catalina.core.StandardHostValve.event(StandardHostValve.java:179) 	at org.apache.catalina.valves.ValveBase.event(ValveBase.java:200) 	at org.apache.catalina.core.StandardEngineValve.event(StandardEngineValve.java:128) 	at org.apache.catalina.connector.CoyoteAdapter.event(CoyoteAdapter.java:198) 	at org.apache.coyote.http11.Http11NioProcessor.event(Http11NioProcessor.java:750) 	at org.apache.coyote.http11.Http11NioProtocol$Http11ConnectionHandler.event(Http11NioProtocol.java:653) 	at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.run(NioEndpoint.java:2081) 	at java.util.concurrent.ThreadPoolExecutor$Worker.runTask(ThreadPoolExecutor.java:885) 	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:907) 	at java.lang.Thread.run(Thread.java:637)</column><column name="report_time">2009-03-19 02:15:04</column><column name="report_timestamp">1237440000</column><column name="status">resolved wontfix</column><column name="commit">08f7a5f</column><column name="commit_timestamp">1238010000</column><column name="files">java/org/apache/catalina/valves/CometConnectionManagerValve.java</column><column name="result">1:java/org/apache/catalina/valves/CometConnectionManagerValve.java</column></table><table name="tomcat"><column name="id">863</column><column name="bug_id">46666</column><column name="summary">Why is disableUploadTimeout and KeepAliveTimeout correlated in Http11 Connector?</column><column name="description">In Http11Processor.java while (started &amp;&amp; !error &amp;&amp; keepAlive) { // Parsing the request header try { if (!disableUploadTimeout &amp;&amp; keptAlive) { if (keepAliveTimeout &gt; 0) { socket.setSoTimeout(keepAliveTimeout); } else if (soTimeout &gt; 0) { socket.setSoTimeout(soTimeout); } } inputBuffer.parseRequestLine(); request.setStartTime(System.currentTimeMillis()); keptAlive = true; if (!disableUploadTimeout) { socket.setSoTimeout(timeout); } disableUploadTimeout - This flag allows the servlet container to use a different, longer connection timeout while a servlet is being executed, which in the end allows either the servlet a longer amount of time to complete its execution, or a longer timeout during data upload. If not specified, this attribute is set to "true". The code above is waiting on a new Http Request and precedes the servlet processing logic. It seems odd to me that I must set disableTimeout to false to get my keepAliveTimeout set. To set keepalivetimout, I must implicitely enable upload timeout whether I need it or not. It seems to me that the disableTimeout is unneccessary in the following line if (!disableUploadTimeout &amp;&amp; keptAlive) { Do you agree with this? Thanks for the insight</column><column name="report_time">2009-02-04 08:28:34</column><column name="report_timestamp">1233750000</column><column name="status">resolved fixed</column><column name="commit">ac6369a</column><column name="commit_timestamp">1234540000</column><column name="files">java/org/apache/coyote/http11/Http11Processor.java</column><column name="result">1:java/org/apache/coyote/http11/Http11Processor.java</column></table><table name="tomcat"><column name="id">864</column><column name="bug_id">46696</column><column name="summary">Missing AL headers</column><column name="description">The following files in tomcat-trunk don't have AL headers; as far as I can tell, they should: modules/jdbc-pool/sign.sh modules/jdbc-pool/test/org/apache/tomcat/jdbc/test/StarvationTest.java</column><column name="report_time">2009-02-11 09:41:23</column><column name="report_timestamp">1234360000</column><column name="status">resolved fixed</column><column name="commit">3b1b7b3</column><column name="commit_timestamp">1234450000</column><column name="files">modules/jdbc-pool/test/org/apache/tomcat/jdbc/test/StarvationTest.java</column><column name="result">1:modules/jdbc-pool/test/org/apache/tomcat/jdbc/test/StarvationTest.java</column></table><table name="tomcat"><column name="id">865</column><column name="bug_id">39396</column><column name="summary">OPTIONS request on directory with no default file reports an incorrect list of allowed HTTP verbs</column><column name="description">When an "options" http request is made to Tomcat to a directory that has no default file (like index.jsp) in it, Tomcat reports a full list of allowed verbs, when in fact, most of them are NOT allowed. For example, a request to a generic img directory: OPTIONS /img/ HTTP/1.0 	Cookie: JSESSIONID=C46C2E18BE95AD91828C9370CBDF0AF2 	Content-Length: 0 	Accept: */* 	Accept-Language: en-us 	Connection: Keep-Alive 	User-Agent: Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; .NET CLR 1.1 	4322; InfoPath.1) Returns: HTTP/1.1 200 OK Server: Apache-Coyote/1.1 Allow: GET, HEAD, POST, PUT, DELETE, TRACE, OPTIONS Content-Length: 0 Date: Mon, 24 Apr 2006 15:11:16 GMT Connection: close Which shows several destructive options available (PUT, DELETE). But a request to DELETE or PUT (correctly) returns a 403 FORBIDDEN result: DELETE /img/ HTTP/1.0 	Cookie: JSESSIONID=C46C2E18BE95AD91828C9370CBDF0AF2 	Content-Length: 0 	Accept: */* 	Accept-Language: en-us 	Connection: Keep-Alive 	User-Agent: Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; .NET CLR 1.1 	4322; InfoPath.1) Returns: HTTP/1.1 403 Forbidden Server: Apache-Coyote/1.1 Content-Type: text/html;charset=utf-8 Content-Length: 964 Date: Mon, 24 Apr 2006 15:12:31 GMT Connection: close Because the initial OPTIONS request returns a list containing dangerous verbs, the directory will be flagged as a serious security vulnerability by most scanners (a false positive). The issue DOES NOT occur when the directory HAS a default file in it: OPTIONS /user_management/ HTTP/1.0 	Cookie: JSESSIONID=C46C2E18BE95AD91828C9370CBDF0AF2 	Content-Length: 0 	Accept: */* 	Accept-Language: en-us 	Connection: Keep-Alive 	User-Agent: Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; .NET CLR 1.1 	4322; InfoPath.1) Returns: HTTP/1.1 200 OK Server: Apache-Coyote/1.1 Set-Cookie: JSESSIONID=BC992F0C86E2BCBD0A2E5F1B3A12C50C; Path=/ Content-Type: text/html;charset=ISO-8859-1 Date: Mon, 24 Apr 2006 15:14:27 GMT Connection: close</column><column name="report_time">2006-04-24 15:15:57</column><column name="report_timestamp">1145910000</column><column name="status">resolved fixed</column><column name="commit">9752018</column><column name="commit_timestamp">1234210000</column><column name="files">java/org/apache/catalina/connector/RequestFacade.java
java/org/apache/catalina/servlets/DefaultServlet.java</column><column name="result">2:java/org/apache/catalina/servlets/DefaultServlet.java
194:java/org/apache/catalina/connector/RequestFacade.java</column></table><table name="tomcat"><column name="id">866</column><column name="bug_id">38570</column><column name="summary">if docBase path contains "webapps", a backslash is inserted</column><column name="description">There seem to be a problem when interpreting docBase in context definitions, if it contains the string "webapps". For testing, I moved tomcat-docs to a separate directory outside of webapps, then defined a file tomcat-docs.xml in CATALINA_HOME/conf/Catalina/localhost : &lt;Context docBase="${catalina.home}/../something/tomcat-docs"&gt; &lt;/Context&gt; When I name that directory "something" as above, everything works ok, http://localhost:12345/tomcat-docs displays the documentation (my tomcat runs on port 12345). When I name that directory "webappsSomething", it is interpreted as "webapps/Something" and loading the application (tomcat docu) fails on start of Tomcat: &lt;Context docBase="${catalina.home}/../webappsSomething/tomcat-docs"&gt; &lt;/Context&gt; 08.02.2006 15:25:30 org.apache.catalina.core.StandardContext resourcesStart SCHWERWIEGEND: Error starting static Resources java.lang.IllegalArgumentException: Document base D:\be\JAVA_IDE\jakarta-tomcat-5.5.9\..\webapps\Something\tomcat-docs does not exist or is not a readable directory 	at org.apache.naming.resources.FileDirContext.setDocBase(FileDirContext.java:140) 	at org.apache.catalina.core.StandardContext.resourcesStart(StandardContext.java:3754) 	at org.apache.catalina.core.StandardContext.start(StandardContext.java:3925) Apparently Tomcat is fiddling around with the docBase path as soon as it contains the string webapps - why?</column><column name="report_time">2006-02-08 15:46:45</column><column name="report_timestamp">1139430000</column><column name="status">resolved fixed</column><column name="commit">8d2b8ff</column><column name="commit_timestamp">1234210000</column><column name="files">java/org/apache/catalina/startup/ContextConfig.java</column><column name="result">9:java/org/apache/catalina/startup/ContextConfig.java</column></table><table name="tomcat"><column name="id">867</column><column name="bug_id">38553</column><column name="summary">Wrong HTTP code for failed CLIENT-CERT authentication</column><column name="description">server.xml: =========== I set clientAuth to "want" tomcat-user.xml: ================ I create a role and an user with the ssl certificate metadata web.xml: ======== For a private URL on my webseite, I create a security constraint like this one: &lt;security-constraint&gt; 	&lt;web-resource-collection&gt; 	&lt;web-resource-name&gt;App&lt;/web-resource-name&gt; 	 &lt;url-pattern&gt;/protected.jsp&lt;/url-pattern&gt; 	&lt;/web-resource-collection&gt; 	&lt;auth-constraint&gt; 	 &lt;role-name&gt;tomcat&lt;/role-name&gt; 	&lt;/auth-constraint&gt; 	&lt;user-data-constraint&gt; 	 &lt;transport-guarantee&gt;CONFIDENTIAL&lt;/transport-guarantee&gt; 	&lt;/user-data-constraint&gt; &lt;/security-constraint&gt; &lt;login-config&gt; &lt;auth-method&gt;CLIENT-CERT&lt;/auth-method&gt; &lt;/login-config&gt; &lt;security-role&gt; &lt;role-name&gt;tomcat&lt;/role-name&gt; &lt;/security-role&gt; My results: (I try to access the restricted JSP-Page) =========== 1) When there is the RIGHT client certificate in the browser keystore: it works :-) 2) When there is the WRONG client certificate I get: HTTP Status 401 - Cannot authenticate with the provided credentials (this is ok, too) 3) When there is NO client certificate I get: HTTP Status 400 - No client certificate chain in this request 400 usually stands for a bad request or bad syntax. The Bug: ======== In case 3 I expect to get HTTP Status 401.</column><column name="report_time">2006-02-07 16:54:17</column><column name="report_timestamp">1139350000</column><column name="status">resolved fixed</column><column name="commit">156f1ca</column><column name="commit_timestamp">1233740000</column><column name="files">java/org/apache/catalina/authenticator/SSLAuthenticator.java</column><column name="result">12:java/org/apache/catalina/authenticator/SSLAuthenticator.java</column></table><table name="tomcat"><column name="id">868</column><column name="bug_id">38197</column><column name="summary">taglib pool bug when tag is used with jsp:attribute</column><column name="description">When i use a taglib twice in the same page and the two instances of these tags share the same atrributes in the declaration but one of them have and attribute set using jsp:attribute, the value of this attribute is used in the other one too. Example &lt;%@ taglib prefix="c" uri="http://java.sun.com/jstl/core" %&gt; &lt;html&gt; &lt;body&gt; &lt;h4&gt;1 to 10 step 2&lt;/h4&gt; &lt;c:forEach var="i" begin="1" end="10"&gt; &lt;jsp:attribute name="step"&gt;2&lt;/jsp:attribute&gt; &lt;jsp:body&gt; &lt;c:out value="${i}"/&gt; &lt;/jsp:body&gt; &lt;/c:forEach&gt; &lt;br&gt; &lt;h4&gt;1 to 10 no step&lt;/h4&gt; &lt;c:forEach var="i" begin="1" end="10" &gt; &lt;c:out value="${i}"/&gt; &lt;/c:forEach&gt; &lt;/body&gt; &lt;/html&gt; The output is Simple Range Iteration 1 to 10 step 2 1 3 5 7 9 1 to 10 no step 1 3 5 7 9 Expected Simple Range Iteration 1 to 10 step 2 1 3 5 7 9 1 to 10 no step 1 2 3 4 5 5 7 8 9 Thanks</column><column name="report_time">2006-01-09 15:53:09</column><column name="report_timestamp">1136840000</column><column name="status">resolved fixed</column><column name="commit">2824a70</column><column name="commit_timestamp">1233740000</column><column name="files">java/org/apache/jasper/compiler/Generator.java</column><column name="result">10:java/org/apache/jasper/compiler/Generator.java</column></table><table name="tomcat"><column name="id">869</column><column name="bug_id">46606</column><column name="summary">WebdavServlet</column><column name="description">In the Webdav standard, there is a header option named "depth". This header must be given when running a propfind webdav request. The value may be greater 0 or the constant "infinity", i.e. the whole file tree is requested. In the WebdavServlet, INFINITY is set to 3, which unfortunately does not correspond to the standard. &gt;&gt;&gt; CODE &gt;&gt;&gt; /** * Default depth is infite. */ private static final int INFINITY = 3; // To limit tree browsing a bit &lt;&lt;&lt; END OF CODE &lt;&lt;&lt; Perhaps this could be changed to a much higher value (e.g. maxint). Below, there is a method named propfind, where the following code can be found: &gt;&gt;&gt; CODE &gt;&gt;&gt; String depthStr = req.getHeader("Depth"); if (depthStr == null) { depth = INFINITY; } else { if (depthStr.equals("0")) { depth = 0; } else if (depthStr.equals("1")) { depth = 1; } else if (depthStr.equals("infinity")) { depth = INFINITY; } } &lt;&lt;&lt; END OF CODE &lt;&lt;&lt; Perhaps one should use an integer conversion function and in case of an exception one could use infinity. Hope this describes the problem good enough. The same problem occurs in Tomcat 5.x, as well.</column><column name="report_time">2009-01-26 07:18:21</column><column name="report_timestamp">1232970000</column><column name="status">resolved fixed</column><column name="commit">f0bd732</column><column name="commit_timestamp">1233730000</column><column name="files">java/org/apache/catalina/servlets/WebdavServlet.java</column><column name="result">1:java/org/apache/catalina/servlets/WebdavServlet.java</column></table><table name="tomcat"><column name="id">870</column><column name="bug_id">46564</column><column name="summary">.tagx files don't compile if the document and page encoding casing differs</column><column name="description">Jasper will raise an error like /WEB-INF/tags/sampletaglib/sampletag.tagx(3,99) Page-encoding specified in XML prolog (iso-8859-1) is different from that specified in page directive (ISO-8859-1) if the encoding specified within the XML prolog and the page directive use different casing: &lt;?xml version="1.0" encoding="iso-8859-1"?&gt; &lt;jsp:root xmlns:jsp="http://java.sun.com/JSP/Page" version="2.0"&gt; &lt;jsp:directive.tag display-name="sampletag" pageEncoding="ISO-8859-1" /&gt; This is a sample tag! &lt;/jsp:root&gt; Proposed solution: Compare the encodings case-insensitive. For example: iso-8859-1 and ISO-8859-1 are both valid identifiers for the same encoding.</column><column name="report_time">2009-01-20 00:34:11</column><column name="report_timestamp">1232430000</column><column name="status">resolved fixed</column><column name="commit">7d7f757</column><column name="commit_timestamp">1233290000</column><column name="files">java/org/apache/jasper/compiler/Validator.java</column><column name="result">2:java/org/apache/jasper/compiler/Validator.java</column></table><table name="tomcat"><column name="id">871</column><column name="bug_id">46471</column><column name="summary">Compiled tag files from different tag libraries share the same package</column><column name="description">When in web application there are several tag libraries packed in jar files that have tag files in them, when those files are compiled they share the same package: org.apache.jsp.tag.meta As a result, if there are tags with the same name in different libraries, only one of them survives. I encountered it while investigating bug #37084. See comment #13 there.</column><column name="report_time">2009-01-04 16:12:40</column><column name="report_timestamp">1231100000</column><column name="status">resolved fixed</column><column name="commit">3aaac85</column><column name="commit_timestamp">1231180000</column><column name="files">java/org/apache/jasper/compiler/ImplicitTagLibraryInfo.java
java/org/apache/jasper/compiler/JspUtil.java
java/org/apache/jasper/compiler/ParserController.java
java/org/apache/jasper/compiler/TagFileProcessor.java
java/org/apache/jasper/compiler/TagLibraryInfoImpl.java</column><column name="result">4:java/org/apache/jasper/compiler/TagLibraryInfoImpl.java
8:java/org/apache/jasper/compiler/ParserController.java
13:java/org/apache/jasper/compiler/ImplicitTagLibraryInfo.java
18:java/org/apache/jasper/compiler/TagFileProcessor.java
64:java/org/apache/jasper/compiler/JspUtil.java</column></table><table name="tomcat"><column name="id">872</column><column name="bug_id">46462</column><column name="summary">JSPWiki JSP compilation prevented by org.apache.jasper.Constants.JSP_PACKAGE_NAME</column><column name="description">Hi, JSPWiki is currently an Incubator project at Apache. We intend to use the package name org.apache.jspwiki. However, any classes in this package tree fail to load when imported into a JSP page, specifically during Jasper's attempt to compile it. For example, &lt;%@ page import="org.apache.jspwiki.WikiPage" %&gt; does not compile. My colleague Harry Metske traced the cause to this line in org.apache.jasper.servlet.JasperLoader: if( !name.startsWith(Constants.JSP_PACKAGE_NAME) ) { // Class is not in org.apache.jsp, therefore, have our // parent load it clazz = parent.loadClass(name); if( resolve ) resolveClass(clazz); return clazz; } The recommended bug fix would be to append a period (".") to the expression passed into name.startsWith(), which in this case would then evaluate to "org.apache.jsp.", and allow JSPWiki classes to load and compile. This issue is important for us as we emerge from incubation. Lack of a fix means that JSPWiki cannot release under the desired package name "org.apache.jspwiki." See additional commentary in the Apache JIRA database here: https://issues.apache.org/jira/browse/JSPWIKI-464</column><column name="report_time">2009-01-01 20:29:15</column><column name="report_timestamp">1230860000</column><column name="status">resolved fixed</column><column name="commit">1ca03ff</column><column name="commit_timestamp">1230890000</column><column name="files">java/org/apache/jasper/servlet/JasperLoader.java</column><column name="result">72:java/org/apache/jasper/servlet/JasperLoader.java</column></table><table name="tomcat"><column name="id">873</column><column name="bug_id">46298</column><column name="summary">JDBCRealm.open() throws NullPointerException if the specified driver doesn't handle the specified JDBC URL</column><column name="description">Created attachment 22949 Check returned connection for null in JDBCRealm.open() Per the Driver.connect(String, Properties) docs: &gt; The driver should return "null" if it realizes it is the wrong kind of driver to connect to the given URL. I ran into this when I fat-fingered the JDBC URL's prefix (jdbc:msql: instead of jdbc:mysql: with the MySQL driver). The offending code calls Driver.connect and immediately calls setAutoCommit(false) on the resulting driver without checking that the connect returned a connection. I've attached a patch based from TOMCAT_6_0_18 that addresses the issue.</column><column name="report_time">2008-11-25 23:25:56</column><column name="report_timestamp">1227670000</column><column name="status">resolved fixed</column><column name="commit">e31998a</column><column name="commit_timestamp">1230510000</column><column name="files">java/org/apache/catalina/realm/JDBCRealm.java</column><column name="result">1:java/org/apache/catalina/realm/JDBCRealm.java</column></table><table name="tomcat"><column name="id">874</column><column name="bug_id">46261</column><column name="summary">Context with %2F in name causes tomcat crash on shutdown</column><column name="description">Context with %2F in name causes tomcat crash on shutdown Several years ago I worked on integrating tomcat 5.5 into our web application management infrastructure. During the process I fixed several tomcat 5.5 bugs, but apparently never sent the fixes upstream. Oops. Our application needs to be deployed to create a URL that looks like this: /product/customername/servlet I worked with several people on IRC to get tomcat5.5 to do this. We had previously been using the path= parameter in the context xml file element with tomcat 4.1. Unfortunately, it appears this feature was removed from tomcat5.5, and tomcat5.5 does not recurse into subdirectories when reading .xml context files. The recommendation on IRC (after several suggestions which would not work for our environment) was to put %2F in the context xml file's name. Such as this product%2Fcustomername.xml This does work, however when you try to shutdown tomcat 6.0.18, you will get this crash: Nov 9, 2008 10:56:17 PM org.apache.coyote.http11.Http11Protocol pause INFO: Pausing Coyote HTTP/1.1 on http-8180 Nov 9, 2008 10:56:18 PM org.apache.catalina.core.StandardService stop INFO: Stopping service Catalina Nov 9, 2008 10:56:18 PM org.apache.catalina.startup.HostConfig undeployApps WARNING: Error while removing context [/product%2Fcustomername] java.lang.NullPointerException at org.apache.catalina.core.ContainerBase.removeChild(ContainerBase.java:915) at org.apache.catalina.startup.HostConfig.undeployApps(HostConfig.java:1191) at org.apache.catalina.startup.HostConfig.stop(HostConfig.java:1162) at org.apache.catalina.startup.HostConfig.lifecycleEvent(HostConfig.java:313) at org.apache.catalina.util.LifecycleSupport.fireLifecycleEvent(LifecycleSupport.java:117) at org.apache.catalina.core.ContainerBase.stop(ContainerBase.java:1086) at org.apache.catalina.core.ContainerBase.stop(ContainerBase.java:1098) at org.apache.catalina.core.StandardEngine.stop(StandardEngine.java:448) at org.apache.catalina.core.StandardService.stop(StandardService.java:584) at org.apache.catalina.core.StandardServer.stop(StandardServer.java:744) at org.apache.catalina.startup.Catalina.stop(Catalina.java:628) at org.apache.catalina.startup.Catalina$CatalinaShutdownHook.run(Catalina.java:671) Nov 9, 2008 10:56:18 PM org.apache.coyote.http11.Http11Protocol destroy INFO: Stopping Coyote HTTP/1.1 on http-8180</column><column name="report_time">2008-11-21 08:34:21</column><column name="report_timestamp">1227270000</column><column name="status">resolved fixed</column><column name="commit">85fc30c</column><column name="commit_timestamp">1230340000</column><column name="files">java/org/apache/catalina/core/StandardContext.java
java/org/apache/catalina/manager/HTMLManagerServlet.java</column><column name="result">2:java/org/apache/catalina/core/StandardContext.java
8:java/org/apache/catalina/manager/HTMLManagerServlet.java</column></table><table name="tomcat"><column name="id">875</column><column name="bug_id">46381</column><column name="summary">Coerce EL expression to java.lang.Object breaks expression concatenation</column><column name="description">Created attachment 23009 Source file I have a simple &lt;c:set&gt; tag with expression concatenation. This tag breaks with this stack trace: org.apache.jasper.JasperException: Unable to compile class for JSP: An error occurred at line: 22 in the jsp file: /templates/paragraphs/notizia.jsp The operator + is undefined for the argument type(s) java.lang.Object, java.lang.Object 19: &lt;c:when test="${!empty(node.link)}"&gt; 20: &lt;c:set value="${node.link}" var="url" /&gt; 21: &lt;c:if test="${!(fn:startsWith(url,'http'))}"&gt; 22: &lt;c:set value="${pageContext.request.contextPath}${url}" var="url" /&gt; 23: &lt;c:set value=" " var="target" /&gt; 24: &lt;/c:if&gt; 25: &lt;a href="${url}" class="${target}"&gt;${node.testo}&lt;/a&gt; Stacktrace: 	at org.apache.jasper.compiler.DefaultErrorHandler.javacError(DefaultErrorHandler.java:92) 	at org.apache.jasper.compiler.ErrorDispatcher.javacError(ErrorDispatcher.java:330) 	at org.apache.jasper.compiler.JDTCompiler.generateClass(JDTCompiler.java:423) 	at org.apache.jasper.compiler.Compiler.compile(Compiler.java:334) 	at org.apache.jasper.compiler.Compiler.compile(Compiler.java:312) 	at org.apache.jasper.compiler.Compiler.compile(Compiler.java:299) 	at org.apache.jasper.JspCompilationContext.compile(JspCompilationContext.java:586) 	at org.apache.jasper.servlet.JspServletWrapper.service(JspServletWrapper.java:317) 	at org.apache.jasper.servlet.JspServlet.serviceJspFile(JspServlet.java:342) 	at org.apache.jasper.servlet.JspServlet.service(JspServlet.java:267) 	at javax.servlet.http.HttpServlet.service(HttpServlet.java:717) 	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:290) 	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:206) 	at org.apache.catalina.core.ApplicationDispatcher.invoke(ApplicationDispatcher.java:646) 	at org.apache.catalina.core.ApplicationDispatcher.doInclude(ApplicationDispatcher.java:551) 	at org.apache.catalina.core.ApplicationDispatcher.include(ApplicationDispatcher.java:488) 	at info.magnolia.context.WebContextImpl.include(WebContextImpl.java:191) 	at info.magnolia.module.templating.paragraphs.JspParagraphRenderer.render(JspParagraphRenderer.java:73) 	at info.magnolia.cms.beans.config.ParagraphRenderingFacade.render(ParagraphRenderingFacade.java:112) 	at info.magnolia.cms.beans.config.ParagraphRenderingFacade.render(ParagraphRenderingFacade.java:91) 	at info.magnolia.cms.taglibs.Include.doEndTag(Include.java:192) 	at org.apache.jsp.templates.paragraphs.bloccoInfo_jsp._jspx_meth_cms_005fincludeTemplate_005f0(bloccoInfo_jsp.java:332) 	at org.apache.jsp.templates.paragraphs.bloccoInfo_jsp._jspx_meth_cms_005fcontentNodeIterator_005f0(bloccoInfo_jsp.java:289) 	at org.apache.jsp.templates.paragraphs.bloccoInfo_jsp._jspService(bloccoInfo_jsp.java:98) 	at org.apache.jasper.runtime.HttpJspBase.service(HttpJspBase.java:70) 	at javax.servlet.http.HttpServlet.service(HttpServlet.java:717) 	at org.apache.jasper.servlet.JspServletWrapper.service(JspServletWrapper.java:374) 	at org.apache.jasper.servlet.JspServlet.serviceJspFile(JspServlet.java:342) 	at org.apache.jasper.servlet.JspServlet.service(JspServlet.java:267) 	at javax.servlet.http.HttpServlet.service(HttpServlet.java:717) 	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:290) 	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:206) 	at org.apache.catalina.core.ApplicationDispatcher.invoke(ApplicationDispatcher.java:646) 	at org.apache.catalina.core.ApplicationDispatcher.doInclude(ApplicationDispatcher.java:551) 	at org.apache.catalina.core.ApplicationDispatcher.include(ApplicationDispatcher.java:488) 	at info.magnolia.context.WebContextImpl.include(WebContextImpl.java:191) 	at info.magnolia.module.templating.paragraphs.JspParagraphRenderer.render(JspParagraphRenderer.java:73) 	at info.magnolia.cms.beans.config.ParagraphRenderingFacade.render(ParagraphRenderingFacade.java:112) 	at info.magnolia.cms.beans.config.ParagraphRenderingFacade.render(ParagraphRenderingFacade.java:91) 	at info.magnolia.cms.taglibs.Include.doEndTag(Include.java:192) 	at org.apache.jsp.templates.pages.firstlevelgruppo_jsp._jspx_meth_cms_005fincludeTemplate_005f1(firstlevelgruppo_jsp.java:428) 	at org.apache.jsp.templates.pages.firstlevelgruppo_jsp._jspx_meth_cms_005fcontentNodeIterator_005f1(firstlevelgruppo_jsp.java:385) 	at org.apache.jsp.templates.pages.firstlevelgruppo_jsp._jspService(firstlevelgruppo_jsp.java:115) 	at org.apache.jasper.runtime.HttpJspBase.service(HttpJspBase.java:70) 	at javax.servlet.http.HttpServlet.service(HttpServlet.java:717) 	at org.apache.jasper.servlet.JspServletWrapper.service(JspServletWrapper.java:374) 	at org.apache.jasper.servlet.JspServlet.serviceJspFile(JspServlet.java:342) 	at org.apache.jasper.servlet.JspServlet.service(JspServlet.java:267) 	at javax.servlet.http.HttpServlet.service(HttpServlet.java:717) 	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:290) 	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:206) 	at info.magnolia.cms.filters.MgnlMainFilter.doFilter(MgnlMainFilter.java:100) 	at info.magnolia.cms.filters.MgnlMainFilter.doFilter(MgnlMainFilter.java:200) 	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:235) 	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:206) 	at org.apache.catalina.core.ApplicationDispatcher.invoke(ApplicationDispatcher.java:646) 	at org.apache.catalina.core.ApplicationDispatcher.processRequest(ApplicationDispatcher.java:436) 	at org.apache.catalina.core.ApplicationDispatcher.doForward(ApplicationDispatcher.java:374) 	at org.apache.catalina.core.ApplicationDispatcher.forward(ApplicationDispatcher.java:302) 	at info.magnolia.module.templating.renderers.JspTemplateRenderer.renderTemplate(JspTemplateRenderer.java:78) 	at info.magnolia.cms.filters.RenderingFilter.doFilter(RenderingFilter.java:103) 	at info.magnolia.cms.filters.AbstractMgnlFilter.doFilter(AbstractMgnlFilter.java:71) 	at info.magnolia.cms.filters.MgnlFilterChain.doFilter(MgnlFilterChain.java:71) 	at info.magnolia.cms.filters.BackwardCompatibilityFilter.doFilter(BackwardCompatibilityFilter.java:72) 	at info.magnolia.cms.filters.OncePerRequestAbstractMgnlFilter.doFilter(OncePerRequestAbstractMgnlFilter.java:62) 	at info.magnolia.cms.filters.MgnlFilterChain.doFilter(MgnlFilterChain.java:71) 	at info.magnolia.cms.filters.InterceptFilter.doFilter(InterceptFilter.java:117) 	at info.magnolia.cms.filters.AbstractMgnlFilter.doFilter(AbstractMgnlFilter.java:71) 	at info.magnolia.cms.filters.MgnlFilterChain.doFilter(MgnlFilterChain.java:71) 	at info.magnolia.cms.filters.AggregatorFilter.doFilter(AggregatorFilter.java:111) 	at info.magnolia.cms.filters.AbstractMgnlFilter.doFilter(AbstractMgnlFilter.java:71) 	at info.magnolia.cms.filters.MgnlFilterChain.doFilter(MgnlFilterChain.java:71) 	at info.magnolia.cms.security.BaseSecurityFilter.doFilter(BaseSecurityFilter.java:61) 	at info.magnolia.cms.filters.AbstractMgnlFilter.doFilter(AbstractMgnlFilter.java:71) 	at info.magnolia.cms.filters.MgnlFilterChain.doFilter(MgnlFilterChain.java:71) 	at info.magnolia.cms.filters.RepositoryMappingFilter.doFilter(RepositoryMappingFilter.java:90) 	at info.magnolia.cms.filters.AbstractMgnlFilter.doFilter(AbstractMgnlFilter.java:71) 	at info.magnolia.cms.filters.MgnlFilterChain.doFilter(MgnlFilterChain.java:71) 	at info.magnolia.cms.filters.CompositeFilter.doFilter(CompositeFilter.java:64) 	at info.magnolia.cms.filters.AbstractMgnlFilter.doFilter(AbstractMgnlFilter.java:71) 	at info.magnolia.cms.filters.MgnlFilterChain.doFilter(MgnlFilterChain.java:71) 	at info.magnolia.cms.filters.MgnlFilterChain.doFilter(MgnlFilterChain.java:65) 	at info.magnolia.cms.filters.MgnlFilterChain.doFilter(MgnlFilterChain.java:73) 	at info.magnolia.cms.filters.MgnlFilterChain.doFilter(MgnlFilterChain.java:73) 	at info.magnolia.cms.filters.MgnlFilterChain.doFilter(MgnlFilterChain.java:73) 	at info.magnolia.cms.filters.MgnlFilterChain.doFilter(MgnlFilterChain.java:73) 	at info.magnolia.cms.filters.MgnlFilterChain.doFilter(MgnlFilterChain.java:73) 	at info.magnolia.cms.filters.MgnlFilterChain.doFilter(MgnlFilterChain.java:73) 	at info.magnolia.cms.filters.MgnlFilterChain.doFilter(MgnlFilterChain.java:73) 	at info.magnolia.cms.filters.MgnlFilterChain.doFilter(MgnlFilterChain.java:73) 	at info.magnolia.cms.filters.MgnlFilterChain.doFilter(MgnlFilterChain.java:73) 	at info.magnolia.cms.filters.CompositeFilter.doFilter(CompositeFilter.java:64) 	at info.magnolia.cms.filters.AbstractMgnlFilter.doFilter(AbstractMgnlFilter.java:71) 	at info.magnolia.cms.filters.MgnlFilterChain.doFilter(MgnlFilterChain.java:71) 	at info.magnolia.cms.filters.VirtualUriFilter.doFilter(VirtualUriFilter.java:115) 	at info.magnolia.cms.filters.OncePerRequestAbstractMgnlFilter.doFilter(OncePerRequestAbstractMgnlFilter.java:62) 	at info.magnolia.cms.filters.MgnlFilterChain.doFilter(MgnlFilterChain.java:71) 	at info.magnolia.cms.i18n.I18nContentSupportFilter.doFilter(I18nContentSupportFilter.java:75) 	at info.magnolia.cms.filters.AbstractMgnlFilter.doFilter(AbstractMgnlFilter.java:71) 	at info.magnolia.cms.filters.MgnlFilterChain.doFilter(MgnlFilterChain.java:71) 	at net.sourceforge.stripes.controller.StripesFilter.doFilter(StripesFilter.java:180) 	at info.magnolia.cms.filters.MgnlFilterChain.doFilter(MgnlFilterChain.java:71) 	at info.magnolia.module.cache.executor.Bypass.processCacheRequest(Bypass.java:57) 	at info.magnolia.module.cache.filter.CacheFilter.doFilter(CacheFilter.java:118) 	at info.magnolia.cms.filters.OncePerRequestAbstractMgnlFilter.doFilter(OncePerRequestAbstractMgnlFilter.java:62) 	at info.magnolia.cms.filters.MgnlFilterChain.doFilter(MgnlFilterChain.java:71) 	at info.magnolia.module.cache.filter.GZipFilter.doFilter(GZipFilter.java:84) 	at info.magnolia.cms.filters.OncePerRequestAbstractMgnlFilter.doFilter(OncePerRequestAbstractMgnlFilter.java:62) 	at info.magnolia.cms.filters.MgnlFilterChain.doFilter(MgnlFilterChain.java:71) 	at info.magnolia.cms.filters.MgnlFilterChain.doFilter(MgnlFilterChain.java:73) 	at info.magnolia.cms.filters.CosMultipartRequestFilter.doFilter(CosMultipartRequestFilter.java:84) 	at info.magnolia.cms.filters.AbstractMgnlFilter.doFilter(AbstractMgnlFilter.java:71) 	at info.magnolia.cms.filters.MgnlFilterChain.doFilter(MgnlFilterChain.java:71) 	at info.magnolia.cms.security.BaseSecurityFilter.doFilter(BaseSecurityFilter.java:61) 	at info.magnolia.cms.filters.AbstractMgnlFilter.doFilter(AbstractMgnlFilter.java:71) 	at info.magnolia.cms.filters.MgnlFilterChain.doFilter(MgnlFilterChain.java:71) 	at info.magnolia.cms.security.LogoutFilter.doFilter(LogoutFilter.java:81) 	at info.magnolia.cms.filters.OncePerRequestAbstractMgnlFilter.doFilter(OncePerRequestAbstractMgnlFilter.java:62) 	at info.magnolia.cms.filters.MgnlFilterChain.doFilter(MgnlFilterChain.java:71) 	at info.magnolia.cms.security.auth.login.LoginFilter.doFilter(LoginFilter.java:76) 	at info.magnolia.cms.filters.AbstractMgnlFilter.doFilter(AbstractMgnlFilter.java:71) 	at info.magnolia.cms.filters.MgnlFilterChain.doFilter(MgnlFilterChain.java:71) 	at info.magnolia.cms.filters.ContentTypeFilter.doFilter(ContentTypeFilter.java:80) 	at info.magnolia.cms.filters.AbstractMgnlFilter.doFilter(AbstractMgnlFilter.java:71) 	at info.magnolia.cms.filters.MgnlFilterChain.doFilter(MgnlFilterChain.java:71) 	at info.magnolia.cms.filters.ContextFilter.doFilter(ContextFilter.java:72) 	at info.magnolia.cms.filters.AbstractMgnlFilter.doFilter(AbstractMgnlFilter.java:71) 	at info.magnolia.cms.filters.MgnlFilterChain.doFilter(MgnlFilterChain.java:71) 	at info.magnolia.cms.filters.CompositeFilter.doFilter(CompositeFilter.java:64) 	at info.magnolia.cms.filters.AbstractMgnlFilter.doFilter(AbstractMgnlFilter.java:71) 	at info.magnolia.cms.filters.MgnlMainFilter.doFilter(MgnlMainFilter.java:97) 	at info.magnolia.cms.filters.MgnlMainFilter.doFilter(MgnlMainFilter.java:200) 	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:235) 	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:206) 	at it.ragno.web.filters.LocaleSyncFilter.doFilter(LocaleSyncFilter.java:82) 	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:235) 	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:206) 	at org.springframework.orm.hibernate3.support.OpenSessionInViewFilter.doFilterInternal(OpenSessionInViewFilter.java:198) 	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:76) 	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:235) 	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:206) 	at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:233) 	at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:191) 	at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:128) 	at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:102) 	at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:109) 	at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:293) 	at org.apache.coyote.http11.Http11Processor.process(Http11Processor.java:845) 	at org.apache.coyote.http11.Http11Protocol$Http11ConnectionHandler.process(Http11Protocol.java:583) 	at org.apache.tomcat.util.net.JIoEndpoint$Worker.run(JIoEndpoint.java:447) 	at java.lang.Thread.run(Thread.java:619)</column><column name="report_time">2008-12-11 07:13:00</column><column name="report_timestamp">1229000000</column><column name="status">resolved fixed</column><column name="commit">24bcb47</column><column name="commit_timestamp">1230330000</column><column name="files">java/org/apache/jasper/compiler/Generator.java</column><column name="result">79:java/org/apache/jasper/compiler/Generator.java</column></table><table name="tomcat"><column name="id">876</column><column name="bug_id">46357</column><column name="summary">FarmWarDeployer has nonsense condition</column><column name="description">FarmWarDeployer has the following code at line 152: if(econtainer == null &amp;&amp; econtainer instanceof Engine) { There's clearly something wrong with that condition.</column><column name="report_time">2008-12-06 05:48:33</column><column name="report_timestamp">1228560000</column><column name="status">resolved fixed</column><column name="commit">7e6a2ec</column><column name="commit_timestamp">1230330000</column><column name="files">java/org/apache/catalina/ha/deploy/FarmWarDeployer.java</column><column name="result">1:java/org/apache/catalina/ha/deploy/FarmWarDeployer.java</column></table><table name="tomcat"><column name="id">877</column><column name="bug_id">46397</column><column name="summary">Potential memory leak with TagHandlers and JspIdConsumer</column><column name="description">Created attachment 23022 test case app As a follow up on the thread on the mailing list, here's my summary again: Since the JSP Spec says that TagHandlers implementing JspIdConsumer may not be reused, I was expecting them to be collected after the servlet finishes processing. A few experiments showed that that is not the case. After delving into the details of the servlet code generated for JSP pages I discovered that the methods instantiating TagHandlers also store them in TagHandlerPools using #reuse(). I ran some more experiments to see what happens with these TagHandlers. My setup is Tomcat 6 + MyFaces + JSF CarDemo, and I'm using AspectJ to trace creation and garbage collection of objects implementing JspIdConsumer. My experiments indicate the following: 1. JspIdConsumer instances do NOT get garbage collected after a page has finished processing. 2. JspIdConsumer instances do NOT always get garbage collected after a session times out. 3. SOME JspIdConsumer instances DO get garbage collected when a given JSP-generated page is reloaded or accessed in a different session. To obtain these results I ran Tomcat with very little heap memory (it seems it starts fine with the 64M default), loaded the car demo in several browser sessions and ran through all the other JSP/Servlet examples that come with Tomcat to increase the memory consumption and trigger GC. Unfortunately I don't have the time and tools to do a proper stress test. To provide some sort of simpler test case, I attach a WAR to use, but you still need to put the runtime library of AspectJ (aspectjrt.jar) on the classpath when running Tomcat. The behavior I observe is that whenever I load/reload the page, the JspIdConsumer objects get allocated, and some, but never all of them get GC'd. You should see messages on the console/log like Adding JspIdConsumer:&lt;someClassName&gt;:&lt;itsHashCode&gt;:&lt;theJspId&gt; and Removed &lt;someJspId&gt; You will see three "Adding messages" for every instance created (it's a mess to track this properly), and you should see one "Removed" message for every GC'd instance. When I run grep | wc on the output, the "distance" between the number of created and GC'd object grows over time and reloads of the test page. I had this running for a bit, trying to see if after a session timeout the remaining instances would be GC'd, but they didn't. I don't know what to make of this, but it feels like Tomcat is holding on to some of the instances for too long for no good reason. In any case, considering the specification of JspIdConsumer, which states that instances may never be reused, the caching of these instances as it is done in current JSPs is unnecessary, and since these instances don't seem to be GC'd, this seems to be a memory leak.</column><column name="report_time">2008-12-15 00:43:53</column><column name="report_timestamp">1229320000</column><column name="status">resolved fixed</column><column name="commit">5277185</column><column name="commit_timestamp">1230060000</column><column name="files">java/org/apache/jasper/compiler/Generator.java</column><column name="result">2:java/org/apache/jasper/compiler/Generator.java</column></table><table name="tomcat"><column name="id">878</column><column name="bug_id">46403</column><column name="summary">Persistent cookies written by 6.0.18 do not work in Internet Explorer or Safari</column><column name="description">This blog post shows up in Google when searching for this problem, and is a better explanation that I can give here: http://cephas.net/blog/2008/11/18/tomcat-6018-version-1-cookies-acegi-remember-me-and-ie/ To summarize, in 6.0.18, the way Tomcat writes persistent cookie headers was changed from: Set-Cookie: yankeessuck=YWFyb246MTIyODI0ODEwMjk5NjoyOGM5ODc4YzExOGZiOGZjZTBkZDE0ZTA1ZWRhZTM3Nw==; Expires=Thu, 19-Nov-2009 02:29:29 GMT; to: Set-Cookie: yankeessuck="YWFyb246MTIyODI0ODEwMjk5NjoyOGM5ODc4YzExOGZiOGZjZTBkZDE0ZTA1ZWRhZTM3Nw=="; Version=1; Max-Age=31536000; The value was enclosed in quotes, a "Version=1" parameter was added, and the Expires parameter was replaced with a Max-Age parameter. Though cookies are written correctly to specification, Internet Explorer (6 and 7) and Safari do not support the Max-Age parameter. As a result, an application writing persistent cookies in this version of Tomcat won't work for Internet Explorer or Safari.</column><column name="report_time">2008-12-15 13:46:47</column><column name="report_timestamp">1229370000</column><column name="status">resolved fixed</column><column name="commit">99c5ca6</column><column name="commit_timestamp">1230040000</column><column name="files">java/org/apache/tomcat/util/http/ServerCookie.java</column><column name="result">26:java/org/apache/tomcat/util/http/ServerCookie.java</column></table><table name="tomcat"><column name="id">879</column><column name="bug_id">46408</column><column name="summary">Invalid cast in SecurityUtil</column><column name="description">In case of PrivilegedActionException thrown in: private static void execute(final Method method, final Object targetObject, final Object[] targetArguments, Principal principal) method, there is a false assumption in catch block, that PrivilegedActionException.getException() will return InvocationTargetException. It could be also IllegalAccessException and possibly other types of exceptions as well. Here is the stack trace provoked on catalina shutdown when enabled security manager: java.lang.ClassCastException: java.lang.IllegalAccessException cannot be cast to java.lang.reflect.InvocationTargetException at org.apache.catalina.security.SecurityUtil.execute(SecurityUtil.java:278) at org.apache.catalina.security.SecurityUtil.doAsPrivilege(SecurityUtil.java:218) at org.apache.catalina.security.SecurityUtil.doAsPrivilege(SecurityUtil.java:178) at org.apache.catalina.core.ApplicationFilterConfig.release(ApplicationFilterConfig.java:326) at org.apache.catalina.core.StandardContext.filterStop(StandardContext.java:3744) at org.apache.catalina.core.StandardContext.stop(StandardContext.java:4513) at org.apache.catalina.core.ContainerBase.removeChild(ContainerBase.java:924) at org.apache.catalina.startup.HostConfig.undeployApps(HostConfig.java:1191) at org.apache.catalina.startup.HostConfig.stop(HostConfig.java:1162) at org.apache.catalina.startup.HostConfig.lifecycleEvent(HostConfig.java:313) at org.apache.catalina.util.LifecycleSupport.fireLifecycleEvent(LifecycleSupport.java:117) at org.apache.catalina.core.ContainerBase.stop(ContainerBase.java:1086) at org.apache.catalina.core.ContainerBase.stop(ContainerBase.java:1098) at org.apache.catalina.core.StandardEngine.stop(StandardEngine.java:448) at org.apache.catalina.core.StandardService.stop(StandardService.java:584) at org.apache.catalina.core.StandardServer.stop(StandardServer.java:744) at org.apache.catalina.startup.Catalina.stop(Catalina.java:628) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25) at java.lang.reflect.Method.invoke(Method.java:597) at org.apache.catalina.startup.Bootstrap.stop(Bootstrap.java:300) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25) at java.lang.reflect.Method.invoke(Method.java:597) at org.apache.commons.daemon.support.DaemonLoader.stop(DaemonLoader.java:200)</column><column name="report_time">2008-12-16 15:22:51</column><column name="report_timestamp">1229460000</column><column name="status">resolved fixed</column><column name="commit">a1e4c86</column><column name="commit_timestamp">1229700000</column><column name="files">java/org/apache/catalina/security/SecurityUtil.java</column><column name="result">4:java/org/apache/catalina/security/SecurityUtil.java</column></table><table name="tomcat"><column name="id">880</column><column name="bug_id">46247</column><column name="summary">SVN property patches</column><column name="description">Created attachment 22905 Patch for tomcat trunk to set SVN properties Script file that can be used to set some missing properties on Tomcat trunk. Usable on Unix and Windows; best run from the OS that last updated the file.</column><column name="report_time">2008-11-19 18:16:54</column><column name="report_timestamp">1227140000</column><column name="status">resolved fixed</column><column name="commit">408175f</column><column name="commit_timestamp">1228490000</column><column name="files">modules/bayeux/java/org/apache/cometd/bayeux/Bayeux.java
modules/bayeux/java/org/apache/cometd/bayeux/Channel.java
modules/bayeux/java/org/apache/cometd/bayeux/Client.java
modules/bayeux/java/org/apache/cometd/bayeux/DataFilter.java
modules/bayeux/java/org/apache/cometd/bayeux/Listener.java
modules/bayeux/java/org/apache/cometd/bayeux/Message.java
modules/bayeux/java/org/apache/cometd/bayeux/SecurityPolicy.java
modules/bayeux/java/org/apache/tomcat/bayeux/BayeuxException.java
modules/bayeux/java/org/apache/tomcat/bayeux/BayeuxRequest.java
modules/bayeux/java/org/apache/tomcat/bayeux/BayeuxServlet.java
modules/bayeux/java/org/apache/tomcat/bayeux/ChannelImpl.java
modules/bayeux/java/org/apache/tomcat/bayeux/ClientImpl.java
modules/bayeux/java/org/apache/tomcat/bayeux/HttpError.java
modules/bayeux/java/org/apache/tomcat/bayeux/MessageImpl.java
modules/bayeux/java/org/apache/tomcat/bayeux/RequestBase.java
modules/bayeux/java/org/apache/tomcat/bayeux/RequestFactory.java
modules/bayeux/java/org/apache/tomcat/bayeux/TomcatBayeux.java
modules/bayeux/java/org/apache/tomcat/bayeux/request/MetaConnectRequest.java
modules/bayeux/java/org/apache/tomcat/bayeux/request/MetaDisconnectRequest.java
modules/bayeux/java/org/apache/tomcat/bayeux/request/MetaHandshakeRequest.java
modules/bayeux/java/org/apache/tomcat/bayeux/request/MetaSubscribeRequest.java
modules/bayeux/java/org/apache/tomcat/bayeux/request/MetaUnsubscribeRequest.java
modules/bayeux/java/org/apache/tomcat/bayeux/request/PublishRequest.java
modules/bayeux/test/org/apache/cometd/bayeux/samples/BayeuxStockTicker.java
modules/bayeux/test/org/apache/cometd/bayeux/samples/EchoChatClient.java
modules/jdbc-pool/java/org/apache/tomcat/jdbc/pool/interceptor/ConnectionState.java
modules/jdbc-pool/java/org/apache/tomcat/jdbc/pool/interceptor/SlowQueryReport.java</column><column name="result">83:modules/jdbc-pool/java/org/apache/tomcat/jdbc/pool/interceptor/ConnectionState.java
264:modules/jdbc-pool/java/org/apache/tomcat/jdbc/pool/interceptor/SlowQueryReport.java
524:modules/bayeux/java/org/apache/tomcat/bayeux/RequestBase.java</column></table><table name="tomcat"><column name="id">881</column><column name="bug_id">42077</column><column name="summary">the iterator from javax.el.CompositeELResolver#getFeatureDescriptor() must not return null values</column><column name="description">According to the spec the iterator which is returned by javax.el.CompositeELResolver#getFeatureDescriptor() must skip any null FeatureDescriptor of a containing el resolver. Currently any feature descriptor value is returned whether it is null or not. I have a working testcase (including a fix) in myfaces 1.2 TestCase: http://svn.apache.org/viewvc/myfaces/core/branches/jsf12/impl/src/test/java/org/apache/myfaces/el/CompositeELResolverTest.java?revision=527076&amp;pathrev=527076 Fix: http://svn.apache.org/viewvc/myfaces/core/branches/jsf12/impl/src/main/java/org/apache/myfaces/el/CompositeELResolver.java?revision=527076&amp;pathrev=527076</column><column name="report_time">2007-04-10 03:03:51</column><column name="report_timestamp">1176190000</column><column name="status">resolved fixed</column><column name="commit">8d5db6f</column><column name="commit_timestamp">1227480000</column><column name="files">java/javax/el/CompositeELResolver.java</column><column name="result">1:java/javax/el/CompositeELResolver.java</column></table><table name="tomcat"><column name="id">882</column><column name="bug_id">42693</column><column name="summary">JSP-Generation error with recursive tagfile structure</column><column name="description">addendum: it's Version 6.13 (not available in combobox above) scenario: ========= a menu is decribed by a tree structure; rendering the menu is done by a tagfile 'render_menuitem', which renders the current item either as a leaf item (clicking on it causes an action) or as a node item (clicking on it opens another next-level submenu); rendering the submenu is done by calling the tagfile again from within its body; this worked fine with tomcat 5.0.x and 5.5.x to make it clear see the following pseudo code (the original code is to voluminous): tagfile 'render_menuitem.tagx': &lt;jsp:root ...&gt; &lt;jsp:directive.attribute name="menu_item"/&gt; &lt;c:choose&gt; &lt;c:when test="${menu_item.isNode} &lt;div&gt;node: ${menu_item.label}&lt;/div&gt; &lt;c:forEach var="sub_item" items="menu_item.children"&gt; &lt;!-- THIS IS GOING TO CAUSE THE PROBLEM WITH TOMCAT6: --&gt; &lt;tags:render_menuitem menu_item="${sub_item}"/&gt; &lt;/c:forEach&gt; &lt;c:when&gt; &lt;c:otherwise&gt; &lt;div&gt;leaf: ${menu_item.label}&lt;/div&gt; &lt;/c:otherwise&gt; &lt;/c:choose&gt; &lt;/jsp:root&gt; faulty behaviour: ================ with tomcat 6.0.13, the generated Java-Source for the tagfile reveals, that the body of the doTag() method is empty and therefore emits no html; the compilation itself was silently done, no error or warning was shown in the logfiles.</column><column name="report_time">2007-06-18 10:10:02</column><column name="report_timestamp">1182180000</column><column name="status">resolved fixed</column><column name="commit">b5a5094</column><column name="commit_timestamp">1227480000</column><column name="files">java/org/apache/jasper/compiler/Compiler.java</column><column name="result">19:java/org/apache/jasper/compiler/Compiler.java</column></table><table name="tomcat"><column name="id">883</column><column name="bug_id">42707</column><column name="summary">add host alias using jmx doesn't take affect until restart</column><column name="description">Adding a host alias using jmx doesn't take affect until tomcat is restarted. To test it I started tomcat using -Dcom.sun.management.jmxremote -Dcom.sun.management.jmxremote.port=6702 -Dcom.sun.management.jmxremote.authenticate=false -Dcom.sun.management.jmxremote.ssl=false I created a webapps_test/test/index.html I created a new host &lt;Host appBase="webapps_test" name="test.localdomain"&gt; &lt;/Host&gt; I tested the url http://test.localdomain:8080/test/ and the index page showed up as expected. I used jconsole under Catalina/Host/test.localdomain/Operations/addAlias and added test1.localdomain (I edited my /etc/hosts file to map test.localdomain and test1.localdomain to 127.0.0.1). I went to the url http://test1.localdomain:8080/test/ and instead of the index.html page I received a 404 error. I tried starting and stopping the host from within jmx, it didn't help, I tried Catalina/Server/Operations/storeConfig and starting and stopping the host and that didn't help either. I tested with the following versions for the server jdk 1.6.0_01-b06 tomcat 5.5.20, 6.0.10, 6.0.13 for the client I was using the jdk 1.6.0_01-b06 jconsole, as well as a custom application I had written as well as the the "administration web application 5.5.23" all the combinations above had similar results. I will briefly mention that in tomcat 6.0.10/13 I was unable to save the configuration due to an error : Jun 20, 2007 5:26:11 PM org.apache.catalina.core.StandardServer storeConfig SEVERE: StoreConfig mbean not registeredCatalina:type=StoreConfig I will open a separate bug for that. In tomcat 5 I was able to save the config. If I restart tomcat5 after saving the config (using catalina.sh stop / start) the new alias works properly. Likewise, if I edit the tomcat 6 conf/server.xml and add the alias entry in manually and restart tomcat, the url http://test1.localdomain:8080/test/ works fine. So, the main problem is that adding an alias dynamically doesn't seem to work.</column><column name="report_time">2007-06-20 14:46:49</column><column name="report_timestamp">1182370000</column><column name="status">resolved fixed</column><column name="commit">23a8ba0</column><column name="commit_timestamp">1226200000</column><column name="files">java/org/apache/catalina/connector/MapperListener.java
java/org/apache/tomcat/util/http/mapper/Mapper.java</column><column name="result">15:java/org/apache/catalina/connector/MapperListener.java
17:java/org/apache/tomcat/util/http/mapper/Mapper.java</column></table><table name="tomcat"><column name="id">884</column><column name="bug_id">42673</column><column name="summary">SSI virtual include broken for context path with slashes</column><column name="description">If the context path of an application contains slashes (e.g. "a/b") the method getPathWithoutContext of class org.apache.catalina.ssi.SSIServletExternalResolver simply cuts from the second slash, so for url "/a/b/do?.." it tries to include "b/do?.." instead of "do?..". The patch is to include the context path and strip the path off: Line 419 String noContext = getPathWithoutContext(normContext.getContextPath(), normalized); Line 356ff protected String getPathWithoutContext(final String contextPath, final String servletPath) { if (servletPath.startsWith(contextPath)) { return servletPath.substring(contextPath.length()); } return servletPath; }</column><column name="report_time">2007-06-15 05:08:34</column><column name="report_timestamp">1181900000</column><column name="status">resolved fixed</column><column name="commit">4d5cca1</column><column name="commit_timestamp">1226190000</column><column name="files">java/org/apache/catalina/ssi/SSIServletExternalResolver.java</column><column name="result">1:java/org/apache/catalina/ssi/SSIServletExternalResolver.java</column></table><table name="tomcat"><column name="id">885</column><column name="bug_id">46011</column><column name="summary">Cannot access to Principal via Subject.getSubject(AccessController.getContext())</column><column name="description">Cannot access to Principal via Subject.getSubject(AccessController.getContext()). Problem is that in method internalDoFilter of ApplicationFilterChain in call of filter chain the code determinate the Principal but don't use it: if( Globals.IS_SECURITY_ENABLED ) { final ServletRequest req = request; final ServletResponse res = response; Principal principal = ((HttpServletRequest) req).getUserPrincipal(); Object[] args = new Object[]{req, res, this}; SecurityUtil.doAsPrivilege ("doFilter", filter, classType, args); args = null; } else { In this manner a SecurityUtil.doAsPrivilege will be called with Principal == null and method execute create a Subject with no Principals. Then call a Subject.doAsPrivileged(subject, pea, null); and this do not propagate Principals. I obtain a Subject without Principals calling Subject.getSubject(AccessController.getContext()). In attachment we send our solution</column><column name="report_time">2008-10-15 02:56:56</column><column name="report_timestamp">1224050000</column><column name="status">resolved fixed</column><column name="commit">e148369</column><column name="commit_timestamp">1225900000</column><column name="files">java/org/apache/catalina/core/ApplicationFilterChain.java
java/org/apache/catalina/security/SecurityUtil.java</column><column name="result">1:java/org/apache/catalina/core/ApplicationFilterChain.java
2:java/org/apache/catalina/security/SecurityUtil.java</column></table><table name="tomcat"><column name="id">886</column><column name="bug_id">46047</column><column name="summary">Issue when using include directive inside tag files that are inside jar files</column><column name="description">Created attachment 22760 patch for ParserController class When we use the include directive inside a tag file like : &lt;%@ tag body-content="empty" description="Renders a date control to query the creation date of a content object." %&gt; &lt;%@include file="/META-INF/tags/search/declaration.tagf" %&gt; And that this tag file is inside a jar file, jasper has an issue dealing the dependencies by losing the fact that the included file is inside a jar file. static { _jspx_dependants = new java.util.ArrayList(4); _jspx_dependants.add("/META-INF/tags/search/declaration.tagf"); _jspx_dependants.add("/META-INF/tags/search/date.tagf"); _jspx_dependants.add("jar:file:/home/rincevent/tools/apache-tomcat-6.0.18/webapps/jahia/WEB-INF/lib/jahia-taglib-6.0-SNAPSHOT.jar!/META-INF/search.tld"); _jspx_dependants.add("jar:file:/home/rincevent/tools/apache-tomcat-6.0.18/webapps/jahia/WEB-INF/lib/jahia-taglib-6.0-SNAPSHOT.jar!/META-INF/tags/search/resultsPageUrl.tag"); } The other dependencies are handled correctly thanks to patch https://issues.apache.org/bugzilla/show_bug.cgi?id=43741 . I propose a patch to ParserController so that when we detect that we are inside a jarFile we prepend the jarFileUrl to absFileName. The patch has been made on the trunk source code of tomcat.</column><column name="report_time">2008-10-21 02:20:44</column><column name="report_timestamp">1224570000</column><column name="status">resolved fixed</column><column name="commit">38ef38d</column><column name="commit_timestamp">1225750000</column><column name="files">java/org/apache/jasper/compiler/ParserController.java</column><column name="result">6:java/org/apache/jasper/compiler/ParserController.java</column></table><table name="tomcat"><column name="id">887</column><column name="bug_id">42409</column><column name="summary">Extra response headers not sent when using custom error page</column><column name="description">If I create a servlet that does the following: response.setHeader("X-BUG", "Value"); response.sendError(HttpServletResponse.SC_BAD_REQUEST); If I use the tomcat default error page for 400 responses, the response will contain the header "X-BUG" with value "Value". However, if I create a custom error page, the response headers do NOT contain the "X-BUG" header in the response. Here is my web.xml, for example: &lt;error-page&gt; &lt;error-code&gt;400&lt;/error-code&gt; &lt;location&gt;/400.jsp&lt;/location&gt; &lt;/error-page&gt; 400.jsp contains plain html: &lt;html&gt; &lt;body&gt; &lt;h3&gt;Custom 400 error page&lt;/h3&gt; &lt;/body&gt; &lt;/html&gt;</column><column name="report_time">2007-05-14 09:03:17</column><column name="report_timestamp">1179150000</column><column name="status">resolved fixed</column><column name="commit">e0489c8</column><column name="commit_timestamp">1225720000</column><column name="files">java/org/apache/catalina/core/StandardHostValve.java</column><column name="result">13:java/org/apache/catalina/core/StandardHostValve.java</column></table><table name="tomcat"><column name="id">888</column><column name="bug_id">46051</column><column name="summary">Servlet response writer does not respect line.separator system property</column><column name="description">Created attachment 22763 remove special CoyoteWriter println handling public void doGet(final HttpServletRequest request, final HttpServletResponse response) throws ServletException, IOException { response.setContentType("text/plain"); PrintWriter writer = response.getWriter(); writer.print("hello world"); writer.println(); //FIXME ignores System.getProperty("line.separator") and always outputs \r\n return; } This means that if you use a servlet Writer on a Unix system to output any text based data format which is defined as requiring Unix format line endings ('\n'), that data will be corrupted. This appears to be because org.apache.catalina.connector.CoyoteWriter does: -------- private static final char[] LINE_SEP = { '\r', '\n' }; public void println() { write(LINE_SEP); } -------- This used to work in Tomcat 4. Looking at the old code at http://svn.apache.org/repos/asf/tomcat/archive/tc4.0.x/tags/tc4.0.6/connectors/coyote/src/java/org/apache/coyote/tomcat4/CoyoteWriter.java it appears to defer line endings to the PrintWriter base class which does the right thing. Was this change was made to output HTTP headers properly or something? It specifically seems to override the default behavior to do this. I don't know the code well enough to determine if the attached patch to revert to the default behavior again would break something? Thanks for your consideration.</column><column name="report_time">2008-10-21 10:54:42</column><column name="report_timestamp">1224600000</column><column name="status">resolved fixed</column><column name="commit">f4bef20</column><column name="commit_timestamp">1225590000</column><column name="files">java/org/apache/catalina/connector/CoyoteWriter.java</column><column name="result">18:java/org/apache/catalina/connector/CoyoteWriter.java</column></table><table name="tomcat"><column name="id">889</column><column name="bug_id">46105</column><column name="summary">URIEncoding doesn't affect after form-authentication redirect</column><column name="description">How to reproduce bug. Configure tomcat connector with URIEncoding=UTF-8 attribute. Make a simple page that write out any request parameter. Configure this page as protected with form-based authentication. Try to access page, e.g. /site/page.jsp?q=%xx%yy%zz%tt where q=%xx%yy%zz is value in UTF-8 charset. When page is being accessed for the first time, then after authentication, parameter "q" is incorrectly interpreted (it seems as it was in ISO8859-1 or anything else, but not UTF-8). But subsequent access to the _same_ URI, i.e. /site/page.jsp?q=%xx%yy%zz%tt gives perfect result. I also tried useBobyEncodingForURI=true and request.setCharacterEncoding("UTF-8") - nothing is changed.</column><column name="report_time">2008-10-27 23:37:52</column><column name="report_timestamp">1225170000</column><column name="status">resolved fixed</column><column name="commit">d9def07</column><column name="commit_timestamp">1225410000</column><column name="files">java/org/apache/catalina/authenticator/FormAuthenticator.java</column><column name="result">1:java/org/apache/catalina/authenticator/FormAuthenticator.java</column></table><table name="tomcat"><column name="id">890</column><column name="bug_id">46075</column><column name="summary">FileUpload memory usage</column><column name="description">The DefaultFileItem class in pacakge org.apache.tomcat.util.http.fileupload creates a ByteArrayOutputStream of the full threshold size for every control on the submitted form. I have a form with 63 controls (checkboxes, text boxes and one File input), and I set the threshold to 20 Meg to allow upload of large image files into memory. I get an OutOfMemory exception since it tries to allocate 63 lots of 20M, although only 1 control requires the requested size. I think it would be much more sensible to create the ByteArrayOutputStream with an initial size of only a few kilobytes size it automatically increases its size as data is written to it.</column><column name="report_time">2008-10-23 03:35:53</column><column name="report_timestamp">1224750000</column><column name="status">resolved fixed</column><column name="commit">85e71cf</column><column name="commit_timestamp">1225150000</column><column name="files">java/org/apache/tomcat/util/http/fileupload/DeferredFileOutputStream.java</column><column name="result">10:java/org/apache/tomcat/util/http/fileupload/DeferredFileOutputStream.java</column></table><table name="tomcat"><column name="id">891</column><column name="bug_id">46085</column><column name="summary">Session are incorrectly expired due to thread unsafe code</column><column name="description">We have identified a bug where sessions are expired even though they are still valid. The source of the problem is concurrent threads reading and writing thisAccessTime in "org.apache.catalina.session.StandardSession" in a way that is not thread safe. The good news is that we have a simple solution, for Tomcat 6. The fix is to mark the class level variables - thisAccessedTime and lastAccessedTime - as volatile. Detailed explanation of the bug: We found that StandardSession's isValid() function was making a call to expire() on the following block of code: if (maxInactiveInterval &gt;= 0) { long timeNow = System.currentTimeMillis(); int timeIdle = (int) ((timeNow - thisAccessedTime) / 1000L); if (timeIdle &gt;= maxInactiveInterval) { expire(true); } } Debugging showed that thisAccessedTime was in the past (1983!) and therefore timeIdle is large enough for expiry to happen. In another thread running in parallel, the access() function runs this line of code: this.thisAccessedTime = System.currentTimeMillis(); That single line of code might be atomic, i.e. is composed of multiple instructions, which means it is possible for another thread reading thisAccessedTime to read a value that is effectively corrupt. Marking thisAccessedTime as volatile ensures that writes are completely finished before reading is allowed. Note that the volatile solution only works for Java 1.5 or higher as the meaning of volatile changed then. That means it cannot be used for older Tomcat's if they have a similar problem. Another solution would have been to synchronize reads and writes to that variable. Reproducing the bug: This is quite hard within Tomcat as is very dependant on timings, the JVM's optimisations, and any changes to code may affect optimisations. We are only able to reproduce the bug on multiprocessor systems running an IBM JVM. Specifically, we are running: SLES 10.3 Linux on an Intel platform. Two or more Intel CPU's Tomcat 6.0.18 JVM package: java-1_5_0-ibm-1.5.0_sr8a-1.1 Initially, we thought that System.currentTimeMillis() was returning an incorrect value and created a test program which demo'd the problem to IBM. We were wrong but they did give us the volatile solution. See here: http://www.ibm.com/developerworks/forums/thread.jspa?threadID=230478</column><column name="report_time">2008-10-24 12:53:09</column><column name="report_timestamp">1224870000</column><column name="status">resolved fixed</column><column name="commit">6344b96</column><column name="commit_timestamp">1225130000</column><column name="files">java/org/apache/catalina/session/StandardSession.java</column><column name="result">2:java/org/apache/catalina/session/StandardSession.java</column></table><table name="tomcat"><column name="id">892</column><column name="bug_id">46096</column><column name="summary">DefaultAnnotationProcessor.processAnnotations should use doPrivileged to call getDeclaredFields</column><column name="description">If tomcat is running with a SecurityManager, and a JSP uses PageContext.forward, DefaultAnnotationProcessor code can be called with untristed code on the call stack. The processAnnotations method contains the line: Field[] fields = instance.getClass().getDeclaredFields(); getDeclaredFields() is subject to security checks so this throws a java.security.AccessControlException. DefaultAnnotationProcessor is part of the code in the catlina lib directory, which is granted AllPermissions in the standard policy file. However, because there is untrusted JSP code on the stack, these permissions are not used. The call to getDeclaredFields() should be wrapped in an AccessController.doPrivileged call to avoid the exception.</column><column name="report_time">2008-10-27 05:44:55</column><column name="report_timestamp">1225100000</column><column name="status">resolved fixed</column><column name="commit">428c03b</column><column name="commit_timestamp">1225130000</column><column name="files">java/org/apache/catalina/core/DefaultInstanceManager.java</column><column name="result">1:java/org/apache/catalina/core/DefaultInstanceManager.java</column></table><table name="tomcat"><column name="id">893</column><column name="bug_id">45735</column><column name="summary">Updated ResourceAttributes.getETag</column><column name="description">After looking at a user's list post, I noticed the implementation was not consistent with the other getters (like getName). I propose changing it to: public String getETag(boolean strong) { if (strong) { // The strong ETag must always be calculated by the resources if (strongETag != null) return strongETag; if (attributes != null) { Attribute attribute = attributes.get(ETAG); if (attribute != null) { try { strongETag = attribute.get().toString(); } catch (NamingException e) { ; // No value for the attribute } } } return strongETag; } else { // The weakETag is contentLenght + lastModified if (weakETag == null) { weakETag = "W/\"" + getContentLength() + "-" + getLastModified() + "\""; } return weakETag; } }</column><column name="report_time">2008-09-03 10:48:23</column><column name="report_timestamp">1220450000</column><column name="status">resolved fixed</column><column name="commit">e40c910</column><column name="commit_timestamp">1224880000</column><column name="files">java/org/apache/naming/resources/ResourceAttributes.java</column><column name="result">1:java/org/apache/naming/resources/ResourceAttributes.java</column></table><table name="tomcat"><column name="id">894</column><column name="bug_id">45977</column><column name="summary">Duplicate comment in code - CoyoteAdapter.java</column><column name="description">The XXX comments below seem to say the same thing. Not sure what the XXX represents. /** * Parse additional request parameters. */ protected boolean postParseRequest(org.apache.coyote.Request req, Request request, 		 org.apache.coyote.Response res, Response response) throws Exception { // XXX the processor needs to set a correct scheme and port prior to this point, // in ajp13 protocols dont make sense to get the port from the connector.. // XXX the processor may have set a correct scheme and port prior to this point, // in ajp13 protocols dont make sense to get the port from the connector... // otherwise, use connector configuration if (! req.scheme().isNull()) { // use processor specified scheme to determine secure state request.setSecure(req.scheme().equals("https"));</column><column name="report_time">2008-10-09 08:28:02</column><column name="report_timestamp">1223560000</column><column name="status">resolved fixed</column><column name="commit">e277f6c</column><column name="commit_timestamp">1223590000</column><column name="files">java/org/apache/catalina/connector/CoyoteAdapter.java</column><column name="result">1:java/org/apache/catalina/connector/CoyoteAdapter.java</column></table><table name="tomcat"><column name="id">895</column><column name="bug_id">45951</column><column name="summary">Provide support for renaming  JSESSIONID</column><column name="description">Created attachment 22673 Diff to add support for changing the value of JSESSIONID When Tomcat is used in conjunction with other application servers behind an Apache HTTPD proxy connection, the session cookie JSESSIONID will be over-written be each other. The solution is to allow the JSESSIONID cookie to be renamed to something else. Equivalent support is already provided by JBOSS and Weblogic. The purpose of this ticket is to mirror the bug opened for Tomcat 5. The bug number is bug 42419. I attached a patch to that bug to allow for the requested functionality and have added an equivalent for Tomcat 6 to this ticket.</column><column name="report_time">2008-10-05 15:15:52</column><column name="report_timestamp">1223230000</column><column name="status">resolved fixed</column><column name="commit">e85ed8c</column><column name="commit_timestamp">1223320000</column><column name="files">java/org/apache/catalina/Globals.java
java/org/apache/catalina/authenticator/Constants.java
java/org/apache/jasper/Constants.java</column><column name="result">16:java/org/apache/catalina/Globals.java
17:java/org/apache/jasper/Constants.java
480:java/org/apache/catalina/authenticator/Constants.java</column></table><table name="tomcat"><column name="id">896</column><column name="bug_id">45933</column><column name="summary">Error processing TLD file in webapp with XML parser</column><column name="description">Along the same lines with CR 29936, com.apache.catalina.startup.TldConfig.tldDigester has an issue with initialization. Basically, the TldConfig's parser can be initialized with the webapp's XML parser, which causes a security problem, since it has permission issues with reading files. This is caused by a similar scenario to CR 29936: 1) Remove all stock webapps that come with the standard installation. This includes the ones in server/webapps. Remember to remove the configurations in conf/Catalina. 2) Add a webapp that has a XML parser located in WEB-INF/lib. For instance, one from sourceforge or Apache Xerces. 3) Add a library containing a .tld file in META-INF like Spring. 4) In order to actually have a log containing the error, you need to enable logging. For example, by following the instructions laid out in http://tomcat.apache.org/tomcat-5.5-doc/logging.html. I used log4j. 5) Start the appserver in secure mode. You should see an error in the log similar to the following: ERROR main org.apache.catalina.startup.TldConfig - Exception processing TLD META-INF/spring-form.tld in JAR at resource path TOMCAT_PATH/webapps/MY_WAR/WEB-INF/lib/spring.jar in context /MY_WAR java.security.AccessControlException: access denied (java.io.FilePermission TOMCAT_PATH/common/lib/jsp-api.jar read) at java.security.AccessControlContext.checkPermission(AccessControlContext.java:323) at java.security.AccessController.checkPermission(AccessController.java:546) at java.lang.SecurityManager.checkPermission(SecurityManager.java:532) at java.lang.SecurityManager.checkRead(SecurityManager.java:871) at java.util.zip.ZipFile.&lt;init&gt;(ZipFile.java:109) at java.util.jar.JarFile.&lt;init&gt;(JarFile.java:133) at java.util.jar.JarFile.&lt;init&gt;(JarFile.java:70) at sun.net.www.protocol.jar.URLJarFile.&lt;init&gt;(URLJarFile.java:72) at sun.net.www.protocol.jar.URLJarFile.getJarFile(URLJarFile.java:48) at sun.net.www.protocol.jar.JarFileFactory.get(JarFileFactory.java:53) at sun.net.www.protocol.jar.JarURLConnection.connect(JarURLConnection.java:104) at sun.net.www.protocol.jar.JarURLConnection.getInputStream(JarURLConnection.java:132) at java.net.URL.openStream(URL.java:1009) at org.apache.xerces.impl.XMLEntityManager.setupCurrentEntity(Unknown Source) at org.apache.xerces.impl.XMLEntityManager.startEntity(Unknown Source) at org.apache.xerces.impl.XMLEntityManager.startDTDEntity(Unknown Source) at org.apache.xerces.impl.XMLDTDScannerImpl.setInputSource(Unknown Source) at org.apache.xerces.impl.XMLDocumentScannerImpl$DTDDispatcher.dispatch(Unknown Source) at org.apache.xerces.impl.XMLDocumentFragmentScannerImpl.scanDocument(Unknown Source) at org.apache.xerces.parsers.XML11Configuration.parse(Unknown Source) at org.apache.xerces.parsers.DTDConfiguration.parse(Unknown Source) at org.apache.xerces.parsers.XMLParser.parse(Unknown Source) at org.apache.xerces.parsers.AbstractSAXParser.parse(Unknown Source) at org.apache.tomcat.util.digester.Digester.parse(Digester.java:1562) at org.apache.catalina.startup.TldConfig.tldScanStream(TldConfig.java:514) at org.apache.catalina.startup.TldConfig.tldScanJar(TldConfig.java:472) at org.apache.catalina.startup.TldConfig.execute(TldConfig.java:307) at org.apache.catalina.core.StandardContext.processTlds(StandardContext.java:4307) at org.apache.catalina.core.StandardContext.start(StandardContext.java:4144) at org.apache.catalina.core.ContainerBase.addChildInternal(ContainerBase.java:760) at org.apache.catalina.core.ContainerBase.access$000(ContainerBase.java:122) at org.apache.catalina.core.ContainerBase$PrivilegedAddChild.run(ContainerBase.java:144) at java.security.AccessController.doPrivileged(Native Method) at org.apache.catalina.core.ContainerBase.addChild(ContainerBase.java:738) at org.apache.catalina.core.StandardHost.addChild(StandardHost.java:544) at org.apache.catalina.startup.HostConfig.deployWAR(HostConfig.java:831) at org.apache.catalina.startup.HostConfig.deployWARs(HostConfig.java:720) at org.apache.catalina.startup.HostConfig.deployApps(HostConfig.java:490) at org.apache.catalina.startup.HostConfig.start(HostConfig.java:1150) at org.apache.catalina.startup.HostConfig.lifecycleEvent(HostConfig.java:311) at org.apache.catalina.util.LifecycleSupport.fireLifecycleEvent(LifecycleSupport.java:120) at org.apache.catalina.core.ContainerBase.start(ContainerBase.java:1022) at org.apache.catalina.core.StandardHost.start(StandardHost.java:736) at org.apache.catalina.core.ContainerBase.start(ContainerBase.java:1014) at org.apache.catalina.core.StandardEngine.start(StandardEngine.java:443) at org.apache.catalina.core.StandardService.start(StandardService.java:448) at org.apache.catalina.core.StandardServer.start(StandardServer.java:700) at org.apache.catalina.startup.Catalina.start(Catalina.java:552) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25) at java.lang.reflect.Method.invoke(Method.java:597) at org.apache.catalina.startup.Bootstrap.start(Bootstrap.java:295) at org.apache.catalina.startup.Bootstrap.main(Bootstrap.java:433) Note that if you restart the appserver, you will need to remove the webapp's TLD cache located at "TOMCAT_PATH/work/Catalina/localhost/MY_WAR/tldCache.ser" to reproduce the error again.</column><column name="report_time">2008-10-01 23:51:18</column><column name="report_timestamp">1222920000</column><column name="status">resolved fixed</column><column name="commit">f69637f</column><column name="commit_timestamp">1223030000</column><column name="files">java/org/apache/catalina/core/StandardContext.java
java/org/apache/catalina/startup/TldConfig.java</column><column name="result">1:java/org/apache/catalina/startup/TldConfig.java
3:java/org/apache/catalina/core/StandardContext.java</column></table><table name="tomcat"><column name="id">897</column><column name="bug_id">45851</column><column name="summary">FarmWarDeployer fails to properly unpack copied war on target node</column><column name="description">Created attachment 22616 files used to reproduce issue When trying to deploy a war to a cluster, it seems that the war will deploy locally when placed in the listener directory, however, it seems that either there is some corruption when moving the war across the wire, or the deployer on the target node is not able to properly unpack and read the files inside. Pertinent portion of the log from the target node is attached. I can provide any other info as needed, but not sure what else would be pertinent. The test.war is simply a war'd copy of the default Tomcat Manager web app. To reproduce: 1. Configure two nodes two make up a SimpleTCPCluster (version 6.0.18 was used) 2. From either node, drop test.war into the listen directory Results: * test.war will be deployed locally * test.war will be copies to the webapps directory on the target * test.war will not fully deploy on the target Expected results: * war unpacked and deployed locally * copied to each node in the cluster * war unpacked and deployed on each node of the cluster</column><column name="report_time">2008-09-19 22:17:57</column><column name="report_timestamp">1221880000</column><column name="status">resolved fixed</column><column name="commit">c340c69</column><column name="commit_timestamp">1222450000</column><column name="files">java/org/apache/catalina/ha/deploy/FarmWarDeployer.java
java/org/apache/catalina/ha/deploy/FileMessageFactory.java</column><column name="result">1:java/org/apache/catalina/ha/deploy/FarmWarDeployer.java
215:java/org/apache/catalina/ha/deploy/FileMessageFactory.java</column></table><table name="tomcat"><column name="id">898</column><column name="bug_id">45026</column><column name="summary">Custom HTTP-Error codes get remapped to 500er codes</column><column name="description">We use Apache 2.2.8 with mod_JK 1.2.26 as a load-balancer for a Tomcat 5.5 cluster. We use Custom HTTP-Error codes like 450 for authentication-purposes. Those codes get remapped to 500. The Error-Code 450 is in the RFC2616 described as valid return code so this is a bug. The custom error-codes worked fine in Apache 1.3.41 with MOD_JK/1.2.25. You can easily reproduce this bug by writing a simple jsp-page with the following line: &lt;%response.setStatus(450);%&gt;</column><column name="report_time">2008-05-18 04:16:12</column><column name="report_timestamp">1211100000</column><column name="status">resolved fixed</column><column name="commit">03097fa</column><column name="commit_timestamp">1221850000</column><column name="files">java/org/apache/jk/common/JkInputStream.java</column><column name="result">76:java/org/apache/jk/common/JkInputStream.java</column></table><table name="tomcat"><column name="id">899</column><column name="bug_id">45419</column><column name="summary">Return Accept-Ranges from DefaultServlet</column><column name="description">Currently the DefaultServlet accepts the "Ranges" request header, but doesn't indicate this in its response by returning "Accept-Ranges: bytes". Although this is not required in HTTP/1.1, setting the header is required in order for the Adobe Acrobat plugin to correctly handle Linearized PDF's (which can speed download by allowing random access to a PDF file). Although it's not strictly necessary according to the specification I can't think of any reason why this header is not safe to set in a response from DefaultServlet, which is always dealing with static files, and not doing so has a negative impact on serving large PDF files - so I'm filing it as a bug rather than an RFE.</column><column name="report_time">2008-07-17 07:38:07</column><column name="report_timestamp">1216290000</column><column name="status">resolved fixed</column><column name="commit">633545f</column><column name="commit_timestamp">1221680000</column><column name="files">java/org/apache/catalina/servlets/DefaultServlet.java</column><column name="result">1:java/org/apache/catalina/servlets/DefaultServlet.java</column></table><table name="tomcat"><column name="id">900</column><column name="bug_id">45441</column><column name="summary">Matching of relevant servlet filters fails when request is forwarded...</column><column name="description">I ran into a situation where Tomcat will not execute appropriate filters on a request that has been forwarded. I'm using the handy URLRewriteFilter implementation (from tuckey.org). When I forwarded a request internally, filters that had a matching url-pattern (in the web.xml file) and with a dispatcher setting of both REQUEST and FORWARD were not invoked. On tracing the code (hours later), I found that the problem lies inside the ApplicationDispatcher code. It set the DISPATCHER_REQUEST_PATH_ATTR state attribue to be the servletPath. That meant that only matches using the servlet path would match, but longer (more exact) urls would fail to match. For example, using the following filter mapping: &lt;filter-mapping&gt; &lt;filter-name&gt;my-filter&lt;/filter-name&gt;		 &lt;url-pattern&gt;/app/level/mycode.do&lt;/url-pattern&gt; &lt;dispatcher&gt;REQUEST&lt;/dispatcher&gt; &lt;dispatcher&gt;FORWARD&lt;/dispatcher&gt; &lt;/filter-mapping&gt; would not match a request that was forwarded to /app/level/mycode.do, which it should! Changing the url pattern to be "/app/*" would match, but "/app/level/*" would not, since the servletPath was /app in this example. The fix for this is quite simple. In the ApplicationDispatcher.java code, in the method processRequest() (which is only called for forwards), change the following statement: state.outerRequest.setAttribute (ApplicationFilterFactory.DISPATCHER_REQUEST_PATH_ATTR, servletPath); to use requestURI instead as follows: state.outerRequest.setAttribute (ApplicationFilterFactory.DISPATCHER_REQUEST_PATH_ATTR, requestURI ); This resolves the problem and let all the examples above correctly match and run the filter on a forward. I believe includes will also be broken in the same manner. Similar changes to the doInclude() method in ApplicationDispatcher.java will likely resolve that issue as well, though I have not tested this personally. Be nice to see this resolved in 6.0.17+. Thanks! ....Andrzej</column><column name="report_time">2008-07-20 10:54:40</column><column name="report_timestamp">1216570000</column><column name="status">resolved fixed</column><column name="commit">2c0fffe</column><column name="commit_timestamp">1221650000</column><column name="files">java/org/apache/catalina/core/ApplicationDispatcher.java</column><column name="result">1:java/org/apache/catalina/core/ApplicationDispatcher.java</column></table><table name="tomcat"><column name="id">901</column><column name="bug_id">45823</column><column name="summary">AccessLogValve doesn't correctly handles combined log format (with patch)</column><column name="description">Created attachment 22595 Patch that corrects this bug When configuring the AccessLogValve valve to use the combined log format and either referer or user-agent fields are unavailable in the request, the corresponding log entry fields will contain "(null)" instead of "-". This behaviour breaks access log analyzers like AWStats and I believe it's also a violation of the log spec. Included is a patch that I believe will correct the problem. The patch make sure that any non-existing header will be logged as '-' instead of trying to log a null pointer. I stumbled on this problem when upgrading from Tomcat 5.5 to 6.0.16 using Debian etch and JDK 6. Tomcat 5.5 didn't suffer from this issue. I haven't yet tried Tomcat 6.0.18 but the AccessLogValve.java file seems to be unchanged between the two releases so I suspect the problem still exists.</column><column name="report_time">2008-09-17 02:20:05</column><column name="report_timestamp">1221630000</column><column name="status">resolved fixed</column><column name="commit">678b516</column><column name="commit_timestamp">1221650000</column><column name="files">java/org/apache/catalina/valves/AccessLogValve.java</column><column name="result">1:java/org/apache/catalina/valves/AccessLogValve.java</column></table><table name="tomcat"><column name="id">902</column><column name="bug_id">45618</column><column name="summary">Selector is not closed.</column><column name="description">In the class ParallelNioSender [1], a Selector (selector) is declared as a field. In line 60, it is opened (selector = Selector.open()). However, it is not closed in any situations. As shown by its Javadoc [2], it has a close() method, and this method should be called to close the selector. [1]http://www.google.com/codesearch?hl=en&amp;q=lang:java+open+java.nio.channels.Selector+show:hsMlF-2s6UU:ZSXpd2XI4bI:dK-_LkuTzG4&amp;sa=N&amp;ct=rx&amp;cd=4&amp;cs_p=http://archive.apache.org/dist/tomcat/tomcat-6/v6.0.0/src/apache-tomcat-6.0.0-src.tar.gz&amp;cs_f=apache-tomcat-6.0.0-src/java/org/apache/catalina/tribes/transport/nio/ParallelNioSender.java&amp;cs_p=http://archive.apache.org/dist/tomcat/tomcat-6/v6.0.0/src/apache-tomcat-6.0.0-src.tar.gz&amp;cs_f=apache-tomcat-6.0.0-src/java/org/apache/catalina/tribes/transport/nio/ParallelNioSender.java [2]http://java.sun.com/j2se/1.5.0/docs/api/java/nio/channels/Selector.html</column><column name="report_time">2008-08-11 22:45:15</column><column name="report_timestamp">1218510000</column><column name="status">resolved fixed</column><column name="commit">d69b378</column><column name="commit_timestamp">1220390000</column><column name="files">java/org/apache/catalina/tribes/transport/nio/ParallelNioSender.java</column><column name="result">11:java/org/apache/catalina/tribes/transport/nio/ParallelNioSender.java</column></table><table name="tomcat"><column name="id">903</column><column name="bug_id">45413</column><column name="summary">Contribution of Bayeux implementation for Tomcat</column><column name="description">Created attachment 22267 Contribution of code The following bugzilla issue is a contribution of a codebase from Filip Hanik(asf:fhanik) and Guy Molinari(individual) Both have ICLAs on file with the ASF. Description: The contribution is two fold 1. The core implementation Core implementation of the Bayeux protocol using Comet and HTTP External dependencies: json.jar from json.org - Apache License 2.0 packages: - org.apache.cometd.bayeux APIs for web application developers derived from a proposed but incomplete API by Dojo Foundation - org.apache.tomcat.bayeux implementation of API classes 2. The sample applications External dependencies: Dojo Toolkit, license: http://trac.dojotoolkit.org/browser/dojo/trunk/LICENSE#L13 COPYRIGHT and LICENSE files included. The contribution is a full environment, to be able to download and build distributions. We don't expect everything to be merged in, instead we expect that the source code be integrated into tomcat/trunk and we can then modify the existing build scripts to fit into the Tomcat build/distribution scheme</column><column name="report_time">2008-07-16 17:49:44</column><column name="report_timestamp">1216240000</column><column name="status">resolved fixed</column><column name="commit">83fe69a</column><column name="commit_timestamp">1220390000</column><column name="files">java/org/apache/cometd/bayeux/Bayeux.java
java/org/apache/cometd/bayeux/Channel.java
java/org/apache/cometd/bayeux/Client.java
java/org/apache/cometd/bayeux/DataFilter.java
java/org/apache/cometd/bayeux/Listener.java
java/org/apache/cometd/bayeux/Message.java
java/org/apache/cometd/bayeux/SecurityPolicy.java
java/org/apache/tomcat/bayeux/BayeuxException.java
java/org/apache/tomcat/bayeux/BayeuxRequest.java
java/org/apache/tomcat/bayeux/BayeuxServlet.java
java/org/apache/tomcat/bayeux/ChannelImpl.java
java/org/apache/tomcat/bayeux/ClientImpl.java
java/org/apache/tomcat/bayeux/HttpError.java
java/org/apache/tomcat/bayeux/MessageImpl.java
java/org/apache/tomcat/bayeux/RequestBase.java
java/org/apache/tomcat/bayeux/RequestFactory.java
java/org/apache/tomcat/bayeux/TomcatBayeux.java
java/org/apache/tomcat/bayeux/request/MetaConnectRequest.java
java/org/apache/tomcat/bayeux/request/MetaDisconnectRequest.java
java/org/apache/tomcat/bayeux/request/MetaHandshakeRequest.java
java/org/apache/tomcat/bayeux/request/MetaSubscribeRequest.java
java/org/apache/tomcat/bayeux/request/MetaUnsubscribeRequest.java
java/org/apache/tomcat/bayeux/request/PublishRequest.java
test/org/apache/cometd/bayeux/samples/EchoChatClient.java</column><column name="result" /></table><table name="tomcat"><column name="id">904</column><column name="bug_id">45628</column><column name="summary">ExtensionValidator doesn't handle wrapped lines in MANIFEST.MF</column><column name="description">Deploying webapps that contain commons-attributes-api.jar or commons-attributes-compiler.jar (downloaded from the Maven repository) fail with a message from ExtensionValidator along the lines of 'Required extension "ant" not found'. This happens because the MANIFEST.MF file in these jars contain wrapped lines. Per the JAR spec, lines longer than 72 bytes have to wrap. These MANIFEST.MF files contain lines like: ant-Implementation-URL: http://www.ibiblio.org/maven/ant/jars/ant-1.5. jar which evidently cause ExtensionValidator to complain. If you edit the MANIFEST.MF files to eliminate the continuation line: ant-Implementation-URL: http://www.ibiblio.org/maven/ant/jars/ant-1.5.jar there are no errors.</column><column name="report_time">2008-08-13 12:47:56</column><column name="report_timestamp">1218650000</column><column name="status">resolved fixed</column><column name="commit">3773ec4</column><column name="commit_timestamp">1220370000</column><column name="files">java/org/apache/catalina/util/ManifestResource.java</column><column name="result">2:java/org/apache/catalina/util/ManifestResource.java</column></table><table name="tomcat"><column name="id">905</column><column name="bug_id">45666</column><column name="summary">JspContextWrapper contains infinite loop in include(String relativeUrlPath, boolean flush)</column><column name="description">public void include(String relativeUrlPath, boolean flush) 			throws ServletException, IOException { 		include(relativeUrlPath, false); // XXX 	} just calls itself it seems. Perhaps this should be (just a guess): public void include(String relativeUrlPath, boolean flush) 			throws ServletException, IOException { 		invokingJspCtxt.include(relativeUrlPath, false); // XXX 	} This came up for me when I had a .tag file that had an include in it. I was using Tomcat 5.5 but looking at the source of JspContextWrapper.java it looks like this issue is in 5.5 as well as 6 (and the svn trunk).</column><column name="report_time">2008-08-21 06:47:17</column><column name="report_timestamp">1219320000</column><column name="status">resolved fixed</column><column name="commit">ccc1014</column><column name="commit_timestamp">1220220000</column><column name="files">java/org/apache/jasper/runtime/JspContextWrapper.java</column><column name="result">1:java/org/apache/jasper/runtime/JspContextWrapper.java</column></table><table name="tomcat"><column name="id">906</column><column name="bug_id">45648</column><column name="summary">Function 'f:length' not found</column><column name="description">This error happens when accessing the Proxy Connectors page in an Apache Archiva 1.1.1 installation: http://localhost:8080/archiva/admin/proxyConnectors.action This error happens against a build exported from trunk on 2008/08/14 (I'm using this build, to work around bug https://issues.apache.org/bugzilla/show_bug.cgi?id=45511 - EL "empty" keyword does not work, which also happens with Archiva). This error seems very similar to 45511. Significant part of the stack trace: org.apache.jasper.JasperException: /WEB-INF/jsp/admin/proxyConnectors.jsp(76,2) "${fn:length(repository.value)}" contains invalid expression(s): javax.el.ELException: Function 'f:length' not found 	org.apache.jasper.compiler.DefaultErrorHandler.jspError(DefaultErrorHandler.java:40) 	org.apache.jasper.compiler.ErrorDispatcher.dispatch(ErrorDispatcher.java:407) 	org.apache.jasper.compiler.ErrorDispatcher.jspError(ErrorDispatcher.java:198) 	org.apache.jasper.compiler.Validator$ValidateVisitor.checkXmlAttributes(Validator.java:1132) 	org.apache.jasper.compiler.Validator$ValidateVisitor.visit(Validator.java:813) 	org.apache.jasper.compiler.Node$CustomTag.accept(Node.java:1512) 	org.apache.jasper.compiler.Node$Nodes.visit(Node.java:2343) 	org.apache.jasper.compiler.Node$Visitor.visitBody(Node.java:2393) 	org.apache.jasper.compiler.Validator$ValidateVisitor.visit(Validator.java:832) 	org.apache.jasper.compiler.Node$CustomTag.accept(Node.java:1512) 	org.apache.jasper.compiler.Node$Nodes.visit(Node.java:2343) 	org.apache.jasper.compiler.Node$Visitor.visitBody(Node.java:2393) 	org.apache.jasper.compiler.Validator$ValidateVisitor.visit(Validator.java:832) 	org.apache.jasper.compiler.Node$CustomTag.accept(Node.java:1512) 	org.apache.jasper.compiler.Node$Nodes.visit(Node.java:2343) 	org.apache.jasper.compiler.Node$Visitor.visitBody(Node.java:2393) 	org.apache.jasper.compiler.Validator$ValidateVisitor.visit(Validator.java:832) 	org.apache.jasper.compiler.Node$CustomTag.accept(Node.java:1512) 	org.apache.jasper.compiler.Node$Nodes.visit(Node.java:2343) 	org.apache.jasper.compiler.Node$Visitor.visitBody(Node.java:2393) 	org.apache.jasper.compiler.Node$Visitor.visit(Node.java:2399) 	org.apache.jasper.compiler.Node$Root.accept(Node.java:489) 	org.apache.jasper.compiler.Node$Nodes.visit(Node.java:2343) 	org.apache.jasper.compiler.Validator.validate(Validator.java:1713) 	org.apache.jasper.compiler.Compiler.generateJava(Compiler.java:166) 	org.apache.jasper.compiler.Compiler.compile(Compiler.java:315) 	org.apache.jasper.compiler.Compiler.compile(Compiler.java:295) 	org.apache.jasper.compiler.Compiler.compile(Compiler.java:282) 	org.apache.jasper.JspCompilationContext.compile(JspCompilationContext.java:589) 	org.apache.jasper.servlet.JspServletWrapper.service(JspServletWrapper.java:312) 	org.apache.jasper.servlet.JspServlet.serviceJspFile(JspServlet.java:321) 	org.apache.jasper.servlet.JspServlet.service(JspServlet.java:268) 	javax.servlet.http.HttpServlet.service(HttpServlet.java:717) 	com.opensymphony.webwork.dispatcher.ServletDispatcherResult.doExecute(ServletDispatcherResult.java:114) 	com.opensymphony.webwork.dispatcher.WebWorkResultSupport.execute(WebWorkResultSupport.java:143) ...</column><column name="report_time">2008-08-18 19:54:44</column><column name="report_timestamp">1219100000</column><column name="status">resolved fixed</column><column name="commit">6d40691</column><column name="commit_timestamp">1220210000</column><column name="files">java/org/apache/el/parser/ELParser.java</column><column name="result">123:java/org/apache/el/parser/ELParser.java</column></table><table name="tomcat"><column name="id">907</column><column name="bug_id">45691</column><column name="summary">Jasper creates duplicate variable names</column><column name="description">Sometimes a JSP's Java code, which have been generated by Jasper, has duplicate variable names. Therefore the JSP cannot be compiled and tomcat delivers an HTTP status code 500. You get an error message like this org.apache.jasper.JasperException: Unable to compile class for JSP: An error occurred at line: 10 in the jsp file: /test1.jsp Duplicate local variable _jspx_temp0 7: 		&lt;c:set var="a"&gt; 8: 			&lt;jsp:attribute name="value"&gt;&lt;%= new java.util.Date().toString() %&gt;&lt;/jsp:attribute&gt; 9: 		&lt;/c:set&gt; 10: 		&lt;c:set var="b"&gt; 11: 			&lt;jsp:attribute name="value"&gt;&lt;%= new java.util.Date().toString() %&gt;&lt;/jsp:attribute&gt; 12: 		&lt;/c:set&gt; 13: 		&lt;h1&gt;Test 1&lt;/h1&gt; The reason of this error is the generation of variable names like _jspx_temp0, which are created for &lt;jsp:attribute&gt; tags. At the beginning of parsing a JSP file a counter is reset to 0. Every time an &lt;jsp:attribute&gt; tag occurs, the counter is used to build a variable name _jspx_temp&lt;counter&gt;. Thereafter the counter will be incremented. Unfortunately the counter is a static member of the JspUtil class. Suppose there's a thread 1, which created _jspx_temp4. The counter is 5. Now a second thread (thread 2) starts and resets the counter. Afterwards thread 2 creates _jspx_temp0 to _jspx_temp3. The counter is 4 by now. Then thread 2 stops and thread 1 continues. The next variable's name in thread 1 will be _jspx_temp4, which already exists. Therefore the generated java class cannot be compiled.</column><column name="report_time">2008-08-26 07:23:33</column><column name="report_timestamp">1219750000</column><column name="status">resolved fixed</column><column name="commit">337d6a6</column><column name="commit_timestamp">1220190000</column><column name="files">java/org/apache/jasper/compiler/Compiler.java
java/org/apache/jasper/compiler/JspUtil.java
java/org/apache/jasper/compiler/Node.java
java/org/apache/jasper/compiler/TagPluginManager.java</column><column name="result">1:java/org/apache/jasper/compiler/Compiler.java
9:java/org/apache/jasper/compiler/JspUtil.java
17:java/org/apache/jasper/compiler/Node.java
42:java/org/apache/jasper/compiler/TagPluginManager.java</column></table><table name="tomcat"><column name="id">908</column><column name="bug_id">45074</column><column name="summary">Add configuration parameters for finer tuning of Http11AprProtocol thread usage</column><column name="description">Created attachment 21997 Add some properties to the connector Here's an enhancement patch to enable tuning of the number of sendfile and poller threads in the APR connector.</column><column name="report_time">2008-05-23 15:44:19</column><column name="report_timestamp">1211570000</column><column name="status">resolved fixed</column><column name="commit">6a1f316</column><column name="commit_timestamp">1219820000</column><column name="files">java/org/apache/coyote/http11/Http11AprProtocol.java</column><column name="result">1:java/org/apache/coyote/http11/Http11AprProtocol.java</column></table><table name="tomcat"><column name="id">909</column><column name="bug_id">44809</column><column name="summary">Improve AprLifecycleListener Error Messages</column><column name="description">Created attachment 21817 Patch to provide more detailed error information on SSLEngine init failure. The AprLifecycleListener currently provides a single, uninformative error message for a variety of possible failure conditions that can occur initializing the SSL engine for the native connectors: Failed to initialize the SSLEngine. It would be trivial to provide additional error details by passing the causing exception to the catalina core logger at, say, the debug level. I'm providing a one-liner patch to do this. FWIW, the additional error information provided by the causing exception allowed me to solve my problem (compiled APR w/out SSL).</column><column name="report_time">2008-04-11 10:18:59</column><column name="report_timestamp">1207920000</column><column name="status">resolved fixed</column><column name="commit">46055c5</column><column name="commit_timestamp">1219820000</column><column name="files">java/org/apache/catalina/core/AprLifecycleListener.java</column><column name="result">1:java/org/apache/catalina/core/AprLifecycleListener.java</column></table><table name="tomcat"><column name="id">910</column><column name="bug_id">43327</column><column name="summary">Socket bind fails on tomcat startup when using apr</column><column name="description">I'm running debian sid, kernel 2.6.22 and use tomcat 6.0.14 together with apr 1.2.11. no special tomcat configuration (out of the box). On start up of tomcat I get the following error log: Debugging apr revealed a problem with IPV6: apr_socket_create() assigns a AF_INET6 socket, apr_socket_bind tries to bind a AF_INET address which fails. INFO: Loaded Apache Tomcat Native library 1.1.10. Sep 7, 2007 6:05:16 PM org.apache.catalina.core.AprLifecycleListener init INFO: APR capabilities: IPv6 [true], sendfile [true], accept filters [false], random [true]. Sep 7, 2007 6:05:16 PM org.apache.coyote.http11.Http11AprProtocol init SEVERE: Error initializing endpoint java.lang.Exception: Socket bind failed: [22] Invalid argument at org.apache.tomcat.util.net.AprEndpoint.init(AprEndpoint.java:612) at org.apache.coyote.http11.Http11AprProtocol.init(Http11AprProtocol.java:121) at org.apache.catalina.connector.Connector.initialize(Connector.java:1059) regards erik</column><column name="report_time">2007-09-07 07:22:31</column><column name="report_timestamp">1189160000</column><column name="status">resolved fixed</column><column name="commit">fea7658</column><column name="commit_timestamp">1219330000</column><column name="files">java/org/apache/tomcat/util/net/AprEndpoint.java</column><column name="result">2:java/org/apache/tomcat/util/net/AprEndpoint.java</column></table><table name="tomcat"><column name="id">911</column><column name="bug_id">45655</column><column name="summary">check permisson</column><column name="description">Created attachment 22458 check permission just check permission if it is allowed don't use cast to same class</column><column name="report_time">2008-08-19 14:13:35</column><column name="report_timestamp">1219170000</column><column name="status">resolved fixed</column><column name="commit">b266836</column><column name="commit_timestamp">1219280000</column><column name="files">java/org/apache/juli/ClassLoaderLogManager.java</column><column name="result">98:java/org/apache/juli/ClassLoaderLogManager.java</column></table><table name="tomcat"><column name="id">912</column><column name="bug_id">45608</column><column name="summary">Race conditions on field countAllocated of class org.apache.catalina.core.StandardWrapper</column><column name="description">We found field countAllocated are accessed by allocate() and deallocate() without any protections by locks. Here is a trace log, Thread http-8081-1 id: 23 : READ [org.apache.catalina.core.StandardWrapper : allocate : 820] [org.apache.catalina.core.StandardWrapperValve : invoke : 129] [org.apache.catalina.core.StandardContextValve : invoke : 175] [org.apache.catalina.core.StandardHostValve : invoke : 128] [org.apache.catalina.valves.ErrorReportValve : invoke : 104] [org.apache.catalina.core.StandardEngineValve : invoke : 109] [org.apache.catalina.connector.CoyoteAdapter : service : 261] [org.apache.coyote.http11.Http11Processor : process : 844] [org.apache.coyote.http11.Http11Protocol$Http11ConnectionHandler : process : 581] [org.apache.tomcat.util.net.JIoEndpoint$Worker : run : 447] [java.lang.Thread : run : 735] Thread http-8081-4 id: 26 : WRITE [org.apache.catalina.core.StandardWrapper : deallocate : 871] [org.apache.catalina.core.StandardWrapperValve : invoke : 298] [org.apache.catalina.core.StandardContextValve : invoke : 175] [org.apache.catalina.core.StandardHostValve : invoke : 128] [org.apache.catalina.valves.ErrorReportValve : invoke : 104] [org.apache.catalina.core.StandardEngineValve : invoke : 109] [org.apache.catalina.connector.CoyoteAdapter : service : 261] [org.apache.coyote.http11.Http11Processor : process : 844] [org.apache.coyote.http11.Http11Protocol$Http11ConnectionHandler : process : 581] [org.apache.tomcat.util.net.JIoEndpoint$Worker : run : 447] [java.lang.Thread : run : 735] Thread http-8081-4 and http-8081-1 will access countAllocated in parallel. Since increment and decrement is *NOT* atomic, we think it is a potential race condition.</column><column name="report_time">2008-08-10 21:27:37</column><column name="report_timestamp">1218420000</column><column name="status">resolved fixed</column><column name="commit">816ecb8</column><column name="commit_timestamp">1218550000</column><column name="files">java/org/apache/catalina/core/StandardWrapper.java</column><column name="result">1:java/org/apache/catalina/core/StandardWrapper.java</column></table><table name="tomcat"><column name="id">913</column><column name="bug_id">41407</column><column name="summary">CLIENT-CERT Authentication with JAASRealm not working</column><column name="description">I tried to config my webapp to authenticate user by CLIENT-CERT auth method. I verified my JAAS LoginModule by using "BASIC" to auth method and successfully authenticated user login. After studying Tomcat 5.5.20 source, I found that the problem is caused by the RealmBase.java and JAASRealm.java. if CLIENT-CERT auth method is used, SSLAuthenticator will call the : JAASRealm.authenticate(X509Certificate certs[]) As JAASRealm didn't override authenticate(X509Certificate certs[]), RealmBase's authenticate will be used and it will only validate the certs and then call getPrincipal(X509Certificate) and then getPrincipal(String) is being called to get the Principal. However, in JAASRealm, this function always return null. That means Tomcat can't use JAASRealm with CLIENT-CERT auth method. Thanks Butler</column><column name="report_time">2007-01-18 18:33:49</column><column name="report_timestamp">1169160000</column><column name="status">resolved fixed</column><column name="commit">6d78232</column><column name="commit_timestamp">1218290000</column><column name="files">java/org/apache/catalina/realm/JAASCallbackHandler.java
java/org/apache/catalina/realm/JAASMemoryLoginModule.java
java/org/apache/catalina/realm/JAASRealm.java</column><column name="result">1:java/org/apache/catalina/realm/JAASRealm.java
4:java/org/apache/catalina/realm/JAASMemoryLoginModule.java
6:java/org/apache/catalina/realm/JAASCallbackHandler.java</column></table><table name="tomcat"><column name="id">914</column><column name="bug_id">45576</column><column name="summary">JAASRealm not working with DigestAuthenticator</column><column name="description">JAASRealm cannot be used with DigestAuthenticator. JAASRealm only overrides authenticate(String, String), whereas DigestAuthenticator calls authenticate(String, String, String, String, String, String, String, String). This is similar to bug 41407, where CLIENT-CERT authentication is used.</column><column name="report_time">2008-08-06 02:12:34</column><column name="report_timestamp">1218000000</column><column name="status">resolved fixed</column><column name="commit">c984c6a</column><column name="commit_timestamp">1218280000</column><column name="files">java/org/apache/catalina/realm/JAASCallbackHandler.java
java/org/apache/catalina/realm/JAASMemoryLoginModule.java
java/org/apache/catalina/realm/JAASRealm.java</column><column name="result">2:java/org/apache/catalina/realm/JAASRealm.java
3:java/org/apache/catalina/realm/JAASCallbackHandler.java
15:java/org/apache/catalina/realm/JAASMemoryLoginModule.java</column></table><table name="tomcat"><column name="id">915</column><column name="bug_id">45591</column><column name="summary">NullPointerException during shutdown in JKMain.pause()</column><column name="description">On startup, if Tomcat discovers that the main port is already bound to another process, it fails and tries to execute the shutdown code. In some situations (I'm not sure which), the org.apache.jk.server.JKMain instance variable wEnv is null at this point, which causes a NullPointerException when JKMain.pause() is called (see stacktrace below). Since this is occurring within a shutdown hook thread, it can result in a dirty shutdown of the JVM. I've observed this with Tomcat 5.5.20, but I looked over the code in 5.5.26 and it looks like the same problem is still present. Fortunately, the solution is very simple. Just add the following if test at the beginning of JKMain.pause(): if (wEnv == null) { return; } Stacktrace: SEVERE: StandardServer.await: create[8006]: java.net.BindException: Address already in use: JVM_Bind 	at java.net.PlainSocketImpl.socketBind(Native Method) 	at java.net.PlainSocketImpl.bind(PlainSocketImpl.java:359) 	at java.net.ServerSocket.bind(ServerSocket.java:319) 	at java.net.ServerSocket.&lt;init&gt;(ServerSocket.java:185) 	at org.apache.catalina.core.StandardServer.await(StandardServer.java:372) 	at org.apache.catalina.startup.Catalina.await(Catalina.java:615) 	at org.apache.catalina.startup.Catalina.start(Catalina.java:575) 	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) 	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) 	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25) 	at java.lang.reflect.Method.invoke(Method.java:585) 	at org.apache.catalina.startup.Bootstrap.start(Bootstrap.java:294) 	at org.apache.catalina.startup.Bootstrap.main(Bootstrap.java:432) Aug 7, 2008 3:25:34 PM org.apache.coyote.http11.Http11BaseProtocol pause INFO: Pausing Coyote HTTP/1.1 on http-8000 Aug 7, 2008 3:25:34 PM org.apache.catalina.connector.Connector pause SEVERE: Protocol handler pause failed java.lang.NullPointerException 	at org.apache.jk.server.JkMain.pause(JkMain.java:678) 	at org.apache.jk.server.JkCoyoteHandler.pause(JkCoyoteHandler.java:162) 	at org.apache.catalina.connector.Connector.pause(Connector.java:1031) 	at org.apache.catalina.core.StandardService.stop(StandardService.java:491) 	at org.apache.catalina.core.StandardServer.stop(StandardServer.java:743) 	at org.apache.catalina.startup.Catalina.stop(Catalina.java:601) 	at org.apache.catalina.startup.Catalina$CatalinaShutdownHook.run(Catalina.java:644)</column><column name="report_time">2008-08-07 12:35:38</column><column name="report_timestamp">1218130000</column><column name="status">resolved fixed</column><column name="commit">38a62a6</column><column name="commit_timestamp">1218210000</column><column name="files">java/org/apache/jk/server/JkMain.java</column><column name="result">2:java/org/apache/jk/server/JkMain.java</column></table><table name="tomcat"><column name="id">916</column><column name="bug_id">45453</column><column name="summary">JDBCRealm.getRoles bad synchronization causes hangs w/ DIGEST authentication</column><column name="description">JDBCRealm.getRoles bad synchronization causes hangs w/ DIGEST authentication JDBCRealm caches PreparedStatement preparedRoles. That, and missing synchronization in JDBCRealm and/or DigestAuthenticator allow two threads to call getRoles simultaneously so that T1 will do stmt.executeQuery() while T2 does stmt.setString(1, userName) plus another .executeQuery() on the same PreparedStatement object. In the worst case, the JDBC driver gets confused by this, and blocks forever waiting for server response, causing all other threads that try to access DB hang. (This was observed with PostgreSQL 8.3-603-jdbc4 JDBC driver) org.postgresql.jdbc2.AbstractJdbc2Statement.execute(AbstractJdbc2Statement.java:451) org.postgresql.jdbc2.AbstractJdbc2Statement.executeWithFlags(AbstractJdbc2Statement.java:350) org.postgresql.jdbc2.AbstractJdbc2Statement.executeQuery(AbstractJdbc2Statement.java:254) org.apache.catalina.realm.JDBCRealm.getRoles(JDBCRealm.java:631) org.apache.catalina.realm.JDBCRealm.getPrincipal(JDBCRealm.java:596) org.apache.catalina.realm.RealmBase.authenticate(RealmBase.java:399) org.apache.catalina.authenticator.DigestAuthenticator.findPrincipal(DigestAuthenticator.java:283) org.apache.catalina.authenticator.DigestAuthenticator.authenticate(DigestAuthenticator.java:176)</column><column name="report_time">2008-07-22 02:25:02</column><column name="report_timestamp">1216710000</column><column name="status">resolved fixed</column><column name="commit">9d3cad7</column><column name="commit_timestamp">1217340000</column><column name="files">java/org/apache/catalina/realm/JDBCRealm.java</column><column name="result">1:java/org/apache/catalina/realm/JDBCRealm.java</column></table><table name="tomcat"><column name="id">917</column><column name="bug_id">45459</column><column name="summary">Startup Listener error message unhelpful</column><column name="description">I get the following error on startup: java.lang.IllegalAccessException: Class org.apache.catalina.core.StandardContext can not access a member of class com.mycom.Myclass with modifiers "private" This occurs when the listener class does not have a public zero argument constructor. Could we improve the error message to make it a little easier to understand? It's too bad that the sun docs don't even mention the requirement: http://java.sun.com/javaee/5/docs/api/index.html?javax/servlet/http/HttpSessionListener.html &gt;&gt;&gt; web.xml: &lt;listener&gt; &lt;listener-class&gt;com.mycom.Myclass&lt;/listener-class&gt; &lt;/listener&gt; where Myclass is located inside my war in WEB-INF/class/com/mycom</column><column name="report_time">2008-07-22 08:44:55</column><column name="report_timestamp">1216730000</column><column name="status">resolved wontfix</column><column name="commit">4cab5f3</column><column name="commit_timestamp">1217340000</column><column name="files">java/org/apache/catalina/core/StandardContext.java</column><column name="result">1:java/org/apache/catalina/core/StandardContext.java</column></table><table name="tomcat"><column name="id">918</column><column name="bug_id">42727</column><column name="summary">CoyoteReader readLine returns null for some post request bodies that are a multiple of MAX_LINE_LENGTH in size</column><column name="description">i have a webapp running on jboss-4.0.5.GA/apache-tomcat-5.5.20 that reads in the http post request body and processes it. i noticed that for request bodies that didn't contain line separators and that had sizes that were exact multiples of org.apache.catalina.connector.CoyoteReader.MAX_LINE_LENGTH (4096), i was receiving null when calling org.apache.catalina.connector.CoyoteReader.readLine (). i believe that the problem is at line 155 in org.apache.catalina.connector.CoyoteReader, where on the last iteration through the loop, "pos" does equal zero and null is returned even though data has been aggregated. here's a command to run in cygwin to easily reproduce the problem: for requestSize in 4095 4096 4097 8191 8192 8193; do dd if=/dev/zero bs=1c count=$requestSize | tr '\000' 'A' | curl --data-binary @- http://localhost:8080/DebugJboss/DebugServlet &gt; $requestSize.txt; done; output from directory listing (size filename): 4095 4095.txt 0 4096.txt 4097 4097.txt 8191 8191.txt 0 8192.txt 8193 8193.txt here's the bulk of the servlet code i used to reproduce the problem: public class DebugServlet extends HttpServlet { 	protected void doPost(HttpServletRequest arg0, HttpServletResponse arg1) 			throws ServletException, IOException { 		BufferedReader br = arg0.getReader(); 		Writer writer = arg1.getWriter(); 		String line = null; 		while ((line = br.readLine()) != null) { 			writer.write(line); 		} 		writer.close(); 		br.close(); 	} } it appears that a workaround is to wrap the requests's input stream instead: BufferedReader br = new BufferedReader(new InputStreamReader(arg0.getInputStream ()));</column><column name="report_time">2007-06-23 06:29:58</column><column name="report_timestamp">1182590000</column><column name="status">resolved fixed</column><column name="commit">92f847d</column><column name="commit_timestamp">1216330000</column><column name="files">java/org/apache/catalina/connector/CoyoteReader.java</column><column name="result">1:java/org/apache/catalina/connector/CoyoteReader.java</column></table><table name="tomcat"><column name="id">919</column><column name="bug_id">42722</column><column name="summary">Potential NullPointerException in org.apache.catalina.servlets.CGIServlet</column><column name="description">There is a potential NPE in CGIServlet, even if it's unlikely it may happen. The following patch resolves this problem: Index: F:/Workspace/Apache2/tomcat6/java/org/apache/catalina/servlets/CGIServlet.java =================================================================== --- F:/Workspace/Apache2/tomcat6/java/org/apache/catalina/servlets/CGIServlet.java (revision 548385) +++ F:/Workspace/Apache2/tomcat6/java/org/apache/catalina/servlets/CGIServlet.java (working copy) @@ -1631,7 +1631,6 @@ * with major modifications by Martin Dengler */ Runtime rt = null; - InputStream cgiOutput = null; BufferedReader commandsStdErr = null; BufferedOutputStream commandsStdIn = null; Process proc = null; @@ -1700,7 +1699,9 @@ new HTTPHeaderInputStream(proc.getInputStream()); BufferedReader cgiHeaderReader = new BufferedReader(new InputStreamReader(cgiHeaderStream)); - + + InputStream cgiOutput = null; + while (isRunning) { try { //set headers @@ -1763,7 +1764,10 @@ } //replacement for Process.waitFor() // Close the output stream used - cgiOutput.close(); + if (cgiOutput != null) + { + cgiOutput.close(); + } } catch (IOException e){ log ("Caught exception " + e);</column><column name="report_time">2007-06-22 05:21:27</column><column name="report_timestamp">1182500000</column><column name="status">resolved fixed</column><column name="commit">d41f610</column><column name="commit_timestamp">1215720000</column><column name="files">java/org/apache/catalina/servlets/CGIServlet.java</column><column name="result">1:java/org/apache/catalina/servlets/CGIServlet.java</column></table><table name="tomcat"><column name="id">920</column><column name="bug_id">42678</column><column name="summary">docBase ignored even if its not a subdir of appBase</column><column name="description">I use latest 6.0 SVN snapshot. I store deployable WARs in "webapps-dist" (aside "webapps"). This is my setup: bash-3.2$ ls $CATALINA_BASE conf logs temp tomcat-dist webapps webapps-dist work bash-3.2$ ls webapps-dist sample.war bash-3.2$ cat conf/Catalina/localhost/sample.xml &lt;Context docBase="${catalina.base}/webapps-dist/sample.war"/&gt; this ends up in: WARNUNG: A docBase /home/juergen/java/tomcat/webapps-dist/sample.war inside the host appBase has been specified, and will be ignored</column><column name="report_time">2007-06-15 15:07:50</column><column name="report_timestamp">1181930000</column><column name="status">resolved fixed</column><column name="commit">252fca1</column><column name="commit_timestamp">1215710000</column><column name="files">java/org/apache/catalina/startup/HostConfig.java</column><column name="result">3:java/org/apache/catalina/startup/HostConfig.java</column></table><table name="tomcat"><column name="id">921</column><column name="bug_id">45317</column><column name="summary">DeltaManager always reports default timeout value for receiving session state on startup</column><column name="description">Hi there, If I override the state transfer timeout: &lt;Manager className="org.apache.catalina.ha.session.DeltaManager" stateTransferTimeout="10" expireSessionsOnShutdown="false" notifyListenersOnReplication="true"/&gt; DeltaManager continues to log the default timeout value (ie: "This operation will timeout if no session state has been received within 60 seconds."): 2008-07-01 14:31:30,419 WARN [org.apache.catalina.ha.session.DeltaManager] - Manager [localhost#/manager], requesting session state from org.apache.catalina.tribes.membership.MemberImpl[tcp://{10, -64, 104, -55}:15000,{10, -64, 104, -55},15000, alive=18586,id={-62 91 -70 -63 -111 50 70 -33 -104 41 -48 -32 91 34 -83 -55 }, payload={}, command={}, domain={}, ]. This operation will timeout if no session state has been received within 60 seconds. 2008-07-01 14:31:35,310 WARN [org.apache.catalina.ha.ClusterListener] - Context manager doesn't exist:localhost#/host-manager But it actually uses the correct timeout value (ie: "timing out after 10,100 ms"): 2008-07-01 14:31:40,518 ERROR [org.apache.catalina.ha.session.DeltaManager] - Manager [localhost#/manager]: No session state send at 01/07/08 14:31 received, timing out after 10,100 ms. This is only an incorrect message, but it is quite annoying especially coupled with the fact that the above configuration is only documented for tomcat 5 (where syntax is subtly different).</column><column name="report_time">2008-07-01 07:50:35</column><column name="report_timestamp">1214910000</column><column name="status">resolved fixed</column><column name="commit">36bb5d9</column><column name="commit_timestamp">1215030000</column><column name="files">java/org/apache/catalina/ha/session/DeltaManager.java</column><column name="result">1:java/org/apache/catalina/ha/session/DeltaManager.java</column></table><table name="tomcat"><column name="id">922</column><column name="bug_id">36155</column><column name="summary">tomcat chooses wrong host if using mod_jk</column><column name="description">Hi, my config is as follows: tomcat 5.5.9 knows two hosts, let's say the host "host1" and the host "host2". http://host1/ is basically a jsp-page echoing the string host1 - http://host2/ echos the string host2. apache 2.0.54 is configured with two vhost with ServerName host1 and host2. Both servers have a ServerAlias too - the one has ServerAlias alias1, the other has ServerAlias alias2 mod-jk 1.2.14 only knows one worker. My worker.properties looks like this: worker.list=worker1 worker.worker1.type=ajp13 worker.worker1.host=127.0.0.1 A very simple config. Both apache vhosts contain a "JkMount *.jsp worker1" Apache's UseCanonialName is on and Tomcats AJP-connector has useIPVHosts turned on. Therefor tomcat will chose the host by the server-name that mod_jk sends. So calling http://alias1/ results in a page containing the string host1, and calling http://alias2/ results in a page containing the string host2. The problem: Sometimes (not always and very selden) http://alias1 returns the string host2 and http://alias2 returns the string host1. I'm not sure, where the problem is, but i'm almost sure it's mod_jk - although i don't know, what should go wrong. I now defined a second worker with the same address and each of apache's vhosts use a different worker. The error didn't come up yet.</column><column name="report_time">2005-08-12 05:08:52</column><column name="report_timestamp">1123840000</column><column name="status">resolved fixed</column><column name="commit">f23907d</column><column name="commit_timestamp">1214620000</column><column name="files">java/org/apache/coyote/ajp/AjpMessage.java</column><column name="result">1051:java/org/apache/coyote/ajp/AjpMessage.java</column></table><table name="tomcat"><column name="id">923</column><column name="bug_id">45279</column><column name="summary">McastServiceImpl leaks sockets.</column><column name="description">McastServiceImpl does not close its socket in stop() as it claims. It merely calls leaveGroup(), which is sufficient to stop receiving messages, but does not close the socket. This causes a file descriptor leak each time the service is stopped. add; socket.close(); after leaveGroup();</column><column name="report_time">2008-06-25 12:21:15</column><column name="report_timestamp">1214410000</column><column name="status">resolved fixed</column><column name="commit">a2a7714</column><column name="commit_timestamp">1214430000</column><column name="files">java/org/apache/catalina/tribes/membership/McastServiceImpl.java</column><column name="result">1:java/org/apache/catalina/tribes/membership/McastServiceImpl.java</column></table><table name="tomcat"><column name="id">924</column><column name="bug_id">45101</column><column name="summary">DirContextURLConnection - Format Date Header Values per HTTP spec</column><column name="description">Created attachment 22035 Return Date header values in HTTP format When you retrieve a header value from a DirContextURLConnection, it currently returns a string by simply calling .toString() on the internal object, no matter the type of that Object. For Date value headers such as 'Last-Modified', this results in a String formatted according to Java standards, rather than the Date format specified by the HTTP standard as clients of the API would expect. This is a follow-up to bug 44611.</column><column name="report_time">2008-05-29 13:42:51</column><column name="report_timestamp">1212080000</column><column name="status">resolved fixed</column><column name="commit">e0200b0</column><column name="commit_timestamp">1212100000</column><column name="files">java/org/apache/naming/resources/DirContextURLConnection.java</column><column name="result">1:java/org/apache/naming/resources/DirContextURLConnection.java</column></table><table name="tomcat"><column name="id">925</column><column name="bug_id">42750</column><column name="summary">Http Post requests not handled correctly if there is more than one space between the "POST" and the URL</column><column name="description">When a Tomcat based Http listener receives a Soap request with more than one space between the "POST" command and the URL, this error response is returned by Tomcat version 5.5.20, and there is no response at all from other versions (4.0.2 and 5.0): HTTP/1.1 505 HTTP Version Not Supported Server: Apache-Coyote/1.1 Date: Fri, 08 Jun 2007 22:19:07 GMT Connection: close Here is what I mean about there being more than one space between the Post and the URL. In the examples below I leave out the body of the Soap request for simplification. I used the TCPMonitor supplied by the Apache project to capture a Soap request and here is how it is displayed in the monitor (it probably looks completely different on the wire): POST http://C010030S:5599/NXAServer/NextAxiomServer HTTP/1.0 User-Agent: Natural 4.2 Content-Type: text/xml; charset=utf-8 SOAPAction: urn:rpc?path=Training.webMethods.validateUserid Content-Length: 338 Note the four spaces between the "POST" and the URL in the first line. Now here is what the request looks like after removing three of the four spaces: POST http://C010030S:5599/NXAServer/NextAxiomServer HTTP/1.0 User-Agent: Natural 4.2 Content-Type: text/xml; charset=utf-8 SOAPAction: urn:rpc?path=Training.webMethods.validateUserid Content-Length: 338 The request seems to only get handled correctly by the Tomcat HTTP listener when there is one space between the "Post" and the URL. This example is from a Soap request issued by a Natural program running on a Z/OS mainframe. Instead of sending you a complete example to recreate the problem (which would require a mainframe) it would probably be easy to use the Apache TCP Monitor to capture a Soap request from an available test system and then add one of more spaces between the Post and the URL, resend the request in the monitor and see what happens. What I'm trying to do is invoke from Natural on a mainframe (which unfortunately we have no control over) a web service running on webMethods (IntegrationServer version 6.1 which uses Tomcat402B.jar, so that may be version 4.0.2B (?), and JVM 1.4.2_13). No response is returned at all from that version. I then tried to do the same thing with webMethods version 6.5 (which uses Tomcat 5.0 and JVM 1.4.2_07) and still got no response. Then I tried NextAxiom version 6.5.2.0 (which uses Tomcat version 5.5.20) and I at least got a response from it (see the response at the top of this description). I then tried invoking web services that use other Http listeners and found the two I tried handled the Soap request just fine. One example is IBM HTTP Server (version 1.3.8) that is running on a WebSphere server; it handles the request with more than one space just fine (by "fine" I mean it recognized the URL and handed it off to the process at that URL). The other I don't know much about; it was just some remote web service I found on the web (http://www.webserviceX.NET). I have looked through the Apache Tomcat website, documentation and an associate looked through the bug database for version 5, and we can't find anything that addresses this problem. I downloaded the source code, but got lost looking around and decided to ask for some help to find and fix this problem. Or maybe someone has an idea on how to configure the Http listener to handle this better. If this is a bug, I would be more than happy to attempt to fix this myself if someone could point me in the right direction. Thank you very very much for your time and efforts. Dick Salisbury Idaho Power Company dsalisbury@idahopower.com</column><column name="report_time">2007-06-26 16:57:13</column><column name="report_timestamp">1182890000</column><column name="status">resolved fixed</column><column name="commit">f93376d</column><column name="commit_timestamp">1211230000</column><column name="files">java/org/apache/coyote/http11/InternalAprInputBuffer.java
java/org/apache/coyote/http11/InternalInputBuffer.java
java/org/apache/coyote/http11/InternalNioInputBuffer.java</column><column name="result">113:java/org/apache/coyote/http11/InternalInputBuffer.java
126:java/org/apache/coyote/http11/InternalAprInputBuffer.java
175:java/org/apache/coyote/http11/InternalNioInputBuffer.java</column></table><table name="tomcat"><column name="id">926</column><column name="bug_id">44986</column><column name="summary">JSP compilation exception with pageEncoding="utf-8"  and file with byte order marks</column><column name="description">JSP-File has byte order marks. If the attribute is set to "UTF-8" (upper case) or the file has no byte order marks, the compilation workes fine. {code} 12:32:16,946 ERROR [[jsp]] Servlet.service() for servlet jsp threw exception org.apache.jasper.JasperException: /dialog.jsp(2,0) Page-encoding specified in XML prolog (UTF-8) is different from that specified in page directive (utf-8) at org.apache.jasper.compiler.DefaultErrorHandler.jspError(DefaultErrorHandler.java:40) at org.apache.jasper.compiler.ErrorDispatcher.dispatch(ErrorDispatcher.java:407) at org.apache.jasper.compiler.ErrorDispatcher.jspError(ErrorDispatcher.java:236) at org.apache.jasper.compiler.Validator$DirectiveVisitor.comparePageEncodings(Validator.java:362) at org.apache.jasper.compiler.Validator$DirectiveVisitor.visit(Validator.java:197) at org.apache.jasper.compiler.Node$PageDirective.accept(Node.java:590) at org.apache.jasper.compiler.Node$Nodes.visit(Node.java:2338) at org.apache.jasper.compiler.Node$Visitor.visitBody(Node.java:2388) at org.apache.jasper.compiler.Node$Visitor.visit(Node.java:2394) at org.apache.jasper.compiler.Node$Root.accept(Node.java:489) at org.apache.jasper.compiler.Node$Nodes.visit(Node.java:2338) at org.apache.jasper.compiler.Validator.validate(Validator.java:1700) at org.apache.jasper.compiler.Compiler.generateJava(Compiler.java:178) at org.apache.jasper.compiler.Compiler.compile(Compiler.java:306) at org.apache.jasper.compiler.Compiler.compile(Compiler.java:286) at org.apache.jasper.compiler.Compiler.compile(Compiler.java:273) at org.apache.jasper.JspCompilationContext.compile(JspCompilationContext.java:566) at org.apache.jasper.servlet.JspServletWrapper.service(JspServletWrapper.java:316) at org.apache.jasper.servlet.JspServlet.serviceJspFile(JspServlet.java:336) at org.apache.jasper.servlet.JspServlet.service(JspServlet.java:265) at javax.servlet.http.HttpServlet.service(HttpServlet.java:803) at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:290) at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:206) at org.apache.catalina.core.ApplicationDispatcher.invoke(ApplicationDispatcher.java:654) at org.apache.catalina.core.ApplicationDispatcher.processRequest(ApplicationDispatcher.java:445) at org.apache.catalina.core.ApplicationDispatcher.doForward(ApplicationDispatcher.java:379) at org.apache.catalina.core.ApplicationDispatcher.forward(ApplicationDispatcher.java:292) at de.cit.jsp.control.DispatchServlet.forward(DispatchServlet.java:286) at de.cit.jsp.control.DispatchServlet.doGet(DispatchServlet.java:272) at javax.servlet.http.HttpServlet.service(HttpServlet.java:690) at javax.servlet.http.HttpServlet.service(HttpServlet.java:803) at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:290) at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:206) at de.cit.util.javax.servlet.ValidationFilter.doFilter(ValidationFilter.java:108) at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:235) at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:206) at de.cit.util.javax.servlet.jsp.XHtmlContentTypeFilter.doFilter(XHtmlContentTypeFilter.java:36) at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:235) at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:206) at org.jboss.web.tomcat.filters.ReplyHeaderFilter.doFilter(ReplyHeaderFilter.java:96) at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:235) at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:206) at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:230) at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:175) at org.jboss.web.tomcat.security.SecurityAssociationValve.invoke(SecurityAssociationValve.java:179) at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:432) at org.jboss.web.tomcat.security.JaccContextValve.invoke(JaccContextValve.java:84) at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:127) at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:102) at org.jboss.web.tomcat.service.jca.CachedConnectionValve.invoke(CachedConnectionValve.java:157) at org.apache.catalina.authenticator.SingleSignOn.invoke(SingleSignOn.java:420) at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:109) at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:262) at org.apache.coyote.ajp.AjpProcessor.process(AjpProcessor.java:437) at org.apache.coyote.ajp.AjpProtocol$AjpConnectionHandler.process(AjpProtocol.java:366) at org.apache.tomcat.util.net.JIoEndpoint$Worker.run(JIoEndpoint.java:446) at java.lang.Thread.run(Thread.java:619) {code} Case insensitive camparison in org.apache.jasper.compiler.Validator.comparePageEncodings(...) seems to fix the problem: {code} /* * Compares page encodings specified in various places, and throws * exception in case of page encoding mismatch. * * @param pageDirEnc The value of the pageEncoding attribute of the page * directive @param pageDir The page directive node * * @throws JasperException in case of page encoding mismatch */ private String comparePageEncodings(String pageDirEnc, Node.PageDirective pageDir) throws JasperException { Node.Root root = pageDir.getRoot(); String configEnc = root.getJspConfigPageEncoding(); /* * Compare the 'pageEncoding' attribute of the page directive with * the encoding specified in the JSP config element whose URL * pattern matches this page. Treat "UTF-16", "UTF-16BE", and * "UTF-16LE" as identical. */ if (configEnc != null) { if (!pageDirEnc.equalsIgnoreCase(configEnc) &amp;&amp; (!pageDirEnc.toUpperCase().startsWith("UTF-16") || !configEnc .toUpperCase().startsWith("UTF-16"))) { err.jspError(pageDir, "jsp.error.config_pagedir_encoding_mismatch", configEnc, pageDirEnc); } else { return configEnc; } } /* * Compare the 'pageEncoding' attribute of the page directive with * the encoding specified in the XML prolog (only for XML syntax, * and only if JSP document contains XML prolog with encoding * declaration). Treat "UTF-16", "UTF-16BE", and "UTF-16LE" as * identical. */ if ((root.isXmlSyntax() &amp;&amp; root.isEncodingSpecifiedInProlog()) || root.isBomPresent()) { String pageEnc = root.getPageEncoding(); if (!pageDirEnc.equalsIgnoreCase(pageEnc) &amp;&amp; (!pageDirEnc.toUpperCase().startsWith("UTF-16") || !pageEnc .toUpperCase().startsWith("UTF-16"))) { err.jspError(pageDir, "jsp.error.prolog_pagedir_encoding_mismatch", pageEnc, pageDirEnc); } else { return pageEnc; } } return pageDirEnc; } {code}</column><column name="report_time">2008-05-13 04:42:11</column><column name="report_timestamp">1210670000</column><column name="status">resolved fixed</column><column name="commit">3c84dcf</column><column name="commit_timestamp">1210710000</column><column name="files">java/org/apache/jasper/compiler/Validator.java</column><column name="result">1:java/org/apache/jasper/compiler/Validator.java</column></table><table name="tomcat"><column name="id">927</column><column name="bug_id">42934</column><column name="summary">sessionDidActivate() called before contextInitialized()</column><column name="description">I'm using Seam and a Seam app depends upon the Seam application being initialized before you can do much of anything in Seam. That said Seam puts some hooks into the sessionDidActivate() and sessionDidPassivate() events. Because of that when I start up my app I'm getting a Seam IllegalStateException because the contextInitialized() event is fired after sessionDidActivate() so Seam is not yet initialized it's Session hooks are being fired. What makes me think this is a bug is that sessionWillPassivate() is being correctly called before contextDestroyed() so it would seem that sessionDidActivate() being called before contextInitialized() would be inconsistent behavior. So to sum up I think tomcat should fire context and session events in the following order: contextInitialized sessionDidActivate sessionWillPassivate contextDestroyed As a side note Tomcat 5 follows what I think is the completely wrong but consistent order by firing events in this order: sessionDidActivate contextInitialized contextDestroyed sessionWillPassivate</column><column name="report_time">2007-07-18 14:40:10</column><column name="report_timestamp">1184780000</column><column name="status">resolved fixed</column><column name="commit">a9cb6a6</column><column name="commit_timestamp">1210360000</column><column name="files">java/org/apache/catalina/core/StandardContext.java</column><column name="result">25:java/org/apache/catalina/core/StandardContext.java</column></table><table name="tomcat"><column name="id">928</column><column name="bug_id">42943</column><column name="summary">jsp:text gets confused with other *:text elements in a JSP tag file</column><column name="description">I have a JSP .tag file (label.tagx) that I want to use in other JSPs. The tag file looks as follows: &lt;jsp:root version="2.0" xmlns:jsp="http://java.sun.com/JSP/Page"&gt; &lt;jsp:directive.tag body-content="scriptless"/&gt; &lt;dul:text xmlns:dul="http://www.whatever.com/dul"&gt;&lt;jsp:doBody/&gt;&lt;/dul:text&gt; &lt;/jsp:root&gt; When I want to use this tag file in a JSP: ... &lt;tagx:label&gt;blablabla&lt;/tagx:label&gt; ... I get the stacktrace at the end of this message. However, if I replace the dul:text element with something else, such as dul:dul:textzz, then everything works fine: &lt;jsp:root version="2.0" xmlns:jsp="http://java.sun.com/JSP/Page"&gt; &lt;jsp:directive.tag body-content="scriptless"/&gt; &lt;dul:textzz xmlns:dul="http://www.whatever.com/dul"&gt;&lt;jsp:doBody/&gt;&lt;/dul:textzz&gt; &lt;/jsp:root&gt; Seems like the dul:text and jsp:text tags get confused (namespace problems?) somewhere during the page compilation. Stacktrace: 2007-07-20 12:05:50,828 [http-8080-Processor25] ERROR org.apache.struts.taglib.tiles.InsertTag - ServletException in '/WEB-INF/jsp/test-page.jsp': /WEB-INF/tags/label.tagx(6,90) &amp;lt;jsp:text&amp;gt; must not have any subelements org.apache.jasper.JasperException: /WEB-INF/tags/label.tagx(6,90) &amp;lt;jsp:text&amp;gt; must not have any subelements 	at org.apache.jasper.compiler.DefaultErrorHandler.jspError(DefaultErrorHandler.java:39) 	at org.apache.jasper.compiler.ErrorDispatcher.dispatch(ErrorDispatcher.java:409) 	at org.apache.jasper.compiler.ErrorDispatcher.jspError(ErrorDispatcher.java:90) 	at org.apache.jasper.compiler.JspDocumentParser.parse(JspDocumentParser.java:201) 	at org.apache.jasper.compiler.ParserController.doParse(ParserController.java:197) 	at org.apache.jasper.compiler.ParserController.parse(ParserController.java:101) 	at org.apache.jasper.compiler.Compiler.generateJava(Compiler.java:203) 	at org.apache.jasper.compiler.Compiler.compile(Compiler.java:495) 	at org.apache.jasper.compiler.Compiler.compile(Compiler.java:476) 	at org.apache.jasper.compiler.Compiler.compile(Compiler.java:464) 	at org.apache.jasper.JspCompilationContext.compile(JspCompilationContext.java:511) 	at org.apache.jasper.servlet.JspServletWrapper.loadTagFile(JspServletWrapper.java:201) 	at org.apache.jasper.compiler.TagFileProcessor.loadTagFile(TagFileProcessor.java:514) 	at org.apache.jasper.compiler.TagFileProcessor.access$000(TagFileProcessor.java:47) 	at org.apache.jasper.compiler.TagFileProcessor$TagFileLoaderVisitor.visit(TagFileProcessor.java:565) 	at org.apache.jasper.compiler.Node$CustomTag.accept(Node.java:1441) 	at org.apache.jasper.compiler.Node$Nodes.visit(Node.java:2163) 	at org.apache.jasper.compiler.Node$Visitor.visitBody(Node.java:2213) 	at org.apache.jasper.compiler.Node$Visitor.visit(Node.java:2324) 	at org.apache.jasper.compiler.Node$UninterpretedTag.accept(Node.java:1185) 	at org.apache.jasper.compiler.Node$Nodes.visit(Node.java:2163) 	at org.apache.jasper.compiler.Node$Visitor.visitBody(Node.java:2213) 	at org.apache.jasper.compiler.TagFileProcessor$TagFileLoaderVisitor.visit(TagFileProcessor.java:569) 	at org.apache.jasper.compiler.Node$CustomTag.accept(Node.java:1441) 	at org.apache.jasper.compiler.Node$Nodes.visit(Node.java:2163) 	at org.apache.jasper.compiler.Node$Visitor.visitBody(Node.java:2213) 	at org.apache.jasper.compiler.Node$Visitor.visit(Node.java:2224) 	at org.apache.jasper.compiler.Node$JspRoot.accept(Node.java:525) 	at org.apache.jasper.compiler.Node$Nodes.visit(Node.java:2163) 	at org.apache.jasper.compiler.Node$Visitor.visitBody(Node.java:2213) 	at org.apache.jasper.compiler.Node$Visitor.visit(Node.java:2219) 	at org.apache.jasper.compiler.Node$Root.accept(Node.java:456) 	at org.apache.jasper.compiler.Node$Nodes.visit(Node.java:2163) 	at org.apache.jasper.compiler.TagFileProcessor.loadTagFiles(TagFileProcessor.java:583) 	at org.apache.jasper.compiler.Compiler.generateJava(Compiler.java:226) 	at org.apache.jasper.compiler.Compiler.compile(Compiler.java:495) 	at org.apache.jasper.compiler.Compiler.compile(Compiler.java:476) 	at org.apache.jasper.compiler.Compiler.compile(Compiler.java:464) 	at org.apache.jasper.JspCompilationContext.compile(JspCompilationContext.java:511) 	at org.apache.jasper.servlet.JspServletWrapper.loadTagFile(JspServletWrapper.java:201) 	at org.apache.jasper.compiler.TagFileProcessor.loadTagFile(TagFileProcessor.java:514) 	at org.apache.jasper.compiler.TagFileProcessor.access$000(TagFileProcessor.java:47) 	at org.apache.jasper.compiler.TagFileProcessor$TagFileLoaderVisitor.visit(TagFileProcessor.java:565) 	at org.apache.jasper.compiler.Node$CustomTag.accept(Node.java:1441) 	at org.apache.jasper.compiler.Node$Nodes.visit(Node.java:2163) 	at org.apache.jasper.compiler.Node$Visitor.visitBody(Node.java:2213) 	at org.apache.jasper.compiler.Node$Visitor.visit(Node.java:2324) 	at org.apache.jasper.compiler.Node$UninterpretedTag.accept(Node.java:1185) 	at org.apache.jasper.compiler.Node$Nodes.visit(Node.java:2163) 	at org.apache.jasper.compiler.Node$Visitor.visitBody(Node.java:2213) 	at org.apache.jasper.compiler.Node$Visitor.visit(Node.java:2324) 	at org.apache.jasper.compiler.Node$UninterpretedTag.accept(Node.java:1185) 	at org.apache.jasper.compiler.Node$Nodes.visit(Node.java:2163) 	at org.apache.jasper.compiler.Node$Visitor.visitBody(Node.java:2213) 	at org.apache.jasper.compiler.TagFileProcessor$TagFileLoaderVisitor.visit(TagFileProcessor.java:569) 	at org.apache.jasper.compiler.Node$CustomTag.accept(Node.java:1441) 	at org.apache.jasper.compiler.Node$Nodes.visit(Node.java:2163) 	at org.apache.jasper.compiler.Node$Visitor.visitBody(Node.java:2213) 	at org.apache.jasper.compiler.Node$Visitor.visit(Node.java:2324) 	at org.apache.jasper.compiler.Node$UninterpretedTag.accept(Node.java:1185) 	at org.apache.jasper.compiler.Node$Nodes.visit(Node.java:2163) 	at org.apache.jasper.compiler.Node$Visitor.visitBody(Node.java:2213) 	at org.apache.jasper.compiler.Node$Visitor.visit(Node.java:2324) 	at org.apache.jasper.compiler.Node$UninterpretedTag.accept(Node.java:1185) 	at org.apache.jasper.compiler.Node$Nodes.visit(Node.java:2163) 	at org.apache.jasper.compiler.Node$Visitor.visitBody(Node.java:2213) 	at org.apache.jasper.compiler.Node$Visitor.visit(Node.java:2324) 	at org.apache.jasper.compiler.Node$UninterpretedTag.accept(Node.java:1185) 	at org.apache.jasper.compiler.Node$Nodes.visit(Node.java:2163) 	at org.apache.jasper.compiler.Node$Visitor.visitBody(Node.java:2213) 	at org.apache.jasper.compiler.TagFileProcessor$TagFileLoaderVisitor.visit(TagFileProcessor.java:569) 	at org.apache.jasper.compiler.Node$CustomTag.accept(Node.java:1441) 	at org.apache.jasper.compiler.Node$Nodes.visit(Node.java:2163) 	at org.apache.jasper.compiler.Node$Visitor.visitBody(Node.java:2213) 	at org.apache.jasper.compiler.Node$Visitor.visit(Node.java:2224) 	at org.apache.jasper.compiler.Node$JspRoot.accept(Node.java:525) 	at org.apache.jasper.compiler.Node$Nodes.visit(Node.java:2163) 	at org.apache.jasper.compiler.Node$Visitor.visitBody(Node.java:2213) 	at org.apache.jasper.compiler.Node$Visitor.visit(Node.java:2219) 	at org.apache.jasper.compiler.Node$Root.accept(Node.java:456) 	at org.apache.jasper.compiler.Node$Nodes.visit(Node.java:2163) 	at org.apache.jasper.compiler.TagFileProcessor.loadTagFiles(TagFileProcessor.java:583) 	at org.apache.jasper.compiler.Compiler.generateJava(Compiler.java:226) 	at org.apache.jasper.compiler.Compiler.compile(Compiler.java:495) 	at org.apache.jasper.compiler.Compiler.compile(Compiler.java:476) 	at org.apache.jasper.compiler.Compiler.compile(Compiler.java:464) 	at org.apache.jasper.JspCompilationContext.compile(JspCompilationContext.java:511) 	at org.apache.jasper.servlet.JspServletWrapper.service(JspServletWrapper.java:295) 	at org.apache.jasper.servlet.JspServlet.serviceJspFile(JspServlet.java:292) 	at org.apache.jasper.servlet.JspServlet.service(JspServlet.java:236) 	at javax.servlet.http.HttpServlet.service(HttpServlet.java:803) 	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:252) 	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:173) 	at org.apache.catalina.core.ApplicationDispatcher.invoke(ApplicationDispatcher.java:696) 	at org.apache.catalina.core.ApplicationDispatcher.doInclude(ApplicationDispatcher.java:585) 	at org.apache.catalina.core.ApplicationDispatcher.include(ApplicationDispatcher.java:510) 	at org.apache.jasper.runtime.JspRuntimeLibrary.include(JspRuntimeLibrary.java:966) 	at org.apache.jasper.runtime.PageContextImpl.include(PageContextImpl.java:602) 	at org.apache.struts.tiles.TilesUtilImpl.doInclude(TilesUtilImpl.java:101) 	at org.apache.struts.tiles.TilesUtil.doInclude(TilesUtil.java:137) 	at org.apache.struts.taglib.tiles.InsertTag.doInclude(InsertTag.java:758) 	at org.apache.struts.taglib.tiles.InsertTag$InsertHandler.doEndTag(InsertTag.java:890) 	at org.apache.struts.taglib.tiles.InsertTag.doEndTag(InsertTag.java:460) 	at org.apache.jsp.WEB_002dINF.jsp.layouts.default_jsp._jspx_meth_tiles_insert_4(default_jsp.java:401) 	at org.apache.jsp.WEB_002dINF.jsp.layouts.default_jsp._jspService(default_jsp.java:135) 	at org.apache.jasper.runtime.HttpJspBase.service(HttpJspBase.java:94) 	at javax.servlet.http.HttpServlet.service(HttpServlet.java:803) 	at org.apache.jasper.servlet.JspServletWrapper.service(JspServletWrapper.java:324) 	at org.apache.jasper.servlet.JspServlet.serviceJspFile(JspServlet.java:292) 	at org.apache.jasper.servlet.JspServlet.service(JspServlet.java:236) 	at javax.servlet.http.HttpServlet.service(HttpServlet.java:803) 	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:252) 	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:173) 	at org.apache.catalina.core.ApplicationDispatcher.invoke(ApplicationDispatcher.java:696) 	at org.apache.catalina.core.ApplicationDispatcher.processRequest(ApplicationDispatcher.java:474) 	at org.apache.catalina.core.ApplicationDispatcher.doForward(ApplicationDispatcher.java:409) 	at org.apache.catalina.core.ApplicationDispatcher.forward(ApplicationDispatcher.java:312) ...</column><column name="report_time">2007-07-20 03:46:22</column><column name="report_timestamp">1184920000</column><column name="status">resolved fixed</column><column name="commit">17b4436</column><column name="commit_timestamp">1210280000</column><column name="files">java/org/apache/jasper/compiler/JspDocumentParser.java</column><column name="result">95:java/org/apache/jasper/compiler/JspDocumentParser.java</column></table><table name="tomcat"><column name="id">929</column><column name="bug_id">43080</column><column name="summary">Suspicious url pattern warning logged to wrong webapp</column><column name="description">"Suspicious url pattern" warnings are logged to the wrong webapp, not the one actually using them. These log events are coming from SecurityCollection.java.</column><column name="report_time">2007-08-09 15:18:42</column><column name="report_timestamp">1186690000</column><column name="status">resolved fixed</column><column name="commit">332d0f0</column><column name="commit_timestamp">1209900000</column><column name="files">java/org/apache/catalina/core/StandardContext.java
java/org/apache/catalina/deploy/SecurityCollection.java</column><column name="result">1:java/org/apache/catalina/deploy/SecurityCollection.java
6:java/org/apache/catalina/core/StandardContext.java</column></table><table name="tomcat"><column name="id">930</column><column name="bug_id">43191</column><column name="summary">compressableMimeType attribute ignored</column><column name="description">I have set compression="on" and compressableMimeType="text/html" in server.xml. It appears that the value of compressableMimeType is being ignored. My XML responses are all coming back gzipped. If I switch to compression="off" the responses are not gzipped, but as soon as I turn it on, regardless of the value of compressableMimeType, the XML responses are coming back gzipped. A full Connector tag follows. Note that this is just an example -- I have tried many values for compressableMimeType (that do NOT include text/xml) and the responses are still compressed. &lt;Connector port="7630" address="${jboss.bind.address}" maxThreads="20" minSpareThreads="4" maxSpareThreads="10" strategy="ms" maxHttpHeaderSize="8192" emptySessionPath="true" enableLookups="false" redirectPort="7643" acceptCount="16" connectionTimeout="20000" disableUploadTimeout="true" compression="off" compressableMimeType="text/html,text/javascript,application/x-javascript,application/javascript" /&gt;</column><column name="report_time">2007-08-22 15:02:44</column><column name="report_timestamp">1187810000</column><column name="status">resolved fixed</column><column name="commit">e2524a8</column><column name="commit_timestamp">1209810000</column><column name="files">java/org/apache/coyote/http11/Http11AprProcessor.java
java/org/apache/coyote/http11/Http11NioProcessor.java
java/org/apache/coyote/http11/Http11Processor.java</column><column name="result">3:java/org/apache/coyote/http11/Http11Processor.java
5:java/org/apache/coyote/http11/Http11AprProcessor.java
6:java/org/apache/coyote/http11/Http11NioProcessor.java</column></table><table name="tomcat"><column name="id">931</column><column name="bug_id">43150</column><column name="summary">Tomcat and path with pound sign (#) -&gt; ClassNotFoundException</column><column name="description">Tomcat will not start if it's located and launched from a path with a # (pound) character somewhere. You'll find all informations in the given mail-thread on tomcat-user, including some developer specific informations. One part of the problem is the usage of File.toURL in URLClassloader... I'd really appreciate it if this problem could be fixed/worked around (see mail-thread for hints). btw. the same applies to version 5.5 and probably earlier versions too. thanks!</column><column name="report_time">2007-08-16 14:35:07</column><column name="report_timestamp">1187290000</column><column name="status">resolved fixed</column><column name="commit">fa91954</column><column name="commit_timestamp">1209680000</column><column name="files">java/org/apache/catalina/startup/ClassLoaderFactory.java
java/org/apache/jasper/JspCompilationContext.java</column><column name="result">2:java/org/apache/jasper/JspCompilationContext.java
33:java/org/apache/catalina/startup/ClassLoaderFactory.java</column></table><table name="tomcat"><column name="id">932</column><column name="bug_id">43142</column><column name="summary">webapp expanded in a FOLDER named webapps/xxx.war is loaded TWICE</column><column name="description">reproduce: copy the expanded of file xxx.war file in a FOLDER tomcat/webapps/xxx.war bug: tomcat will load the app TWICE</column><column name="report_time">2007-08-16 06:24:52</column><column name="report_timestamp">1187260000</column><column name="status">resolved fixed</column><column name="commit">6a8b1bb</column><column name="commit_timestamp">1209630000</column><column name="files">java/org/apache/catalina/startup/HostConfig.java</column><column name="result">2:java/org/apache/catalina/startup/HostConfig.java</column></table><table name="tomcat"><column name="id">933</column><column name="bug_id">43366</column><column name="summary">Session Statistics command in manager fails with "Unknown command /sessions"</column><column name="description">A documentation page for Tomcat 6 at http://tomcat.apache.org/tomcat-6.0-doc/manager-howto.html#Session%20Statistics allows for the following command to be used in the manager: http://localhost/manager/sessions?path=/ This used to work in Tomcat 5. In Tomcat 6, the following error is returned: FAIL - Unknown command /sessions I have created two different installations of Tomcat 6.0.14 (one on CentOS 5, and one on Fedora 7). Both installations exhibit the same failure.</column><column name="report_time">2007-09-12 08:15:55</column><column name="report_timestamp">1189600000</column><column name="status">resolved fixed</column><column name="commit">f4a7632</column><column name="commit_timestamp">1209320000</column><column name="files">java/org/apache/catalina/manager/ManagerServlet.java</column><column name="result">12:java/org/apache/catalina/manager/ManagerServlet.java</column></table><table name="tomcat"><column name="id">934</column><column name="bug_id">44877</column><column name="summary">ClassCastException due to bad TagHandlerPool name generation of two different tags</column><column name="description">Created attachment 21857 Small Eclipse 3.3 WST project The two different tags below will have the same TagHandlerPool name in the generated JSP. This will lead to a ClassCastException when accessing the JSP at runtime. &lt;bug:hello_world/&gt; &lt;bug:hello world="true"/&gt; ------------------- Top of stacktrace : java.lang.ClassCastException: fr.illod.tomcat.bug.taglib.HelloWorldTag 	org.apache.jsp.index_jsp._jspx_meth_bug_005fhello_005f0(index_jsp.java:115) 	org.apache.jsp.index_jsp._jspService(index_jsp.java:75) 	org.apache.jasper.runtime.HttpJspBase.service(HttpJspBase.java:98) ... -------------- The error seems to come from the "createTagHandlerPoolName" method in org.apache.jasper.compiler.Generator.java</column><column name="report_time">2008-04-25 13:43:26</column><column name="report_timestamp">1209150000</column><column name="status">resolved fixed</column><column name="commit">dfa25f4</column><column name="commit_timestamp">1209320000</column><column name="files">java/org/apache/jasper/compiler/Generator.java</column><column name="result">3:java/org/apache/jasper/compiler/Generator.java</column></table><table name="tomcat"><column name="id">935</column><column name="bug_id">43425</column><column name="summary">Non-compliant annotations</column><column name="description">A few of the annotations have compliance problem. javax.annotation.security.DenyAll @Target should only be METHOD javax.ejb.EJB missing description property javax.persistence.PersistenceContext missing properties property and associated PersistenceProperty annotation class The annotations can be verified by checking the JavaEE5 javadocs at http://java.sun.com/javaee/5/ docs/api/ I will post a patch to correct these problems.</column><column name="report_time">2007-09-18 21:33:56</column><column name="report_timestamp">1190170000</column><column name="status">resolved fixed</column><column name="commit">48131cd</column><column name="commit_timestamp">1209160000</column><column name="files">java/javax/annotation/security/DenyAll.java
java/javax/ejb/EJB.java
java/javax/persistence/PersistenceContext.java
java/javax/persistence/PersistenceProperty.java</column><column name="result" /></table><table name="tomcat"><column name="id">936</column><column name="bug_id">31257</column><column name="summary">java.endorsed.dirs is not used when JSP compilation is forked</column><column name="description">When the JSP compiler forks a javac process, it should check to see what the currently endorsed directories are (check the system property "java.endorsed.dirs" - otherwise, classes end up missing and JSP pages do not properly compile. We experienced a problem when we explicitly set the java.endorsed.dirs property on the command line, and the JSP compiler did not use it when javac was forked. I have patched org.apache.jasper.compiler.Compiler to support this: *** src.original\jakarta-tomcat-jasper\jasper2 \src\share\org\apache\jasper\compiler\Compiler.java Tue Jun 15 17:30:35 2004 --- src\org\apache\jasper\compiler\Compiler.java Thu Sep 16 00:05:14 2004 *************** *** 349,358 **** --- 349,369 ---- extdirs.setPath(exts); javac.setExtdirs(extdirs); info.append(" extension dir=" + exts + "\n"); } + // Add endorsed directories + String endorsed = System.getProperty("java.endorsed.dirs"); + if(endorsed != null) { + Javac.ImplementationSpecificArgument endorsedArg = javac.createCompilerArg(); + endorsedArg.setLine("-J-Djava.endorsed.dirs="+endorsed); + info.append(" endorsed dir=" + endorsed + "\n"); + } + else { + info.append(" no endorsed dirs specified\n"); + } + // Configure the compiler object javac.setEncoding(javaEncoding); javac.setClasspath(path); javac.setDebug(ctxt.getOptions().getClassDebugInfo()); true, i should probably check ctxt.getOptions().getFork() in the if() as well, but since i always fork it doesn't matter to me.</column><column name="report_time">2004-09-16 05:10:06</column><column name="report_timestamp">1095330000</column><column name="status">resolved fixed</column><column name="commit">0ea3e15</column><column name="commit_timestamp">1208730000</column><column name="files">java/org/apache/jasper/compiler/AntCompiler.java</column><column name="result">1:java/org/apache/jasper/compiler/AntCompiler.java</column></table><table name="tomcat"><column name="id">937</column><column name="bug_id">29936</column><column name="summary">XML parser loading problems by container</column><column name="description">I'm trying to use JSTL 1.1 with this version of tomcat and have both saxon and crimson in my web-app. If we have crimson and saxon in our webapp lib then tomcat tries to use crimson as the xml parser when reading the web.xml and compiling the jsp and we get the prefix error: org.apache.jasper.JasperException: &lt;h3&gt;Validation error messages from TagLibraryValidator for c&lt;/h3&gt;&lt;p&gt;null: java.lang.IllegalStateException: can't declare any more prefixes in this context&lt;/p&gt;&lt;h3&gt;Validation error messages from TagLibraryValidator for fmt&lt;/h3&gt;&lt;p&gt;null: java.lang.IllegalStateException: can't declare any more prefixes in this context&lt;/p&gt; If we remove crimson, tomcat uses saxon (aelfred parser) and this fails on reading the web.xml (javax.xml.parsers.ParserConfigurationException: AElfred parser is namespace-aware) If we remove saxon and crimson then we are okay (defaults to xerces in the tomcat endorsed directory?) It seems to me that tomcat is using the parser in my web-app to read the web.xml rather than using xerces from the endorsed directory. The same web-app runs without problems in version 5.0.16. Tomcat seems to be using the service provider mechanism in 5.0.25 as I have property files in C:\Java\jakarta-tomcat-5.0.25 \work\Catalina\localhost\diabetes\loader\META-INF\services (can't find any documents on this). If I'm using more than one parser won't this cause problems as tomcat is setting only one parser and xslt processor here? Any comments are gratefully received. Thanks, Peter Neville</column><column name="report_time">2004-07-06 15:18:51</column><column name="report_timestamp">1089140000</column><column name="status">resolved fixed</column><column name="commit">06c23d8</column><column name="commit_timestamp">1208720000</column><column name="files">java/org/apache/catalina/startup/ContextConfig.java</column><column name="result">10:java/org/apache/catalina/startup/ContextConfig.java</column></table><table name="tomcat"><column name="id">938</column><column name="bug_id">44380</column><column name="summary">TldConfig / Scan of URL that are not files</column><column name="description">The TldConfig class (org.apache.catalina.startup) is asking ClassLoader and all parent ClassLoader in order to get the URLs and then assume that the URLs are using "file" protocol. But when Tomcat is embedded, sometimes the URL are not always using "file" protocol and then new File() will fail. The given patch is to skip the URLs that are not using file protocol (that avoids ugly NPE in the "new File(urls[i].toURI());" call</column><column name="report_time">2008-02-08 05:29:21</column><column name="report_timestamp">1202470000</column><column name="status">resolved fixed</column><column name="commit">2edf51e</column><column name="commit_timestamp">1207960000</column><column name="files">java/org/apache/catalina/startup/TldConfig.java</column><column name="result">1:java/org/apache/catalina/startup/TldConfig.java</column></table><table name="tomcat"><column name="id">939</column><column name="bug_id">44389</column><column name="summary">Cleanup of org.apache.naming.resources.CacheEntry resources (memory leak)</column><column name="description">Hi, I am memory profiling a webapp for my company because we suspect it has memory leaks when redeploying. This webapp has to be redeployed several times a week for security reasons (most of the time it is undeployed) and the memory leaks forced us to shutdown tomcat once a week to avoid OOM exception. I'm using jvm1.5 and tomcat 6.0.13 (also tried with 6.0.14 and today with 6.0.16), and Yourkit as the profiling tool. I have made the test in both linux and windows. I have created a JMeter test to deploy the app using the manager, make some request to the app and then undeploy it using again the manager app in a loop. After some redeployments, I got my OutOfMemoryException. Then I checked with my profiling tool and found that my own classes were correctly destroyed, and the classes retaining more memory were these ones (listed as a heirarchy): org.apache.catalina.core.ApplicationContext$DispatchData org.apache.catalina.core.ApplicationContext mapper of org.apache.catalina.core.StandardContext context of org.apache.tomcat.util.http.mapper.Mapper resources of org.apache.tomcat.util.http.mapper.Mapper$Context cache of org.apache.naming.resources.ProxyDirContext cache of org.apache.naming.resources.ResourceCache org.apache.naming.resources.CacheEntry[] The number of objects of each class were exactly the number of times I had redeployed the webapp. I have checked the contents of CacheEntry inside CacheEntry[] and it has an attribute "name" and the contents are the jsps and tld files of my app. There are as many CacheEntry with the same jsp attribute as times the webapp has been reloaded, so I guess there is no cleaning of CacheEntry resources at context shutdown. To reproduce this, a simple webapp with 2 jsp and a taglibrary can be used. Deploy and undeploy it many times so you can see how the count of these objects grows in memory.</column><column name="report_time">2008-02-11 02:03:09</column><column name="report_timestamp">1202710000</column><column name="status">resolved fixed</column><column name="commit">6723b35</column><column name="commit_timestamp">1207950000</column><column name="files">java/org/apache/catalina/core/ApplicationContext.java</column><column name="result">5:java/org/apache/catalina/core/ApplicationContext.java</column></table><table name="tomcat"><column name="id">940</column><column name="bug_id">44391</column><column name="summary">SSI handling of escaped characters broken</column><column name="description">In org.apache.catalina.ssi.SSIProcessor the method parseParamNames is broken. If I have a SSI directive like &lt;!--#set var="test" value="blubb\"\"" --&gt; the method detects three parameters instead of two. This is because there are two consecutive escaped characters. Although the first one \" is detected correctly the next one isn't because the flag escaped is still set to true, although this character isn't escaped anymore. You have to replace boolean escaped = false; for (; bIdx &lt; cmd.length() &amp;&amp; quotes != 2; bIdx++) { char c = cmd.charAt(bIdx); // Need to skip escaped characters if (c == '\\' &amp;&amp; !escaped) { escaped = true; bIdx++; continue; } escaped = false; if (c == '"') quotes++; } by for (; bIdx &lt; cmd.length() &amp;&amp; quotes != 2; bIdx++) { char c = cmd.charAt(bIdx); // Need to skip escaped characters if (c == '\\') { bIdx++; continue; } if (c == '"') quotes++; } Just removing the flag escaped is sufficient, because you don't have to remember whether the last character was escaped and that should have no influence to consecutive characters. The bug still exists in the HEAD revision of the repository.</column><column name="report_time">2008-02-11 04:37:40</column><column name="report_timestamp">1202720000</column><column name="status">resolved fixed</column><column name="commit">df75937</column><column name="commit_timestamp">1207950000</column><column name="files">java/org/apache/catalina/ssi/SSIProcessor.java</column><column name="result">1:java/org/apache/catalina/ssi/SSIProcessor.java</column></table><table name="tomcat"><column name="id">941</column><column name="bug_id">44392</column><column name="summary">HTML entities not resolved in SSI filter</column><column name="description">HTML entities which are contained in an SSI set directive aren't resolved by the SSI filter (in contrary to what is done by mod_include of Apaches HTTP). mod_include resolves all HTML entities in most of the attribute values of ssi directives. It also resolves \" to " and \$ to $. The ssi filter of tomcat resolves all escaped character which are escaped with a backslash, but no HTML entities at all. Apart from that, giving encoding "entity" should be different from giving encoding="none" to the SSI echo directive. One should replace all invalid HTML characters by valid HTML entities and the other one should do nothing. The encoding is especially important if you wan't to store a HTML-Comment within a SSI variable. If I want to store a variable test with the value "&lt;!-- testvalue "x" --&gt;" &lt;!--#set var="test" value="&lt;!-- testvalue "x" --&gt;"--&gt; for mod_include you must write: &lt;!--#set var="test" value="&lt;!&amp;#45;&amp;#45; testvalue \"x\" &amp;#45;&amp;#45;&gt;" --&gt; for Tomcats SSI you must write: &lt;!--#set var="test" value="&lt;!\-\- testvalue \"x\" \-\-&gt;" --&gt; And there should be a difference whether I output this variable with &lt;!--#echo var="test" encoding="none" --&gt; which should lead to &lt;!-- testvalue "x" --&gt;, or &lt;!--#echo var="test" encoding="entity" --&gt; which should lead to &amp;lt;!-- testvalue &amp;quot;x&amp;quot; --&amp;gt;</column><column name="report_time">2008-02-11 05:37:37</column><column name="report_timestamp">1202730000</column><column name="status">resolved fixed</column><column name="commit">75fbd91</column><column name="commit_timestamp">1207940000</column><column name="files">java/org/apache/catalina/ssi/SSIEcho.java
java/org/apache/catalina/ssi/SSIMediator.java</column><column name="result">2:java/org/apache/catalina/ssi/SSIEcho.java
6:java/org/apache/catalina/ssi/SSIMediator.java</column></table><table name="tomcat"><column name="id">942</column><column name="bug_id">44408</column><column name="summary">EL-expression evaluation slow due to synchronization caused by JspFactory.getDefaultFactory</column><column name="description">Tomcat version 6.0.16 trunk (and earlier) PageContextImpl.java has: public static Object proprietaryEvaluate() that does a: final ExpressionFactory exprFactory = JspFactory.getDefaultFactory().get JspApplicationContext(pageContext.getServletContext()).getExpressionFactory(); Our benchmarking of pages using large amounts of EL-expression shows this turns into a bottleneck due to the fact that JspFactory.getDefaultFactory() is synchronized. The bug is very similar to bug #41558 I have a patch that fixes the issue, coming up...</column><column name="report_time">2008-02-13 03:36:02</column><column name="report_timestamp">1202890000</column><column name="status">resolved fixed</column><column name="commit">1f41c3d</column><column name="commit_timestamp">1207850000</column><column name="files">java/org/apache/jasper/runtime/PageContextImpl.java</column><column name="result">6:java/org/apache/jasper/runtime/PageContextImpl.java</column></table><table name="tomcat"><column name="id">943</column><column name="bug_id">44428</column><column name="summary">FunctionMapperImpl.Function throws a NPE in certain circumstances</column><column name="description">In FunctionMapperImpl.Function it is possible for writeExternal to fail if the class has just been de-serialised and is then serialised again. If you look at writeExternal: public void writeExternal(ObjectOutput out) throws IOException { out.writeUTF((this.prefix != null) ? this.prefix : ""); out.writeUTF(this.localName); out.writeUTF(this.m.getDeclaringClass().getName()); out.writeUTF(this.m.getName()); out.writeObject(ReflectionUtil.toTypeNameArray( this.m.getParameterTypes())); } you can see that it externalises the function to be invoked by using the reference to the Method itself. If you look at readExternal however: public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException { this.prefix = in.readUTF(); if ("".equals(this.prefix)) this.prefix = null; this.localName = in.readUTF(); this.owner = in.readUTF(); this.name = in.readUTF(); this.types = (String[]) in.readObject(); } You can see that it doesn't restore the Method after deserialisation. The method is restored if it is accessed, however if it's not and then serialisation is performed writeExternal will throw a NPE (as m is still null). The fix is to either get the method to be reconstructed as soon as deserialisation completes - or perhaps to be a bit more efficient, in writeExternal change it such that if m is null it externalises using the components of the method: public void writeExternal(ObjectOutput out) throws IOException { out.writeUTF((this.prefix != null) ? this.prefix : ""); out.writeUTF(this.localName); if (m == null) { out.writeUTF(this.owner); out.writeUTF(this.name); out.writeObject(this.types); } else if (this.m != null) { out.writeUTF(this.m.getDeclaringClass().getName()); out.writeUTF(this.m.getName()); out.writeObject(ReflectionUtil.toTypeNameArray( this.m.getParameterTypes())); } }</column><column name="report_time">2008-02-15 02:36:16</column><column name="report_timestamp">1203060000</column><column name="status">resolved fixed</column><column name="commit">0035fd4</column><column name="commit_timestamp">1207780000</column><column name="files">java/org/apache/el/lang/FunctionMapperImpl.java</column><column name="result">1:java/org/apache/el/lang/FunctionMapperImpl.java</column></table><table name="tomcat"><column name="id">944</column><column name="bug_id">44595</column><column name="summary">Add possibility to request the QueueSize of an executor via JMX</column><column name="description">Created attachment 21660 Patch against 6.0.16 The attached patch adds the possibility to check the QueueSize of an executor via JMX.</column><column name="report_time">2008-03-13 01:34:50</column><column name="report_timestamp">1205390000</column><column name="status">resolved fixed</column><column name="commit">c3c525b</column><column name="commit_timestamp">1207560000</column><column name="files">java/org/apache/catalina/core/StandardThreadExecutor.java</column><column name="result">16:java/org/apache/catalina/core/StandardThreadExecutor.java</column></table><table name="tomcat"><column name="id">945</column><column name="bug_id">44529</column><column name="summary">RealmBase authorization via hasResourcePermission not fully servlet spec compliant</column><column name="description">The authorization implementation in RealmBase, in the hasResourcePermission method is not fully servlet specification compliant. The spec (both 2.4 and 2.5) states: "... A security constraint that does not contain an authorization constraint shall combine with authorization constraints that name or imply roles to allow unauthenticated access. The special case of an authorization constraint that names no roles shall combine with any other constraints to override their affects and cause access to be precluded. ..." In Tomcat this works fine as long as there aren't weird (but legal!) combinations or security-constraints on the same URLs. Example: &lt;security-constraint&gt; &lt;web-resource-collection&gt; &lt;url-pattern&gt;/someUrl/*&lt;/url-pattern&gt; &lt;http-method&gt;POST&lt;/http-method&gt; &lt;/web-resource-collection&gt; &lt;!-- no auth-constraint, to allow everyone --&gt; &lt;/security-constraint&gt; &lt;security-constraint&gt; &lt;web-resource-collection&gt; &lt;url-pattern&gt;/someUrl/*&lt;/url-pattern&gt; &lt;http-method&gt;POST&lt;/http-method&gt; &lt;/web-resource-collection&gt; &lt;!-- no roles, to allow noone --&gt; &lt;auth-constraint /&gt; &lt;/security-constraint&gt; (if we ignore that this kind of configuration is pretty pointless,) the spec dictates that a POST to /someUrl/index.html should be denied access. Tomcat grants it. (both 5.5.23 and 6.0.14 do) Example 2: &lt;security-constraint&gt; &lt;web-resource-collection&gt; &lt;url-pattern&gt;/someUrl/*&lt;/url-pattern&gt; &lt;http-method&gt;POST&lt;/http-method&gt; &lt;/web-resource-collection&gt; &lt;!-- no roles, to allow noone --&gt; &lt;auth-constraint /&gt; &lt;/security-constraint&gt; &lt;security-constraint&gt; &lt;web-resource-collection&gt; &lt;url-pattern&gt;/someUrl/*&lt;/url-pattern&gt; &lt;http-method&gt;POST&lt;/http-method&gt; &lt;/web-resource-collection&gt; &lt;auth-constraint&gt; &lt;role-name&gt;*&lt;/role-name&gt; &lt;/auth-constraint&gt; &lt;/security-constraint&gt; Now it gets interesting. In "strict" mode, access to /someUrl/index.html is denied (regardless of the web.xml-configured security roles and the roles the user has). In "auth-only" mode, access is always granted, and in "strict auth-only" mode access is granted if there are no web.xml-configured security roles. Now these modes are a Tomcat addition to the spec, but I feel access should have been denied in all modes, both to stay in line with the spec and to keep the behaviour predictable.</column><column name="report_time">2008-03-04 08:04:54</column><column name="report_timestamp">1204640000</column><column name="status">resolved fixed</column><column name="commit">7be2374</column><column name="commit_timestamp">1206800000</column><column name="files">java/org/apache/catalina/realm/RealmBase.java</column><column name="result">1:java/org/apache/catalina/realm/RealmBase.java</column></table><table name="tomcat"><column name="id">946</column><column name="bug_id">44673</column><column name="summary">ServletInputStream still readable even when closed</column><column name="description">Created attachment 21716 Echo "OK" if the behaviour is correct, "KO" otherwise InputBuffer does not check "closed" in any read, mark, skip operation, thus bytes can be read even when the application has requested to close the inputstream. This causes programming problems to go unnoticed. See the attached test case.</column><column name="report_time">2008-03-25 15:32:18</column><column name="report_timestamp">1206470000</column><column name="status">resolved fixed</column><column name="commit">ca41a27</column><column name="commit_timestamp">1206490000</column><column name="files">java/org/apache/catalina/connector/InputBuffer.java</column><column name="result">16:java/org/apache/catalina/connector/InputBuffer.java</column></table><table name="tomcat"><column name="id">947</column><column name="bug_id">44646</column><column name="summary">IllegalStateException when using CometConnectionManagerValve</column><column name="description">We're writing an application that processes requests using both a normal servlet and a CometProcessor. The normal servlet handles user authentication and logout (among other things). Once the user has been authenticated, the client makes a Comet request, which is open until the server has something to push to the client. When the user decides to log out, we need to stop processing Comet events for that client. I enabled the CometConnectionManagerValve in context.xml, hoping I would get an END event when the session goes away. Instead, I get an IllegalStateException: Mar 10, 2008 2:05:41 PM org.apache.catalina.connector.CoyoteAdapter event SEVERE: An exception or error occurred in the container during the request processing java.lang.IllegalStateException: Cannot create a session after the response has been committed at org.apache.catalina.connector.Request.doGetSession(Request.java:2301) at org.apache.catalina.connector.Request.getSession(Request.java:2075) at org.apache.catalina.valves.CometConnectionManagerValve.event(CometConnectionManagerValve.java:311) at org.apache.catalina.core.StandardHostValve.event(StandardHostValve.java:179) at org.apache.catalina.valves.ValveBase.event(ValveBase.java:200) at org.apache.catalina.core.StandardEngineValve.event(StandardEngineValve.java:128) at org.apache.catalina.connector.CoyoteAdapter.event(CoyoteAdapter.java:198) at org.apache.coyote.http11.Http11NioProcessor.event(Http11NioProcessor.java:749) at org.apache.coyote.http11.Http11NioProtocol$Http11ConnectionHandler.event(Http11NioProtocol.java:653) at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.run(NioEndpoint.java:2080) at java.util.concurrent.ThreadPoolExecutor$Worker.runTask(ThreadPoolExecutor.java:885) at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:907) at java.lang.Thread.run(Thread.java:619) Presumably my servlet handles the "logout" request, and after sending a response to the client, calls invalidate() on the HttpSession. Subsequently, CometConnectionManagerValue.event() calls request.getSession(true), resulting in the IllegalStateException.</column><column name="report_time">2008-03-20 09:33:14</column><column name="report_timestamp">1206020000</column><column name="status">resolved fixed</column><column name="commit">fdac1d6</column><column name="commit_timestamp">1206310000</column><column name="files">java/org/apache/catalina/valves/CometConnectionManagerValve.java</column><column name="result">1:java/org/apache/catalina/valves/CometConnectionManagerValve.java</column></table><table name="tomcat"><column name="id">948</column><column name="bug_id">44558</column><column name="summary">cite attempted address when throwing "Cannot assign requested address"</column><column name="description">SEVERE: Error starting endpoint java.net.BindException: Cannot assign requested address:2217 at org.apache.tomcat.util.net.JIoEndpoint.init(JIoEndpoint.java:501) at org.apache.tomcat.util.net.JIoEndpoint.start(JIoEndpoint.java:515) at org.apache.coyote.http11.Http11Protocol.start(Http11Protocol.java:203) at org.apache.catalina.connector.Connector.start(Connector.java:1131) at org.apache.catalina.core.StandardService.start(StandardService.java:531) at org.apache.catalina.core.StandardServer.start(StandardServer.java:710) at org.apache.catalina.startup.Catalina.start(Catalina.java:578) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) saying which address a bind was attempted for would accelerate the error resolution quite a bit!</column><column name="report_time">2008-03-07 07:41:10</column><column name="report_timestamp">1204890000</column><column name="status">resolved fixed</column><column name="commit">7bd915c</column><column name="commit_timestamp">1205080000</column><column name="files">java/org/apache/tomcat/util/net/JIoEndpoint.java</column><column name="result">1:java/org/apache/tomcat/util/net/JIoEndpoint.java</column></table><table name="tomcat"><column name="id">949</column><column name="bug_id">44562</column><column name="summary">HEAD requests cannot go through request dispatch include.</column><column name="description">See https://issues.apache.org/jira/browse/GERONIMO-3896 briefly... tomcat complains: Servlet.service() for servlet SimpleDispatchServlet threw exception javax.servlet.ServletException: Original SevletResponse or wrapped original ServletResponse not passed to RequestDispatcher in violation of SRV.8.2 and SRV.14.2.5.1 at org.apache.catalina.core.ApplicationDispatcher.checkSameObjects(ApplicationDispatcher.java:985) ... The relevant code seems to be in javax.servlet.http.HttpServlet protected void doHead(HttpServletRequest req, HttpServletResponse resp) 	throws ServletException, IOException { 	NoBodyResponse response = new NoBodyResponse(resp); 	 	doGet(req, response); 	response.setContentLength(); } which is fine but class NoBodyResponse implements HttpServletResponse { rather than class NoBodyResponse extends HttpServletResponseWrapper { The patch attached to the jira issue makes this change and adapts NoBodyResponse to be a subclass of HttpServletResponseWrapper and the user reports that it fixes the problem. I don't know if there would be formatting issues applying the patch to tomcat's copy of the spec classes.</column><column name="report_time">2008-03-07 13:19:40</column><column name="report_timestamp">1204910000</column><column name="status">resolved fixed</column><column name="commit">288b2ae</column><column name="commit_timestamp">1205080000</column><column name="files">java/javax/servlet/http/HttpServlet.java</column><column name="result">14:java/javax/servlet/http/HttpServlet.java</column></table><table name="tomcat"><column name="id">950</column><column name="bug_id">44337</column><column name="summary">Dir listing crashes if no readme-file present</column><column name="description">DefaultServlet docu 6.0 says about attibute readmeFile: If a directory listing is presented, a readme file *may* also be presented with the listing. This file is inserted ..... This was true for 5.5.x. 6.0.14 crashes if the file is absent in the listed directory. javax.servlet.ServletException: Error opening readme resource at org.apache.catalina.servlets.DefaultServlet.getReadme(DefaultServlet.java:1418) This new behaviour blocks the listing of big directory trees managed by others, where the work-around is nor feasible. Work around 1: readme file in *every* subdir, empty (length=0) if none wanted (and subsequent changes in the used XSL-Transformers) Work around 2: Change "may" to "must" in docu. Repair: fix DefaultServlet From web.xml: &lt;servlet&gt; &lt;servlet-name&gt;default&lt;/servlet-name&gt; &lt;servlet-class&gt;org.apache.catalina.servlets.DefaultServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;listings&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;globalXsltFile&lt;/param-name&gt; &lt;param-value&gt;D:\www\serv-intra\meva-dir-li.xsl&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;readmeFile&lt;/param-name&gt; &lt;param-value&gt;readme.htm&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt;</column><column name="report_time">2008-02-01 01:54:32</column><column name="report_timestamp">1201850000</column><column name="status">resolved fixed</column><column name="commit">8a3b14b</column><column name="commit_timestamp">1202090000</column><column name="files">java/org/apache/catalina/servlets/DefaultServlet.java</column><column name="result">1:java/org/apache/catalina/servlets/DefaultServlet.java</column></table><table name="tomcat"><column name="id">951</column><column name="bug_id">43701</column><column name="summary">Error while starting tomcat</column><column name="description">this is my NIO Connector configuration in server.xml &lt;Connector acceptCount="100" enableLookups="false" port="80" protocol="org.apache.coyote.http11.Http11NioProtocol" acceptorThreadCount="2" socket.bufferPool="-1" connectionTimeout="60000" maxKeepAliveRequests="-1" maxThreads="200" minSpareThreads="25" redirectPort="8443" /&gt; when I am starting my tomcat it is giving following error in the console several time SEVERE: java.lang.NullPointerException 	at org.apache.tomcat.util.net.NioEndpoint.setSocketOptions(NioEndpoint.java:985) 	at org.apache.tomcat.util.net.NioEndpoint$Acceptor.run(NioEndpoint.java:1169) 	at java.lang.Thread.run(Thread.java:595)</column><column name="report_time">2007-10-26 03:01:21</column><column name="report_timestamp">1193380000</column><column name="status">resolved fixed</column><column name="commit">bf6ce6f</column><column name="commit_timestamp">1202070000</column><column name="files">java/org/apache/tomcat/util/net/NioEndpoint.java</column><column name="result">1:java/org/apache/tomcat/util/net/NioEndpoint.java</column></table><table name="tomcat"><column name="id">952</column><column name="bug_id">44282</column><column name="summary">WebappClassLoader.findClass calls getClassLoader without privileges</column><column name="description">When logging is in TRACE mode or lower, org.apache.catalina.loader.WebappClassLoader.findClass(String) calls getClassLoader() without a privileged block. With security enabled, this will cause a SecurityException if the RuntimePermission to getClassLoader is not granted.</column><column name="report_time">2008-01-22 23:50:47</column><column name="report_timestamp">1201060000</column><column name="status">resolved fixed</column><column name="commit">948598d</column><column name="commit_timestamp">1201740000</column><column name="files">java/org/apache/catalina/loader/WebappClassLoader.java</column><column name="result">1:java/org/apache/catalina/loader/WebappClassLoader.java</column></table><table name="tomcat"><column name="id">953</column><column name="bug_id">44268</column><column name="summary">Multiple registrations of same ServletContextListener class not possible</column><column name="description">When I register the same class implementing ServletContextListener twice or more its' contextInitialized methods only gets called once. The servlet specifications (2.4 and 2.5) say the conforming container has to call the listeners in the same order they are registered in the deployment descriptor. The case that one listener class is registered twice is not mentioned explicitly in the specification, though. Example: &lt;listener&gt; &lt;listener-class&gt;test.ServletContextListener1&lt;/listener-class&gt; &lt;/listener&gt; &lt;listener&gt; &lt;listener-class&gt;test.ServletContextListener2&lt;/listener-class&gt; &lt;/listener&gt; &lt;listener&gt; &lt;listener-class&gt;test.ServletContextListener1&lt;/listener-class&gt; &lt;/listener&gt; test.ServletContextListener1 and test.ServletContextListener2 get called, but test.ServletContextListener1 does not get called again. Apache Tomcat 5.5.25 has the same bug.</column><column name="report_time">2008-01-18 08:42:18</column><column name="report_timestamp">1200660000</column><column name="status">resolved fixed</column><column name="commit">cdff09f</column><column name="commit_timestamp">1200950000</column><column name="files">java/org/apache/catalina/core/StandardContext.java</column><column name="result">6:java/org/apache/catalina/core/StandardContext.java</column></table><table name="tomcat"><column name="id">954</column><column name="bug_id">44223</column><column name="summary">Tomcat ignores the "javax.net.ssl.trustStoreType" system property</column><column name="description">Set up a SSL Connector with a keystore in JKS format: &lt;Connector ... SSLEnabled="true" keystoreFile="tomcat.keystore" keystoreType="JKS"&gt; Let's say you need a custom truststore (e.g. for authenticating self-signed client certificates), and that this truststore is also needed by some of your webapps, not only Tomcat. The natural thing to do then is to configure this truststore globally for the whole JVM, not in server.xml. Let's also assume this truststore is in a different format (e.g. PKCS#12). So before starting Tomcat, you do this: export JAVA_OPTS="-Djavax.net.ssl.trustStore=trusted.keystore - Djavax.net.ssl.trustStoreType=PKCS12" Well, it doesn't work. If you look at tomcat/logs/catalina.out, you will see a keystore-related exception. Upon further debugging, you will discover the problem is that Tomcat is trying to open the truststore as if it were in JKS format, even though it is clearly specified as type PKCS12 in JAVA_OPTS above.</column><column name="report_time">2008-01-14 04:24:16</column><column name="report_timestamp">1200300000</column><column name="status">resolved fixed</column><column name="commit">f9e41b8</column><column name="commit_timestamp">1200690000</column><column name="files">java/org/apache/tomcat/util/net/jsse/JSSESocketFactory.java</column><column name="result">2:java/org/apache/tomcat/util/net/jsse/JSSESocketFactory.java</column></table><table name="tomcat"><column name="id">955</column><column name="bug_id">43468</column><column name="summary">HTMLManagerServlet NullPointerException listing context</column><column name="description">Obtained the following NullPointerException, stack trace below java.lang.NullPointerException 	org.apache.catalina.manager.HTMLManagerServlet.list(HTMLManagerServlet.java:437) 	org.apache.catalina.manager.HTMLManagerServlet.doGet(HTMLManagerServlet.java:136) Code is: args[11] = new Integer(context.getManager().getMaxInactiveInterval()/60); Seemingly the getManager() is returning null.</column><column name="report_time">2007-09-24 18:46:12</column><column name="report_timestamp">1190670000</column><column name="status">resolved fixed</column><column name="commit">e14afee</column><column name="commit_timestamp">1200530000</column><column name="files">java/org/apache/catalina/manager/HTMLManagerServlet.java</column><column name="result">1:java/org/apache/catalina/manager/HTMLManagerServlet.java</column></table><table name="tomcat"><column name="id">956</column><column name="bug_id">11117</column><column name="summary">Coyote connector does not correctly deal with large PUT when using chunked transfer encoding</column><column name="description">I've built a small test servlet (included below) that shows this behaviour. If I upload data to tomcat (configured to use the HTTP/1.1 Coyote connector) using a chunked transfer-encoding on a PUT, then the result (i.e. what I read using the servlet's request.getInputStream() is corrupted. This _only_ happens on large PUTs (it happens every time I tried it (about 10) on a large PUT - I was testing with something around 700 kB, and another thing of about 1 MB, but does NOT always corrupt it in the same way. I did not see any corruption on small files (~50 kB and smaller), though I didn't test this extensively. The total length of the data read is exactly correct (712080 bytes in my first test). At the first point of corruption in the file, a chunk header appears in the output ("\r\n1000\r\n") followed by correct data from about 700 bytes later on, then a second copy (in the correct place, I think) of the corrupt data (i.e. correct data, followed by the chunk header, followed by some data repeated, the second instance of which is in the correct place - so the first instance is being produced _instead_ of the correct data for that point in the input). Test servlet follows: import java.io.*; import javax.servlet.*; import javax.servlet.http.*; public class Test extends HttpServlet { public void doPut(HttpServletRequest req, HttpServletResponse res) throws ServletException, IOException { FileOutputStream fos = new FileOutputStream("/tmp/servlet-out"); InputStream is = req.getInputStream(); byte buf[] = new byte[2000]; int ret; while((ret = is.read(buf)) &gt; 0) { fos.write(buf, 0, ret); } fos.close(); is.close(); PrintWriter pw = res.getWriter(); pw.println("Done"); pw.flush(); pw.close(); } }</column><column name="report_time">2002-07-24 07:44:57</column><column name="report_timestamp">1027510000</column><column name="status">resolved fixed</column><column name="commit">1cc6641</column><column name="commit_timestamp">1199830000</column><column name="files">java/org/apache/coyote/http11/filters/ChunkedInputFilter.java</column><column name="result">107:java/org/apache/coyote/http11/filters/ChunkedInputFilter.java</column></table><table name="tomcat"><column name="id">957</column><column name="bug_id">43743</column><column name="summary">Cannot jspc precompile jsps with nested .tag files</column><column name="description">myjsp.jsp: HELLO &lt;tag1/&gt; tag1.tag: &lt;tag2&gt; tag2.tag: WORLD Crashes (null pointer) while trying to load tag2.class, called by TagFileProcessor.loadTagFile. Very Initial analysis:- TagFileProcessor.loadTagFile creates wrapper, but ctxt.getTagFileJarUrl (tagFilePath) returns null for nested .tag. Thus in JspCompilationContext.Compile JspCCtx.isPackagedFile == false, so outDated test is wrong So tag2.tag not compiled, thus class cannot be loaded. But problem also appears if tags not packaged in a .jar, so there is more going on. Work around is to create dummy.jsp that calls the .tags in leaf first order so .class files are created.</column><column name="report_time">2007-10-30 21:25:38</column><column name="report_timestamp">1193790000</column><column name="status">resolved fixed</column><column name="commit">98b8ba2</column><column name="commit_timestamp">1199750000</column><column name="files">java/org/apache/jasper/compiler/Parser.java</column><column name="result">41:java/org/apache/jasper/compiler/Parser.java</column></table><table name="tomcat"><column name="id">958</column><column name="bug_id">43758</column><column name="summary">java.lang.NullPointerException from org.apache.jasper.compiler.ServletWriter.printMultiLn() on validation of JSPX with empty &lt;jsp:scriptlet&gt; element</column><column name="description">Provided a JSPX with empty jsp:scriptlet element: &lt;jsp:root xmlns:jsp="http://java.sun.com/JSP/Page" xmlns="http://www.w3.org/1999/xhtml" version="2.0"&gt; &lt;jsp:scriptlet&gt;&lt;/jsp:scriptlet&gt; &lt;html&gt; &lt;head&gt;&lt;title&gt;Simple jspx page&lt;/title&gt;&lt;/head&gt; &lt;body&gt;Place content here&lt;/body&gt; &lt;/html&gt; &lt;/jsp:root&gt; Validated this with Jasper using ant task, similar to one described in http://tomcat.apache.org/tomcat-4.1-doc/jasper-howto.html (adjusted to Tomcat 6, of course). Got the trace: java.lang.NullPointerException 	at org.apache.jasper.compiler.ServletWriter.printMultiLn(ServletWriter.java:169) 	at org.apache.jasper.compiler.Generator$GenerateVisitor.visit(Generator.java:883) 	at org.apache.jasper.compiler.Node$Scriptlet.accept(Node.java:915) 	at org.apache.jasper.compiler.Node$Nodes.visit(Node.java:2336) 	at org.apache.jasper.compiler.Node$Visitor.visitBody(Node.java:2386) 	at org.apache.jasper.compiler.Node$Visitor.visit(Node.java:2397) 	at org.apache.jasper.compiler.Node$JspRoot.accept(Node.java:566) 	at org.apache.jasper.compiler.Node$Nodes.visit(Node.java:2336) 	at org.apache.jasper.compiler.Node$Visitor.visitBody(Node.java:2386) 	at org.apache.jasper.compiler.Node$Visitor.visit(Node.java:2392) 	at org.apache.jasper.compiler.Node$Root.accept(Node.java:489) 	at org.apache.jasper.compiler.Node$Nodes.visit(Node.java:2336) 	at org.apache.jasper.compiler.Generator.generate(Generator.java:3374) 	at org.apache.jasper.compiler.Compiler.generateJava(Compiler.java:210) 	at org.apache.jasper.compiler.Compiler.compile(Compiler.java:306) 	at org.apache.jasper.JspC.processFile(JspC.java:1007) 	at org.apache.jasper.JspC.execute(JspC.java:1156) 	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) 	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) 	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25) 	at java.lang.reflect.Method.invoke(Method.java:585) 	at org.apache.tools.ant.dispatch.DispatchUtils.execute(DispatchUtils.java:105) 	at org.apache.tools.ant.TaskAdapter.execute(TaskAdapter.java:134) 	at org.apache.tools.ant.UnknownElement.execute(UnknownElement.java:288) 	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) 	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) 	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25) 	at java.lang.reflect.Method.invoke(Method.java:585) 	at org.apache.tools.ant.dispatch.DispatchUtils.execute(DispatchUtils.java:105) 	at org.apache.tools.ant.Task.perform(Task.java:348) 	at org.apache.tools.ant.Target.execute(Target.java:357) 	at org.apache.tools.ant.Target.performTasks(Target.java:385) 	at org.apache.tools.ant.Project.executeSortedTargets(Project.java:1329) 	at org.apache.tools.ant.Project.executeTarget(Project.java:1298) 	at org.apache.tools.ant.helper.DefaultExecutor.executeTargets(DefaultExecutor.java:41) 	at org.apache.tools.ant.Project.executeTargets(Project.java:1181) 	at org.apache.tools.ant.Main.runBuild(Main.java:698) 	at org.apache.tools.ant.Main.startAnt(Main.java:199) 	at org.apache.tools.ant.launch.Launcher.run(Launcher.java:257) 	at org.apache.tools.ant.launch.Launcher.main(Launcher.java:104) 	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) 	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) 	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25) 	at java.lang.reflect.Method.invoke(Method.java:585) 	at com.intellij.rt.ant.execution.AntMain2.main(AntMain2.java:17) Without &lt;jsp:scriptlet&gt;&lt;/jsp:scriptlet&gt; there is no problem.</column><column name="report_time">2007-10-31 11:58:06</column><column name="report_timestamp">1193850000</column><column name="status">resolved fixed</column><column name="commit">61ce1a3</column><column name="commit_timestamp">1199220000</column><column name="files">java/org/apache/jasper/compiler/Node.java</column><column name="result">184:java/org/apache/jasper/compiler/Node.java</column></table><table name="tomcat"><column name="id">959</column><column name="bug_id">43868</column><column name="summary">MBeanServer invoke issue</column><column name="description">Impossible to invoke "removeRole" or other MBean methods and "setAttribute" by MBeanServer cause of the same bug in ManagedBean.java at both lines 545 (getSetter method) and 604 (getInvoke method): object = this; Must be replace by: object = bean; Fortunately getGetter method is correct.</column><column name="report_time">2007-11-15 01:26:51</column><column name="report_timestamp">1195110000</column><column name="status">resolved fixed</column><column name="commit">ccadbbc</column><column name="commit_timestamp">1198970000</column><column name="files">java/org/apache/tomcat/util/modeler/ManagedBean.java</column><column name="result">1:java/org/apache/tomcat/util/modeler/ManagedBean.java</column></table><table name="tomcat"><column name="id">960</column><column name="bug_id">43285</column><column name="summary">Missing EL Coercion causes argument type mismatch</column><column name="description">I'll attach a sample web application reproducing the error. Note that this error only occurs when using Tomcat 6.0.x (i.e. it works with Jetty as it uses Sun's EL RI). Moreover it doesn't matter which JSF implementation you're using to reproduce the error (I just wanted to mention that as it's definitely no bug in MyFaces even though the following stack trace shows a FacesException). The exception stack trace: javax.faces.FacesException: Exception while calling broadcast on component : {Component-Path : [Class: javax.faces.component.UIViewRoot,ViewId: /home.jsp][ Class: javax.faces.component.html.HtmlForm,Id: j_id_jsp_923754602_1][Class: javax.faces.component.html.HtmlCommandButton,Id: j_id_jsp_923754602_3]} at javax.faces.component.UIComponentBase.broadcast(UIComponentBase.java:494) at javax.faces.component.UICommand.broadcast(UICommand.java:105) at javax.faces.component.UIViewRoot._broadcastForPhase(UIViewRoot.java:292) at javax.faces.component.UIViewRoot.process(UIViewRoot.java:209) at javax.faces.component.UIViewRoot.processApplication(UIViewRoot.java:117) at org.apache.myfaces.lifecycle.InvokeApplicationExecutor.execute(InvokeApplicationExecutor.java:32) at org.apache.myfaces.lifecycle.LifecycleImpl.executePhase(LifecycleImpl.java:95) at org.apache.myfaces.lifecycle.LifecycleImpl.execute(LifecycleImpl.java:70) at javax.faces.webapp.FacesServlet.service(FacesServlet.java:144) at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:290) at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:206) at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:233) at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:175) at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:128) at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:102) at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:109) at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:263) at org.apache.coyote.http11.Http11Processor.process(Http11Processor.java:844) at org.apache.coyote.http11.Http11Protocol$Http11ConnectionHandler.process(Http11Protocol.java:584) at org.apache.tomcat.util.net.JIoEndpoint$Worker.run(JIoEndpoint.java:447) at java.lang.Thread.run(Thread.java:619) Caused by: org.apache.jasper.el.JspELException: /home.jsp(12,3) '#{numberBean.number}' java.lang.IllegalArgumentException: argument type mismatch at org.apache.jasper.el.JspValueExpression.setValue(JspValueExpression.java:94) at org.apache.myfaces.event.SetPropertyActionListener.processAction(SetPropertyActionListener.java:72) at javax.faces.event.ActionEvent.processListener(ActionEvent.java:48) at javax.faces.component.UIComponentBase.broadcast(UIComponentBase.java:489) ... 20 more Caused by: java.lang.IllegalArgumentException: argument type mismatch at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25) at java.lang.reflect.Method.invoke(Method.java:597) at javax.el.BeanELResolver.setValue(BeanELResolver.java:108) at javax.el.CompositeELResolver.setValue(CompositeELResolver.java:68) at org.apache.myfaces.el.unified.resolver.FacesCompositeELResolver.access$501(FacesCompositeELResolver.java:46) at org.apache.myfaces.el.unified.resolver.FacesCompositeELResolver$6.invoke(FacesCompositeELResolver.java:132) at org.apache.myfaces.el.unified.resolver.FacesCompositeELResolver.invoke(FacesCompositeELResolver.java:148) at org.apache.myfaces.el.unified.resolver.FacesCompositeELResolver.setValue(FacesCompositeELResolver.java:128) at org.apache.el.parser.AstValue.setValue(AstValue.java:114) at org.apache.el.ValueExpressionImpl.setValue(ValueExpressionImpl.java:249) at org.apache.jasper.el.JspValueExpression.setValue(JspValueExpression.java:85) ... 23 more</column><column name="report_time">2007-09-02 13:14:26</column><column name="report_timestamp">1188750000</column><column name="status">resolved fixed</column><column name="commit">c5bcc98</column><column name="commit_timestamp">1198720000</column><column name="files">java/org/apache/el/parser/AstValue.java</column><column name="result">14:java/org/apache/el/parser/AstValue.java</column></table><table name="tomcat"><column name="id">961</column><column name="bug_id">42503</column><column name="summary">ServletContext.getResourceAsStream returns stale data</column><column name="description">Under certain conditions, the resource cache implementation used by the servlet/JSP engine (in org.apache.naming.resource) does not detect that a file in its cache has been modified and therefore returns the previous contents of the file. This happens only * when the file contents are modified but the file length doesn't change * until the time the first change in the file is detected after server startup To reproduce the problem, put the attached test.jsp and test.txt into the ROOT web app and then do the following. (I used Tomcat 6's trunk for the test) % cat test.txt abcd % telnet . 9080 Trying 0.0.0.0... Connected to .. Escape character is '^]'. GET /test.jsp HTTP/1.0 HTTP/1.1 200 OK Server: Apache-Coyote/1.1 Set-Cookie: JSESSIONID=706D6FE8B06687509D42E79DBEE266EF; Path=/ Content-Type: text/html Content-Length: 26 Date: Wed, 23 May 2007 23:03:05 GMT Connection: close File contents=[ abcd ] Connection to . closed by foreign host. % cat test.txt (change the contents but not the size) efgh % telnet . 9080 Trying 0.0.0.0... Connected to .. Escape character is '^]'. GET /test.jsp HTTP/1.0 HTTP/1.1 200 OK Server: Apache-Coyote/1.1 Set-Cookie: JSESSIONID=2B144247B747F54184114FA82869DE14; Path=/ Content-Type: text/html Content-Length: 26 Date: Wed, 23 May 2007 23:04:24 GMT Connection: close File contents=[ abcd ]</column><column name="report_time">2007-05-23 16:52:35</column><column name="report_timestamp">1179950000</column><column name="status">resolved fixed</column><column name="commit">2441155</column><column name="commit_timestamp">1198720000</column><column name="files">java/org/apache/naming/resources/FileDirContext.java</column><column name="result">186:java/org/apache/naming/resources/FileDirContext.java</column></table><table name="tomcat"><column name="id">962</column><column name="bug_id">43914</column><column name="summary">HTTP spec violation when generating HTTP redirects for folders without trailing slash</column><column name="description">Copy the attached static.war into $CATALINA_HOME/webapps. Then start the server and paste this HTTP request in netcat: GET /static/name%20with%20spaces HTTP/1.1 User-Agent: Jakarta Commons-HttpClient/3.0 Host: localhost:8080 Tomcat will answer with the following HTTP redirect: HTTP/1.1 302 Moved Temporarily Server: Apache-Coyote/1.1 Location: http://localhost:8080/static/name with spaces/ Transfer-Encoding: chunked Date: Tue, 20 Nov 2007 13:46:12 GMT Observe the Location: header. It has raw unencoded spaces in the URL which is in clear violation of the HTTP specification.</column><column name="report_time">2007-11-20 05:53:53</column><column name="report_timestamp">1195560000</column><column name="status">resolved fixed</column><column name="commit">e452200</column><column name="commit_timestamp">1198700000</column><column name="files">java/org/apache/catalina/connector/CoyoteAdapter.java</column><column name="result">95:java/org/apache/catalina/connector/CoyoteAdapter.java</column></table><table name="tomcat"><column name="id">963</column><column name="bug_id">43909</column><column name="summary">EL EvaluationContext wrapper hides locale</column><column name="description">org.apache.el.lang.EvaluationContext doesn't pass locale to the wrapped ELContext as does org.apache.jasper.el.ELContextWrapper. This prohibits using of the locale for it's original purpose.</column><column name="report_time">2007-11-19 23:06:25</column><column name="report_timestamp">1195530000</column><column name="status">resolved fixed</column><column name="commit">fdb170e</column><column name="commit_timestamp">1198520000</column><column name="files">java/org/apache/el/lang/EvaluationContext.java</column><column name="result">2:java/org/apache/el/lang/EvaluationContext.java</column></table><table name="tomcat"><column name="id">964</column><column name="bug_id">43944</column><column name="summary">org.apache.el.lang.ELArithmetic.coerce throws MissingResourceException for key el.convert</column><column name="description">The class org.apache.el.lang.ELArithmetic has the following code snippet: throw new IllegalArgumentException(MessageFactory.get("el.convert", obj, objType)); But the key "el.convert" doesn't exist in "org.apache.el.Messages". As a result, I'm receiving the exception: java.util.MissingResourceException: Can't find resource for bundle java.util.PropertyResourceBundle, key el.convert 	at java.util.ResourceBundle.getObject(ResourceBundle.java:325) 	at java.util.ResourceBundle.getString(ResourceBundle.java:285) 	at org.apache.el.util.MessageFactory.getArray(MessageFactory.java:67) 	at org.apache.el.util.MessageFactory.get(MessageFactory.java:47) 	at org.apache.el.lang.ELArithmetic.coerce(ELArithmetic.java:367) 	at org.apache.el.lang.ELArithmetic.add(ELArithmetic.java:238) 	at org.apache.el.parser.AstPlus.getValue(AstPlus.java:24) 	at org.apache.el.ValueExpressionImpl.getValue (ValueExpressionImpl.java:186)</column><column name="report_time">2007-11-22 19:23:45</column><column name="report_timestamp">1195780000</column><column name="status">resolved fixed</column><column name="commit">c228054</column><column name="commit_timestamp">1198510000</column><column name="files">java/org/apache/el/lang/ELArithmetic.java</column><column name="result">1:java/org/apache/el/lang/ELArithmetic.java</column></table><table name="tomcat"><column name="id">965</column><column name="bug_id">44088</column><column name="summary">Cannot expire session via html manager webapp</column><column name="description">The html manager webapp done not work correctly when clicking the expire sessions button. The idle param is missing from the form. The following html shows this bug... &lt;form method="POST" action="/manager/html/expire?path=/"&gt; &lt;small&gt; &amp;nbsp;&lt;input type="submit" value="Expire sessions"&gt;&amp;nbsp;with idle &amp;ge;&amp;nbsp;&lt;input type="text" name="expire" size="5" value="30"&gt;&amp;nbsp;minutes&amp;nbsp; &lt;/small&gt; &lt;/form&gt; The name of the text input should be idle.</column><column name="report_time">2007-12-17 15:14:23</column><column name="report_timestamp">1197920000</column><column name="status">resolved fixed</column><column name="commit">df2b1e6</column><column name="commit_timestamp">1198450000</column><column name="files">java/org/apache/catalina/manager/HTMLManagerServlet.java</column><column name="result">1:java/org/apache/catalina/manager/HTMLManagerServlet.java</column></table><table name="tomcat"><column name="id">966</column><column name="bug_id">44084</column><column name="summary">JAASRealm useContextClassLoader has problems</column><column name="description">The useContextClassLoader config option doesn't work right. - it is ignored when setting userClassNames and roleClassNames - it's respected when the LoginContext is created, but that is insufficient, because all the needed classes are not necessarily loaded until loginContext.login() is called Patch to follow. With it I'm able to keep everything related to the JAASRealm in my webapp.</column><column name="report_time">2007-12-15 14:27:25</column><column name="report_timestamp">1197750000</column><column name="status">resolved fixed</column><column name="commit">46721e4</column><column name="commit_timestamp">1198450000</column><column name="files">java/org/apache/catalina/realm/JAASRealm.java</column><column name="result">1:java/org/apache/catalina/realm/JAASRealm.java</column></table><table name="tomcat"><column name="id">967</column><column name="bug_id">43236</column><column name="summary">Response.setCharacterEncoding() fails after Response.getWriter() and Response.reset()</column><column name="description">The class org.apache.catalina.connector.Response resets the internal hold coyoteResponse and outputBuffer during reset(): public void reset() { if (included) return; // Ignore any call from an included servlet coyoteResponse.reset(); outputBuffer.reset(); } but if anyone has already set the characterEncoding (e.g. to UTF-8) and already got the writer, than all following invocations of request.setCharacterEncoding() will do nothing, because the internal save flag for usingWriter is not reseted. This is very annoying, because the coyoteResponse.reset(), resets the characterEncoding to iso8859-1. So I have no change to change/reset the charaterEncoding to UTF-8. I'll think if you reset the response, you should also reset the usingWriter flag or add another special flag, that works with this circumstances.</column><column name="report_time">2007-08-29 03:56:43</column><column name="report_timestamp">1188370000</column><column name="status">resolved fixed</column><column name="commit">71bd193</column><column name="commit_timestamp">1198020000</column><column name="files">java/org/apache/catalina/connector/Response.java</column><column name="result">1:java/org/apache/catalina/connector/Response.java</column></table><table name="tomcat"><column name="id">968</column><column name="bug_id">43241</column><column name="summary">ServletContext.getResourceAsStream()  does not follow API specs for Path</column><column name="description">Say for example, you have a file style.css deployed in your context. The call to ServletContext.getResourceAsStream("style.css") returns an input stream. This is not correct behavior. The spec (2.3) says: &gt; The path must be specified according to &gt; the rules given in getResource. getResource() says: &gt; The path must begin with a "/" and is interpreted &gt; as relative to the current context root. My reading of these two things is that getResourceAsStream("style.css") should return null, not an input stream to the file. I got bit on this because my app behavior changed (broke) when ran on the current version of WebSphere.</column><column name="report_time">2007-08-29 12:54:18</column><column name="report_timestamp">1188410000</column><column name="status">resolved fixed</column><column name="commit">8f91433</column><column name="commit_timestamp">1198020000</column><column name="files">java/org/apache/catalina/core/ApplicationContext.java</column><column name="result">7:java/org/apache/catalina/core/ApplicationContext.java</column></table><table name="tomcat"><column name="id">969</column><column name="bug_id">43611</column><column name="summary">autodeployment with unpackWARs="true" does not work, when a context for that war file exists in server.xml</column><column name="description">if a context for the war file exists in server.xml, the manager uploads the new .war file, but does not expand it, if the necessary directory does not exist, and if the directory exists, it is not overwritten, so you see the old application. see server.xml &lt;Host name="xxx" appBase="webapps" unpackWARs="true"&gt; &lt;Context path="/yyy"&gt; ... if I don't have a context for yyy in server.xml, autodeploy works as expected. Even if you say, remove context from the manager application, it is always there in the application view, you can't remove it. And finally, it never cleans up the work directory for the application yyy, which I guess, is just a subsequent error of the above behaviour.</column><column name="report_time">2007-10-12 05:15:52</column><column name="report_timestamp">1192180000</column><column name="status">resolved fixed</column><column name="commit">ffbbe88</column><column name="commit_timestamp">1196530000</column><column name="files">java/org/apache/catalina/manager/HTMLManagerServlet.java</column><column name="result">7:java/org/apache/catalina/manager/HTMLManagerServlet.java</column></table><table name="tomcat"><column name="id">970</column><column name="bug_id">43622</column><column name="summary">compression / minCompressionSize attribute not properly implemented</column><column name="description">2 of the compression related attributes for the http connector are: compression = on | off | force | &lt;integer val&gt; The documentation states that integer val will be implemented as: compression="on" and minCompressionSize = &lt;integer val&gt; minCompressionSize = &lt;integer val&gt; (The documentation for 5.5.12 doesnt mention this at all, but read this in the server.xml) The problem is that the documenation gives the impression that only setting compression="some integer val" is sufficient, however the way the code is written, the value of "minCompressionSize" always overrides the value specified in the "compression" field. Even if minCompressionSize isnt set, it will still get the default value of 2048 and override whatever value was there in the "compression" field. I looked at the implementation of the http11 connector and found the following code that might be the culprit: In org.apache.coyote.http11.Http11BaseProtocol.Http11ConnectionHandler.init processor.setCompression( proto.compression ); processor.setCompressionMinSize( proto.compressionMinSize); since the "setCompressionMinSize" is called after compressionMinSize, its value will override the value read from compression atttribute. I have looked at the code for Tomcat 6.0 also, and the problems appears to still be present.</column><column name="report_time">2007-10-15 03:51:24</column><column name="report_timestamp">1192430000</column><column name="status">resolved fixed</column><column name="commit">d1d0619</column><column name="commit_timestamp">1196450000</column><column name="files">java/org/apache/coyote/http11/Http11AprProtocol.java
java/org/apache/coyote/http11/Http11NioProtocol.java
java/org/apache/coyote/http11/Http11Protocol.java</column><column name="result">4:java/org/apache/coyote/http11/Http11NioProtocol.java
5:java/org/apache/coyote/http11/Http11Protocol.java
6:java/org/apache/coyote/http11/Http11AprProtocol.java</column></table><table name="tomcat"><column name="id">971</column><column name="bug_id">43757</column><column name="summary">Improper parsing of response.sendRedirect() in JSP source</column><column name="description">Tomcat is throwing a java.lang.illegalStateException due to an attempted response.sendRedirect() after the time for such matters has come and gone... But, this appears to be a symptom of bad .jsp parsing at runtime. ========================== org.apache.jasper.JasperException: Exception in JSP: /buslog.jsp:42 39: // if (session.getAttribute("isAuth") == null) { 40: // session.setAttribute("messageToUser","Authentication failed."); 41: // you.shouldNotParseThis(); 42: // response.sendRedirect("./index.jsp"); 43: // } 44: 45: // if (session.getAttribute("isAuth") != null) { ============================== These lines are commented out in the source, and should not conceivably cause a runtime error. Changing "response.sendRedirect(...)" to "response.sendAbendOMG(...)" suppresses the error. I am willing to provide the complete source if necessary. Build and execution environments are NetBeans 5.5.1 with bundled Tomcat 5.5.17.</column><column name="report_time">2007-10-31 11:55:53</column><column name="report_timestamp">1193850000</column><column name="status">resolved fixed</column><column name="commit">eb87635</column><column name="commit_timestamp">1196380000</column><column name="files">java/org/apache/jasper/compiler/ErrorDispatcher.java</column><column name="result">14:java/org/apache/jasper/compiler/ErrorDispatcher.java</column></table><table name="tomcat"><column name="id">972</column><column name="bug_id">43706</column><column name="summary">Fix a litmus warning for WebdavServlet</column><column name="description">The litmus WebDAV compliance test suite produces a couple of warnings in its 'copymove' group of tests. This is the output on tomcat6 trunk: $ env TESTS="copymove" litmus http://localhost:8080/webdav/ -&gt; running `copymove': 0. init.................. pass 1. begin................. pass 2. copy_init............. pass 3. copy_simple........... WARNING: COPY to new resource didn't give 201 ...................... pass (with 1 warning) 4. copy_overwrite........ pass 5. copy_cleanup.......... pass 6. copy_coll............. pass 7. move.................. WARNING: MOVE to new resource didn't give 201 ...................... pass (with 1 warning) 8. move_coll............. pass 9. move_cleanup.......... pass 10. finish................ pass &lt;- summary for `copymove': of 11 tests run: 11 passed, 0 failed. 100.0% -&gt; 2 warnings were issued. With my patch the warnings are gone: $ env TESTS="copymove" litmus http://localhost:8080/webdav/ -&gt; running `copymove': 0. init.................. pass 1. begin................. pass 2. copy_init............. pass 3. copy_simple........... pass 4. copy_overwrite........ pass 5. copy_cleanup.......... pass 6. copy_coll............. pass 7. move.................. pass 8. move_coll............. pass 9. move_cleanup.......... pass 10. finish................ pass &lt;- summary for `copymove': of 11 tests run: 11 passed, 0 failed. 100.0%</column><column name="report_time">2007-10-26 07:03:28</column><column name="report_timestamp">1193400000</column><column name="status">resolved fixed</column><column name="commit">324387d</column><column name="commit_timestamp">1196200000</column><column name="files">java/org/apache/catalina/servlets/WebdavServlet.java</column><column name="result">1:java/org/apache/catalina/servlets/WebdavServlet.java</column></table><table name="tomcat"><column name="id">973</column><column name="bug_id">43887</column><column name="summary">StandardWrapper.registerJMX() doesn't log exceptions correctly</column><column name="description">I was getting some rather unhelpful error messages when trying to deploy a web.xml that included illegal servlet names. I tracked them down to this part of /org/apache/catalina/core/StandardWrapper.java: } catch( Exception ex ) { log.info("Error registering servlet with jmx " + this); } This should probably be changed to: log.info("Error registering servlet with jmx " + ex); Same thing for the catch block ten lines below this one. I first noticed this in 5.5.23, but this code is still present in 6.0 trunk.</column><column name="report_time">2007-11-16 15:31:21</column><column name="report_timestamp">1195250000</column><column name="status">resolved fixed</column><column name="commit">9314e5b</column><column name="commit_timestamp">1195850000</column><column name="files">java/org/apache/catalina/core/StandardWrapper.java</column><column name="result">1:java/org/apache/catalina/core/StandardWrapper.java</column></table><table name="tomcat"><column name="id">974</column><column name="bug_id">43893</column><column name="summary">WebdavServlet returns incorrect values for the "href" property when it is mapped with / url prefix, instead of /*</column><column name="description">Deploy the attached WAR file under a vanilla installation of Tomcat 6.0.14, then send the following WebDAV request (I simply pasted it in netcat, maybe telnet will work too if you don't have netcat): PROPFIND /webdav/file.txt HTTP/1.1 Content-Type: text/xml; charset=utf-8 User-Agent: Jakarta Commons-HttpClient/3.0 Host: localhost:8080 Depth: 0 Don't forget to press enter twice at the end. Observe the result: &lt;?xml version="1.0" encoding="utf-8" ?&gt; &lt;multistatus xmlns="DAV:"&gt;&lt;response&gt;&lt;href&gt;/webdav/file.txt/file.txt&lt;/href&gt; &lt;propstat&gt;&lt;prop&gt;&lt;creationdate&gt;2007-11-18T07:42:14Z&lt;/creationdate&gt; &lt;displayname&gt;&lt;![CDATA[file.txt]]&gt;&lt;/displayname&gt; &lt;getlastmodified&gt;Sun, 18 Nov 2007 07:42:14 GMT&lt;/getlastmodified&gt; &lt;getcontentlength&gt;0&lt;/getcontentlength&gt; &lt;getcontenttype&gt;text/plain&lt;/getcontenttype&gt; &lt;getetag&gt;W/"0-1195371734000"&lt;/getetag&gt; &lt;resourcetype/&gt;&lt;source&gt;&lt;/source&gt; &lt;supportedlock&gt;&lt;lockentry&gt;&lt;lockscope&gt;&lt;exclusive/&gt;&lt;/lockscope&gt;&lt;locktype&gt;&lt;write/ &gt;&lt;/locktype&gt;&lt;/lockentry&gt;&lt;lockentry&gt;&lt;lockscope&gt;&lt;shared/&gt;&lt;/ lockscope&gt;&lt;locktype&gt;&lt;write/&gt;&lt;/locktype&gt;&lt;/lockentry&gt;&lt;/supportedlock&gt; &lt;/prop&gt; &lt;status&gt;HTTP/1.1 200 OK&lt;/status&gt; &lt;/propstat&gt; &lt;/response&gt; &lt;/multistatus&gt; Note in particular the incorrect value in &lt;href&gt;/webdav/file.txt/file.txt&lt;/ href&gt;, paths are being duplicated. This wouldn't usually be a big problem as many WebDAV clients don't rely so much on this "href" value, but the Apache slide-webdavlib client library relies on it and breaks if it's incorrect, so any WebDAV enabled applications using this library will not work with Tomcat 6. That's the only reason I marked this bug as major, apologies if it's a wrong classification.</column><column name="report_time">2007-11-18 00:04:05</column><column name="report_timestamp">1195360000</column><column name="status">resolved wontfix</column><column name="commit">3c61f9b</column><column name="commit_timestamp">1195840000</column><column name="files">java/org/apache/catalina/servlets/WebdavServlet.java</column><column name="result">1:java/org/apache/catalina/servlets/WebdavServlet.java</column></table><table name="tomcat"><column name="id">975</column><column name="bug_id">43479</column><column name="summary">APR sendfile thread leaks memory</column><column name="description">The APR sendfile thread leaks memory by adding SendfileData objects to its HashMap and failing to remove them.</column><column name="report_time">2007-09-25 19:49:30</column><column name="report_timestamp">1190760000</column><column name="status">resolved fixed</column><column name="commit">16464d6</column><column name="commit_timestamp">1192060000</column><column name="files">java/org/apache/tomcat/util/net/AprEndpoint.java</column><column name="result">2:java/org/apache/tomcat/util/net/AprEndpoint.java</column></table><table name="tomcat"><column name="id">976</column><column name="bug_id">43453</column><column name="summary">ClassCastException at org.apache.catalina.core.StandardContext.findStatusPage(int)</column><column name="description">StandardContext.java reads public String findStatusPage(int status) { return ((String) statusPages.get(new Integer(status))); } This is wrong and it should be public String findStatusPage(int status) { return ((ErrorPage) statusPages.get(new Integer(status))).getLocation(); } Regards, lg</column><column name="report_time">2007-09-23 13:50:20</column><column name="report_timestamp">1190570000</column><column name="status">resolved fixed</column><column name="commit">73b5e41</column><column name="commit_timestamp">1190590000</column><column name="files">java/org/apache/catalina/core/StandardContext.java</column><column name="result">1:java/org/apache/catalina/core/StandardContext.java</column></table><table name="tomcat"><column name="id">977</column><column name="bug_id">43435</column><column name="summary">AbstractReplicatedMap.memberDisappeared is executed more than the necessity.</column><column name="description">The following codes are in the memberDisappeared method of org.apache.catalina.tribes.tipis.AbstractReplicatedMap. public void memberDisappeared(Member member) { boolean removed = false; synchronized (mapMembers) { removed = (mapMembers.remove(member) != null ); } Iterator i = super.entrySet().iterator(); while (i.hasNext()) { ** omit Relocate of session. ** This means relocate of the session is done every time after member is deleted from mapMembers (The value of removed : regardless of true/false). I think that if the member has already been deleted, the relocate of the session need not be done. This most strongly influencing is stop Tomcat(setting TcpFailureDetector) in Cluster at a high load (A lot of requests are processed at the same time). Above-mentioned case is The relocate of the session is done at all requests where memberDisappeared is detected by TcpFailureDetector. The relocate of the session is a little heavy processing. IMHO, this is not good thing. I made AbstractReplicatedMap's patch. Index: /tomcat6- trunk/java/org/apache/catalina/tribes/tipis/AbstractReplicatedMap.java =================================================================== --- /tomcat6- trunk/java/org/apache/catalina/tribes/tipis/AbstractReplicatedMap.java 	(revision 577691) +++ /tomcat6- trunk/java/org/apache/catalina/tribes/tipis/AbstractReplicatedMap.java 	(working copy) @@ -713,6 +713,7 @@ boolean removed = false; synchronized (mapMembers) { removed = (mapMembers.remove(member) != null ); + if (!removed) return; } Iterator i = super.entrySet().iterator(); Regards.</column><column name="report_time">2007-09-20 04:51:07</column><column name="report_timestamp">1190280000</column><column name="status">resolved fixed</column><column name="commit">5aed2f5</column><column name="commit_timestamp">1190400000</column><column name="files">java/org/apache/catalina/tribes/tipis/AbstractReplicatedMap.java</column><column name="result">1:java/org/apache/catalina/tribes/tipis/AbstractReplicatedMap.java</column></table><table name="tomcat"><column name="id">978</column><column name="bug_id">43356</column><column name="summary">keystoreFile parameter, when specified as relative, is not treated relative to $CATALINA_BASE or catalina.base property for NioEndPoint</column><column name="description">This issue is virtually the same symptoms as http://issues.apache.org/bugzilla/ show_bug.cgi?id=27050 except that it is with org.apache.tomcat.util.net.NioEndpoint.java instead of JSSESocketFactory ---- The docs state "keystoreFile - Add this attribute if the keystore file you created is not in the default place that Tomcat expects (a file named .keystore in the user home directory under which Tomcat is running). You can specify an absolute pathname, or a relative pathname that is resolved against the $CATALINA_BASE environment variable." Relative paths don't work though with NioConnector. Here is the problem code in NioEndPoint starting line 744: // Initialize SSL if needed if (isSSLEnabled()) { // Initialize SSL char[] passphrase = getKeystorePass().toCharArray(); KeyStore ks = KeyStore.getInstance(getKeystoreType()); ks.load(new FileInputStream(getKeystoreFile()), passphrase); KeyStore ts = KeyStore.getInstance(getKeystoreType()); ts.load(new FileInputStream(getKeystoreFile()), passphrase); As you can see $CATALINA_BASE is not taken into account at all and therefore we get something like this on startup: [] 2007-09-11 14:38:20,828 ERROR org.apache.coyote.http11.Http11NioProtocol.start(168) | Error starting endpoint java.net.BindException: Address already in use: bind at sun.nio.ch.Net.bind(Native Method) at sun.nio.ch.ServerSocketChannelImpl.bind(ServerSocketChannelImpl.java:119) at sun.nio.ch.ServerSocketAdaptor.bind(ServerSocketAdaptor.java:59) at org.apache.tomcat.util.net.NioEndpoint.init(NioEndpoint.java:731) at org.apache.tomcat.util.net.NioEndpoint.start(NioEndpoint.java:779) at org.apache.coyote.http11.Http11NioProtocol.start(Http11NioProtocol.java:166) at org.apache.catalina.connector.Connector.start(Connector.java:1132) at org.apache.catalina.core.StandardService.start(StandardService.java:531) at org.apache.catalina.core.StandardServer.start(StandardServer.java:710) at org.apache.catalina.startup.Catalina.start(Catalina.java:566) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25) at java.lang.reflect.Method.invoke(Method.java:597) at org.apache.catalina.startup.Bootstrap.start(Bootstrap.java:288) at org.apache.catalina.startup.Bootstrap.main(Bootstrap.java:413) Also I am curious why the keystoreFile is being used as the truststoreFile? Also found this against version 6.0.13, not 6.0.9 ( although it may be in 6.0.9 too).</column><column name="report_time">2007-09-11 11:42:39</column><column name="report_timestamp">1189530000</column><column name="status">resolved fixed</column><column name="commit">28da141</column><column name="commit_timestamp">1189810000</column><column name="files">java/org/apache/coyote/http11/Http11NioProtocol.java
java/org/apache/tomcat/util/net/NioEndpoint.java</column><column name="result">1:java/org/apache/tomcat/util/net/NioEndpoint.java
3:java/org/apache/coyote/http11/Http11NioProtocol.java</column></table><table name="tomcat"><column name="id">979</column><column name="bug_id">30949</column><column name="summary">After Failed Include, Request and Response not Unwrapped</column><column name="description">In org.apache.catalina.core.ApplicationDispatcher.doInclude(ServletRequest request, ServletResponse response), after invoke() is called to perform the include, the request and response objects are normally unwrapped. However, if a ServletException or IOException is thrown, the unwrapping does not take place. This leads to problems in environments in which cross context includes are being performed. For example, 1. Web App A performs an include to a Servlet in Web App B 2. The Servlet in Web App B throws a ServletException 3. Web App A catches the ServletException and attempts to forward to an error jsp. Step 3 above will fail due to the fact that the request has not been unwrapped. The active request will contain the ServletContext of web app B and the jsp file will not be found.</column><column name="report_time">2004-08-30 23:54:36</column><column name="report_timestamp">1093920000</column><column name="status">resolved fixed</column><column name="commit">4dd22a5</column><column name="commit_timestamp">1188960000</column><column name="files">java/org/apache/catalina/core/ApplicationDispatcher.java</column><column name="result">1:java/org/apache/catalina/core/ApplicationDispatcher.java</column></table><table name="tomcat"><column name="id">980</column><column name="bug_id">43216</column><column name="summary">ACTIVITY_CHECK does not work correctly when Tomcat is restarted</column><column name="description">Hi, I noticed that org.apache.catalina.session.StandardSession.ACTIVITY_CHECK does not work correctly because the StandardSession#accessCount will be set as -1 when Tomcat is restarted and session is loaded from the SESSION.ser file. StandardManager#doLoad() calls session.endAccess() and this method execute 2 things. * set isNew = false * decrement accessCount I think isNew attribute is already set by session.readObjectData(ois) in StandardManager#doLoad(), and accessCount is already set as 0. IMHO, it is not necessary calling session.endAccess() in the doLoad(). Here is a patch. Index: /tc6.0.x/trunk/java/org/apache/catalina/session/StandardManager.java =================================================================== --- /tc6.0.x/trunk/java/org/apache/catalina/session/StandardManager.java (revision 569774) +++ /tc6.0.x/trunk/java/org/apache/catalina/session/StandardManager.java (working copy) @@ -395,7 +395,6 @@ session.setManager(this); sessions.put(session.getIdInternal(), session); session.activate(); - session.endAccess(); } } catch (ClassNotFoundException e) { log.error(sm.getString("standardManager.loading.cnfe", e), e);</column><column name="report_time">2007-08-26 09:28:12</column><column name="report_timestamp">1188130000</column><column name="status">resolved fixed</column><column name="commit">9c37a01</column><column name="commit_timestamp">1188310000</column><column name="files">java/org/apache/catalina/session/StandardManager.java</column><column name="result">8:java/org/apache/catalina/session/StandardManager.java</column></table><table name="tomcat"><column name="id">981</column><column name="bug_id">42944</column><column name="summary">plus sign in url-pattern in servlet-mapping does not work</column><column name="description">Hi all, I had servlet-mappings that contain plus signs (they were created by JspC), e.g.: &lt;servlet-mapping&gt; &lt;servlet-name&gt;org.apache.jsp.suchergebnis_005fbu_002bbb_jsp&lt;/servlet-name&gt; &lt;url-pattern&gt;/suchergebnis_bu+bb.jsp&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; This mapping does not work (the referred class is present)! When I change the original file names of the JSPs such that the plus signs are replaced by a minus signs the following mapping results: &lt;servlet-mapping&gt; &lt;servlet-name&gt;org.apache.jsp.suchergebnis_005fbu_002dbb_jsp&lt;/servlet-name&gt; &lt;url-pattern&gt;/suchergebnis_bu-bb.jsp&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; Now the mapping works. Therefore I assume that there is a bug in handling servlet mappings with plus signs in their url pattern.</column><column name="report_time">2007-07-20 09:32:19</column><column name="report_timestamp">1184940000</column><column name="status">resolved fixed</column><column name="commit">44e36ea</column><column name="commit_timestamp">1186240000</column><column name="files">java/org/apache/catalina/util/RequestUtil.java</column><column name="result">241:java/org/apache/catalina/util/RequestUtil.java</column></table><table name="tomcat"><column name="id">982</column><column name="bug_id">39212</column><column name="summary">a bug in example code DummyCart.java</column><column name="description">Hi! I found a bug in the example code DummyCart.java Your code: /* * Copyright 2004 The Apache Software Foundation * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package sessions; import javax.servlet.http.*; import java.util.Vector; import java.util.Enumeration; public class DummyCart { Vector v = new Vector(); String submit = null; String item = null; private void addItem(String name) { v.addElement(name); } private void removeItem(String name) { v.removeElement(name); } public void setItem(String name) { item = name; } public void setSubmit(String s) { submit = s; } public String[] getItems() { String[] s = new String[ v.size()]; v.copyInto(s); return s; } public void processRequest(HttpServletRequest request) { // null value for submit - user hit enter instead of clicking on // "add" or "remove" if (submit == null) addItem(item); if (submit.equals("add")) addItem(item); else if (submit.equals("remove")) removeItem(item); // reset at the end of the request reset(); } // reset private void reset() { submit = null; item = null; } } 1. the argument request in method processRequest does nothing. 2. see this code block: // null value for submit - user hit enter instead of clicking on // "add" or "remove" if (submit == null) addItem(item); if (submit.equals("add")) addItem(item); else if (submit.equals("remove")) removeItem(item); there is a logical bug in it. It should be: if (submit == null || submit.equals("add")) addItem(item); elseif (submit.equals("remove")) removeItem(item); because if submit == null is true: the original code will yield an NullPointerException. under the condition submit == null, submit.equals("add") will not work properly.</column><column name="report_time">2006-04-05 10:20:19</column><column name="report_timestamp">1144250000</column><column name="status">resolved fixed</column><column name="commit">8aa247e</column><column name="commit_timestamp">1185820000</column><column name="files">webapps/examples/WEB-INF/classes/sessions/DummyCart.java</column><column name="result">1:webapps/examples/WEB-INF/classes/sessions/DummyCart.java</column></table><table name="tomcat"><column name="id">983</column><column name="bug_id">42753</column><column name="summary">Race condition when using available() or reading in CometProcessor.event()</column><column name="description">Tomcat version: 6.0.13 (no 6.0.13 available in the version field) When trying to process data in CometProcessor.event() either during the BEGIN event or during the READ event, it is impossible to guarantee that all data has been read before returning (since new data may arrive between the last statement before the return, and the return statement itself). However, the CoyoteProcessor does this check: } else if (!error &amp;&amp; read &amp;&amp; request.getAvailable()) { // If this was a read and not all bytes have been read, or if no data // was read from the connector, then it is an error error = true; log.error(sm.getString("coyoteAdapter.read")); } causing a severe error and the Comet request to break when this race condition manifests itself. I am using the following code according to the aio.html description to read data in my comet event handler: while (request.getInputStream().available() &gt; 0) { // read some data } // ***** NO MORE DATA AVAILABLE return; And I am experiencing the error as described in certain conditions (rapid arrival of fragmented data): SEVERE: The servlet did not read all available bytes during the processing of the read event</column><column name="report_time">2007-06-27 05:21:53</column><column name="report_timestamp">1182940000</column><column name="status">resolved fixed</column><column name="commit">a6ea14d</column><column name="commit_timestamp">1183120000</column><column name="files">java/org/apache/catalina/core/ApplicationFilterFactory.java</column><column name="result">161:java/org/apache/catalina/core/ApplicationFilterFactory.java</column></table><table name="tomcat"><column name="id">984</column><column name="bug_id">41722</column><column name="summary">role-link tag in web.xml can not  be omitted.</column><column name="description">The application with follwing web.xml can not be deployed. --- &lt;servlet&gt; &lt;servlet-name&gt;sample&lt;/servlet-name&gt; &lt;servlet-class&gt;sample.TheServlet&lt;/servlet-class&gt; &lt;security-role-ref&gt; &lt;role-name&gt;users&lt;/role-name&gt; &lt;/security-role-ref&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; .... &lt;/servlet-mapping&gt; &lt;security-role&gt; &lt;role-name&gt;users&lt;/role-name&gt; &lt;/security-role&gt; --- "java.lang.IllegalArgumentException: Can't convert argument: null" occurred. The Specification says: --- The security-role-ref element declares the security role reference in a components or in a deployment components code. It consists of an optional description, the security role name used in the code(role-name), and an optional link to a security role(role-link). --- &lt;role-link&gt; is optional.</column><column name="report_time">2007-02-28 01:00:41</column><column name="report_timestamp">1172640000</column><column name="status">resolved fixed</column><column name="commit">ba25bfb</column><column name="commit_timestamp">1182710000</column><column name="files">java/org/apache/catalina/deploy/SecurityRoleRef.java
java/org/apache/catalina/startup/WebRuleSet.java</column><column name="result">35:java/org/apache/catalina/startup/WebRuleSet.java</column></table><table name="tomcat"><column name="id">985</column><column name="bug_id">42314</column><column name="summary">Jasper output no details with compilation error in specific case.</column><column name="description">Jasper output no details when Jasper cannot find mappings between generated servlet code (with mistakes) and former JSP. One example JSP is the following. (The imported class in the JSP is not found.) --- &lt;%@ page import = "not.exist.class" %&gt; ---</column><column name="report_time">2007-05-02 01:13:16</column><column name="report_timestamp">1178080000</column><column name="status">resolved fixed</column><column name="commit">6c6ad83</column><column name="commit_timestamp">1182690000</column><column name="files">java/org/apache/jasper/compiler/JavacErrorDetail.java</column><column name="result">19:java/org/apache/jasper/compiler/JavacErrorDetail.java</column></table><table name="tomcat"><column name="id">986</column><column name="bug_id">42547</column><column name="summary">Same env-entry (web.xml) and ResourceLink (context) names causes NPE</column><column name="description">Having the following in web.xml: &lt;env-entry&gt; &lt;env-entry-name&gt;testIt&lt;/env-entry-name&gt; &lt;env-entry-type&gt;java.lang.String&lt;/env-entry-type&gt; &lt;env-entry-value&gt;test&lt;/env-entry-value&gt; &lt;/env-entry&gt; and the following in your context descriptor: &lt;ResourceLink name="testIt" global="testIt" type="java.lang.String"/&gt; causes an NPE on context load. java.lang.NullPointerException 	at org.apache.catalina.deploy.NamingResources.addEnvironment(NamingResources.java:188) 	 This assumes you have an entry for 'testIt' in the &lt;GlobalNamingResources&gt; section of server.xml to link to. This worked in 5.5.20. No longer works in 5.5.23.</column><column name="report_time">2007-05-30 11:29:37</column><column name="report_timestamp">1180540000</column><column name="status">resolved fixed</column><column name="commit">53add24</column><column name="commit_timestamp">1182610000</column><column name="files">java/org/apache/catalina/deploy/NamingResources.java</column><column name="result">1:java/org/apache/catalina/deploy/NamingResources.java</column></table><table name="tomcat"><column name="id">987</column><column name="bug_id">42643</column><column name="summary">Duplicate JSP function mapper variables</column><column name="description">When we deploy ~20 or so web apps at a time, we invariably end up with an app or two on each server that has compilation errors due to code generated like this: static private org.apache.jasper.runtime.ProtectedFunctionMapper _jspx_fnmap_0; static private org.apache.jasper.runtime.ProtectedFunctionMapper _jspx_fnmap_1; static private org.apache.jasper.runtime.ProtectedFunctionMapper _jspx_fnmap_2; static private org.apache.jasper.runtime.ProtectedFunctionMapper _jspx_fnmap_3; static private org.apache.jasper.runtime.ProtectedFunctionMapper _jspx_fnmap_4; static private org.apache.jasper.runtime.ProtectedFunctionMapper _jspx_fnmap_5; static private org.apache.jasper.runtime.ProtectedFunctionMapper _jspx_fnmap_6; static private org.apache.jasper.runtime.ProtectedFunctionMapper _jspx_fnmap_7; static private org.apache.jasper.runtime.ProtectedFunctionMapper _jspx_fnmap_0; static private org.apache.jasper.runtime.ProtectedFunctionMapper _jspx_fnmap_1; static private org.apache.jasper.runtime.ProtectedFunctionMapper _jspx_fnmap_2; static private org.apache.jasper.runtime.ProtectedFunctionMapper _jspx_fnmap_3; static private org.apache.jasper.runtime.ProtectedFunctionMapper _jspx_fnmap_4; static private org.apache.jasper.runtime.ProtectedFunctionMapper _jspx_fnmap_5; static private org.apache.jasper.runtime.ProtectedFunctionMapper _jspx_fnmap_6; static private org.apache.jasper.runtime.ProtectedFunctionMapper _jspx_fnmap_7; This looks like it might be as simple as unsynchronized access to the static 'currFunc' in ELFunctionMapper, but I'm far from an expert on this code and unfortunately lack the time to become one. :) This only appears to happen when we mass-deploy apps, and we can resolve it by deleting the generated .java file and manually restarting the affected app.</column><column name="report_time">2007-06-12 07:34:16</column><column name="report_timestamp">1181650000</column><column name="status">resolved fixed</column><column name="commit">5b65cf4</column><column name="commit_timestamp">1182010000</column><column name="files">java/org/apache/jasper/compiler/ELFunctionMapper.java</column><column name="result">2:java/org/apache/jasper/compiler/ELFunctionMapper.java</column></table><table name="tomcat"><column name="id">988</column><column name="bug_id">42497</column><column name="summary">304 response should consistently include ETag header</column><column name="description">According to the HTTP spec, if a server includes an ETag header when it sends a file, it must also include the ETag when it sends a 304 (not-modified) response for that file. Tomcat does not do this for static files - if you request a static file and get a 200 response, the response has an ETag header; but if you get a 304 resopnse, the ETag is omitted. To reproduce: - In a browser, request a static file from Tomcat (e.g. http://localhost/tomcat.gif) - Make sure you get a 200 response (force reload or clear browser cache) - Examine the response headers (using a browser plugin or whatever) - note that there is an ETag header - Request the same file again, getting a 304 (not-modified) response from Tomcat - Examine the response headers - note there is no ETag The 304 response should include an ETag header, because the 200 response had one. Spec reference: RFC 2616 section 10.3.5 says: "304 Not Modified [...] The response MUST include the following header fields: [...] - ETag and/or Content-Location, if the header would have been sent in a 200 response to the same request"</column><column name="report_time">2007-05-23 09:00:19</column><column name="report_timestamp">1179930000</column><column name="status">resolved fixed</column><column name="commit">0114b2d</column><column name="commit_timestamp">1180740000</column><column name="files">java/org/apache/catalina/servlets/DefaultServlet.java</column><column name="result">5:java/org/apache/catalina/servlets/DefaultServlet.java</column></table><table name="tomcat"><column name="id">989</column><column name="bug_id">42559</column><column name="summary">ErrorReportValve does not provide an error report</column><column name="description">rev 535915 changed the behavior of ErrorReportValve in tomcat6 to not produce an error report when response.sendError() is called. For example, using this code in a servlet's service() does not produce an error report: response.sendError(HttpServletResponse.SC_GONE, "error occurred"); The underlying cause is that the valve's check for response.isCommitted() was replaced with response.isAppCommitted(). The latter returns true, which causes the Valve's invoke() method to immediately return instead of producing the report.</column><column name="report_time">2007-05-31 09:09:05</column><column name="report_timestamp">1180620000</column><column name="status">resolved fixed</column><column name="commit">71eccb3</column><column name="commit_timestamp">1180650000</column><column name="files">java/org/apache/catalina/valves/ErrorReportValve.java</column><column name="result">1:java/org/apache/catalina/valves/ErrorReportValve.java</column></table><table name="tomcat"><column name="id">990</column><column name="bug_id">39875</column><column name="summary">RealmBase#init() needs cleanup</column><column name="description">In RealmBase#init(): &lt;quote&gt; public void init() { this.containerLog = container.getLogger(); if( initialized &amp;&amp; container != null ) return; initialized=true; if( container== null ) { &lt;/quote&gt; If the container is null, then a NPE will occurs. The container is not null, then the if block is no longer needed. The first line is changed at revision r372854. http://svn.apache.org/viewvc/tomcat/container/tc5.5.x/catalina/src/share/org/apache/catalina/realm/RealmBase.java?r1=371686&amp;r2=372854</column><column name="report_time">2006-06-23 11:15:08</column><column name="report_timestamp">1151080000</column><column name="status">resolved fixed</column><column name="commit">0ea4c7c</column><column name="commit_timestamp">1179890000</column><column name="files">java/org/apache/catalina/realm/RealmBase.java</column><column name="result">1:java/org/apache/catalina/realm/RealmBase.java</column></table><table name="tomcat"><column name="id">991</column><column name="bug_id">42438</column><column name="summary">Duplicate JSP temp variable declaration when jsp:attribute used in conjunction with custom tags</column><column name="description">Here is an example of the bug in its most primitive form: WEB-INF/jsp/test.jsp: =================================== &lt;%@ page contentType="text/html;charset=UTF-8" language="java" %&gt; &lt;%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core"%&gt; &lt;%@ taglib prefix="t" tagdir="/WEB-INF/tags" %&gt; &lt;jsp:element name="a"&gt; &lt;jsp:attribute name="href"&gt;http://www.apache.org&lt;/jsp:attribute&gt; &lt;/jsp:element&gt; &lt;t:test /&gt; &lt;c:if test="${true}"&gt;it's true!&lt;/c:if&gt; =================================== WEB-INF/tags/test.tag: =================================== &lt;%@ tag pageEncoding="UTF-8" body-content="scriptless" %&gt; do nothing =================================== WEB-INF/tagPlugins.xml: =================================== &lt;tag-plugins&gt; &lt;tag-plugin&gt; &lt;tag-class&gt;org.apache.taglibs.standard.tag.rt.core.IfTag&lt;/tag-class&gt; &lt;plugin-class&gt;org.apache.jasper.tagplugins.jstl.core.If&lt;/plugin-class&gt; &lt;/tag-plugin&gt; &lt;/tag-plugins&gt; =================================== Once you run this through Jasper, you will get the following java code: =================================== package org.apache.jsp.WEB_002dINF.jsp; import javax.servlet.*; import javax.servlet.http.*; import javax.servlet.jsp.*; public final class test_jsp extends org.apache.jasper.runtime.HttpJspBase implements org.apache.jasper.runtime.JspSourceDependent { private static java.util.List _jspx_dependants; static { _jspx_dependants = new java.util.ArrayList(1); _jspx_dependants.add("/WEB-INF/tags/test.tag"); } private org.apache.jasper.runtime.TagHandlerPool _jspx_tagPool_c_if_test; public Object getDependants() { return _jspx_dependants; } public void _jspInit() { _jspx_tagPool_c_if_test = org.apache.jasper.runtime.TagHandlerPool.getTagHandlerPool(getServletConfig()); } public void _jspDestroy() { _jspx_tagPool_c_if_test.release(); } public void _jspService(HttpServletRequest request, HttpServletResponse response) throws java.io.IOException, ServletException { JspFactory _jspxFactory = null; PageContext pageContext = null; HttpSession session = null; ServletContext application = null; ServletConfig config = null; JspWriter out = null; Object page = this; JspWriter _jspx_out = null; PageContext _jspx_page_context = null; try { _jspxFactory = JspFactory.getDefaultFactory(); response.setContentType("text/html;charset=UTF-8"); pageContext = _jspxFactory.getPageContext(this, request, response, 			null, true, 8192, true); _jspx_page_context = pageContext; application = pageContext.getServletContext(); config = pageContext.getServletConfig(); session = pageContext.getSession(); out = pageContext.getOut(); _jspx_out = out; String _jspx_temp0 = "http://www.apache.org"; out.write("&lt;" + "a" + " href=\"" + _jspx_temp0 + "\"" + "/&gt;"); if (_jspx_meth_t_test_0(_jspx_page_context)) return; boolean _jspx_temp0= ((java.lang.Boolean) org.apache.jasper.runtime.PageContextImpl.proprietaryEvaluate("${true}", java.lang.Boolean.class, (PageContext)_jspx_page_context, null, false)).booleanValue(); if (_jspx_temp0){ out.write("it's true!"); } } catch (Throwable t) { if (!(t instanceof SkipPageException)){ out = _jspx_out; if (out != null &amp;&amp; out.getBufferSize() != 0) out.clearBuffer(); if (_jspx_page_context != null) _jspx_page_context.handlePageException(t); } } finally { if (_jspxFactory != null) _jspxFactory.releasePageContext(_jspx_page_context); } } private boolean _jspx_meth_t_test_0(PageContext _jspx_page_context) throws Throwable { PageContext pageContext = _jspx_page_context; JspWriter out = _jspx_page_context.getOut(); // t:test org.apache.jsp.tag.web.test_tag _jspx_th_t_test_0 = new org.apache.jsp.tag.web.test_tag(); _jspx_th_t_test_0.setJspContext(_jspx_page_context); _jspx_th_t_test_0.doTag(); return false; } } =================================== Scan that code for the temp variable named _jspx_temp0. Notice that there is one String with that name and one boolean with that name. Thus, this results in a java compilation error once you ultimately try to compile the page: =================================== Compiling 2 source files to c:\work\marzen\tmp\jspc\classes c:\work\marzen\tmp\jspc\src\org\apache\jsp\WEB_002dINF\jsp\test_jsp.java:61: _jspx_temp0 is already defined in _jspService(javax.servlet.http.HttpServletRequest,javax.servlet.http.HttpServletResponse) boolean _jspx_temp0= ^ c:\work\marzen\tmp\jspc\src\org\apache\jsp\WEB_002dINF\jsp\test_jsp.java:63: incompatible types found : java.lang.String required: boolean if (_jspx_temp0){ ^ Note: c:\work\marzen\tmp\jspc\src\org\apache\jsp\WEB_002dINF\jsp\test_jsp.java uses unchecked or unsafe operations. Note: Recompile with -Xlint:unchecked for details. 2 errors =================================== The problem is caused by the fact that the Node.NamedAttribute constructor directly uses JspUtil.nextTemporaryVariableName() to generate a variable name. I *believe* that if the variable was initialized just-in-time in the getter, that the problem would be solved. The flow goes like this: 1) When compiling test.jsp, Compiler.generateJava() calls JspUtil.resetTemporaryVariableName() to reset the temp variable name 2) The test.jsp file gets parsed immediately thereafter, thus creating a variable with name _jspx_temp0 for the "href" attribute 3) Shortly thereafter, tag files are loaded, which means that the test.tag file will be recompiled, thus resulting in JspUtil.resetTemporaryVariableName() being invoked again (thus setting the variable back to 0). 4) Since test.tag doesn't do anything to cause a temporary variable name to be recreated, the temp variable name remains at 0. 5) Upon returning to the compilation of the test.jsp, the If tag plugin is used to create yet another variable name with name _jspx_temp0, hence the conflict. I think step 2 is the root of the problem. If the NamedAttribute didn't get a temporary variable name assigned in the constructor and instead generated it just-in-time in the getter, then this issue wouldn't exist since the "href" attribute variable name would be created only after first compiling all of the tag files. I still think that the logic in the compilation is a bit strange given that the JSP will use temporary variable names starting at whatever point the last compiled tag file left off at. I think that issue could be resolved by moving the JspUtil.resetTemporaryVariableName() call in Compiler.generateJava() down after the call to loadTagFiles(). Note that you would probably also want to call JspUtil.resetTemporaryVariableName() in the ctxt.isPrototypeMode() scenario. Here is the diff that I would propose for Compiler.java based on the 5.5.20 codebase: =================================== 150,152d149 &lt; // Reset the temporary variable counter for the generator. &lt; JspUtil.resetTemporaryVariableName(); &lt; 157a155,156 &gt; // Reset the temporary variable counter for the generator. &gt; JspUtil.resetTemporaryVariableName(); 179a179,181 &gt; // Reset the temporary variable counter for the generator. &gt; JspUtil.resetTemporaryVariableName(); &gt; =================================== Here is the diff I would propose for Node.java: =================================== 1791d1790 &lt; temporaryVariableName = JspUtil.nextTemporaryVariableName(); 1837a1837,1839 &gt; if(temporaryVariableName==null) { &gt; temporaryVariableName = JspUtil.nextTemporaryVariableName(); &gt; } ===================================</column><column name="report_time">2007-05-16 17:43:51</column><column name="report_timestamp">1179350000</column><column name="status">resolved fixed</column><column name="commit">5e188bc</column><column name="commit_timestamp">1179890000</column><column name="files">java/org/apache/jasper/compiler/Node.java</column><column name="result" /></table><table name="tomcat"><column name="id">992</column><column name="bug_id">42459</column><column name="summary">Tomcat Web Application Manager table error</column><column name="description">html table -&gt; tr wrong formating when stop (not last) in Tomcat Web Application Manager.</column><column name="report_time">2007-05-19 13:32:58</column><column name="report_timestamp">1179600000</column><column name="status">resolved fixed</column><column name="commit">33c9949</column><column name="commit_timestamp">1179680000</column><column name="files">java/org/apache/catalina/manager/HTMLManagerServlet.java</column><column name="result" /></table><table name="tomcat"><column name="id">993</column><column name="bug_id">42444</column><column name="summary">Potential NullPointerException in org.apache.catalina.valves.AccessLogValve</column><column name="description">In the class AccessLogValve.RequestElement in the method addElement there is an access of the form: request.getProtocol(), even though the variable request is known to be 'null' which will cause a NullPointerException. Patch below: --- Index: F:/Workspace/Apache2/tomcat6/java/org/apache/catalina/valves/AccessLogValve.java =================================================================== --- F:/Workspace/Apache2/tomcat6/java/org/apache/catalina/valves/AccessLogValve.java	(revision 538877) +++ F:/Workspace/Apache2/tomcat6/java/org/apache/catalina/valves/AccessLogValve.java	(working copy) @@ -1035,7 +1035,7 @@ buf.append(request.getProtocol()); } else { buf.append("- - "); - buf.append(request.getProtocol()); + // buf.append(request.getProtocol()); } } }</column><column name="report_time">2007-05-17 08:15:53</column><column name="report_timestamp">1179400000</column><column name="status">resolved fixed</column><column name="commit">776736f</column><column name="commit_timestamp">1179600000</column><column name="files">java/org/apache/catalina/valves/AccessLogValve.java</column><column name="result" /></table><table name="tomcat"><column name="id">994</column><column name="bug_id">42361</column><column name="summary">POST content type incorrect for multipart forms after login</column><column name="description">When using a form with a custom encoding (e.g. "multipart/form-data"), the content type is not restored after a redirect to a login page (auth-method = FORM). To reproduce: - A page that POSTs using multipart/form-data encoding (or anything other than application/x-www-form-urlencoded) to a result page that is protected by a login page (auth-method=FORM) is invoked. - Even though the multipart POST data exists (verified by reading input stream of request from result page) the content type of the request is always "application/x-www-form-urlencoded". - This only happens when redirected to the login page first. It does not happen if already logged in.</column><column name="report_time">2007-05-08 16:06:35</column><column name="report_timestamp">1178650000</column><column name="status">resolved fixed</column><column name="commit">637acc5</column><column name="commit_timestamp">1178670000</column><column name="files">java/org/apache/catalina/authenticator/FormAuthenticator.java
java/org/apache/catalina/authenticator/SavedRequest.java</column><column name="result" /></table><table name="tomcat"><column name="id">995</column><column name="bug_id">42309</column><column name="summary">Request: support for NIO in Embedded Tomcat</column><column name="description">in org.apache.catalina.startup.Embedded there is no direct API to create an NIO connector. This would be very helpful for all applications which use tomcat in embedded mode and require the CometProcessor.</column><column name="report_time">2007-05-01 02:03:28</column><column name="report_timestamp">1178000000</column><column name="status">resolved fixed</column><column name="commit">9546005</column><column name="commit_timestamp">1178210000</column><column name="files">java/org/apache/catalina/startup/Embedded.java</column><column name="result" /></table><table name="tomcat"><column name="id">996</column><column name="bug_id">42308</column><column name="summary">with APR bytessent bytesreceived performance data is not collected</column><column name="description">with APR bytes received and bytes sent are always 0.</column><column name="report_time">2007-05-01 01:57:57</column><column name="report_timestamp">1178000000</column><column name="status">resolved fixed</column><column name="commit">4a04722</column><column name="commit_timestamp">1178020000</column><column name="files">java/org/apache/coyote/http11/Http11AprProcessor.java
java/org/apache/coyote/http11/Http11AprProtocol.java
java/org/apache/coyote/http11/Http11NioProcessor.java
java/org/apache/coyote/http11/InternalNioInputBuffer.java</column><column name="result" /></table><table name="tomcat"><column name="id">997</column><column name="bug_id">42202</column><column name="summary">if you install tomcat in a directory with spaces it ignores TLD files inside jar files</column><column name="description">if you install tomcat or a web application in a directory with spaces in the name, for example "C:\Program Files\vds\tomcat" for tomcat or "C:\Program Files\vds\console" for a web application. the TLD files that are inside the META-INF directory of the jar files will not be loaded. the problem is is the file treatment inside the TldConfig class ... I have attached a patch with the correction. this bug is found in Tomcat 6 too</column><column name="report_time">2007-04-23 14:07:38</column><column name="report_timestamp">1177350000</column><column name="status">resolved fixed</column><column name="commit">f9ddaba</column><column name="commit_timestamp">1177420000</column><column name="files">java/org/apache/catalina/startup/TldConfig.java</column><column name="result" /></table><table name="tomcat"><column name="id">998</column><column name="bug_id">42071</column><column name="summary">If a JSP throws an UnavailableException twice, an IllegalStateException occurs.</column><column name="description">If a JSP throws an UnavailableException twice, an IllegalStateException occurs. first access: JSP throws UnavailableException. second access: If the JSP throws an UnavailableException again then an IllegalStateException occurs and Tomcat returns status code:500 to the client. The problem is not that the IllegalStateException occurs. The problem is that the JSP can be called even though it cannot be used.</column><column name="report_time">2007-04-08 17:49:37</column><column name="report_timestamp">1176070000</column><column name="status">resolved fixed</column><column name="commit">508f513</column><column name="commit_timestamp">1176950000</column><column name="files">java/org/apache/jasper/servlet/JspServletWrapper.java</column><column name="result" /></table><table name="tomcat"><column name="id">999</column><column name="bug_id">42039</column><column name="summary">Tomcat doesn't output the stack trace of UnavailableException.</column><column name="description">When UnavailableException is thrown from the Servlet:init, Tomcat doesn't output the stack trace of UnavailableException. The cause of problem is lost. Tomcat should output the stack trace at the "invoke" method of StandardWrapperValue.</column><column name="report_time">2007-04-03 16:54:58</column><column name="report_timestamp">1175630000</column><column name="status">resolved fixed</column><column name="commit">c3d2ce4</column><column name="commit_timestamp">1176660000</column><column name="files">java/org/apache/catalina/core/StandardWrapperValve.java</column><column name="result" /></table><table name="tomcat"><column name="id">1000</column><column name="bug_id">42119</column><column name="summary">request.getCharacterEncoding misparses charset=UTF-8; xyz=3</column><column name="description">(This bug is also present in Coyote source 6.0.10.) If there is an HTTP header Content-Type: text/abc; charset=UTF-8; xyz=3 request.getCharacterEncoding() returns "UTF-8; xyz=3" but Tomcat 4.1.24 returns "UTF-8". In Tomcat 4.1.24, request.getCharacterEncoding uses parseCharacterEncoding defined in jakarta-tomcat-4.1.24-src/catalina/src/share/org/apache/catalina/util/RequestUtil.java and it correctly handles the case of other Content-Type parameters. In Tomcat 5.5.23, however, request.getCharacterEncoding uses getCharsetFromContentType defined in from apache-tomcat-5.5.23-src/connectors/util/java/org/apache/tomcat/util/http/ContentType.java which does not search for a possible terminating semicolon in the charset, thus erroneously including additional characters in the charset. The code in 5.5.23 has a comment begins // Basically return everything after ";charset=" Please consider using the code from 4.1.24 This problem showed up when Content-Type was multipart/mixed and a client specified a charset parameter to Content-Type; however, it will occur in any Content-Type where charset is specified and is not the last parameter.</column><column name="report_time">2007-04-13 12:01:02</column><column name="report_timestamp">1176480000</column><column name="status">resolved fixed</column><column name="commit">4cf171a</column><column name="commit_timestamp">1176600000</column><column name="files">java/org/apache/tomcat/util/http/ContentType.java</column><column name="result" /></table><table name="tomcat"><column name="id">1001</column><column name="bug_id">42085</column><column name="summary">java.util.Logging duplicated since 5.5.23.  5.5.20 is OK</column><column name="description">We use the followwing logging.properties in our WebApplication: ----------%&lt;--------------------%&lt;---------------- handlers = 1tivoli.java.util.logging.FileHandler, 2product.java.util.logging.FileHandler # Handlers for the root logger .handlers = 1tivoli.java.util.logging.FileHandler, 2product.java.util.logging.FileHandler 1tivoli.java.util.logging.FileHandler.level = INFO 1tivoli.java.util.logging.FileHandler.pattern = /var/log/product/tivoli%g.log # limit Output to 1MB 1tivoli.java.util.logging.FileHandler.limit=1048576 # Limit rotation to 10 Logs ... 1tivoli.java.util.logging.FileHandler.count=10 1tivoli.java.util.logging.FileHandler.append=true 1tivoli.java.util.logging.FileHandler.formatter=de.customer.product.tivoli.TivoliFormatter 2product.java.util.logging.FileHandler.level = FINEST 2product.java.util.logging.FileHandler.pattern = /var/log/product/product%g.log # limit Output to 1MB 2product.java.util.logging.FileHandler.limit=1048576 # Limit rotation to 5 Logs ... 2product.java.util.logging.FileHandler.count=5 2product.java.util.logging.FileHandler.append=true 2product.java.util.logging.FileHandler.formatter=java.util.logging.SimpleFormatter ----------%&lt;--------------------%&lt;---------------- When using apache-tomcat-5.5.23 every Line in the Logfiles is duplicated. Debugging I found that the TivoliFormatter is actually created twice. And the root-logger has actually 4 Handlers and not two as intended. This does not allow us an upgrade beyond 5.5.20. Found on Linux64Bit and Windows-XP, both with JDK 1.5_R11</column><column name="report_time">2007-04-10 23:13:02</column><column name="report_timestamp">1176260000</column><column name="status">resolved fixed</column><column name="commit">fa2b746</column><column name="commit_timestamp">1176390000</column><column name="files">java/org/apache/juli/ClassLoaderLogManager.java</column><column name="result" /></table><table name="tomcat"><column name="id">1002</column><column name="bug_id">42072</column><column name="summary">The call of the jspDestroy method violates it about the Java Servlet Specification 2.4, SRV.2.3.2.1.</column><column name="description">When a JSP is accessed for a second time, the jspDestroy method is called even if a ServletException is thrown from the init method of the class that extends HttpJspPage. This violates the Java Servlet Specification 2.4, SRV.2.3.2.1.</column><column name="report_time">2007-04-08 18:07:02</column><column name="report_timestamp">1176070000</column><column name="status">resolved fixed</column><column name="commit">3d27771</column><column name="commit_timestamp">1176160000</column><column name="files">java/org/apache/jasper/servlet/JspServletWrapper.java</column><column name="result" /></table><table name="tomcat"><column name="id">1003</column><column name="bug_id">41289</column><column name="summary">Error when deploying XML Configuration file URL</column><column name="description">I tried to deploy a webapp using a context.xml file under manager webapp and received this error: java.io.FileNotFoundException: /opt/apache-tomcat-6.0.2/conf/Catalina/localhost/mywebapp3.xml (No such file or directory) at java.io.FileOutputStream.open(Native Method) at java.io.FileOutputStream.&lt;init&gt;(FileOutputStream.java:179) at java.io.FileOutputStream.&lt;init&gt;(FileOutputStream.java:131) at org.apache.catalina.manager.ManagerServlet.copyInternal(ManagerServlet.java:1570) at org.apache.catalina.manager.ManagerServlet.copy(ManagerServlet.java:1530) at org.apache.catalina.manager.ManagerServlet.deploy(ManagerServlet.java:803) at org.apache.catalina.manager.HTMLManagerServlet.deployInternal(HTMLManagerServlet.java:249) at org.apache.catalina.manager.HTMLManagerServlet.doGet(HTMLManagerServlet.java:96) at javax.servlet.http.HttpServlet.service(HttpServlet.java:690) at javax.servlet.http.HttpServlet.service(HttpServlet.java:803) at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:290) at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:206) at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:228) at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:175) at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:525) at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:128) at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:105) at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:109) at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:212) at org.apache.coyote.http11.Http11Processor.process(Http11Processor.java:818) at org.apache.coyote.http11.Http11Protocol$Http11ConnectionHandler.process(Http11Protocol.java:624) at org.apache.tomcat.util.net.JIoEndpoint$Worker.run(JIoEndpoint.java:445) at java.lang.Thread.run(Thread.java:613) I did checked and noticed apache-tomcat-6.0.2/conf/Catalina directory no longer exists in version 6. Did something changed?</column><column name="report_time">2007-01-04 07:42:41</column><column name="report_timestamp">1167910000</column><column name="status">resolved fixed</column><column name="commit">d721522</column><column name="commit_timestamp">1175780000</column><column name="files">java/org/apache/catalina/manager/ManagerServlet.java</column><column name="result" /></table><table name="tomcat"><column name="id">1004</column><column name="bug_id">41703</column><column name="summary">Variable assigned with it's own value.</column><column name="description">The variable this.address is assigned by it's own value instead of assigning the data provided by the parameter to the method setAddress(). Patch below will take the parameter and assign it to this.address. Index: C:/Work/Apache/tomcat6/java/org/apache/catalina/ha/authenticator/SingleSignOnMessage.java =================================================================== --- C:/Work/Apache/tomcat6/java/org/apache/catalina/ha/authenticator/SingleSignOnMessage.java (revision 511768) +++ C:/Work/Apache/tomcat6/java/org/apache/catalina/ha/authenticator/SingleSignOnMessage.java (working copy) @@ -71,7 +71,7 @@ * @param member Member */ public void setAddress(Member member) { -	this.address = address; +	this.address = member; } /**</column><column name="report_time">2007-02-26 02:18:39</column><column name="report_timestamp">1172470000</column><column name="status">resolved fixed</column><column name="commit">2049b78</column><column name="commit_timestamp">1174980000</column><column name="files">java/org/apache/catalina/ha/authenticator/SingleSignOnMessage.java</column><column name="result" /></table><table name="tomcat"><column name="id">1005</column><column name="bug_id">41682</column><column name="summary">ClassCastException with BackupManager + debug logging</column><column name="description">(Still happening in 6.0.9, though that isn't an option in Bugzilla) If I use the BackupManager for session replication AND turn on debug logging, I get this exception when I try to invalidate the session: java.lang.ClassCastException: org.apache.catalina.ha.session.BackupManager cannot be cast to org.apache.catalina.ha.session.DeltaManager 	at org.apache.catalina.ha.session.DeltaSession.expire(DeltaSession.java:361) 	at org.apache.catalina.ha.session.DeltaSession.expire(DeltaSession.java:352) 	at org.apache.catalina.session.StandardSession.expire(StandardSession.java:660) 	at org.apache.catalina.session.StandardSession.invalidate(StandardSession.java:1112) 	at org.apache.catalina.session.StandardSessionFacade.invalidate(StandardSessionFacade.java:150) The bug is easy to find in the source. If debug logging is enabled, it tries to cast manager to DeltaManager without an instanceof, even though it is doing an instanceof immediately after: public void expire(boolean notify, boolean notifyCluster) { String expiredId = getIdInternal(); super.expire(notify); if (notifyCluster) { if (log.isDebugEnabled()) log.debug(sm.getString("deltaSession.notifying", ((DeltaManager)manager).getName(), new Boolean(isPrimarySession()), expiredId)); if ( manager instanceof DeltaManager ) { ( (DeltaManager) manager).sessionExpired(expiredId); } } }</column><column name="report_time">2007-02-22 13:05:50</column><column name="report_timestamp">1172170000</column><column name="status">resolved fixed</column><column name="commit">12d912d</column><column name="commit_timestamp">1174980000</column><column name="files">java/org/apache/catalina/ha/session/DeltaSession.java</column><column name="result" /></table><table name="tomcat"><column name="id">1006</column><column name="bug_id">41166</column><column name="summary">Unable to start ReplicatedContext</column><column name="description">I try to test the Cluster function. I got a problem: something like following apears in the $CATALINA_HOME/logs/catalina.out SEVERE: Unable to start ReplicatedContext java.lang.ClassCastException: org.apache.naming.resources.ProxyDirContext cannot be cast to java.io.Serializable at org.apache.catalina.tribes.tipis.AbstractReplicatedMap$MapEntry.setValue (AbstractReplicatedMap.java:1060) I didn't change any file in $CATALINA_HOME except server.xml, the any thing I changed in server.xml is uncomment the line: &lt;Cluster className="org.apache.catalina.ha.tcp.SimpleTcpCluster"/&gt;. and I add a context configuration file test.xml to $CATALINA_HOME/conf/Catalina/localhost with the flolling content [Aray@BONC-01 conf]$ cat Catalina/localhost/test.xml &lt;Context className="org.apache.catalina.ha.context.ReplicatedContext" path="/test" docBase="/var/www/ClusterTest" debug="0" privileged="true" reloadable="true" &gt; the web.xml file in /var/www/ClusterTest has no &lt;distributable/&gt; element I am worrying about I can't explain the problem clearly with my poor English. So I paste the stepes I do as following: [Aray@BONC-01 apache-tomcat-6.0.2]$ which java /usr/java/jdk1.6.0/bin/java [Aray@BONC-01 apache-tomcat-6.0.2]$ java -version java version "1.6.0-rc" Java(TM) SE Runtime Environment (build 1.6.0-rc-b104) Java HotSpot(TM) Client VM (build 1.6.0-rc-b104, mixed mode, sharing) [Aray@BONC-01 apache-tomcat-6.0.2]$ echo $JAVA_HOME /usr/java/jdk1.6.0 [Aray@BONC-01 apache-tomcat-6.0.2]$ echo $CLASSPATH [Aray@BONC-01 apache-tomcat-6.0.2]$ uname -a Linux BONC-01 2.6.9-34.EL #1 Wed Mar 8 00:07:35 CST 2006 i686 i686 i386 GNU/Linux [root@BONC-01 local]# cat /etc/redhat-release CentOS release 4.3 (Final) [Aray@BONC-01 apache-tomcat-6.0.2]$ cd conf [Aray@BONC-01 conf]$ cat server.xml &lt;!-- Note: A "Server" is not itself a "Container", so you may not define subcomponents such as "Valves" at this level. Documentation at /docs/config/server.html --&gt; &lt;Server port="8005" shutdown="SHUTDOWN"&gt; &lt;!--APR library loader. Documentation at /docs/apr.html --&gt; &lt;Listener className="org.apache.catalina.core.AprLifecycleListener" SSLEngine="on" /&gt; &lt;!--Initialize Jasper prior to webapps are loaded. Documentation at /docs/jasper-howto.html --&gt; &lt;Listener className="org.apache.catalina.core.JasperListener" /&gt; &lt;!-- JMX Support for the Tomcat server. Documentation at /docs/non- existent.html --&gt; &lt;Listener className="org.apache.catalina.mbeans.ServerLifecycleListener" /&gt; &lt;Listener className="org.apache.catalina.mbeans.GlobalResourcesLifecycleListener" /&gt; &lt;!-- Global JNDI resources Documentation at /docs/jndi-resources-howto.html --&gt; &lt;GlobalNamingResources&gt; &lt;!-- Editable user database that can also be used by UserDatabaseRealm to authenticate users --&gt; &lt;Resource name="UserDatabase" auth="Container" type="org.apache.catalina.UserDatabase" description="User database that can be updated and saved" factory="org.apache.catalina.users.MemoryUserDatabaseFactory" pathname="conf/tomcat-users.xml" /&gt; &lt;/GlobalNamingResources&gt; &lt;!-- A "Service" is a collection of one or more "Connectors" that share a single "Container" Note: A "Service" is not itself a "Container", so you may not define subcomponents such as "Valves" at this level. Documentation at /docs/config/service.html --&gt; &lt;Service name="Catalina"&gt; &lt;!-- A "Connector" represents an endpoint by which requests are received and responses are returned. Documentation at : Java HTTP Connector: /docs/config/http.html (blocking &amp; non-blocking) Java AJP Connector: /docs/config/ajp.html APR (HTTP/AJP) Connector: /docs/apr.html Define a non-SSL HTTP/1.1 Connector on port 8080 --&gt; &lt;Connector port="8080" protocol="HTTP/1.1" maxThreads="150" connectionTimeout="20000" redirectPort="8443" /&gt; &lt;!-- Define a SSL HTTP/1.1 Connector on port 8443 This connector uses the JSSE configuration, when using APR, the connector should be using the OpenSSL style configuration described in the APR documentation --&gt; &lt;!-- &lt;Connector port="8443" protocol="HTTP/1.1" maxThreads="150" scheme="https" secure="true" clientAuth="false" sslProtocol="TLS" /&gt; --&gt; &lt;!-- Define an AJP 1.3 Connector on port 8009 --&gt; &lt;Connector port="8009" protocol="AJP/1.3" redirectPort="8443" /&gt; &lt;!-- An Engine represents the entry point (within Catalina) that processes every request. The Engine implementation for Tomcat stand alone analyzes the HTTP headers included with the request, and passes them on to the appropriate Host (virtual host). Documentation at /docs/config/engine.html --&gt; &lt;!-- You should set jvmRoute to support load-balancing via AJP ie : &lt;Engine name="Standalone" defaultHost="localhost" jvmRoute="jvm1"&gt; --&gt; &lt;Engine name="Catalina" defaultHost="localhost"&gt; &lt;!--For clustering, please take a look at documentation at: /docs/cluster-howto.html (simple how to) /docs/config/cluster.html (reference documentation) --&gt; &lt;Cluster className="org.apache.catalina.ha.tcp.SimpleTcpCluster"/&gt; &lt;!-- The request dumper valve dumps useful debugging information about the request and response data received and sent by Tomcat. Documentation at: /docs/config/valve.html --&gt; &lt;!-- &lt;Valve className="org.apache.catalina.valves.RequestDumperValve"/&gt; --&gt; &lt;!-- This Realm uses the UserDatabase configured in the global JNDI resources under the key "UserDatabase". Any edits that are performed against this UserDatabase are immediately available for use by the Realm. --&gt; &lt;Realm className="org.apache.catalina.realm.UserDatabaseRealm" resourceName="UserDatabase"/&gt; &lt;!-- Define the default virtual host Note: XML Schema validation will not work with Xerces 2.2. --&gt; &lt;Host name="localhost" appBase="webapps" unpackWARs="true" autoDeploy="true" xmlValidation="false" xmlNamespaceAware="false"&gt; &lt;!-- SingleSignOn valve, share authentication between web applications Documentation at: /docs/config/valve.html --&gt; &lt;!-- &lt;Valve className="org.apache.catalina.authenticator.SingleSignOn" /&gt; --&gt; &lt;!-- Access log processes all example. Documentation at: /docs/config/valve.html --&gt; &lt;!-- &lt;Valve className="org.apache.catalina.valves.FastCommonAccessLogValve" directory="logs" prefix="localhost_access_log." suffix=".txt" pattern="common" resolveHosts="false"/&gt; --&gt; &lt;/Host&gt; &lt;/Engine&gt; &lt;/Service&gt; &lt;/Server&gt; [Aray@BONC-01 conf]$ mkdir Catalina [Aray@BONC-01 conf]$ ln -s /usr/local/tomcatConf/localhost/ Catalina/localhost [Aray@BONC-01 conf]$ cat Catalina/localhost/test.xml &lt;Context className="org.apache.catalina.ha.context.ReplicatedContext" path="/test" docBase="/var/www/ClusterTest" debug="0" privileged="true" reloadable="true" &gt; &lt;/Context&gt; [Aray@BONC-01 conf]$ cd .. [Aray@BONC-01 apache-tomcat-6.0.2]$ ls bin conf lib LICENSE logs NOTICE RELEASE-NOTES RUNNING.txt temp webapps work [Aray@BONC-01 apache-tomcat-6.0.2]$ rm logs/* [Aray@BONC-01 apache-tomcat-6.0.2]$ bin/catalina.sh version Using CATALINA_BASE: /home/Aray/download/apache-tomcat-6.0.2 Using CATALINA_HOME: /home/Aray/download/apache-tomcat-6.0.2 Using CATALINA_TMPDIR: /home/Aray/download/apache-tomcat-6.0.2/temp Using JRE_HOME: /usr/java/jdk1.6.0 Server version: Apache Tomcat/6.0.2 Server built: Nov 16 2006 12:31:06 Server number: 6.0.2.0 OS Name: Linux OS Version: 2.6.9-34.EL Architecture: i386 JVM Version: 1.6.0-rc-b104 JVM Vendor: Sun Microsystems Inc. [Aray@BONC-01 apache-tomcat-6.0.2]$ bin/startup.sh Using CATALINA_BASE: /home/Aray/download/apache-tomcat-6.0.2 Using CATALINA_HOME: /home/Aray/download/apache-tomcat-6.0.2 Using CATALINA_TMPDIR: /home/Aray/download/apache-tomcat-6.0.2/temp Using JRE_HOME: /usr/java/jdk1.6.0 [Aray@BONC-01 apache-tomcat-6.0.2]$ cat logs/catalina.out INFO: Initializing Coyote HTTP/1.1 on http-8080 Dec 13, 2006 4:07:39 PM org.apache.catalina.startup.Catalina load INFO: Initialization processed in 2532 ms Dec 13, 2006 4:07:40 PM org.apache.catalina.core.StandardService start INFO: Starting service Catalina Dec 13, 2006 4:07:40 PM org.apache.catalina.core.StandardEngine start INFO: Starting Servlet Engine: Apache Tomcat/6.0.2 Dec 13, 2006 4:07:40 PM org.apache.catalina.ha.tcp.SimpleTcpCluster start INFO: Cluster is about to start Dec 13, 2006 4:07:40 PM org.apache.catalina.tribes.transport.ReceiverBase bind INFO: Receiver Server Socket bound to:/127.0.0.1:4000 Dec 13, 2006 4:07:40 PM org.apache.catalina.tribes.membership.McastServiceImpl setupSocket INFO: Setting cluster mcast soTimeout to 500 Dec 13, 2006 4:07:40 PM org.apache.catalina.tribes.membership.McastServiceImpl waitForMembers INFO: Sleeping for 1000 milliseconds to establish cluster membership, start level:4 Dec 13, 2006 4:07:41 PM org.apache.catalina.tribes.membership.McastServiceImpl waitForMembers INFO: Done sleeping, membership established, start level:4 Dec 13, 2006 4:07:41 PM org.apache.catalina.tribes.membership.McastServiceImpl waitForMembers INFO: Sleeping for 1000 milliseconds to establish cluster membership, start level:8 Dec 13, 2006 4:07:42 PM org.apache.catalina.tribes.membership.McastServiceImpl waitForMembers INFO: Done sleeping, membership established, start level:8 Dec 13, 2006 4:07:42 PM org.apache.catalina.core.StandardHost start INFO: XML validation disabled Dec 13, 2006 4:07:42 PM org.apache.catalina.tribes.tipis.AbstractReplicatedMap init INFO: Initializing AbstractReplicatedMap with context name:/test Dec 13, 2006 4:07:43 PM org.apache.catalina.ha.context.ReplicatedContext start SEVERE: Unable to start ReplicatedContext java.lang.ClassCastException: org.apache.naming.resources.ProxyDirContext cannot be cast to java.io.Serializable at org.apache.catalina.tribes.tipis.AbstractReplicatedMap$MapEntry.setValue (AbstractReplicatedMap.java:1060) at org.apache.catalina.tribes.tipis.AbstractReplicatedMap$MapEntry.&lt;init&gt; (AbstractReplicatedMap.java:1005) at org.apache.catalina.tribes.tipis.AbstractReplicatedMap.put (AbstractReplicatedMap.java:859) at org.apache.catalina.core.ApplicationContext.setAttribute (ApplicationContext.java:756) at org.apache.catalina.core.ApplicationContextFacade.setAttribute (ApplicationContextFacade.java:334) at org.apache.catalina.core.StandardContext.start (StandardContext.java:4296) at org.apache.catalina.ha.context.ReplicatedContext.start (ReplicatedContext.java:55) at org.apache.catalina.core.ContainerBase.addChildInternal (ContainerBase.java:760) at org.apache.catalina.core.ContainerBase.addChild (ContainerBase.java:740) at org.apache.catalina.core.StandardHost.addChild(StandardHost.java:525) at org.apache.catalina.startup.HostConfig.deployDescriptor (HostConfig.java:626) at org.apache.catalina.startup.HostConfig.deployDescriptors (HostConfig.java:553) at org.apache.catalina.startup.HostConfig.deployApps (HostConfig.java:488) at org.apache.catalina.startup.HostConfig.start(HostConfig.java:1138) at org.apache.catalina.startup.HostConfig.lifecycleEvent (HostConfig.java:311) at org.apache.catalina.util.LifecycleSupport.fireLifecycleEvent (LifecycleSupport.java:120) at org.apache.catalina.core.ContainerBase.start(ContainerBase.java:1022) at org.apache.catalina.core.StandardHost.start(StandardHost.java:719) at org.apache.catalina.core.ContainerBase.start(ContainerBase.java:1014) at org.apache.catalina.core.StandardEngine.start (StandardEngine.java:443) at org.apache.catalina.core.StandardService.start (StandardService.java:451) at org.apache.catalina.core.StandardServer.start (StandardServer.java:710) at org.apache.catalina.startup.Catalina.start(Catalina.java:552) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke (NativeMethodAccessorImpl.java:39) at sun.reflect.DelegatingMethodAccessorImpl.invoke (DelegatingMethodAccessorImpl.java:25) at java.lang.reflect.Method.invoke(Method.java:597) at org.apache.catalina.startup.Bootstrap.start(Bootstrap.java:288) at org.apache.catalina.startup.Bootstrap.main(Bootstrap.java:413) Dec 13, 2006 4:07:43 PM org.apache.catalina.core.ContainerBase addChildInternal SEVERE: ContainerBase.addChild: start: LifecycleException: Failed to start ReplicatedContext: java.lang.ClassCastException: org.apache.naming.resources.ProxyDirContext cannot be cast to java.io.Serializable at org.apache.catalina.ha.context.ReplicatedContext.start (ReplicatedContext.java:58)</column><column name="report_time">2006-12-13 00:18:02</column><column name="report_timestamp">1165990000</column><column name="status">resolved fixed</column><column name="commit">4f96d21</column><column name="commit_timestamp">1174970000</column><column name="files">java/org/apache/catalina/core/ApplicationContext.java
java/org/apache/catalina/ha/context/ReplicatedContext.java
java/org/apache/catalina/tribes/tipis/AbstractReplicatedMap.java</column><column name="result" /></table><table name="tomcat"><column name="id">1007</column><column name="bug_id">41675</column><column name="summary">Add a debug statement when some necessary header information is missing</column><column name="description">Reference: org.apache.coyote.http11.Http11Processor.java It would be helpful for developers to get informed when some required header information is missing. eg when headers.getValue("host"); returns null and http11 is true. Couldn't you add a log.debug statement that informs the user about missing header-fields? (For example in Http11Processor.java:1391)</column><column name="report_time">2007-02-22 00:36:16</column><column name="report_timestamp">1172120000</column><column name="status">resolved fixed</column><column name="commit">7fd4fa8</column><column name="commit_timestamp">1174860000</column><column name="files">java/org/apache/coyote/http11/Http11Processor.java</column><column name="result" /></table><table name="tomcat"><column name="id">1008</column><column name="bug_id">40150</column><column name="summary">Incorrect User/Role classnames are silently ignored.</column><column name="description">org.apache.catalina.realm.JAASRealm does not verify any of the class names that are set through setRoleClassNames() and setUserClassNames(). If an incorrect class name (e.g. a typo) is configured in context.xml, this is unnoticed by JAASRealm. The result is that during authentication, when the subject's principals are checked against the configured class names, the principals are not recognised, and therefore not added to the subject. The fact an incorrect configured class name is currently not detected and logged makes it very hard to find the source of the problem. It can be easily fixed by checking the class names in the two methods mentioned above. The class must exist, and it must implement java.security.Principal, which is currently not enforced/checked by the code.</column><column name="report_time">2006-08-01 08:52:32</column><column name="report_timestamp">1154440000</column><column name="status">resolved fixed</column><column name="commit">400d684</column><column name="commit_timestamp">1174860000</column><column name="files">java/org/apache/catalina/realm/JAASRealm.java</column><column name="result" /></table><table name="tomcat"><column name="id">1009</column><column name="bug_id">41790</column><column name="summary">JDTCompiler::getContents does not close the reader</column><column name="description">In the class org.apache.jasper.compiler.JDTCompiler: ------------------------------------------------------------------------- public char[] getContents() { char[] result = null; try { InputStreamReader isReader = new InputStreamReader(new FileInputStream(sourceFile), ctxt.getOptions().getJavaEncoding()); Reader reader = new BufferedReader(isReader); if (reader != null) { char[] chars = new char[8192]; StringBuffer buf = new StringBuffer(); int count; while ((count = reader.read(chars, 0, chars.length)) &gt; 0) { buf.append(chars, 0, count); } result = new char[buf.length()]; buf.getChars(0, result.length, result, 0); } } catch (IOException e) { log.error("Compilation error", e); } return result; } ------------------------------------------------------------------------- the variable "reader" is not closed after use it. if I update jsp files frequently, it will exhaust the system file handler. "too many files" errors will come. I test it on Redhat linux, the same problem will occured in tomcat 5 and tomcat 6.</column><column name="report_time">2007-03-07 19:02:57</column><column name="report_timestamp">1173310000</column><column name="status">resolved fixed</column><column name="commit">455b6f8</column><column name="commit_timestamp">1173370000</column><column name="files">java/org/apache/jasper/compiler/JDTCompiler.java</column><column name="result" /></table><table name="tomcat"><column name="id">1010</column><column name="bug_id">41752</column><column name="summary">Wrong message on exception in MemoryRealm</column><column name="description">When Digester read tomcat-user.xml file and exception is throw, then is created new LifecycleException. As first parameter of this Exception is message string. This string is hardcoded to "memoryRealm.readXml", so I thing that log message will be wrong too! I think that there must be used StringManager. actual implementation: Digester digester = getDigester(); try { synchronized (digester) { digester.push(this); digester.parse(file); } } catch (Exception e) { throw new LifecycleException("memoryRealm.readXml", e); } finally { digester.reset(); } fixed: Digester digester = getDigester(); try { synchronized (digester) { digester.push(this); digester.parse(file); } } catch (Exception e) { throw new LifecycleException(sm.getString("memoryRealm.readXml"), e); } finally { digester.reset(); }</column><column name="report_time">2007-03-02 16:28:19</column><column name="report_timestamp">1172870000</column><column name="status">resolved fixed</column><column name="commit">e33b67a</column><column name="commit_timestamp">1172940000</column><column name="files">java/org/apache/catalina/realm/MemoryRealm.java</column><column name="result" /></table><table name="tomcat"><column name="id">1011</column><column name="bug_id">41666</column><column name="summary">If-Unmodified-Since failure</column><column name="description">The If-Unmodified-Since header doesn't work enoughly. failed case: The If-Unmodified-Since header value: 1000000(milliseconds) The lastModified value of target resource: 1001000(milliseconds) In this case, the response's status code should be SC_PRECONDITION_FAILED, but the result is not so. caused by: In DefaultServlet#checkIfUnmodifiedSince: if ( lastModified &gt; (headerValue + 1000)) { I think it should be: if ( lastModified &gt;= (headerValue + 1000)) {</column><column name="report_time">2007-02-21 01:44:28</column><column name="report_timestamp">1172040000</column><column name="status">resolved fixed</column><column name="commit">9ac3428</column><column name="commit_timestamp">1172940000</column><column name="files">java/org/apache/catalina/servlets/DefaultServlet.java</column><column name="result" /></table><table name="tomcat"><column name="id">1012</column><column name="bug_id">41739</column><column name="summary">The servlet with the value 0 in &lt;load-on-startup&gt; tag must be loaded at first.</column><column name="description">Servlet 2.4 specification says: --- If the value is a positive integer or 0, the container must load and initialize the servlet as the application is deployed. The container must guarantee that servlets marked with lower integers are loaded before servlets marked with higher integers. --- I think the servlet with value 0 in &lt;load-on-startup&gt; tag must be loaded at the first. However, Tomcat loads the servlet at the last.</column><column name="report_time">2007-03-01 06:09:41</column><column name="report_timestamp">1172750000</column><column name="status">resolved fixed</column><column name="commit">01d38a5</column><column name="commit_timestamp">1172800000</column><column name="files">java/org/apache/catalina/core/StandardContext.java</column><column name="result" /></table><table name="tomcat"><column name="id">1013</column><column name="bug_id">41608</column><column name="summary">The log level is different at same messages.</column><column name="description">I suggest a little message improvement. The log level is different at same messages. The message "Servlet.service() for servlet {0} threw exception" is output in eight places, but the message level is not same. --org.apache.catalina.core.ApplicationDispatcher#invoke ... wrapper.getLogger().error(sm.getString("applicationDispatcher.serviceException", wrapper.getName()), e); ... wrapper.getLogger().error(sm.getString("applicationDispatcher.serviceException", wrapper.getName()), e); ... wrapper.getLogger().error(sm.getString("applicationDispatcher.serviceException", wrapper.getName()), rootCause); ... wrapper.getLogger().error(sm.getString("applicationDispatcher.serviceException", wrapper.getName()), e); --org.apache.catalina.core.StandardWrapperValve#invoke container.getLogger().warn(sm.getString("standardWrapper.serviceException", wrapper.getName()), e); ... container.getLogger().warn(sm.getString("standardWrapper.serviceException", wrapper.getName()), e); ... container.getLogger().error(sm.getString("standardWrapper.serviceException", wrapper.getName()), rootCause); ... container.getLogger().error(sm.getString("standardWrapper.serviceException", wrapper.getName()), e); Are there any reasons for using getLogger().warn()? I think it would be better that all of them use getLogger().error(...).</column><column name="report_time">2007-02-13 21:45:29</column><column name="report_timestamp">1171420000</column><column name="status">resolved fixed</column><column name="commit">8ba8334</column><column name="commit_timestamp">1171600000</column><column name="files">java/org/apache/catalina/core/StandardWrapperValve.java</column><column name="result" /></table><table name="tomcat"><column name="id">1014</column><column name="bug_id">41578</column><column name="summary">Avoid SimplePool.get/put synchronization in JspFactoryImpl</column><column name="description">Only 1 instance of the JspFactory object (JspFactoryImpl) is created. Consequently there is a single SimplePool of PageContext objects for all JSP requests and so every JSP request must synchronize on the lock inside SimplePool when getting and releasing a PageContext instance. Moreover, the pool has a fixed capacity and after that, the code in JspFactoryImpl will first acquire the lock to see if there are any free objects in the pool, failing which a new PageContext object is created. Instead of a single process-wide pool, a per thread pool of PageContext objects can be used by JspFactoryImpl.</column><column name="report_time">2007-02-09 00:00:43</column><column name="report_timestamp">1171000000</column><column name="status">resolved fixed</column><column name="commit">4612c8a</column><column name="commit_timestamp">1171070000</column><column name="files">java/org/apache/jasper/runtime/JspFactoryImpl.java</column><column name="result" /></table><table name="tomcat"><column name="id">1015</column><column name="bug_id">41558</column><column name="summary">Unnecessary synchronization caused by JspFactory.getDefaultFactory while servicing JSPs</column><column name="description">Tomcat version: 6.0.x trunk Every generated JSP has try { _jspxFactory = JspFactory.getDefaultFactory(); response.setContentType("text/html"); in its _jspService method. The use of JspFactory.getDefaultFactory during request processing should be avoided as it is a *static synchronized* method. I have a diff that addresses this and will attach it to this bug.</column><column name="report_time">2007-02-07 06:03:18</column><column name="report_timestamp">1170850000</column><column name="status">resolved fixed</column><column name="commit">1a8c492</column><column name="commit_timestamp">1170890000</column><column name="files">java/org/apache/jasper/compiler/Generator.java
java/org/apache/jasper/compiler/JspRuntimeContext.java
java/org/apache/jasper/runtime/HttpJspBase.java</column><column name="result" /></table><table name="tomcat"><column name="id">1016</column><column name="bug_id">41521</column><column name="summary">filter-mapping doesn't support * for servlet-name</column><column name="description">SRV 6.2.5 of the servlet 2.5 spec introduces support for '*' as the servlet-name in a filter-mapping. TC6 does not currently support that value as specified. I will attach a patch shortly.</column><column name="report_time">2007-02-01 14:18:55</column><column name="report_timestamp">1170360000</column><column name="status">resolved fixed</column><column name="commit">8b0d130</column><column name="commit_timestamp">1170890000</column><column name="files">java/org/apache/catalina/core/ApplicationFilterFactory.java
java/org/apache/catalina/deploy/FilterMap.java</column><column name="result" /></table><table name="tomcat"><column name="id">1017</column><column name="bug_id">41466</column><column name="summary">NIO Connector: IllegalArgumentException: You can only write using the application write buffer provided by the handler</column><column name="description">Trying to use NIO connector instead of APR connector using Tomcat6 HEAD, I get an IllegalArgumentException while in a call to sendAck. Looking at InternalNioOutputBuffer.sendAck(), it uses ByteBuffer.wrap() to create a new ByteBuffer and uses this ByteBuffer in a call to writeToSocket. There is a check in SecureNioChannel.write() that the ByteBuffer is the one stored in the Commenting the line 372 in SecureNioChannel.java fixes the problem. //if ( src != bufHandler.getWriteBuffer() ) throw new IllegalArgumentException("You can only write using the application write buffer provided by the handler."); But I guess that the check is here for a valid reason, and a better fix would very likely consist in fixing the sendAck or in adding an "or" condition to the test for the case of sendAck(). GRAVE: Cannot find message associated with key standardWrapper.acknowledgeException java.lang.IllegalArgumentException: You can only write using the application write buffer provided by the handler. 	at org.apache.tomcat.util.net.SecureNioChannel.write(SecureNioChannel.java:372) 	at org.apache.tomcat.util.net.NioSelectorPool.write(NioSelectorPool.java:111) 	at org.apache.coyote.http11.InternalNioOutputBuffer.writeToSocket(InternalNioOutputBuffer.java:434) 	at org.apache.coyote.http11.InternalNioOutputBuffer.sendAck(InternalNioOutputBuffer.java:418) 	at org.apache.coyote.http11.Http11NioProcessor.action(Http11NioProcessor.java:1028) 	at org.apache.coyote.Response.action(Response.java:183) 	at org.apache.coyote.Response.acknowledge(Response.java:310) 	at org.apache.catalina.connector.Response.sendAcknowledgement(Response.java:1154) 	at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:169) 	at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:175) 	at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:128) 	at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:105) 	at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:109) 	at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:212) 	at org.apache.coyote.http11.Http11NioProcessor.process(Http11NioProcessor.java:888) 	at org.apache.coyote.http11.Http11NioProtocol$Http11ConnectionHandler.process(Http11NioProtocol.java:624) 	at org.apache.tomcat.util.net.NioEndpoint$Worker.run(NioEndpoint.java:1467) 	at java.lang.Thread.run(Thread.java:595)</column><column name="report_time">2007-01-25 09:12:11</column><column name="report_timestamp">1169730000</column><column name="status">resolved fixed</column><column name="commit">fce171f</column><column name="commit_timestamp">1170020000</column><column name="files">java/org/apache/tomcat/util/net/NioSelectorPool.java</column><column name="result" /></table><table name="tomcat"><column name="id">1018</column><column name="bug_id">39572</column><column name="summary">fixes to use CompressionFilter in WebSphere app server</column><column name="description">There are a couple of small bugs in the compression filter classes that are triggered by using the filter in WebSphere 5.1 or 6. Here are patches. - CompressionResponseStream should not compress the output stream if the response has been committed (because then it cannot write the Content-Encoding: gzip header, and the browser displays the compressed output as-is) - CompressionServletResponseWrapper causes a NullPointerException if you flush before writing anything</column><column name="report_time">2006-05-12 22:28:57</column><column name="report_timestamp">1147490000</column><column name="status">resolved fixed</column><column name="commit">f06d41f</column><column name="commit_timestamp">1169940000</column><column name="files">webapps/examples/WEB-INF/classes/compressionFilters/CompressionFilterTestServlet.java
webapps/examples/WEB-INF/classes/compressionFilters/CompressionResponseStream.java
webapps/examples/WEB-INF/classes/compressionFilters/CompressionServletResponseWrapper.java</column><column name="result" /></table><table name="tomcat"><column name="id">1019</column><column name="bug_id">41265</column><column name="summary">JspServlet's checkInterval parameter cannot be set to 0 implicitly</column><column name="description">conf\web.xml's JspServlet init parameters include 'checkInterval', whose value is explained as follows: If development is false and checkInterval is greater than zero, background compilations are enabled. If I add the following parameters one would think the background compilations would be disabled (the value is not greater than zero). &lt;init-param&gt; &lt;param-name&gt;checkInterval&lt;/param-name&gt; &lt;param-value&gt;0&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;development&lt;/param-name&gt; &lt;param-value&gt;false&lt;/param-value&gt; &lt;/init-param&gt; However, the value is changed to 300 and the following warning is outputted: Dec 30, 2006 7:13:57 PM org.apache.jasper.EmbeddedServletOptions &lt;init&gt; WARNING: Warning: Invalid value for the initParam checkInterval. Will use the default value of "300" seconds According to the comment in web.xml "0" was a valid value. Either the comment or the validity check is wrong. Or my understanding of them.</column><column name="report_time">2006-12-30 02:34:23</column><column name="report_timestamp">1167460000</column><column name="status">resolved fixed</column><column name="commit">39fe247</column><column name="commit_timestamp">1169940000</column><column name="files">java/org/apache/jasper/EmbeddedServletOptions.java</column><column name="result" /></table><table name="tomcat"><column name="id">1020</column><column name="bug_id">40524</column><column name="summary">request.getAuthType() returns different string from HttpServletRequest.CLIENT_CERT_AUTH</column><column name="description">using inspect: request.getAuthType() (java.lang.String) CLIENT-CERT 	 HttpServletRequest.CLIENT_CERT_AUTH (java.lang.String) CLIENT_CERT api says they should be the same object (== should work)</column><column name="report_time">2006-09-16 01:49:08</column><column name="report_timestamp">1158390000</column><column name="status">resolved fixed</column><column name="commit">dc33554</column><column name="commit_timestamp">1169930000</column><column name="files">java/org/apache/catalina/authenticator/Constants.java
java/org/apache/catalina/authenticator/SSLAuthenticator.java
java/org/apache/catalina/authenticator/SingleSignOn.java
java/org/apache/catalina/authenticator/SingleSignOnEntry.java</column><column name="result" /></table><table name="tomcat"><column name="id">1021</column><column name="bug_id">41217</column><column name="summary">SingleSignOn Cookie does not honor https access: Login Information Disclosure</column><column name="description">When using the SingleSignOn Valve (org.apache.catalina.authenticator.SingleSignOn) via https the Cookie JSESSIONIDSSO is transmitted without the "secure" attribute, resulting in it being transmitted to any content that is - by purpose or error - requested via http from the same server. As the content of the SSO-Cookie is confidential (it will lead to automatically logged in sessions in other contexts - https or non-https) this should never happen. Sorry to have no patch. I've not installed the complete source distribution in my development environment, but it seems the points to change are org.apache.catalina.authenticator.AuthenticatorBase.register(...), the code of interest being (from 5.5.30 source distribution) Cookie cookie = new Cookie(Constants.SINGLE_SIGN_ON_COOKIE, ssoId); cookie.setMaxAge(-1); cookie.setPath("/"); hres.addCookie(cookie); As hres is an org.apache.catalina.HttpRequest, and I've looked through the code to find org.apache.catalina.Request.setSecure() but no ...isSecure() (though this is mentioned in the Javadoc for ...setSecure()) I suppose there needs to be another change to provide isSecure on Request or HttpRequest, but this is difficult to tell only from the editor. If isSecure() was there, there'd be a cookie.setSecure(hres.isSecure()) missing in the statements above...</column><column name="report_time">2006-12-20 05:13:27</column><column name="report_timestamp">1166610000</column><column name="status">resolved fixed</column><column name="commit">11b9c92</column><column name="commit_timestamp">1169930000</column><column name="files">java/org/apache/catalina/authenticator/AuthenticatorBase.java</column><column name="result" /></table><table name="tomcat"><column name="id">1022</column><column name="bug_id">41327</column><column name="summary">Jasper does'nt display the full path of the file in a 404 Not found  error page</column><column name="description">When you try accessing a non-existent jsp page in a webapp, tomcat(jasper) doesnt display the full path of the file which was not found in the browser. example: Accessing a non-existent jsp page say a.jsp with this url http://localhost:8080/jsp-examples/a.jsp would return a 404 Not Found error page which displays "/a.jsp not found". Rather it should be "/jsp-examples/a.jsp not found".</column><column name="report_time">2007-01-09 00:32:55</column><column name="report_timestamp">1168320000</column><column name="status">resolved fixed</column><column name="commit">3a6225a</column><column name="commit_timestamp">1169930000</column><column name="files">java/org/apache/jasper/servlet/JspServlet.java</column><column name="result" /></table><table name="tomcat"><column name="id">1023</column><column name="bug_id">40820</column><column name="summary">Default JSP factory not initialized early enough</column><column name="description">With the latest TC6 code, I'm seeing a problem that did not exist on earlier TC6 drivers. Sorry that I can't put a finger on when this problem arose. I looked into relevant source files (like JspRuntimeContext) but haven't found the source of the problem. Here's the issue (a testcase will be attached). The app is very simple: it installs ServletContextListener for the purpose of adding a custom ELResolver. It accomplishes this via: public void contextInitialized(ServletContextEvent evt) { ServletContext context = evt.getServletContext(); JspApplicationContext jspContext = JspFactory.getDefaultFactory().getJspApplicationContext(context); jspContext.addELResolver(new ChipsELResolver()); } The problem is that JspFactory.getDefaultFactory() is returning null; see below. Oct 4, 2006 5:32:18 PM org.apache.catalina.core.AprLifecycleListener lifecycleEv ent INFO: The Apache Tomcat Native library which allows optimal performance in produ ction environments was not found on the java.library.path: C:\javaFor6.0BuildJDK 15\java\jre\bin;.;C:\javaFor6.0BuildJDK15\java\bin;c:\mantis2.1\mantis\bin;C:\se tupIBASE;C:\Perl\bin\;C:\WINDOWS\system32;C:\WINDOWS;C:\WINDOWS\System32\Wbem;c: \Python22;C:\Program Files\PC-Doctor for Windows\services;c:\cvsnt-2.0.4;c:\ecli pse;w:\;w:\bin;C:\Program Files\QuickTime\QTSystem\;C:\Diskeeper\;C:\CMVC\exe;C: \CMVC\exe\bin;;C:\CMVCDC50;C:\CMVCDC50;C:\CMVCDC50; Oct 4, 2006 5:32:18 PM org.apache.coyote.http11.Http11Protocol init INFO: Initializing Coyote HTTP/1.1 on http-8080 Oct 4, 2006 5:32:19 PM org.apache.catalina.startup.Catalina load INFO: Initialization processed in 1234 ms Oct 4, 2006 5:32:19 PM org.apache.catalina.core.StandardService start INFO: Starting service Catalina Oct 4, 2006 5:32:19 PM org.apache.catalina.core.StandardEngine start INFO: Starting Servlet Engine: Apache Tomcat/6.0.0-dev Oct 4, 2006 5:32:19 PM org.apache.catalina.core.StandardHost start INFO: XML validation disabled Oct 4, 2006 5:32:19 PM org.apache.catalina.startup.HostConfig deployWAR INFO: Deploying web application archive ELResolverTest.war ChipsListener.contextInitialized evt= javax.servlet.ServletContextEvent[source= org.apache.catalina.core.ApplicationContextFacade@3fbe3fbe] ChipsListener.contextInitialized context= org.apache.catalina.core.ApplicationC ontextFacade@3fbe3fbe ChipsListener.contextInitialized JspFactory.getDefaultFactory()= null Oct 4, 2006 5:32:20 PM org.apache.catalina.core.StandardContext start SEVERE: Error listenerStart Oct 4, 2006 5:32:20 PM org.apache.catalina.core.StandardContext start SEVERE: Context [/ELResolverTest] startup failed due to previous errors Oct 4, 2006 5:32:21 PM org.apache.coyote.http11.Http11Protocol start INFO: Starting Coyote HTTP/1.1 on http-8080 Oct 4, 2006 5:32:21 PM org.apache.jk.common.ChannelSocket init INFO: JK: ajp13 listening on /0.0.0.0:8009 Oct 4, 2006 5:32:21 PM org.apache.jk.server.JkMain start INFO: Jk running ID=0 time=0/63 config=null Oct 4, 2006 5:32:21 PM org.apache.catalina.startup.Catalina start INFO: Server startup in 2657 ms This is easily reproducible when you deploy the ELResolverTest.war *before* the server has started (I assume JspFactory.setDefaultFactory() hasn't been invoked at the time the listeners are being installed). If you deploy the WAR *after* the server starts, the problem does not manifest and the app works --- until you stop and restart the server.</column><column name="report_time">2006-10-26 07:52:03</column><column name="report_timestamp">1161860000</column><column name="status">resolved fixed</column><column name="commit">a1b1bed</column><column name="commit_timestamp">1167780000</column><column name="files">java/org/apache/catalina/core/JasperListener.java</column><column name="result" /></table><table name="tomcat"><column name="id">1024</column><column name="bug_id">41074</column><column name="summary">Output of tag "jsp:plugin" is not conform to XHTML.</column><column name="description">The jsp comiler outputs all tag required for an object in upper case letters. To be conform with XHTML lower case is required, but all tags are hard coded in the generator.</column><column name="report_time">2006-11-29 05:35:54</column><column name="report_timestamp">1164800000</column><column name="status">resolved fixed</column><column name="commit">5f9c18d</column><column name="commit_timestamp">1165550000</column><column name="files">java/org/apache/jasper/compiler/Generator.java</column><column name="result" /></table><table name="tomcat"><column name="id">1025</column><column name="bug_id">40585</column><column name="summary">org.apache.juli.FileHandler does not allow programmatic creation using parametrized constructor</column><column name="description">If org.apache.juli.FileHandler is created programmatically with parametrized constructor public FileHandler(String directory, String prefix, String suffix) , FileHandler ignores custom constructor parameters, creates log handler with default configuration and writes log file to "${catalina_home}/bin/logs" with the name "juli.YYYY-MM-DD.log" (YYYY, MM and DD are substituted with actual year, month and date) It looks like the problem is in the fact parametrized constructor calls default constructor. Default constructor in turn performs handler configuration from LogManager properties and creates a log file based on this default configuration. This makes custom constructor parameters effectively ignored.</column><column name="report_time">2006-09-22 18:06:20</column><column name="report_timestamp">1158960000</column><column name="status">resolved fixed</column><column name="commit">c6b3f71</column><column name="commit_timestamp">1165540000</column><column name="files">java/org/apache/juli/FileHandler.java</column><column name="result" /></table><table name="tomcat"><column name="id">1026</column><column name="bug_id">41089</column><column name="summary">JspFactoryImpl has SPEC_VERSION = "2.0"</column><column name="description">org.apache.jasper.runtime.JspFactoryImpl has private static final String SPEC_VERSION = "2.0"; Should be: private static final String SPEC_VERSION = "2.1";</column><column name="report_time">2006-11-30 10:12:31</column><column name="report_timestamp">1164900000</column><column name="status">resolved fixed</column><column name="commit">514256e</column><column name="commit_timestamp">1164980000</column><column name="files">java/org/apache/jasper/compiler/ImplicitTagLibraryInfo.java
java/org/apache/jasper/compiler/PageDataImpl.java
java/org/apache/jasper/compiler/Validator.java</column><column name="result" /></table><table name="tomcat"><column name="id">1027</column><column name="bug_id">41057</column><column name="summary">Tomcat leaks memory on every request</column><column name="description">POST parameter values stay referenced by a static field in org.apache.tomcat.util.buf.StringCache - thus the GC can never release the memory. Steps to Reproduce: 1) install and start tomcat 5.5 (http://apache.zone-h.org/tomcat/tomcat-5/v5.5.20/bin/apache-tomcat-5.5.20.zip) 2) see the example webapp "Request Parameters Example" included in the install (http://localhost:8080/servlets-examples/servlet/RequestParamExample) 3) run script "send.sh" to create heavy load #!/bin/bash export LEAK_COMMAND='curl --silent http://localhost:8080/servlets-examples/servlet/RequestParamExample --output response.htm --data @send.txt' #create initial POST parameter with value about 10kB echo "firstname=" &gt; send.txt for((i=0;$i&lt;=10000;i=$(($i+1))));do echo -n "x" &gt;&gt; send.txt done #send the request for((i=0;$i&lt;=1000;i=$(($i+1))));do echo $i # modify the param value to send (append i) echo -n $i &gt;&gt; send.txt $LEAK_COMMAND done 4) running the script causes heap usage to increase for some 40MB</column><column name="report_time">2006-11-28 10:07:27</column><column name="report_timestamp">1164730000</column><column name="status">resolved fixed</column><column name="commit">de5c3b7</column><column name="commit_timestamp">1164760000</column><column name="files">java/org/apache/tomcat/util/buf/StringCache.java</column><column name="result" /></table><table name="tomcat"><column name="id">1028</column><column name="bug_id">41008</column><column name="summary">POST request ignores command line parameters</column><column name="description">example: &lt;form method="POST" action="test.exe?test1"&gt;&lt;input type="hidden" value="test2"&gt;&lt;input type="submit"&gt;&lt;/form&gt; this code does invoke the test.exe without passing the test1 command line parameter the example works in apache httpd and ms iis fix: CGIServlet.java if (!"GET".equals(req.getMethod()) &amp;&amp; !"POST".equals(req.getMethod()) &amp;&amp; !"HEAD".equals(req.getMethod())) return;</column><column name="report_time">2006-11-21 09:20:32</column><column name="report_timestamp">1164120000</column><column name="status">resolved fixed</column><column name="commit">b70962f</column><column name="commit_timestamp">1164410000</column><column name="files">java/org/apache/catalina/servlets/CGIServlet.java</column><column name="result" /></table><table name="tomcat"><column name="id">1029</column><column name="bug_id">40901</column><column name="summary">listings page does not escape XML characters</column><column name="description">On Solaris you can have a file or directory name called "&lt;b&gt;xxx" or "&lt;i&gt;yyy". Using Tomcat's listings feature, you get a directory listing with the file name in bold or italics. I am not familiar with Javascript or cross-site scripting security problems, but I believe Tomcat escapes XML characters like "&gt;" and "&lt;" to prevent client browsers to interpret HTML codes that are not intended to be interpreted as such for the default error page. I think the same should be done for listings, or a warning should be added to the documentation not to use it if you have no control over the file/directory names you list.</column><column name="report_time">2006-11-05 20:38:27</column><column name="report_timestamp">1162780000</column><column name="status">resolved fixed</column><column name="commit">cb2c655</column><column name="commit_timestamp">1163980000</column><column name="files">java/org/apache/catalina/servlets/DefaultServlet.java</column><column name="result" /></table><table name="tomcat"><column name="id">1030</column><column name="bug_id">40929</column><column name="summary">Misleading comments in StandardClassLoader</column><column name="description">Sometime during the Tomcat 5 development, the StandardClassLoader in org.apache.catalina.loader package was stripped down, and is now just a URLClassLoader. I work with code that extends the StandardClassLoader (we use the automatic reloading of jar files), and during an upgrade from tomcat 4 to tomcat 5.5 found difficultly trying to figure out what had happened to the code. I ended up having to install SVN and do a svn log to figure out why the code was removed. When the code was stripped down, the comments in the java file (and therefore in the javadoc api) remained identical, so the javadoc api for the class is very misleading. For instance, the comments say that the class implements Reloader, when it in fact does not. The class comments should be updated to reflect the state of the code. I can't see this as being very high priority, but it would likely be an easy to fix for people whom are in the code regularly, and it would make the javadoc much more readable for people that extend the StandardClassLoader for their own purposes.</column><column name="report_time">2006-11-08 14:23:40</column><column name="report_timestamp">1163010000</column><column name="status">resolved fixed</column><column name="commit">6009702</column><column name="commit_timestamp">1163980000</column><column name="files">java/org/apache/catalina/loader/StandardClassLoader.java</column><column name="result" /></table><table name="tomcat"><column name="id">1031</column><column name="bug_id">40860</column><column name="summary">Tomcat loses request parameters</column><column name="description">Hi, Im having a problem with parameters loses in tomcat. Its an intermittent problem. That occurs when I do some ajaxs request and then I do one or more form submissions. I put the tomcat in debug mode and I observed the class CoyoteAdapter  the method service(). There exists a request variable (CoyoteRequest type) that has a protected variable requestParametersParsed that is a flag to parse or not parse the parameters of a post or get. In the end of the method exists a finally clause that force the request variable to do a recycle. The recycle forces the requestParametersParsed variable to change to false. Then in the next utilization of the class the parameters will be parsed again. The problem that Ive found is in some situations (as described at the start) the requestParametersParsed variable is true and the parameters are not parsed. The consequence of this is that in my servlet when I ask request.getParameter() and it returns null but in my query string or in my post data has the parameter. The prove of that is when I ask request.getQueryString() and it returns a not empty string with my parameter. Ex: request.getQueryString() = servlet?param=x request.getParameter(param) = null See a pierce of the method service of CoyoteAdapter: public void service(Request req, Response res) throws Exception {  try { // Parse and set Catalina and configuration specific // request parameters if ( postParseRequest(req, request, res, response) ) { // Calling the container connector.getContainer().invoke(request, response); }  } finally { // Recycle the wrapper request and response request.recycle(); response.recycle(); } } At line if postParseRequest( the request. requestParametersParsed must be false but in some situations it is true! I cant find the cause of the problem but I found the problem. To resolve my problem I put a request.recycle(); before the line to force the requestParametersParsed variable to false. I dont want to have a tomcat modified by me. Its not good. See the post http://mail-archives.apache.org/mod_mbox/tomcat-dev/200601.mbox/%3C43D11EAA.1090905@amazon.com.br%3E He is having the same problem. Thanks Thiago</column><column name="report_time">2006-11-01 04:29:15</column><column name="report_timestamp">1162370000</column><column name="status">resolved fixed</column><column name="commit">e713e77</column><column name="commit_timestamp">1163980000</column><column name="files">java/org/apache/catalina/connector/Request.java
java/org/apache/tomcat/util/http/Parameters.java</column><column name="result" /></table><table name="tomcat"><column name="id">1032</column><column name="bug_id">37509</column><column name="summary">ClassLoaderLogManager remove '\n' at the end of logging.properties values</column><column name="description">The method ClassLoaderLogManager.replace(String) that is in charge of replacing system properties at the begining of the property also modify the end of the property due to a call to trim. This implies that Logger/Handler/Formatter that relies on properties endding with some spases (including '\n') will have a different behaviour with JDK LogManger and tomcat ClassLoaderLogManager a modified verstion of this method could be: protected String replace(String str) { // start modification 	 // String result = str.trim(); // commented out 	 	int len = str.length(); 	int st = 0; 	while ((st &lt; len) &amp;&amp; (str.charAt(st) &lt;= ' ')) { 	 st++; 	} 	String result = (st &gt; 0) ? str.substring(st) : str; // end modification if (result.startsWith("${")) { int pos = result.indexOf('}'); if (pos != -1) { String propName = result.substring(2, pos); String replacement = System.getProperty(propName); if (replacement != null) { result = replacement + result.substring(pos + 1); } } } return result; }</column><column name="report_time">2005-11-15 18:22:38</column><column name="report_timestamp">1132100000</column><column name="status">resolved fixed</column><column name="commit">a6d6962</column><column name="commit_timestamp">1163980000</column><column name="files">java/org/apache/juli/ClassLoaderLogManager.java</column><column name="result" /></table><table name="tomcat"><column name="id">1033</column><column name="bug_id">40844</column><column name="summary">JDBCRealm.getPassword throws NullPointerException</column><column name="description">JDBCRealm.getPassword throws NullPointerException I'm using tomcat 5.5.20 with postgresql-8.1-407.jdbc3.jar and postgresql-8.1.4 on Ubuntu Dapper. Authenticating two users simultaneously with HTTP DIGEST causes sometimes the following errors and a 401 Unauthorized reply: 30.10.2006 14:24:54 org.apache.catalina.realm.JDBCRealm getPassword SEVERE: Exception performing authentication org.postgresql.util.PSQLException: ERROR: invalid message format at org.postgresql.core.v3.QueryExecutorImpl.receiveErrorResponse(QueryExecutorImpl.java:1525) at org.postgresql.core.v3.QueryExecutorImpl.processResults(QueryExecutorImpl.java:1309) at org.postgresql.core.v3.QueryExecutorImpl.execute(QueryExecutorImpl.java:188) at org.postgresql.jdbc2.AbstractJdbc2Statement.execute(AbstractJdbc2Statement.java:452) at org.postgresql.jdbc2.AbstractJdbc2Statement.executeWithFlags(AbstractJdbc2Statement.java:354) at org.postgresql.jdbc2.AbstractJdbc2Statement.executeQuery(AbstractJdbc2Statement.java:258) at org.apache.catalina.realm.JDBCRealm.getPassword(JDBCRealm.java:546) at org.apache.catalina.realm.RealmBase.getDigest(RealmBase.java:1156) at org.apache.catalina.realm.RealmBase.authenticate(RealmBase.java:365) at org.apache.catalina.authenticator.DigestAuthenticator.findPrincipal(DigestAuthenticator.java:282) at org.apache.catalina.authenticator.DigestAuthenticator.authenticate(DigestAuthenticator.java:175) at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:490) at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:126) at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:105) at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:107) at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:148) at org.apache.coyote.http11.Http11Processor.process(Http11Processor.java:869) at org.apache.coyote.http11.Http11BaseProtocol$Http11ConnectionHandler.processConnection(Http11BaseProtocol.java:664) at org.apache.tomcat.util.net.PoolTcpEndpoint.processSocket(PoolTcpEndpoint.java:527) at org.apache.tomcat.util.net.LeaderFollowerWorkerThread.runIt(LeaderFollowerWorkerThread.java:80) at org.apache.tomcat.util.threads.ThreadPool$ControlRunnable.run(ThreadPool.java:684) at java.lang.Thread.run(Thread.java:595) 30.10.2006 14:24:54 org.apache.catalina.connector.CoyoteAdapter service SEVERE: An exception or error occurred in the container during the request processing java.lang.NullPointerException at org.apache.catalina.realm.JDBCRealm.getPassword(JDBCRealm.java:568) at org.apache.catalina.realm.JDBCRealm.getPrincipal(JDBCRealm.java:594) at org.apache.catalina.realm.RealmBase.authenticate(RealmBase.java:398) at org.apache.catalina.authenticator.DigestAuthenticator.findPrincipal(DigestAuthenticator.java:282) at org.apache.catalina.authenticator.DigestAuthenticator.authenticate(DigestAuthenticator.java:175) at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:490) at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:126) at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:105) at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:107) at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:148) at org.apache.coyote.http11.Http11Processor.process(Http11Processor.java:869) at org.apache.coyote.http11.Http11BaseProtocol$Http11ConnectionHandler.processConnection(Http11BaseProtocol.java:664) at org.apache.tomcat.util.net.PoolTcpEndpoint.processSocket(PoolTcpEndpoint.java:527) at org.apache.tomcat.util.net.LeaderFollowerWorkerThread.runIt(LeaderFollowerWorkerThread.java:80) at org.apache.tomcat.util.threads.ThreadPool$ControlRunnable.run(ThreadPool.java:684) at java.lang.Thread.run(Thread.java:595)</column><column name="report_time">2006-10-30 06:25:52</column><column name="report_timestamp">1162210000</column><column name="status">resolved fixed</column><column name="commit">be9d523</column><column name="commit_timestamp">1163980000</column><column name="files">java/org/apache/catalina/realm/JDBCRealm.java</column><column name="result" /></table><table name="tomcat"><column name="id">1034</column><column name="bug_id">40913</column><column name="summary">JasperException raised against valid attribute</column><column name="description">In org.apache.jasper.compiler.Validator.checkXmlAttributes(), the validation for deferred values and methods is raising an exception when an rtexprvalue attribute is legitimate. ------Stacktrace------ org.apache.jasper.JasperException: org.apache.jasper.JasperException: /index.jsp(83,0) According to TLD or attribute directive in tag file, attribute items does not accept any expressions org.apache.jasper.servlet.JspServletWrapper.handleJspException (JspServletWrapper.java:565) org.apache.jasper.servlet.JspServletWrapper.service (JspServletWrapper.java:354) org.apache.jasper.servlet.JspServlet.serviceJspFile(JspServlet.java:320) org.apache.jasper.servlet.JspServlet.service(JspServlet.java:266) javax.servlet.http.HttpServlet.service(HttpServlet.java:803) ------relevant code in checkXmlAttributes()------ if (!deferred &amp;&amp; (tldAttrs[j].isDeferredMethod() || tldAttrs [j].isDeferredValue())) { // Only deferred expressions are allowed for this attribute err.jspError(n, "jsp.error.attribute.custom.non_rt_with_expr", tldAttrs[j].getName()); } ------testcase------ &lt;c:forEach var="k" items="${colors}"&gt; &lt;li&gt;&lt;font color="${k}"&gt;This line is ${k}&lt;/font&gt;. &lt;/c:forEach&gt; The TLD for JSTL 1.2 says items can be an rtexprvalue and also a deferred- value. So the above usage is correct. Attaching a testcase WAR. ------summary------ I don't think this code is really necessary; at least, it needs to be relaxed to allow tai.canBeRequestTime() values.</column><column name="report_time">2006-11-06 16:24:05</column><column name="report_timestamp">1162850000</column><column name="status">resolved fixed</column><column name="commit">f7ca96d</column><column name="commit_timestamp">1162900000</column><column name="files">java/org/apache/jasper/compiler/Validator.java</column><column name="result" /></table><table name="tomcat"><column name="id">1035</column><column name="bug_id">34956</column><column name="summary">Tomcat should enforce the requirements from servlet 2.4 specification SRV.8.2</column><column name="description">Tomcat should enforce the requirements from servlet 2.4 specification SRV.8.2 SRV.8.2 Using a Request Dispatcher "To use a request dispatcher, a servlet calls either the include method or forward method of the RequestDispatcher interface. The parameters to these methods can be either the request and response arguments that were passed in via the service method of the Servlet interface, or instances of subclasses of the request and response wrapper classes that have been introduced for version 2.3 of the specification. In the latter case, the wrapper instances must wrap the request or response objects that the container passed into the service method. The Container Provider must ensure that the dispatch of the request to a target servlet occurs in the same thread of the same VM as the original request" Justification: ============== The absense of this enforcement leads to software beeing developed not following the specification. The software cannot be deployed later on a container which conforms to the above paragraph and hence must be changed before deployment. This somehow contradicts the idea of having a standards based infrastructure.</column><column name="report_time">2005-05-18 14:47:47</column><column name="report_timestamp">1116440000</column><column name="status">resolved fixed</column><column name="commit">22d1ad7</column><column name="commit_timestamp">1162680000</column><column name="files">java/org/apache/catalina/core/ApplicationDispatcher.java
java/org/apache/catalina/core/ApplicationFilterChain.java</column><column name="result" /></table><table name="tomcat"><column name="id">1036</column><column name="bug_id">40817</column><column name="summary">servlet-cgi throws index out of bounds exception on certain cgi</column><column name="description">First, servlets-cgi.jar needs to exist and the servlet must be mapped: for example: &lt;servlet-mapping&gt; &lt;servlet-name&gt;cgi&lt;/servlet-name&gt; &lt;url-pattern&gt;*.pl&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; Test perl cgi script: #!/usr/bin/perl print "Content-type: text/plain", "\n\n"; print "Hello world, from Perl\n"; One perl script is placed in www-root ("/test.pl") and the other in any subfolder ("/test/test.pl" or "/cgi-bin/test.pl", etc.) The cgi script in the subfolder will run fine. The cgi script in the www-root will generate an exception: java.lang.StringIndexOutOfBoundsException: String index out of range: -1 	java.lang.String.substring(String.java:1768) 	java.lang.String.substring(String.java:1735) 	org.apache.catalina.servlets.CGIServlet$CGIEnvironment.findCGI(CGIServlet.java:948) 	org.apache.catalina.servlets.CGIServlet$CGIEnvironment.setCGIEnvironment(CGIServlet.java:1015) 	org.apache.catalina.servlets.CGIServlet$CGIEnvironment.&lt;init&gt;(CGIServlet.java:766) 	org.apache.catalina.servlets.CGIServlet.doGet(CGIServlet.java:584) 	javax.servlet.http.HttpServlet.service(HttpServlet.java:689) 	javax.servlet.http.HttpServlet.service(HttpServlet.java:802) The problem is this line (line 948 in CGIServlet.java): cginame = currentLocation.getParent().substring(webAppRootDir.length())+ File.separator + name; The problem is that webAppRootDir is 1 char longer than currentLocation.getParent() because webAppRootDir ends with a File.separator (in this case, a "/"). And removing the extra File.separator from webAppRootDir will result in a different String related exception elsewhere. And here's a fix that works: cginame = (currentLocation.getParent() + File.separator).substring(webAppRootDir.length()) + name; (If necessary, the fix can be made more adaptive by checking to see if it really does have a File.separator at the end and if not...add it...otherwise, let it be, etc.) (on a side note, I have one more bug to fix; the ENV_VAR "SCRIPT_FILENAME" isn't defined as it should be [required for PHP4/5] but I'll submit a different bug/fix for that.)</column><column name="report_time">2006-10-25 20:02:52</column><column name="report_timestamp">1161820000</column><column name="status">resolved fixed</column><column name="commit">6d274b4</column><column name="commit_timestamp">1162680000</column><column name="files">java/org/apache/catalina/servlets/CGIServlet.java</column><column name="result" /></table><table name="tomcat"><column name="id">1037</column><column name="bug_id">37458</column><column name="summary">Datarace on org.apache.catalina.loader.WebappClassLoader</column><column name="description">In findClassInternal, it is possible that entry.manifest is set to null by another thread right before calling definePackage(packageName, entry.manifest, entry.codeBase).</column><column name="report_time">2005-11-10 21:34:17</column><column name="report_timestamp">1131680000</column><column name="status">resolved fixed</column><column name="commit">79631bb</column><column name="commit_timestamp">1162680000</column><column name="files">java/org/apache/catalina/loader/WebappClassLoader.java</column><column name="result" /></table><table name="tomcat"><column name="id">1038</column><column name="bug_id">40723</column><column name="summary">Wrong and misleading documentation in JDBCAccessLogValve</column><column name="description">In the class JDBCAccessLogValve is an example for an table to hold access log values. In this table is a column ts which is defined as not null. This will only work on MySQL, because this value is never written by the Valve and other databases will complain about a column which is not filled with a value.</column><column name="report_time">2006-10-11 02:50:26</column><column name="report_timestamp">1160550000</column><column name="status">resolved fixed</column><column name="commit">9cb5aff</column><column name="commit_timestamp">1161140000</column><column name="files">java/org/apache/catalina/valves/JDBCAccessLogValve.java</column><column name="result" /></table><table name="tomcat"><column name="id">1039</column><column name="bug_id">40771</column><column name="summary">Can't read POST data from within a filter or valve</column><column name="description">I was attempting to create a Filter or Valve that could be placed in front of an Axis web service that would handle security according to the WS-Security specification. That turned out to be a rabbit trail, but I did find and fix a bug that I discovered along the way. I ran into problems reading POST data (the web service request) from the org.apache.catalina.connector.Request object exposed in the Filter/Valve interfaces. This is a chunk of code in a prototype Valve that didn't work: private ByteChunk getPOSTBody(Request request) throws IOException { ByteChunk retval = new ByteChunk(request.getContentLength()); ByteChunk body = new ByteChunk(request.getContentLength()); int bytesRead; do { bytesRead = request.getCoyoteRequest().doRead(body); retval.append(body); } while (bytesRead &gt;= 0) ; //puts the data back into the pipe. request.getCoyoteRequest().action (ActionCode.ACTION_REQ_SET_BODY_REPLAY, retval); return retval; } This code works as designed, however the problem occurs later on when Axis attempted to parse the web service request. I don't remember the exact Axis error, but I was able to track the problem down to a bug in the org.apache.coyote.http11.filters.SavedRequestInputFilter class. The doRead method was not properly implemented to return a -1 when appropriate. Here is my modified version of the doRead method: public int doRead(ByteChunk chunk, org.apache.coyote.Request request) throws IOException { int writeLength = 0; if (chunk.getLimit() &gt; 0 &amp;&amp; chunk.getLimit() &lt; input.getLength()) { writeLength = chunk.getLimit(); } else { 	writeLength = input.getLength(); } if(input.getOffset()&gt;= input.getEnd()) return -1; input.substract(chunk.getBuffer(), 0, writeLength); chunk.setOffset(0); chunk.setEnd(writeLength); return writeLength; } This bug won't show up unless someone tries to use a filter/valve to do something with web services. That's not too likely because that's what we have SOAPHandlers for.</column><column name="report_time">2006-10-16 16:08:36</column><column name="report_timestamp">1161030000</column><column name="status">resolved fixed</column><column name="commit">17eecdb</column><column name="commit_timestamp">1161140000</column><column name="files">java/org/apache/coyote/http11/filters/SavedRequestInputFilter.java</column><column name="result" /></table><table name="tomcat"><column name="id">1040</column><column name="bug_id">39724</column><column name="summary">Bug on StandardPipeline.removeValve(Valve valve) for T5.5.16+</column><column name="description">I run into this problem with T5 when tring to add/remove/add a valve to the standard engine. -For what I understand an empty pipeline has: basic = StandardEngineValve (For example); first = null; -If you add a valve you will get basic = StandardEngineValve first = myValve (with myValve.next = StandardEngineValve) -If you remove the valve you will get basic =StandardEngineValve first = StandardEngineValve Note that StandardEngineValve is in first too here. -If I try to add a new valve given the actual code in addValve the valve will not be added because (see the **) current = basic and current.getNext() = null; addValve(Valve valve) { // Add this Valve to the set associated with this Pipeline if (first == null) { first = valve; valve.setNext(basic); } else { Valve current = first; while (current != null) { ** if (current.getNext() == basic) { current.setNext(valve); valve.setNext(basic); break; } current = current.getNext(); } } }</column><column name="report_time">2006-06-05 14:01:56</column><column name="report_timestamp">1149530000</column><column name="status">resolved fixed</column><column name="commit">b18c29e</column><column name="commit_timestamp">1159840000</column><column name="files">java/org/apache/catalina/core/StandardPipeline.java</column><column name="result" /></table><table name="tomcat"><column name="id">1041</column><column name="bug_id">29727</column><column name="summary">JNDI env-entry not reload when context reloaded</column><column name="description">If environment entries are changed in web.xml, and the application context is restarted, the values in the JNDI context are the old values. If the environment entries are changed via the Tomcat 'admin' interface, then the values provided to the context are correct. The following code is can be used to check the environment: try { InitialContext ic = new InitialContext(); NamingEnumeration enum = ic.listBindings("java:comp/env"); while (enum.hasMore()) { Binding binding = (Binding) enum.next(); jndi.setProperty(binding.getName(), "" + binding.getObject()); System.out.println("jndi setting: " + binding.getName() + "=" + binding.getObject()); } } catch (NamingException e) { System.err.println("unable to read JNDI settings, " + e); } The web.xml fragment looks as follows: 	&lt;env-entry&gt; 		&lt;env-entry-name&gt;DatabaseURL&lt;/env-entry-name&gt; 		&lt;env-entry-value&gt;jdbc:hsqldb:hsql://localhost&lt;/env-entry-value&gt; 		&lt;env-entry-type&gt;java.lang.String&lt;/env-entry-type&gt; 	&lt;/env-entry&gt;</column><column name="report_time">2004-06-21 22:56:25</column><column name="report_timestamp">1087870000</column><column name="status">resolved fixed</column><column name="commit">1a5e6e7</column><column name="commit_timestamp">1159750000</column><column name="files">java/org/apache/catalina/deploy/NamingResources.java</column><column name="result" /></table><table name="tomcat"><column name="id">1042</column><column name="bug_id">40625</column><column name="summary">CGIServlet eats root cause</column><column name="description">The code below doesn't make sense: &lt;snip&gt; catch (IOException e){ log ("Caught exception " + e); throw new IOException (e.toString()); } &lt;/snip&gt; It should be "throw e;". IMHO, It seems no need to log this exception here, so the cache block can be removed.</column><column name="report_time">2006-09-28 05:16:58</column><column name="report_timestamp">1159440000</column><column name="status">resolved fixed</column><column name="commit">bbb8fe1</column><column name="commit_timestamp">1159570000</column><column name="files">java/org/apache/catalina/servlets/CGIServlet.java</column><column name="result" /></table><table name="tomcat"><column name="id">1043</column><column name="bug_id">40518</column><column name="summary">The message key "requestListenerValve.requestInit" has not be referred to correctly.</column><column name="description">The bug is: An illegal message is output to the log when the listener application that implements ServletRequestListener interface throws RuntimeException from the requestInitialized method or the requestDestroyed method. message: "Cannot find message associated with key requestListenerValve.requestInit" cause: The key exists in the properties file "org.apache.catalina.valves.LocalStrings.properties", but the logic refers other properties file "org.apache.catalina.core.LocalStrings.properties"</column><column name="report_time">2006-09-15 09:13:40</column><column name="report_timestamp">1158330000</column><column name="status">resolved fixed</column><column name="commit">fda223a</column><column name="commit_timestamp">1158810000</column><column name="files">java/org/apache/catalina/core/StandardContextValve.java</column><column name="result" /></table><table name="tomcat"><column name="id">1044</column><column name="bug_id">34399</column><column name="summary">Undeploying fails when context defined in server.xml &amp; server fails to stop</column><column name="description">Steps to reproduce: 1. autodeploy a web application by defining its context in server.xml 2. start the Tomcat server 3. use the Tomcat Manager to undeploy the application You will get the "OK - Undeployed application at context path /WebApplication" message, but the application will NOT be undeployed, it will be only stopped. If you try to stop the server after that, it will fail! I have used the shared installation (CATALINA_BASE dir), but I guess this won't work for standalone Tomcat isntallation either.</column><column name="report_time">2005-04-11 16:32:42</column><column name="report_timestamp">1113250000</column><column name="status">resolved fixed</column><column name="commit">9dd8a23</column><column name="commit_timestamp">1158810000</column><column name="files">java/org/apache/catalina/manager/HTMLManagerServlet.java
java/org/apache/catalina/manager/ManagerServlet.java
java/org/apache/catalina/startup/HostConfig.java</column><column name="result" /></table><table name="tomcat"><column name="id">1045</column><column name="bug_id">34509</column><column name="summary">tag names that are xml:Name but not java identifier are not accepted</column><column name="description">According to the JSP 2.0 specification, custom tag prefix and name should be of the type XML:Name. However, for Tomcat 5.5.8, if the name is not a legal java identifier, then a compilation error occurs. For instance, Tomcat won't accept Da~te`T#ag as a legal name for the Tag.</column><column name="report_time">2005-04-19 00:45:34</column><column name="report_timestamp">1113890000</column><column name="status">resolved fixed</column><column name="commit">823101d</column><column name="commit_timestamp">1158370000</column><column name="files">java/org/apache/jasper/compiler/Generator.java</column><column name="result" /></table><table name="tomcat"><column name="id">1046</column><column name="bug_id">33356</column><column name="summary">Incorrect parsing of tag attributes</column><column name="description">I get a org.apache.jasper.JasperException: with the error: "The function string must be used with a prefix when a default namespace is not specified" when trying to compile the following within a JSP page: &lt;foo:set var="bar" value="this $ is a { silly string ("/&gt; "foo" is our own tablib, it seems that Jasper seems to think that the string provided to the value attribute contains some JSP/EL which it does not. If I change the page to be: &lt;c:set var="bar" value="this $ is a { silly string ("/&gt; Then I do not get this error. However I need to use my own taglib. In the foo.tld file, the "value" attribute of "set" has rtexprvalue=true. If I set this to false then the problem goes away. However I noticed that c.tld in standard.jar also has rtexprvalue=true for the "value" attribute of "set". Why the difference in behaviour ? We also wish to have rtexprvalue=true.</column><column name="report_time">2005-02-02 14:55:18</column><column name="report_timestamp">1107370000</column><column name="status">resolved fixed</column><column name="commit">b55e9c2</column><column name="commit_timestamp">1157860000</column><column name="files">java/org/apache/jasper/compiler/ELParser.java</column><column name="result" /></table><table name="tomcat"><column name="id">1047</column><column name="bug_id">31804</column><column name="summary">setParent() is not called on nested tags in a tag file (.tagx)</column><column name="description">Hi, everybody. Suppose I have a tag file (.tagx to be precise). I have some custom tags of mine included in that tag file. If I override setParent() in such a custom tag, then I see, that it's invoked with "null" parameter. Custom tag is a "Classic" tag (extends TagSupport). Simplified example: This tag file is called "submit.tagx" &lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;jsp:root xmlns:jsp="http://java.sun.com/JSP/Page" xmlns:custom="http://my.com/ tags-html" version="2.0" &gt; &lt;jsp:directive.tag body-content="empty"/&gt; &lt;jsp:directive.attribute name="action" required="true" rtexprvalue="true"/&gt; &lt;jsp:directive.attribute name="label" required="true" rtexprvalue="true"/&gt; &lt;custom:submit action="${action}" label="${label}" name="submitButton" /&gt; &lt;/jsp:root&gt; In debug output from setParent(Tag) of custom:submit I see, that it's called with "null" value. If, instead of custom:submit, I put there another custom tag, which follows SimpleTagSupport model, then setParent(JspTag) is not called at all!!! I would expect a reference to something, representing translated class of Tag File (submit.tagx) is passed. As the result, tag nesting tree is broken. I need to access Struts html:form tag, which is the embracing tag from my inner &lt;custom:submit&gt; tag to obtain form name, but this is not possible. &lt;nested:form action="/Action"&gt; &lt;ctrl:submit action="save" label="Save"/&gt; &lt;/nested:form&gt; (where ctrl:submit is submit.tagx)</column><column name="report_time">2004-10-20 16:26:40</column><column name="report_timestamp">1098300000</column><column name="status">resolved fixed</column><column name="commit">2d6d717</column><column name="commit_timestamp">1157840000</column><column name="files">java/org/apache/jasper/compiler/Generator.java</column><column name="result" /></table><table name="tomcat"><column name="id">1048</column><column name="bug_id">38713</column><column name="summary">java.io.IOException: tmpFile.renameTo(classFile) failed when compiling new JSP (upon redeploy)</column><column name="description">[http-8080-Processor24 ERROR 26902165 DispatcherServlet.serviceWrapper()] - Could not complete request org.apache.jasper.JasperException: Unable to compile class for JSP at org.apache.jasper.JspCompilationContext.compile(JspCompilationContext.java:565) at org.apache.jasper.servlet.JspServletWrapper.service(JspServletWrapper.java:293) at org.apache.jasper.servlet.JspServlet.serviceJspFile(JspServlet.java:291) at org.apache.jasper.servlet.JspServlet.service(JspServlet.java:241) at javax.servlet.http.HttpServlet.service(HttpServlet.java:802) at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:252) at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:173) at org.apache.catalina.core.ApplicationDispatcher.invoke(ApplicationDispatcher.java:672) at org.apache.catalina.core.ApplicationDispatcher.processRequest(ApplicationDispatcher.java:463) at org.apache.catalina.core.ApplicationDispatcher.doForward(ApplicationDispatcher.java:398) at org.apache.catalina.core.ApplicationDispatcher.forward(ApplicationDispatcher.java:301) at org.springframework.web.servlet.view.InternalResourceView.renderMergedOutputModel(InternalResourceView.java:97) at org.springframework.web.servlet.view.AbstractView.render(AbstractView.java:250) at org.springframework.web.servlet.DispatcherServlet.render(DispatcherServlet.java:928) at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:705) at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:625) at org.springframework.web.servlet.FrameworkServlet.serviceWrapper(FrameworkServlet.java:386) at org.springframework.web.servlet.FrameworkServlet.doGet(FrameworkServlet.java:346) at javax.servlet.http.HttpServlet.service(HttpServlet.java:689) at javax.servlet.http.HttpServlet.service(HttpServlet.java:802) at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:252) at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:173) at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:213) at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:178) at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:126) at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:105) at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:107) at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:148) at org.apache.coyote.http11.Http11Processor.process(Http11Processor.java:856) at org.apache.coyote.http11.Http11Protocol$Http11ConnectionHandler.processConnection(Http11Protocol.java:744) at org.apache.tomcat.util.net.PoolTcpEndpoint.processSocket(PoolTcpEndpoint.java:527) at org.apache.tomcat.util.net.LeaderFollowerWorkerThread.runIt(LeaderFollowerWorkerThread.java:80) at org.apache.tomcat.util.threads.ThreadPool$ControlRunnable.run(ThreadPool.java:684) at java.lang.Thread.run(Thread.java:595) [http-8080-Processor24 ERROR 26902165 [wirelessapp].invoke()] - Servlet.service() for servlet wirelessapp threw exception java.io.IOException: tmpFile.renameTo(classFile) failed at org.apache.jasper.compiler.SmapUtil$SDEInstaller.install(SmapUtil.java:245) at org.apache.jasper.compiler.SmapUtil.installSmap(SmapUtil.java:164) at org.apache.jasper.compiler.AntCompiler.generateClass(AntCompiler.java:267) at org.apache.jasper.compiler.Compiler.compile(Compiler.java:288) at org.apache.jasper.compiler.Compiler.compile(Compiler.java:267) at org.apache.jasper.compiler.Compiler.compile(Compiler.java:255) at org.apache.jasper.JspCompilationContext.compile(JspCompilationContext.java:556) at org.apache.jasper.servlet.JspServletWrapper.service(JspServletWrapper.java:293) at org.apache.jasper.servlet.JspServlet.serviceJspFile(JspServlet.java:291) at org.apache.jasper.servlet.JspServlet.service(JspServlet.java:241) at javax.servlet.http.HttpServlet.service(HttpServlet.java:802) at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:252) at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:173) at org.apache.catalina.core.ApplicationDispatcher.invoke(ApplicationDispatcher.java:672) at org.apache.catalina.core.ApplicationDispatcher.processRequest(ApplicationDispatcher.java:463) at org.apache.catalina.core.ApplicationDispatcher.doForward(ApplicationDispatcher.java:398) at org.apache.catalina.core.ApplicationDispatcher.forward(ApplicationDispatcher.java:301) at org.springframework.web.servlet.view.InternalResourceView.renderMergedOutputModel(InternalResourceView.java:97) at org.springframework.web.servlet.view.AbstractView.render(AbstractView.java:250) at org.springframework.web.servlet.DispatcherServlet.render(DispatcherServlet.java:928) at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:705) at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:625) at org.springframework.web.servlet.FrameworkServlet.serviceWrapper(FrameworkServlet.java:386) at org.springframework.web.servlet.FrameworkServlet.doGet(FrameworkServlet.java:346) at javax.servlet.http.HttpServlet.service(HttpServlet.java:689) at javax.servlet.http.HttpServlet.service(HttpServlet.java:802) at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:252) at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:173) at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:213) at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:178) at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:126) at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:105) at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:107) at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:148) at org.apache.coyote.http11.Http11Processor.process(Http11Processor.java:856) at org.apache.coyote.http11.Http11Protocol$Http11ConnectionHandler.processConnection(Http11Protocol.java:744) at org.apache.tomcat.util.net.PoolTcpEndpoint.processSocket(PoolTcpEndpoint.java:527) at org.apache.tomcat.util.net.LeaderFollowerWorkerThread.runIt(LeaderFollowerWorkerThread.java:80) at org.apache.tomcat.util.threads.ThreadPool$ControlRunnable.run(ThreadPool.java:684) at java.lang.Thread.run(Thread.java:595)</column><column name="report_time">2006-02-20 08:08:04</column><column name="report_timestamp">1140440000</column><column name="status">resolved fixed</column><column name="commit">c7f0f60</column><column name="commit_timestamp">1157190000</column><column name="files">java/org/apache/jasper/JspCompilationContext.java
java/org/apache/jasper/compiler/Compiler.java
java/org/apache/jasper/servlet/JspServletWrapper.java</column><column name="result" /></table><table name="tomcat"><column name="id">1049</column><column name="bug_id">40306</column><column name="summary">mod_jk, POST request bodies are not restored on successful login when using mod_jk</column><column name="description">After the FormAuthenticator intercepts a POST request to a protected resource, the original request is not properly restored upon successful login when using mod_jk. When connectiong to tomcat directly (8080), the POST request is restored as expected. I've tested this with mod_jk 1.2.15 and 1.2.18. It seems the problem is that the orginal request is not saved properly. I (think) I've narrowed down the issue in FormAuthenticator.java. body.toString() was returning null. (The buffer was null) so it looks like the root of the problem is that nothing is read from the input stream. During testing I reverted to the old way of adding the request parameters (saved.addParameter()) to see if they were indeed there and it worked. I also tried, InputStream is = new BufferedInputStream(request.getInputStream()); which didn't work.. from FormAuthenticator.java: protected void saveRequest(Request request, Session session) throws IOException { ... if ("POST".equalsIgnoreCase(request.getMethod())) { ByteChunk body = new ByteChunk(); body.setLimit(request.getConnector().getMaxSavePostSize()); byte[] buffer = new byte[4096]; int bytesRead; InputStream is = request.getInputStream(); while ( (bytesRead = is.read(buffer) ) &gt;= 0) { body.append(buffer, 0, bytesRead); } 			 saved.setBody(body); } ... }</column><column name="report_time">2006-08-23 19:48:03</column><column name="report_timestamp">1156380000</column><column name="status">resolved fixed</column><column name="commit">a91b95e</column><column name="commit_timestamp">1156740000</column><column name="files">java/org/apache/coyote/ajp/AjpAprProcessor.java
java/org/apache/jk/core/MsgContext.java</column><column name="result" /></table><table name="tomcat"><column name="id">1050</column><column name="bug_id">38676</column><column name="summary">permanently reloading tagfile classes without changes to the tagfile</column><column name="description">Scenario: - jsp with a tag in it (tagfile, no taglib) - activate "reloading" in web.xml - clean work directory - start tomcat - load jsp Tomcat generates/compiles/load the jsp and the tagfile classes. After "checkInterval" seconds the background compile thread "JspRuntimeContext[\*]" loads the tagfile classes (and only them) again and again. This produces a lot of work for the garbage collector. (permanently class unloading of tagfile classes) A Breakpoint in the method loadTagFile() in JspServletWrapper.java will show this. Perhaps the reload flag must be set to false after loading the TagFile? JspServletWrapper.java: ... if(reload) { tagHandlerClass = ctxt.load(); reload = false; //perhaps, this solves the problem but i am not shure } ... After restarting the server the problem is not present because no JspServletWrapper is instantiated for the tagfile an therefore the backround compile task does not check the tagfile.</column><column name="report_time">2006-02-16 11:48:57</column><column name="report_timestamp">1140110000</column><column name="status">resolved fixed</column><column name="commit">edc20fa</column><column name="commit_timestamp">1155910000</column><column name="files">java/org/apache/el/lang/ELSupport.java
java/org/apache/jasper/servlet/JspServletWrapper.java</column><column name="result" /></table><table name="tomcat"><column name="id">1051</column><column name="bug_id">39592</column><column name="summary">SSI does not correctly process HEAD request</column><column name="description">Hello, I think there is a small bug in Tomcat 5.0 and 5.5 (at least I could see it already with many versions of Tomcat). I use SSI org.apache.catalina.ssi.SSIServlet and &lt;param-name&gt;isVirtualWebappRelative&lt;/param-name&gt; &lt;param-value&gt;1&lt;/param-value&gt; All my pages (*.html) are processed by the SSI &lt;url-pattern&gt;*.html&lt;/url-pattern&gt; If there is a normal GET request, SSI compiles a page and everything is just OK. However, for the HEAD request to the same page (there is no need to compile the page) the SSI still tries to do it and generates a number of exceptions (see enclosed). This error is not critical but overloads my catalina.out file. I do not think that it is difficult to fix it. I already reported this error to tomcat-dev, but decided to create a formal "bug" report at ASF Bugzilla to see if it was already fixed or not. This is not a big error, but it is annoying. Thanks! With the best regards, Igor Tetko ***** Apr 28, 2006 11:26:45 AM org.apache.catalina.core.ApplicationContext log SEVERE: #include--Couldn't include file: styles.html java.io.IOException: Couldn't find file: /incl/styles.html at org.apache.catalina.ssi.SSIServletExternalResolver.getFileText(SSIServletExternalResolver.java: 537) at org.apache.catalina.ssi.SSIMediator.getFileText(SSIMediator.java:155) at org.apache.catalina.ssi.SSIInclude.process(SSIInclude.java:44) at org.apache.catalina.ssi.SSIProcessor.process(SSIProcessor.java:146) at org.apache.catalina.ssi.SSIServlet.processSSI(SSIServlet.java:221) at org.apache.catalina.ssi.SSIServlet.requestHandler(SSIServlet.java:187) at org.apache.catalina.ssi.SSIServlet.doGet(SSIServlet.java:123) at javax.servlet.http.HttpServlet.doHead(HttpServlet.java:270) at javax.servlet.http.HttpServlet.service(HttpServlet.java:706) at javax.servlet.http.HttpServlet.service(HttpServlet.java:802) at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:252) at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:173) at org.apache.catalina.core.ApplicationDispatcher.invoke(ApplicationDispatcher.java:672) at org.apache.catalina.core.ApplicationDispatcher.doInclude(ApplicationDispatcher.java:574) at org.apache.catalina.core.ApplicationDispatcher.include(ApplicationDispatcher.java:499) at org.apache.catalina.ssi.SSIServletExternalResolver.getFileText(SSIServletExternalResolver.java: 519) at org.apache.catalina.ssi.SSIMediator.getFileText(SSIMediator.java:155) at org.apache.catalina.ssi.SSIInclude.process(SSIInclude.java:44) at org.apache.catalina.ssi.SSIProcessor.process(SSIProcessor.java:146) at org.apache.catalina.ssi.SSIServlet.processSSI(SSIServlet.java:221) at org.apache.catalina.ssi.SSIServlet.requestHandler(SSIServlet.java:187) at org.apache.catalina.ssi.SSIServlet.doGet(SSIServlet.java:123) at javax.servlet.http.HttpServlet.doHead(HttpServlet.java:270) at javax.servlet.http.HttpServlet.service(HttpServlet.java:706) at javax.servlet.http.HttpServlet.service(HttpServlet.java:802) at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:252) at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:173) at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:213) at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:178) at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:126) at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:105) at org.apache.catalina.valves.FastCommonAccessLogValve.invoke (FastCommonAccessLogValve.java:495) at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:107) at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:148) at org.apache.coyote.http11.Http11Processor.process(Http11Processor.java:869) at org.apache.coyote.http11.Http11BaseProtocol$Http11ConnectionHandler.processConnection (Http11BaseProtocol.java:664) at org.apache.tomcat.util.net.PoolTcpEndpoint.processSocket(PoolTcpEndpoint.java:527) at org.apache.tomcat.util.net.LeaderFollowerWorkerThread.runIt (LeaderFollowerWorkerThread.java:80) at org.apache.tomcat.util.threads.ThreadPool$ControlRunnable.run(ThreadPool.java:684) at java.lang.Thread.run(Thread.java:613)</column><column name="report_time">2006-05-16 17:40:47</column><column name="report_timestamp">1147820000</column><column name="status">resolved fixed</column><column name="commit">0f9844c</column><column name="commit_timestamp">1153960000</column><column name="files">java/org/apache/catalina/ssi/SSIServletExternalResolver.java</column><column name="result" /></table><table name="tomcat"><column name="id">1052</column><column name="bug_id">39689</column><column name="summary">Tomcat Server Side Includes (SSI) do not work with single quotes</column><column name="description">In http://httpd.apache.org/docs/2.0/en/mod/mod_include.html (apache 2.0 SSI documentation) you can read: "The value [of an attribute value] will often be enclosed in double quotes, but single quotes (') and backticks (`) are also possible." Tomcat SSI support is suposed to implement the same SSI directives as Apache. Unfortunately, it is not possible to enclose attribute values in single quotes. Thank you very much for reading this bug report.</column><column name="report_time">2006-05-31 07:46:22</column><column name="report_timestamp">1149080000</column><column name="status">resolved fixed</column><column name="commit">8ed77be</column><column name="commit_timestamp">1153600000</column><column name="files">java/org/apache/catalina/ssi/SSIProcessor.java</column><column name="result" /></table><table name="tomcat"><column name="id">1053</column><column name="bug_id">34801</column><column name="summary">PATCH: CGIServlet does not terminate child after a timeout</column><column name="description">CGIServlet does not kill CGI child process on IOException, nor terminate child after a timeout. We had a problem where a CGI child process (in perl, on windows) remained running for a long time. In some situations where the client disconnected, an IOException was thrown in the servlet, but this did not result in a cleanup of the CGI child process. This was a problem as our CGI program accessed a single threaded resource over TCP, and could therefore lock the system up indefinitly. === --- CGIServlet.java	Sun May 08 04:46:05 2005 +++ C:\Temp\hjakarta-tomcat-5.5.9-src.tar\jakarta-tomcat-5.5.9-src\jakarta-tomcat-catalina\catalina\src\share\org\apache\catalina\servlets\CGIServlet.java Sat Mar 26 18:24:02 2005 @@ -267,8 +267,6 @@ private String parameterEncoding = System.getProperty("file.encoding", "UTF-8"); - private long lScriptTimeoutMillis = 2000; - /** object used to ensure multiple threads don't try to expand same file */ static Object expandFileLock = new Object(); @@ -332,16 +330,10 @@ cgiExecutable = value; } - value = getServletConfig().getInitParameter("parameterEncoding"); if (value != null) { parameterEncoding = value; } - // Added by CJD - value = getServletConfig().getInitParameter("scriptTimeout"); - if (value != null) { - lScriptTimeoutMillis = Integer.valueOf(value).intValue(); - } // Identify the internal container resources we need context = config.getServletContext(); @@ -1440,7 +1432,7 @@ */ protected class CGIRunner { - private Process proc = null; + /** script/command to be executed */ private String command = null; @@ -1656,6 +1648,7 @@ InputStream cgiOutput = null; BufferedReader commandsStdErr = null; BufferedOutputStream commandsStdIn = null; + Process proc = null; int bufRead = -1; //create query arguments @@ -1731,200 +1724,138 @@ } rt = Runtime.getRuntime(); - try { + proc = rt.exec(cmdAndArgs.toString(), hashToStringArray(env), wd); - proc = rt.exec(cmdAndArgs.toString(), hashToStringArray(env), wd); + if(contentStream != null) { + commandsStdIn = new BufferedOutputStream(proc.getOutputStream()); + commandsStdIn.write(contentStream.toByteArray()); + commandsStdIn.flush(); + commandsStdIn.close(); + } - if(contentStream != null) { - commandsStdIn = new BufferedOutputStream(proc.getOutputStream()); - commandsStdIn.write(contentStream.toByteArray()); - commandsStdIn.flush(); - commandsStdIn.close(); - } + /* we want to wait for the process to exit, Process.waitFor() + * is useless in our situation; see + * http://developer.java.sun.com/developer/ + * bugParade/bugs/4223650.html + */ - /* we want to wait for the process to exit, Process.waitFor() - * is useless in our situation; see - * http://developer.java.sun.com/developer/ - * bugParade/bugs/4223650.html - */ - - boolean isRunning = true; - commandsStdErr = new BufferedReader - (new InputStreamReader(proc.getErrorStream())); - BufferedWriter servletContainerStdout = null; + boolean isRunning = true; + commandsStdErr = new BufferedReader + (new InputStreamReader(proc.getErrorStream())); + BufferedWriter servletContainerStdout = null; - try { - if (response.getOutputStream() != null) { - servletContainerStdout = - new BufferedWriter(new OutputStreamWriter - (response.getOutputStream())); - } - } catch (IOException ignored) { - //NOOP: no output will be written + try { + if (response.getOutputStream() != null) { + servletContainerStdout = + new BufferedWriter(new OutputStreamWriter + (response.getOutputStream())); } - final BufferedReader stdErrRdr = commandsStdErr ; + } catch (IOException ignored) { + //NOOP: no output will be written + } + final BufferedReader stdErrRdr = commandsStdErr ; - new Thread() { - public void run () { - sendToLog(stdErrRdr) ; - } ; - }.start() ; - - - new Thread() { - public void run () { - deadProcWatcher(proc,lScriptTimeoutMillis) ; - } ; - }.start() ; - - InputStream cgiHeaderStream = - new HTTPHeaderInputStream(proc.getInputStream()); - BufferedReader cgiHeaderReader = - new BufferedReader(new InputStreamReader(cgiHeaderStream)); - boolean isBinaryContent = false; + new Thread() { + public void run () { + sendToLog(stdErrRdr) ; + } ; + }.start() ; + + InputStream cgiHeaderStream = + new HTTPHeaderInputStream(proc.getInputStream()); + BufferedReader cgiHeaderReader = + new BufferedReader(new InputStreamReader(cgiHeaderStream)); + boolean isBinaryContent = false; - - - while (isRunning) { - try { - //set headers - String line = null; - while (((line = cgiHeaderReader.readLine()) != null) - &amp;&amp; !("".equals(line))) { - if (debug &gt;= 2) { - log("runCGI: addHeader(\"" + line + "\")"); - } - if (line.startsWith("HTTP")) { - //TODO: should set status codes (NPH support) - /* - * response.setStatus(getStatusCode(line)); - */ - } else if (line.indexOf(":") &gt;= 0) { - String header = - line.substring(0, line.indexOf(":")).trim(); - String value = - line.substring(line.indexOf(":") + 1).trim(); - response.addHeader(header , value); - if ((header.toLowerCase().equals("content-type")) - &amp;&amp; (!value.toLowerCase().startsWith("text"))) { - isBinaryContent = true; - } - } else { - log("runCGI: bad header line \"" + line + "\""); + while (isRunning) { + try { + //set headers + String line = null; + while (((line = cgiHeaderReader.readLine()) != null) + &amp;&amp; !("".equals(line))) { + if (debug &gt;= 2) { + log("runCGI: addHeader(\"" + line + "\")"); + } + if (line.startsWith("HTTP")) { + //TODO: should set status codes (NPH support) + /* + * response.setStatus(getStatusCode(line)); + */ + } else if (line.indexOf(":") &gt;= 0) { + String header = + line.substring(0, line.indexOf(":")).trim(); + String value = + line.substring(line.indexOf(":") + 1).trim(); + response.addHeader(header , value); + if ((header.toLowerCase().equals("content-type")) + &amp;&amp; (!value.toLowerCase().startsWith("text"))) { + isBinaryContent = true; } + } else { + log("runCGI: bad header line \"" + line + "\""); } + } - //write output - if (isBinaryContent) { - byte[] bBuf = new byte[2048]; - OutputStream out = response.getOutputStream(); - cgiOutput = proc.getInputStream(); - while ((bufRead = cgiOutput.read(bBuf)) != -1) { - if (debug &gt;= 4) { - log("runCGI: output " + bufRead + - " bytes of binary data"); - } - out.write(bBuf, 0, bufRead); + //write output + if (isBinaryContent) { + byte[] bBuf = new byte[2048]; + OutputStream out = response.getOutputStream(); + cgiOutput = proc.getInputStream(); + while ((bufRead = cgiOutput.read(bBuf)) != -1) { + if (debug &gt;= 4) { + log("runCGI: output " + bufRead + + " bytes of binary data"); } - } else { - commandsStdOut = new BufferedReader - (new InputStreamReader(proc.getInputStream())); + out.write(bBuf, 0, bufRead); + } + } else { + commandsStdOut = new BufferedReader + (new InputStreamReader(proc.getInputStream())); - char[] cBuf = new char[1024]; - try { - while ((bufRead = commandsStdOut.read(cBuf)) != -1) { - if (servletContainerStdout != null) { - if (debug &gt;= 4) { - log("runCGI: write(\"" + + char[] cBuf = new char[1024]; + try { + while ((bufRead = commandsStdOut.read(cBuf)) != -1) { + if (servletContainerStdout != null) { + if (debug &gt;= 4) { + log("runCGI: write(\"" + new String(cBuf, 0, bufRead) + "\")"); - } - servletContainerStdout.write(cBuf, 0, bufRead); } - } - } finally { - // Attempt to consume any leftover byte if something bad happens, - // such as a socket disconnect on the servlet side; otherwise, the - // external process could hang - if (bufRead != -1) { - while ((bufRead = commandsStdOut.read(cBuf)) != -1) {} + servletContainerStdout.write(cBuf, 0, bufRead); } } - - if (servletContainerStdout != null) { - servletContainerStdout.flush(); + } finally { + // Attempt to consume any leftover byte if something bad happens, + // such as a socket disconnect on the servlet side; otherwise, the + // external process could hang + if (bufRead != -1) { + while ((bufRead = commandsStdOut.read(cBuf)) != -1) {} } } - - proc.exitValue(); // Throws exception if alive - - isRunning = false; - - } catch (IllegalThreadStateException e) { - try { - Thread.sleep(500); - } catch (InterruptedException ignored) { + + if (servletContainerStdout != null) { + servletContainerStdout.flush(); } } - - } //replacement for Process.waitFor() - // Close the output stream used - if (isBinaryContent) { - cgiOutput.close(); - } else { - commandsStdOut.close(); - } - } - catch (IOException e){ - log ("Caught exception " + e); - System.out.println("Caught IOException - printing dump 1"); - e.printStackTrace(); - if (proc != null){ - proc.destroy(); - proc = null; - } - throw new IOException (e.toString()); - } - finally{ - log ("Running finally block"); - if (proc != null){ - proc.destroy(); - proc = null; - } - } - } - private void deadProcWatcher(Process myproc,long lWait){ - long processRunDeadline = System.currentTimeMillis() +lWait; + proc.exitValue(); // Throws exception if alive + + isRunning = false; - while(System.currentTimeMillis() &lt; processRunDeadline){ - log("deadProcWatcher: cgi run: " + - processRunDeadline + " " + - System.currentTimeMillis() + - " " + myproc); - try{ - myproc.exitValue(); // Throws exception if alive - log("deadProcWatcher: exiting normally"); - return; // child has exited, we can exit - } catch (IllegalThreadStateException e) { try { Thread.sleep(500); } catch (InterruptedException ignored) { } } + } //replacement for Process.waitFor() + // Close the output stream used + if (isBinaryContent) { + cgiOutput.close(); + } else { + commandsStdOut.close(); } - if (System.currentTimeMillis() &gt; processRunDeadline){ - log("Killing process due to timeout" + - processRunDeadline + " " + - System.currentTimeMillis() + - " " + myproc); - myproc.destroy(); - } - } - - private void sendToLog(BufferedReader rdr) { String line = null; int lineCount = 0 ;</column><column name="report_time">2005-05-08 06:47:30</column><column name="report_timestamp">1115550000</column><column name="status">resolved fixed</column><column name="commit">c30afec</column><column name="commit_timestamp">1153530000</column><column name="files">java/org/apache/catalina/servlets/CGIServlet.java</column><column name="result" /></table><table name="tomcat"><column name="id">1054</column><column name="bug_id">40012</column><column name="summary">Legacy EL Support not resolving variables correctly</column><column name="description">Given the following page: &lt;% pageContext.setAttribute("t", "foo"); %&gt; ${t} &lt;% out.print( pageContext.getExpressionEvaluator().evaluate( "${t}", String.class, pageContext.getVariableResolver(), null)); %&gt; You will notice that the ${t} prints out fine when in the JSP but does not resolve using the scriplet and prints nothing. For a sanity check, I tested this and it worked in glassfish to ensure I wasn't doing anything odd. I'm trying to find root cause; but haven't found it yet, so I'm logging it in case anyone else has the itch to scratch.</column><column name="report_time">2006-07-11 13:00:29</column><column name="report_timestamp">1152640000</column><column name="status">resolved fixed</column><column name="commit">01a9b59</column><column name="commit_timestamp">1152640000</column><column name="files">java/org/apache/jasper/el/VariableResolverImpl.java</column><column name="result" /></table><table name="tomcat"><column name="id">1055</column><column name="bug_id">39769</column><column name="summary">Wrong class loader when the myServlet.destroy() called if myServlet is in the T5 shared directory</column><column name="description">Hi all, My web app needs to have Thread.currentThread().getContextClassLoader() always right. When the application is unload it seem not be the case. My classes are under the T5's shared directory (so all my servlet.getClass().getClassLoader() == the shared classloader i.e.: StandardCalssLoader. My understanding is that when executing the code in my web app Thread.currentThread().getContextClassLoader() should always give the WebappLoader used in the StandardContext. The problem occurs in StandardWrapper.unload() before calling the servlet.destroy() method .... ClassLoader oldCtxClassLoader = Thread.currentThread().getContextClassLoader(); ClassLoader classLoader = instance.getClass().getClassLoader(); PrintStream out = System.out; if (swallowOutput) { SystemLogHandler.startCapture(); } // Call the servlet destroy() method try { instanceSupport.fireInstanceEvent (InstanceEvent.BEFORE_DESTROY_EVENT, instance); Thread.currentThread().setContextClassLoader(classLoader); if( System.getSecurityManager() != null) { SecurityUtil.doAsPrivilege("destroy", instance); SecurityUtil.remove(instance); } else { instance.destroy(); } .... In the code, the INSTANCE variable is my servlet and it have been loaded by the SHARED classloader. So the classloader set in the thread is not the right one. It Should be the classloader related to StandardContext.getLoader() This problem occurs when I try to close my T5 dos windows and I suppose will occurs when I will uninstall any webApp from my T5. I notice the problem in T5 5.5.16 but I verified and it's the same code in 5.5.17. So probably the problem is still there Best Regards /David Gagnon</column><column name="report_time">2006-06-09 20:09:27</column><column name="report_timestamp">1149900000</column><column name="status">resolved fixed</column><column name="commit">276e5ac</column><column name="commit_timestamp">1150060000</column><column name="files">java/org/apache/catalina/core/StandardWrapper.java</column><column name="result" /></table><table name="tomcat"><column name="id">1056</column><column name="bug_id">39699</column><column name="summary">simple deploy failed in cluster (distributable flag)</column><column name="description">Hi, i encounter a strange problem with my tomcat cluster and webapps deployment. server.xml -------------------------------- &lt;Server port="8005" shutdown="SHUTDOWN"&gt; &lt;Listener className="org.apache.catalina.core.AprLifecycleListener" /&gt; &lt;Listener className="org.apache.catalina.mbeans.ServerLifecycleListener" /&gt; &lt;Listener className="org.apache.catalina.mbeans.GlobalResourcesLifecycleListener" /&gt; &lt;Listener className="org.apache.catalina.storeconfig.StoreConfigLifecycleListener"/&gt; &lt;!-- Global JNDI resources --&gt; &lt;GlobalNamingResources&gt; &lt;Environment name="simpleValue" type="java.lang.Integer" value="30"/&gt; &lt;Resource name="UserDatabase" auth="Container" type="org.apache.catalina.UserDatabase" description="User database that can be updated and saved" factory="org.apache.catalina.users.MemoryUserDatabaseFactory" pathname="conf/tomcat-users.xml" /&gt; &lt;/GlobalNamingResources&gt; &lt;!-- Define the Tomcat Stand-Alone Service --&gt; &lt;Service name="Catalina"&gt; &lt;!-- Define a non-SSL HTTP/1.1 Connector on port 8080 --&gt; &lt;Connector address="polen-integ" port="8080" maxHttpHeaderSize="8192" maxThreads="300" minSpareThreads="25" maxSpareThreads="100" enableLookups="false" acceptCount="100" connectionTimeout="20000" disableUploadTimeout="true" /&gt; &lt;!-- Define an AJP 1.3 Connector on port 8009 --&gt; &lt;Connector port="8009" address="polen-integ.sofinco.fr" minProcessors="20" maxProcessors="0" maxThreads="350" minSpareThreads="50" maxSpareThreads="100" enableLookups="false" redirectPort="8080" protocol="AJP/1.3" disableUploadTimeout="true" /&gt; &lt;Engine name="Catalina" defaultHost="localhost" jvmRoute="uxdev103" &gt; &lt;Realm className="org.apache.catalina.realm.UserDatabaseRealm" resourceName="UserDatabase"/&gt; &lt;Host name="localhost" appBase="webapps" unpackWARs="true" autoDeploy="true" xmlValidation="false" xmlNamespaceAware="false" &gt; &lt;!-- Cluster Definition --&gt; &lt;Cluster className="org.apache.catalina.cluster.tcp.SimpleTcpCluster" doClusterLog="true" clusterLogName="clusterlog" expireSessionsOnShutdown="false" useDirtyFlag="true" notifyListenersOnReplication="true"&gt; &lt;Membership className="org.apache.catalina.cluster.mcast.McastService" mcastAddr="228.0.0.4" mcastBindAddress="127.0.0.1" mcastClusterDomain="polen-integ" mcastPort="45564" mcastFrequency="1000" mcastDropTime="30000"/&gt; &lt;Receiver className="org.apache.catalina.cluster.tcp.ReplicationListener" tcpListenAddress="polen-integ" tcpSelectorTimeout="100" tcpThreadCount="6"/&gt; &lt;Sender className="org.apache.catalina.cluster.tcp.ReplicationTransmitter" replicationMode="fastasyncqueue" doTransmitterProcessingStats="true" doProcessingStats="false" doWaitAckStats="false" waitForAck="false" keepAliveMaxRequestCount="-1"/&gt; &lt;Valve className="org.apache.catalina.cluster.tcp.ReplicationValve" filter=".*\.gif;.*\.js;.*\.css;.*\.png;.*\.jpeg;.*\.jpg;.*\.htm;.*\.html;.*\.txt;" /&gt; &lt;Valve className="org.apache.catalina.cluster.session.JvmRouteBinderValve" enabled="true" /&gt; &lt;ClusterListener className="org.apache.catalina.cluster.session.ClusterSessionListener" /&gt; &lt;ClusterListener className="org.apache.catalina.cluster.session.JvmRouteSessionIDBinderListener" /&gt; &lt;Deployer className="org.apache.catalina.cluster.deploy.FarmWarDeployer" tempDir="/home/tomcat/polen-integ/tmp/war-temp/" deployDir="${catalina.base}/webapps" watchDir="/home/tomcat/polen-integ/tmp/war-listen/" watchEnabled="true"/&gt; &lt;/Cluster&gt; &lt;/Host&gt; &lt;/Engine&gt; &lt;/Service&gt; &lt;/Server&gt; ------------------------ when i am trying to deploy a 'dsitributable' (and only when this flag is enabled) i get the following errors : --------------------------- INFO ContainerBackgroundProcessor[StandardEngine[Catalina]] org.apache.catalina.startup.HostConfig - Deploying web application archive po len.war INFO ContainerBackgroundProcessor[StandardEngine[Catalina]] org.apache.catalina.loader.WebappClassLoader - Illegal access: this web appli cation instance has been stopped already. Could not load java.io.PrintStream. The eventual following stack trace is caused by an error t hrown for debugging purposes as well as to attempt to terminate the thread which caused the illegal access, and has no functional impact. java.lang.IllegalStateException at org.apache.catalina.loader.WebappClassLoader.loadClass(WebappClassLoader.java:1238) at org.apache.catalina.loader.WebappClassLoader.loadClass(WebappClassLoader.java:1198) at java.lang.ClassLoader.loadClassInternal(Unknown Source) at org.apache.log4j.helpers.LogLog.error(LogLog.java:142) at org.apache.log4j.helpers.PatternParser$DatePatternConverter.convert(PatternParser.java:447) at org.apache.log4j.helpers.PatternConverter.format(PatternConverter.java:64) at org.apache.log4j.PatternLayout.format(PatternLayout.java:503) at org.apache.log4j.WriterAppender.subAppend(WriterAppender.java:301) at org.apache.log4j.RollingFileAppender.subAppend(RollingFileAppender.java:234) at org.apache.log4j.WriterAppender.append(WriterAppender.java:159) at org.apache.log4j.AppenderSkeleton.doAppend(AppenderSkeleton.java:230) at org.apache.log4j.helpers.AppenderAttachableImpl.appendLoopOnAppenders(AppenderAttachableImpl.java:65) at org.apache.log4j.Category.callAppenders(Category.java:203) at org.apache.log4j.Category.forcedLog(Category.java:388) at org.apache.log4j.Category.log(Category.java:853) at org.apache.commons.logging.impl.Log4JLogger.info(Log4JLogger.java:133) at org.apache.catalina.cluster.session.DeltaManager.start(DeltaManager.java:976) at org.apache.catalina.core.ContainerBase.setManager(ContainerBase.java:431) at org.apache.catalina.core.StandardContext.start(StandardContext.java:4125) at org.apache.catalina.core.ContainerBase.addChild(ContainerBase.java:739) at org.apache.catalina.core.StandardHost.addChild(StandardHost.java:524) at org.apache.catalina.startup.HostConfig.deployWAR(HostConfig.java:809) at org.apache.catalina.startup.HostConfig.deployWARs(HostConfig.java:698) at org.apache.catalina.startup.HostConfig.deployApps(HostConfig.java:472) at org.apache.catalina.startup.HostConfig.check(HostConfig.java:1190) at org.apache.catalina.startup.HostConfig.lifecycleEvent(HostConfig.java:292) at org.apache.catalina.util.LifecycleSupport.fireLifecycleEvent(LifecycleSupport.java:119) at org.apache.catalina.core.ContainerBase.backgroundProcess(ContainerBase.java:1305) at org.apache.catalina.core.ContainerBase$ContainerBackgroundProcessor.processChildren(ContainerBase.java:1569) at org.apache.catalina.core.ContainerBase$ContainerBackgroundProcessor.processChildren(ContainerBase.java:1578) at org.apache.catalina.core.ContainerBase$ContainerBackgroundProcessor.run(ContainerBase.java:1558) at java.lang.Thread.run(Unknown Source) INFO ContainerBackgroundProcessor[StandardEngine[Catalina]] org.apache.catalina.loader.WebappClassLoader - Illegal access: this web applic ation instance has been stopped already. Could not load java.io.PrintStream. The eventual following stack trace is caused by an error th rown for debugging purposes as well as to attempt to terminate the thread which caused the illegal access, and has no functional impact. Java.lang.IllegalStateException at org.apache.catalina.loader.WebappClassLoader.loadClass(WebappClassLoader.java:1238) at org.apache.catalina.loader.WebappClassLoader.loadClass(WebappClassLoader.java:1198) at java.lang.ClassLoader.loadClassInternal(Unknown Source) at org.apache.log4j.helpers.LogLog.error(LogLog.java:142) at org.apache.log4j.helpers.PatternParser$DatePatternConverter.convert(PatternParser.java:447) at org.apache.log4j.helpers.PatternConverter.format(PatternConverter.java:64) at org.apache.log4j.PatternLayout.format(PatternLayout.java:503) at org.apache.log4j.WriterAppender.subAppend(WriterAppender.java:301) at org.apache.log4j.RollingFileAppender.subAppend(RollingFileAppender.java:234) at org.apache.log4j.WriterAppender.append(WriterAppender.java:159) at org.apache.log4j.AppenderSkeleton.doAppend(AppenderSkeleton.java:230) at org.apache.log4j.helpers.AppenderAttachableImpl.appendLoopOnAppenders(AppenderAttachableImpl.java:65) at org.apache.log4j.Category.callAppenders(Category.java:203) at org.apache.log4j.Category.forcedLog(Category.java:388) at org.apache.log4j.Category.log(Category.java:853) at org.apache.commons.logging.impl.Log4JLogger.info(Log4JLogger.java:133) at org.apache.catalina.cluster.session.DeltaManager.start(DeltaManager.java:976) at org.apache.catalina.core.ContainerBase.setManager(ContainerBase.java:431) at org.apache.catalina.core.StandardContext.start(StandardContext.java:4125) at org.apache.catalina.core.ContainerBase.addChildInternal(ContainerBase.java:759) at org.apache.catalina.core.ContainerBase.addChild(ContainerBase.java:739) at org.apache.catalina.core.StandardHost.addChild(StandardHost.java:524) at org.apache.catalina.startup.HostConfig.deployWAR(HostConfig.java:809) at org.apache.catalina.startup.HostConfig.deployWARs(HostConfig.java:698) at org.apache.catalina.startup.HostConfig.deployApps(HostConfig.java:472) at org.apache.catalina.startup.HostConfig.check(HostConfig.java:1190) at org.apache.catalina.startup.HostConfig.lifecycleEvent(HostConfig.java:292) at org.apache.catalina.util.LifecycleSupport.fireLifecycleEvent(LifecycleSupport.java:119) at org.apache.catalina.core.ContainerBase.backgroundProcess(ContainerBase.java:1305) at org.apache.catalina.core.ContainerBase$ContainerBackgroundProcessor.processChildren(ContainerBase.java:1569) at org.apache.catalina.core.ContainerBase$ContainerBackgroundProcessor.processChildren(ContainerBase.java:1578) at org.apache.catalina.core.ContainerBase$ContainerBackgroundProcessor.run(ContainerBase.java:1558) at java.lang.Thread.run(Unknown Source) INFO ContainerBackgroundProcessor[StandardEngine[Catalina]] org.apache.catalina.loader.WebappClassLoader - Illegal access: this web applic ation instance has been stopped already. Could not load org.apache.log4j.spi.VectorWriter. The eventual following stack trace is caused by an error thrown for debugging purposes as well as to attempt to terminate the thread which caused the illegal access, and has no functi onal impact. java.lang.IllegalStateException at org.apache.catalina.loader.WebappClassLoader.loadClass(WebappClassLoader.java:1238) at org.apache.catalina.loader.WebappClassLoader.loadClass(WebappClassLoader.java:1198) at java.lang.ClassLoader.loadClassInternal(Unknown Source) at org.apache.log4j.spi.LoggingEvent.&lt;init&gt;(LoggingEvent.java:154) at org.apache.log4j.Category.forcedLog(Category.java:388) at org.apache.log4j.Category.log(Category.java:853) at org.apache.commons.logging.impl.Log4JLogger.error(Log4JLogger.java:193) at org.apache.catalina.cluster.session.DeltaManager.start(DeltaManager.java:990) at org.apache.catalina.core.ContainerBase.setManager(ContainerBase.java:431) at org.apache.catalina.core.StandardContext.start(StandardContext.java:4125) at org.apache.catalina.core.ContainerBase.addChildInternal(ContainerBase.java:759) at org.apache.catalina.core.ContainerBase.addChild(ContainerBase.java:739) at org.apache.catalina.core.StandardHost.addChild(StandardHost.java:524) at org.apache.catalina.startup.HostConfig.deployWAR(HostConfig.java:809) at org.apache.catalina.startup.HostConfig.deployWARs(HostConfig.java:698) at org.apache.catalina.startup.HostConfig.deployApps(HostConfig.java:472) at org.apache.catalina.startup.HostConfig.check(HostConfig.java:1190) at org.apache.catalina.startup.HostConfig.lifecycleEvent(HostConfig.java:292) at org.apache.catalina.util.LifecycleSupport.fireLifecycleEvent(LifecycleSupport.java:119) at org.apache.catalina.core.ContainerBase.backgroundProcess(ContainerBase.java:1305) at org.apache.catalina.core.ContainerBase$ContainerBackgroundProcessor.processChildren(ContainerBase.java:1569) at org.apache.catalina.core.ContainerBase$ContainerBackgroundProcessor.processChildren(ContainerBase.java:1578) at org.apache.catalina.core.ContainerBase$ContainerBackgroundProcessor.run(ContainerBase.java:1558) at java.lang.Thread.run(Unknown Source) INFO ContainerBackgroundProcessor[StandardEngine[Catalina]] org.apache.catalina.loader.WebappClassLoader - Illegal access: this web applic ation instance has been stopped already. Could not load org.apache.log4j.spi.VectorWriter. The eventual following stack trace is caused by an error thrown for debugging purposes as well as to attempt to terminate the thread which caused the illegal access, and has no functi onal impact. java.lang.IllegalStateException at org.apache.catalina.loader.WebappClassLoader.loadClass(WebappClassLoader.java:1238) at org.apache.catalina.loader.WebappClassLoader.loadClass(WebappClassLoader.java:1198) at java.lang.ClassLoader.loadClassInternal(Unknown Source) at org.apache.log4j.spi.LoggingEvent.&lt;init&gt;(LoggingEvent.java:154) at org.apache.log4j.Category.forcedLog(Category.java:388) at org.apache.log4j.Category.log(Category.java:853) at org.apache.commons.logging.impl.Log4JLogger.error(Log4JLogger.java:193) at org.apache.catalina.cluster.session.DeltaManager.start(DeltaManager.java:990) at org.apache.catalina.core.ContainerBase.setManager(ContainerBase.java:431) at org.apache.catalina.core.StandardContext.start(StandardContext.java:4125) at org.apache.catalina.core.ContainerBase.addChildInternal(ContainerBase.java:759) at org.apache.catalina.core.ContainerBase.addChild(ContainerBase.java:739) at org.apache.catalina.core.StandardHost.addChild(StandardHost.java:524) at org.apache.catalina.startup.HostConfig.deployWAR(HostConfig.java:809) at org.apache.catalina.startup.HostConfig.deployWARs(HostConfig.java:698) at org.apache.catalina.startup.HostConfig.deployApps(HostConfig.java:472) at org.apache.catalina.startup.HostConfig.check(HostConfig.java:1190) at org.apache.catalina.startup.HostConfig.lifecycleEvent(HostConfig.java:292) at org.apache.catalina.util.LifecycleSupport.fireLifecycleEvent(LifecycleSupport.java:119) at org.apache.catalina.core.ContainerBase.backgroundProcess(ContainerBase.java:1305) at org.apache.catalina.core.ContainerBase$ContainerBackgroundProcessor.processChildren(ContainerBase.java:1569) at org.apache.catalina.core.ContainerBase$ContainerBackgroundProcessor.processChildren(ContainerBase.java:1578) at org.apache.catalina.core.ContainerBase$ContainerBackgroundProcessor.run(ContainerBase.java:1558) at java.lang.Thread.run(Unknown Source) ERROR ContainerBackgroundProcessor[StandardEngine[Catalina]] org.apache.commons.modeler.Registry - Null component Catalina:type=JspMonitor ,name=jsp,WebModule=//localhost/polen,J2EEApplication=none,J2EEServer=none ERROR ContainerBackgroundProcessor[StandardEngine[Catalina]] org.apache.catalina.startup.HostConfig - Error deploying web application arc hive polen.war java.lang.NoClassDefFoundError: org/apache/log4j/spi/VectorWriter at org.apache.log4j.spi.LoggingEvent.&lt;init&gt;(LoggingEvent.java:154) at org.apache.log4j.Category.forcedLog(Category.java:388) at org.apache.log4j.Category.log(Category.java:853) at org.apache.commons.logging.impl.Log4JLogger.error(Log4JLogger.java:193) at org.apache.catalina.cluster.session.DeltaManager.start(DeltaManager.java:990) at org.apache.catalina.core.ContainerBase.setManager(ContainerBase.java:431) at org.apache.catalina.core.StandardContext.start(StandardContext.java:4125) at org.apache.catalina.core.ContainerBase.addChildInternal(ContainerBase.java:759) at org.apache.catalina.core.ContainerBase.addChild(ContainerBase.java:739) at org.apache.catalina.core.StandardHost.addChild(StandardHost.java:524) at org.apache.catalina.startup.HostConfig.deployWAR(HostConfig.java:809) at org.apache.catalina.startup.HostConfig.deployWARs(HostConfig.java:698) at org.apache.catalina.startup.HostConfig.deployApps(HostConfig.java:472) at org.apache.catalina.startup.HostConfig.check(HostConfig.java:1190) at org.apache.catalina.startup.HostConfig.lifecycleEvent(HostConfig.java:292) at org.apache.catalina.util.LifecycleSupport.fireLifecycleEvent(LifecycleSupport.java:119) at org.apache.catalina.core.ContainerBase.backgroundProcess(ContainerBase.java:1305) at org.apache.catalina.core.ContainerBase$ContainerBackgroundProcessor.processChildren(ContainerBase.java:1569) at org.apache.catalina.core.ContainerBase$ContainerBackgroundProcessor.processChildren(ContainerBase.java:1578) at org.apache.catalina.core.ContainerBase$ContainerBackgroundProcessor.run(ContainerBase.java:1558) at java.lang.Thread.run(Unknown Source) ERROR ContainerBackgroundProcessor[StandardEngine[Catalina]] org.apache.catalina.startup.HostConfig - Error deploying web application arch ive polen.war java.lang.NoClassDefFoundError: org/apache/log4j/spi/VectorWriter at org.apache.log4j.spi.LoggingEvent.&lt;init&gt;(LoggingEvent.java:154) at org.apache.log4j.Category.forcedLog(Category.java:388) at org.apache.log4j.Category.log(Category.java:853) at org.apache.commons.logging.impl.Log4JLogger.error(Log4JLogger.java:193) at org.apache.catalina.cluster.session.DeltaManager.start(DeltaManager.java:990) at org.apache.catalina.core.ContainerBase.setManager(ContainerBase.java:431) at org.apache.catalina.core.StandardContext.start(StandardContext.java:4125) at org.apache.catalina.core.ContainerBase.addChildInternal(ContainerBase.java:759) at org.apache.catalina.core.ContainerBase.addChild(ContainerBase.java:739) at org.apache.catalina.core.StandardHost.addChild(StandardHost.java:524) at org.apache.catalina.startup.HostConfig.deployWAR(HostConfig.java:809) at org.apache.catalina.startup.HostConfig.deployWARs(HostConfig.java:698) at org.apache.catalina.startup.HostConfig.deployApps(HostConfig.java:472) at org.apache.catalina.startup.HostConfig.check(HostConfig.java:1190) at org.apache.catalina.startup.HostConfig.lifecycleEvent(HostConfig.java:292) at org.apache.catalina.util.LifecycleSupport.fireLifecycleEvent(LifecycleSupport.java:119) at org.apache.catalina.core.ContainerBase.backgroundProcess(ContainerBase.java:1305) at org.apache.catalina.core.ContainerBase$ContainerBackgroundProcessor.processChildren(ContainerBase.java:1569) at org.apache.catalina.core.ContainerBase$ContainerBackgroundProcessor.processChildren(ContainerBase.java:1578) at org.apache.catalina.core.ContainerBase$ContainerBackgroundProcessor.run(ContainerBase.java:1558) at java.lang.Thread.run(Unknown Source) --------------- i have tried to deployed via web manager application or simple copy of my war in webapps directory... No luck, if i put '&lt;distributable/&gt; flag in application web.xml config file, i encounter this error ; i need to restart manually tomcat instance... After this restart the application is correctly deployed without any error... Of course if i disable cluster in server.xml, no problem...</column><column name="report_time">2006-06-01 16:28:04</column><column name="report_timestamp">1149190000</column><column name="status">resolved fixed</column><column name="commit">7b870a4</column><column name="commit_timestamp">1149780000</column><column name="files">java/org/apache/catalina/core/StandardContext.java</column><column name="result" /></table></database></root>
